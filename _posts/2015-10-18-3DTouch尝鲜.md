---
title: 3DTouch尝鲜
date: 2015-10-18 15:50:40
tags:
- Swift
comments: true
toc: false
---

#3DTouch尝鲜

随着IOS9和iphone6S的推出,苹果新提供了3D Touch功能,让以往平面的操作,扩展到了3维.
让我们对应用的操作增加了新的方式.  
目前最常用的3DTouch方式就是快捷菜单已经内容浏览了.于是我也把我练手的一个`知乎日报`的[DEMO](http://git.oschina.net/xycm/ZhiHuDaily-Swift)程序增加上了3DTouch.

由于在xcode的模拟器上是没有办法模拟出3DTouch的操作,因此如果想在模拟器上开发这个功能的话,需要参考github上的一位大神的[解决方案](https://github.com/DeskConnect/SBShortcutMenuSimulator),当然这种方案只能模拟快捷菜单,其他的3DTouch的操作是没法模拟的,最好的方式还是去买一个iphone6S.


##快捷菜单
所谓的快捷菜单就是 在应用的图标上重按,然后会出现几个快捷项.直接点击这些菜单项就可以执行某些操作.

![](/img/2015/10/18/1.gif)

<!--more-->

###UI设置
要实现这些个快捷菜单就需要在程序启动或配置info.plist程序的时候给程序增加上`UIMutableApplicationShortcutItem`.
这个其实就是`UIApplicationShortcutItem`的一个子类.`UIApplicationShortcutItem`就是IOS用来表示快捷菜单的类,并且一个程序最多只能有4个快捷菜单项.
他有几个重要的属性:

* UIApplicationShortcutItemType,事件的唯一标识,用来表示你到底点击了哪个操作
* UIApplicationShortcutItemTitle,标题,在没有子标题的情况下可以自动换行
* UIApplicationShortcutItemSubtitle,子标题,在标题下方较小字体显示
* UIApplicationShortcutItemIconType,枚举选取系统中的一个图标
* UIApplicationShortcutItemIconFile,自定义一个图标文件,以单色35*35的大小展示
* UIApplicationShortcutItemUserInfo,自定义字典,可以放入自定义的属性.

因此,要给我的程序增加`最新日报` `每日瞎扯`的话,就需要这样操作:

1. info.plist配置方式:

```xml
<key>UIApplicationShortcutItems</key>
<array>
    <dict>
        <key>UIApplicationShortcutItemType</key>
        <string>newNews</string>
        <key>UIApplicationShortcutItemTitle</key>
        <string>最新日报</string>
        <key>UIApplicationShortcutItemIconType</key>
        <string>Share</string>
    </dict>
    <dict>
        <key>UIApplicationShortcutItemType</key>
        <string>xiaCheNews</string>
        <key>UIApplicationShortcutItemTitle</key>
        <string>每日瞎扯</string>
        <key>UIApplicationShortcutItemIconType</key>
        <string>Compose</string>
    </dict>
</array>
```

2. 编程方式:

```swift
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
	...
	...
	// 增加Icon 3DTouch的功能
        
        //添加icon 3d Touch
        //先建立图标
        let firstItemIcon:UIApplicationShortcutIcon = UIApplicationShortcutIcon(type: .Share)
        //然后创建按钮项,通过Type可以确定是哪一个按钮,
        let firstItem = UIMutableApplicationShortcutItem(type: "1", localizedTitle: "最新日报", localizedSubtitle: nil, icon: firstItemIcon, userInfo: nil)
        
        let secondItemIcon:UIApplicationShortcutIcon = UIApplicationShortcutIcon(type: .Compose)
        let secondItem = UIMutableApplicationShortcutItem(type: "2", localizedTitle: "每日瞎扯", localizedSubtitle: nil, icon: secondItemIcon, userInfo: nil)
        
        application.shortcutItems = [firstItem,secondItem]
}
```

###事件处理
UI解决了后,接下来需要做的就是处理快捷菜单的事件了.
在`IOS9`中`UIApplication`增加了一个回调方法:

```swift
func application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: (Bool) -> Void)
```

当接收到快捷菜单的点击后,会调用这个方法.因此我们的事件处理就可以放到这里面:

```swift
// MARK: - 3D Touch的操作
    func application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: (Bool) -> Void) {
        //这个方法就是激活了3DTouch时触发的操作.
        
        let handledShortCutItem = handleShortCutItem(shortcutItem)
        completionHandler(handledShortCutItem)
    }
    
    /**
    这个方法用处处理3DTouch的操作
    
    - parameter shortcutItem: 3DTouch的按钮
    
    - returns: 是否执行成功
    */
    func handleShortCutItem(shortcutItem: UIApplicationShortcutItem) -> Bool {
        
        var handled = false
        
        //找到根视图
        let launchImageViewController = window!.rootViewController as? LaunchImageViewController
        //打开根视图
        let rootNavigationViewController = launchImageViewController!.viewController as? UINavigationController
        let pkRevealController = rootNavigationViewController?.viewControllers.first as? PKRevealController
        let rootViewController = pkRevealController?.frontViewController
        
        if shortcutItem.type == "1" { //最新日报
            
            //然后打开最新的日报
            rootViewController?.performSegueWithIdentifier("pushSegue", sender: "newNews")
            
            handled = true
        }
        
        if shortcutItem.type == "2" { //每日瞎扯
            
            //然后打开每日瞎扯
            rootViewController?.performSegueWithIdentifier("pushSegue", sender: "xiacheNews")
            
            handled = true
            
        }
        return handled
    }
```

需要注意的是`completionHandler`
在API中说明如果我们的应用程序不在后台而是重新启动的时候,应该设置为false,并且这时的回调是:

```swift
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool 
```

因此我们还需要再在`didFinishLaunchingWithOptions`中增加相应的逻辑:

```swift
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {
// 增加3DTouch启动程序时的处理
        // 从启动项中获取是否是从3DTouch中启动的
        let launchShortcutItem:UIApplicationShortcutItem? = launchOptions?[UIApplicationLaunchOptionsShortcutItemKey as NSObject] as? UIApplicationShortcutItem
        if  launchShortcutItem != nil{
            //说明是使用3DTouch启动的,那么当页面启动的时候就需要直接跳转到新闻详细中
            //这里的逻辑是这样的,在启动的时候设置一个标志,是否需要跳转,然后在LaunchImageViewController中会判断是否有这个标志.如果有
            //就进行界面的跳转
            LaunchImageViewController.jumpTo = launchShortcutItem?.type == "1" ? "newNews" : "xiacheNews"
        }
}
```
也就是我们可以从启动的`launchOptions`获取`key`为`UIApplicationLaunchOptionsShortcutItemKey`的项,如果没有就说明不是3DTouch启动的,否则就是点击某一个`快捷菜单`启动的.

当这两个地方都处理了后, 3DTouch的快捷菜单功能就算是完成了.

##内容预览

3DTouch在应用中还有一个常用的功能,就是内容预览.通过轻按(peek)和重按(pop)来进行一系列的操作.

![](/img/2015/10/18/2.PNG)

![](/img/2015/10/18/3.PNG)

首先需要的是判断3DTouch是否在这个Controller上开启,决定这个的是`UIForceTouchCapability`:

* UIForceTouchCapabilityUnknown		//3D Touch检测失败
* UIForceTouchCapabilityUnavailable		//3D Touch不可用
* UIForceTouchCapabilityAvailable		//3D Touch可用

所以在程序中我们可以这样写:

```swift
/**
    检测页面是否处于3DTouch
    */
    func check3DTouch(){
        
        if self.traitCollection.forceTouchCapability == UIForceTouchCapability.Available {
            
            self.registerForPreviewingWithDelegate(self, sourceView: self.view)
            //长按停止
            self.longPress.enabled = false
            
        } else {
            self.longPress.enabled = true
        }
    }
```

当我们想给某一个controller增加内容预览功能的时候,就需要给这个controller实现`UIViewControllerPreviewingDelegate`协议.

这个协议有两个方法,分别是`peek`操作时触发以及`pop`操作触发:

```swift
// 轻按
public func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -> UIViewController?

//重按
public func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)
```

那么轻按预览的逻辑就很好处理了.
在`public func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -> UIViewController?`这个方法中,根据`location`找到轻按的内容项是哪一个,然后在程序中找到对应的详细内容.然后构造一个UIViewController进行返回.

```swift
/**
    轻按进入浮动页面
    
    - parameter previewingContext:
    - parameter location:
    
    - returns:
    */
    func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -> UIViewController? {
        
        let cellPosition = mainTableView.convertPoint(location, fromView: view)
        
        if let touchedIndexPath = mainTableView.indexPathForRowAtPoint(cellPosition) {
            
            mainTableView.deselectRowAtIndexPath(touchedIndexPath, animated: true)
            
            let aStoryboard = UIStoryboard(name: "Main", bundle:NSBundle.mainBundle())
            
            if let newsDetailViewController = aStoryboard.instantiateViewControllerWithIdentifier("newsDetailViewController") as? NewsDetailViewController  {
                
                if  newsDetailViewController.newsListControl == nil {
                    newsDetailViewController.newsListControl = self.newsListControl
                    newsDetailViewController.mainViewController = self
                }
                
                newsDetailViewController.newsLocation = (touchedIndexPath.section,touchedIndexPath.row)
                
                let cellFrame = mainTableView.cellForRowAtIndexPath(touchedIndexPath)!.frame
                previewingContext.sourceRect = view.convertRect(cellFrame, fromView: mainTableView)
                
                return newsDetailViewController
            }
        } 
        
        return UIViewController()
    }

```

在我的程序中就是找到轻按的新闻列表行.然后找到具体是哪一篇新闻,然后从`storyBoard`中获取出新闻详细的ViewController.然后传入新闻详细的参数,最后返回. 这样就完成了轻按显示详细的目的.

而重案的话就更好处理了,在方法`public func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)`中的`viewControllerToCommit`表示的就是你轻按激活的预览View.如果你想直接放大显示这个View的话,就直接调用`self.showViewController(viewControllerToCommit, sender: self)`即可.比如我程序中的:

```swift
/**
    重按进入文章详情页
    
    - parameter previewingContext:
    - parameter viewControllerToCommit:
    */
    func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController) {
        
        self.showViewController(viewControllerToCommit, sender: self)
    }
```
当然,你还可以增加些其他的操作.

更高级的操作比如内容预览上的Action等,等我后面增加到我的程序中后再来补充.


