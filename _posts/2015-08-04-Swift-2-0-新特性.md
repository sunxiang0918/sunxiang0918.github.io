---
title: Swift 2.0 新特性
date: 2015-08-04 21:35:51
tags:
- Swift
comments: true
---


# Swift 2.0 新特性

`Swift2.0` 算是一个大得版本更新.新增或修改了很多的特性.出来这么久了,我也把我练手写的知乎日报全部转换成了`Swfit2.0`.其中还是遇到了一些问题.因此,趁有空,就尝试总结一下`Swift2.0`的一些新特性或新的变化.

PS:本文写的时候采用的是 Swift2.0+Xcode7 beta4 的环境.

## 1.guard语句
`Swift2.0`中新引入了一个关键字`guard`用于条件的判断处理.它和`if`语句比较类似,都是通过一个`boolean`值来决定流程的走向.但是与`if`语句不同的是.`guard`语句只会有一个代码块.没有像`if else`那样有多个`guard else`.

那么`guard`到底有何作用呢?`guard`允许在一个代码周期中提前退出.也就是说,在`guard`关键字后接一个布尔表达式,只有当值为`false`的时候,才会执行`else`后的内容.如果值为`true`,那么就跳过这个`guard`代码块.

`guard`语句最常见的用法就是替代`if`做参数的合法性校验.
比如在以前:

```swift
func doSomeThing(a:String?,b:String?){

	if	let _a = a {
		if	let _b = b {
			print("\(_a):\(_b)")
		}
	}
	
	// print("\(_a):(_b)")  //这个地方不能访问_a和_b
}
```
向上面的例子那样,如果每一个参数都使用`if`语句来判断,那么这样的代码写起来非常的繁琐.读起来也不是很清晰.基于这种的情况,`Swift2.0`增加了`guard`关键字.把上面的代码改成使用`guard`的写法就会成这样:

```swift
func doSomeThing2(a:String?,b:String?){
    
    guard let _a = a else{
        return
    }
    
    guard let _b = b else{
        return
    }
    
    print("\(_a):\(_b)")	//这个地方是可以访问_a和_b
}
```
这样写比起以前使用`if`来做判断,代码的可读性更强了.并且`Optaion`类型的变量的解包可以在全局可见了.这在网络编程中解析JSON等是非常有用的.

`guard`除了用于入参的校验和可选类型的解包外.还可以用于抛出异常以及结合`available`做函数的检查:

```swift
guard name != nil else {
	throw IllegalArgumentException
}

guard #available(iOS 8, *) else {
	return
}
```
<!--more-->

## 2.协议扩展
在之前的`Swift`中,协议(`Protocol`)其实相当于JAVA中的接口,可以定义若干的方法以及属性.然后其他的类、结构体、枚举等都继承这个协议.然后有各自的实现.而现在,在`Swift2.0`中,可以对协议进行扩展(`extension`),就和给一般的`Class`进行扩展一样.并且,同`JDK1.8`一样,现在协议允许拥有默认的**方法实现**了.这样就大大的增加了编程的灵活度.避免了当需要修改协议时候，需要修改全部实现该协议的类.
举一个例子:

```swift
// 申明一个协议 要求实现 说话的方法
protocol Person {
	func sayHello()
}

// 扩展协议 增加 walk 方法, 并默认实现
extension Person {
	func walk(){
		sayHello()
		print("walk")
	}
}

// 一个Lily类遵循Person协议
class Lily : Person {
	//实现协议中定义的方法
	func sayHello(){
		print("hello!")
	}
}

// 实例化一个Lily对象
let lily = Lily()

// 这个时候lily类可以直接调用协议中的两个方法
lily.sayHello()
lily.walk()
```

在`swift2.0`中很多的协议都被苹果公司增加了扩展. 比如`CollectionType`这个协议.所有的集合类型都遵循了这个协议,然后在`swift2.0`中增加了若干的扩展:

```swift
func map<T>(@noescape transform: (Self.Generator.Element) -> T) -> [T]

func filter(@noescape includeElement: (Self.Generator.Element) -> Bool) -> [Self.Generator.Element]

var last: Self.Generator.Element? { get }

func indexOf(element: Self.Generator.Element) -> Self.Index?
```
等等.

这样就可以在不改变原有协议的基础上给协议增加了若干的方法:

```swift
let numbers = [1, 5, 6, 10, 16, 42, 45]

// Swift 1
find(filter(map(numbers, { $0 * 2}), { $0 % 3 == 0 }), 90)

// Swift 2
numbers.map { $0 * 2 }.filter { $0 % 3 == 0 }.indexOf(90) // returns 2
```

## 3.Available检查
由于在苹果的生态环境中,基本上每一年都会推出新的`OS`,每年在发布会上都会说新的操作系统又新增了好多好多的`API`.好处当然是增加了很多功能,坏处也是显而易见的---不同版本间的`API`存在兼容的问题.比如我们调用了一个`IOS9`中新增的方法,那么这个应用程序运行在了`IOS8`上,这个时候如果我们不进行系统的版本测试的话,那么我们的应用就会直接的崩溃掉,这显然不是我们所期望的.

为了解决这个问题,在`Swift2.0`中新引入了`#available`.配合Available检查,新的`Swift`编译器,也会在编译的时候就进行检测,当我们在低版本的OS中使用高版本的`API`的时候,编译器会直接的报错.而当编译器帮我们检测到`API`版本问题后,接下来就需要我们使用`#available`语法进行处理了.

`#available`的使用语法是:

```swift
if #abailable(platform name version,...,*){
	//执行对应APIS
}else{
	//执行之前老版本APIS
}
```
前面的`platform name version`表示的是在平台的版本,允许有多个.
后面的* 表示的是其他平台,例如`Watch OS`

```swift
if #available(iOS9,OSX 10.11,*){
	//使用iOS 9以上的 API接口 以及使用 OS X10.11以上的API接口
}else{
	//使用老版本接口
}
```
这样就可以使用一套代码来完成不同平台的正确编译与运行了.这对我们现在的开发有了很大的便利.

## 4.defer关键字
由于我是学`JAVA`的,所以当学习`Swift`的时候就思考过一个问题:在`Swift`中有没有类似于`JAVA`中`try/finally`的语法.也就是说无论前面的代码如何执行,在离开这个代码块之前,一定要执行一段逻辑.很遗憾的是我在`swift1`中没有发现类似的语法.而在`Swift2.0`中,Apple提供了这个功能,也就是新引入的`defer`关键字.

`defer`关键字允许包括一个代码块.然后让这段代码块延迟到`defer`所在域的最后执行.这样说起来有第一点抽象,看一个例子就明白了.

```swift
func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        
        while let line = try file.readline() {
            // Work with the file.
        }
        
        close(file) is called here, at the end of the scope.
    }
}
```
上面的代码有一个问题,那就是如果file.readline方法抛出异常的时候,那么 这段代码最后的close(file)方法可能就不会执行了,这就造成了资源的未关闭问题.

那么如果我们使用`defer`来修正这个问题,就会这样:

```swift
func processFile(filename: String) throws {
    if exists(filename) {
        let file = open(filename)
        defer {
            close(file)
        }
        while let line = try file.readline() {
            // Work with the file.
        }
    }
}
```
在上面的代码中,有一个`defer`代码块.其中编写了文件关闭的逻辑. 而这段逻辑就会在整个`if`作用域的最后执行,无论是程序是正常的走出`if`,还是由于异常而跳出`if`.这样就保证了无论如何程序都会关闭文件.

这里有一个地方需要注意的是多个`defer`的调用顺序,如果是在不同的作用域中,那么`defer`的执行顺序是从里到外的.而如果是在同一个作用域中,`defer`的执行顺序是自下而上的.这和平时的代码调用顺序是相反的.

```swift
func aaa(a:Boolean) {
	print("1-1")
	
	print("1-2")
	defer{
		print("1-3")
	}
	
	if	a {
		print("2-1")
		defer{
			print("2-2")
		}
		print("2-3")
		defer{
			print("2-4")
		}
	}
}

aaa(true)
```
上面这段代码最后打印出来的信息是:

> 1-1
> 1-2
> 2-1
> 2-3
> 2-4
> 2-2
> 1-3
大家注意一下这个的打印顺序,体会一下就明白了.

## 5.异常处理
上面说完了类似于`JAVA`中的`try-finally`,下面就来说说`try-catch`.
在`Swift1`中是没有异常处理以及抛出异常的,如果要处理异常.大多数情况下都是使用`NSError`或者闭包回调的方式来处理的.这些方法都没法像`JAVA`中的`try-catch`一样方便简洁的处理异常.虽然现在在`JAVA`界中现在有人觉得随意的抛出异常是一种不负责任的做法,会导致程序的可读性降低,并且开始反思有没有一种更好的方式来处理异常,但就目前来说,无疑是最好的方式.

在`Swift2.0`中,苹果提供了`throws` `throw` `do` `catch` `try` 这几个关键字来处理异常.

* `throws`关键字写在一个方法签名的后面,返回值前,用于标识这个方法是会抛出异常的.
* `throw`关键字用于在代码块中抛出一个异常
* `do`关键字用于包裹一个代码块,形成一个`do-catch`作用域,来捕获异常
* `catch`关键字用于捕获某种异常,并且申明异常的处理逻辑
* `try`关键字用于调用某个会抛出异常的方法前,用于标识会尝试调用这个方法

例如:

```swift
// 定义一个异常类型
enum AppException : ErrorType {
	case IllegalArgumentException
	case IllegalFormatException
}

// 定义一个方法,可能会抛出异常
func doSomeThing(age:Int) throws -> Void {
	// 检测入参是否合法,如果不合法就抛出异常
	if age < 0 {
		throw AppException.IllegalArgumentException
	}
	
	// 合法 执行业务逻辑
	print("age:\(age)")
}

// 尝试执行方法
func tryDoing(){
	do {
		try doSomeThing(-1)
	} catch e {
		print("error: \(e)")
		return
	}
}
```

1. 首先,需要定义一个异常,和`JAVA`中所有的异常都需要实现`Throwable`接口一样,在`Swift2`中异常是需要遵循`ErrorType`协议. 这里只是定义了一个异常的枚举.
2. 然后定义一个方法,并用`throws`关键字来标志这个函数会抛出异常.但是这个关键字后面不需要申明到底抛出什么异常
3. 接着在方法中使用`throw`抛出一个异常.这个和`JAVA`类似.
4. 在调用`doSomeThing`方法的地方使用`do-catch`来捕获异常.注意的是,这个地方apple又任性了一把,没有使用其他语言中通常使用的`try-catch`.
5. 在具体调用会抛出异常的方法时,使用`try`关键字来标识.这样做有一个好处,就是可以一眼就看出在一个代码域中到底是哪可能会抛出异常.而不是将所有的代码都混在`try-catch`作用域中.
6. 在`do-catch`语法中,同`try-catch`一样,也是允许有多个`catch`代码块的.比如:

	```swift
	do{
		try doSomeThing(-1)
	}catch AppException.IllegalArgumentException{
		print("xxx") 
	}catch AppException.IllegalFormatException{
		print("aaaa")
	}
	```
7. 同可选类型的解包一样.`try`也支持`try!`的写法.用于表示在明确的知道某一个throwing的方法不会抛出异常的情况下,使用`try!`就可以不用捕捉异常了.比如:
	
	```swift
		try! doSomeThing(10)
	```

当然,现在`Swift2.0`中的异常捕获还有完善的地方,比如还没有区分运行时异常,非运行时异常,错误等等.但这已经是一个好的开始,期望在以后的版本中继续完善.

## 6.print改变
Apple已经把它的简洁的基因发挥到了极致了.居然想到了把从C语言就开始的`println`与`print`函数统一成了一个`func print<T>(value: T, appendNewline: Bool)`函数.第二个参数就是用于表示是否起新的一行. 默认是`true`.
以后学编程的第一个例子再也不是

```swift
println("Hello World")
```

## 7.do-while语句重命名
由于`do`关键字已经被用于了异常的捕获了.如果这个地方再使用`do-while`就有可能产生歧义.因此,apple也把这个从C语言开始就有的语法给改了名字:`repeat-while`.幸好,只是改了一个名字,还是同样的配方,还是同样的味道 ^.^

## 8.重新可以使用performSelector
`performSelector`方法在`Swift1`中被Apple认为有安全的问题而去掉了.然后,为了实现相同的功能,广大码农想了千奇百怪的办法.比如使用`NSThread.detachNewThreadSelector:`,比如`NSTimer.scheduledTimerWithTimeInterval:`,又比如`sendAction:`.
不过在`Swift2.0`中,Apple又在`NSObjectProtocol`协议中恢复了这个方法的调用.
现在可以方便的使用了

```swift
func performSelector(aSelector: Selector) -> Unmanaged<AnyObject>!
func performSelector(aSelector: Selector, withObject object: AnyObject!) -> Unmanaged<AnyObject>!
func performSelector(aSelector: Selector, withObject object1: AnyObject!, withObject object2: AnyObject!) -> Unmanaged<AnyObject>!
```
比如:

```swift
self.performSelector("action", withObject: nil)
self.performSelectorInBackground("action", withObject: nil)
```
注意,这个方法在`Playground`中还是不能使用哈.

## 9.更强的语言结构性
由于`扩展协议`功能的出现,Apple把大量原来非面向对象的全局函数都封装到了各个协议中.让整个`Swift2`的语言结构性更强了.比如:

```swift
let numbers = [1, 5, 6, 10, 16, 42, 45]

// Swift 1
find(filter(map(numbers, { $0 * 2}), { $0 % 3 == 0 }), 90)

// Swift 2
numbers.map { $0 * 2 }.filter { $0 % 3 == 0 }.indexOf(90) // returns 2

//Swift 1
if	contains(numbers,6) {
	println("success")
}

//Swift 2
if	numbers.contains(6) {
	println("success")
}

let str = "Swift"
//Swift 1
let c = count(str)

//Swift 2
let c = str.characters.count
```

## 10.枚举的递归
在Swift中枚举类型是非常的强大的.它不仅可以拥有自己的属性,自己的方法.还可以遵循协议.极端点来说上来说,光使用枚举和结构体,就能把一个程序写完.
在`Swift2.0`中枚举又得到了增强,现在可以递归的定义枚举类型了.
什么叫递归的枚举喃?就是在枚举定义中引用自己,看一个例子就明白了:

```swift
indirect enum Tree<T> {
       case Leaf(T)
       case Branch(left: Tree<T>, right: Tree<T>)
}
```
看到了没,在定义Tree.Branch枚举的时候允许传入两个参数,并且这两个参数又是Tree枚举的.这就形成了枚举的递归.这样做有什么用呢?它其实扩大了枚举的使用场景.通过枚举就可以构建很复杂的数据结构和业务逻辑了.
比如:

```swift
//: 定义一个计算的协议
protocol Evaluate {
    func evaluate() -> Int
}

//: 定义一个计算表达式的枚举
indirect enum ArithmeticExpression : Evaluate{
  
  //表示数  
  case Number(Int)
  //表示加法
  case Addition(ArithmeticExpression,ArithmeticExpression)
  //表示乘法
  case Multiplication(ArithmeticExpression,ArithmeticExpression)
  
  //实现Evaluate协议
  func evaluate() -> Int {
  	//进行计算
    switch self {
    case .Number(let value):
        return value
    case .Addition(let left, let right):
        return left.evaluate() + right.evaluate()
    case .Multiplication(let left, let right):
        return left.evaluate() * right.evaluate()
    }
  }
}

// evaluate (3 + 8) * 3
let three = ArithmeticExpression.Number(3)
let eight = ArithmeticExpression.Number(8)
let sum = ArithmeticExpression.Addition(three, eight)
let product = ArithmeticExpression.Multiplication(sum,three)
print(product.evaluate())		//这里打印结果 33

```

## 11.增强化的模式匹配
在`Swift2.0`中强化了模式匹配,现在对于控制流增加了很多种组合.比如:
`if/case` `while/case` `guard/case` `for-in/case`等等,并且上述的语法都允许像`switch`/`case`那样后面接上`where`做判断.
比如:

```swift
enum SignUpFormField {
    case FirstName(String)
    case LastName(String)
    case EmailAddress(String)
    case DOB(NSDate)
}

//Swift1
func bornBeforeTaylorSwift(signUpFormField: SignUpFormField) {
 
    switch signUpFormField {
    case .DOB(let otherBday)
        where taylorSwiftsBday.compare(otherBday) == .OrderedDescending:
        print("Fun fact: You were born before Taylor Swift!")
    default:
        break
    }
}

// Swift2
func bornBeforeTaylorSwift(signUpFormField: SignUpFormField) {
 
    if case .DOB(let otherBday) = signUpFormField
        where taylorSwiftsBday.compare(otherBday) == .OrderedDescending
    {
        print("Fun fact: You were born before Taylor Swift!")
    }
}
```
上面例子说明,`if/case`的用法,它和`switch`中的`case`其实是一样的.如果满足case后的条件,那么就执行`if`中的操作.这样像上例那样只有一个分支的枚举选择,就不需要使用`switch`语句了.

增强的模式匹配不光是可以用在枚举类型上.对于`可选类型`的解包操作同样的奏效.比如:

```swift
let someNumber:Int? = 1

//使用case的方式解包
if case let x? = someNumber {
	//这里的x已经不是可选类型了
	print("someNumber is \(x)")
}

let arrayOfNumbers:[Int?] = [1,2,nil,4,5,nil]

//Swift1
for x in arrayOfNumbers {
	if let _x = x {
		print("Found a number \(_x)")
	}
}

//Swift2.0
for case let x? in arrayOfNumbers {
	print("Found a number \(x)")
}
```
直接一步就搞定了,比以前方便了.

## 结束语
`Swift2.0`是一个大版本,有着许多优化与改动.经过这一次的改变,`Swift2.0`变得更加的友好、方便、安全,大大的增加了我们的开发体验.这里只介绍了其中的一些大点的改动,更多的API方面的变化等着我们继续的去挖掘.


