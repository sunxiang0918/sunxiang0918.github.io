title: Kotlin中常见扩展函数和顶层函数
date: 2017-07-30 11:39:43
tags:
- Kotlin
---

# Kotlin中常见扩展函数和顶层函数

为了编程的方便,kotlin中为我们提供了一些常用的扩展函数和顶层函数,掌握好这些函数可以大大的提高我们的编程效率

## let函数

let函数扩展了所有的泛型对象,默认当前这个对象作为闭包的it参数,而返回值是闭包函数的最后一行,或者指定其return.

函数定义为:

```java

public inline fun <T, R> T.let(block: (T) -> R): R

``` 

通过这个函数,我们可以用来安全执行可空变量的一些操作.例如:

```java

fun letTest(a:Int?){
    //当a不为空的时候才执行let中的语句, 为空的时候略过
    val let = a?.let {
        println(it)     //it 即为a
        println(a)  //上下文智能推断出不为空,因此不需要!!
        return@let 2    //返回值2   也可以直接写一个2 即可
    }
    println(let)
}

```

<!--more-->

## apply函数

apply函数扩展了所有的泛型对象,在闭包范围内可以任意调用该对象的任意方法,并在最后返回该对象.

函数定义为:

```java

public inline fun <T> T.apply(block: T.() -> Unit): T

``` 

它的一个主要作用是可以用来简化初始化对象的功能.例如我们在JAVA中的这样的写法:

```java

public void applyTest(B b) {
        
        A a = new A();
        a.setXXX(1);
        a.setYYY(1);
        a.doZZZZ(1);

        /* b的doAction需要一个A对象,并且必须是初始化后的A对象.
        * 那么,在JAVA中就只能先实例化出来一个A,然后调用A的方法进行一些处理,
        * 最后再作为参数 传入到b的方法中去.*/
        b.doAction(a);     
    }
    
```

而在Kotlin中,我们可以使用apply函数来简化这个事情:

```java

fun applyTest(b: B) {

    b.doAction(
       A().apply {
        this.setXXX(1)
        this.setYYY(1)
        this.doZZZZ(1)
    })
}

```
特别需要注意的是apply函数中表示对象本身使用的是`this`关键字而不是`it`

# run函数

run函数的用法和apply函数基本相同,唯一的区别在于 apply函数返回的是对象本身,而run函数返回的是闭包的返回.

函数定义:

```java

public inline fun <T, R> T.run(block: T.() -> R): R

```

# also函数

这个函数是kotlin1.1新增的, 起用法和apply函数也基本相同,也是返回对象本身,区别在于 在also函数内我们使用`it`来指代对象本身而不是使用`this`关键字.

函数定义:

```java

public inline fun <T> T.also(block: (T) -> Unit): T 

```

# with函数

with函数不是扩展函数,而是顶层函数,它是将某个对象作为函数的参数,在函数块中可以通过this来指代该对象,返回值为闭包函数的最后一行或者return表达式

函数定义:

```java

public inline fun <T, R> with(receiver: T, block: T.() -> R): R

```

with函数主要可以用来简化和集中对某一个对象的操作. 

比如在JAVA中:

```java

        A a = new A();
        a.setXXX(1);
        a.setYYY(1);
        a.doZZZZ(1);
        ...
        
```

而在kotlin中就可以:

```java

    with(A()){
        setXXX(1)
        setYYY(1)
        doZZZZ(1)
        this
    }
    
```

# repeat函数

repeat为顶层函数,其实就是简化了for循环,允许重复执行闭包中的事情.

函数定义为:

```java

public inline fun repeat(times: Int, action: (Int) -> Unit) 

```

例如:

```java

    repeat(10){
        println(it)     //it表示的是循环的index
    }
    
```

# takeIf函数 takeUnless函数

这两个函数都是kotlin1.1中新增加的,都是扩展函数,允许传入一个闭包.
taskIf函数如果传入的闭包返回为真,那么就返回对象T,否则返回null.
taskUnless函数与taskIf函数相反.

函数定义:

```java

public inline fun <T> T.takeIf(predicate: (T) -> Boolean): T?

public inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T?

```

这两个函数可以用来简化filter的实现或者条件过滤

# lazy函数

lazy表示延迟运算, 只有当第一次访问的时候,才调用lazy内部的初始化闭包,通过这个方式,很容易的实现一些延迟的处理.通常和`by`关键字配合,实现属性的延迟加载.

函数定义:

```java

public fun <T> lazy(initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer)

public fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T>

public fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T>

```

这个函数看似神奇,内部的实现其实很简单,在内部主要是把函数闭包给封装成了Lazy<T>的对象, 当第一次访问的时候,触发调用`getValue`,然后在内部执行闭包函数,从而延迟运行.

例子:

```java

private val graphDef: ByteArray by lazy {
        ClassifierTest::class.java.getResource("/models/tensorflow_inception_graph.pb").readBytes()
    }
    
```

# use函数

在JDK1.7中引入了`try-with-resources`表达式,允许自动的关闭某一些对象,比如最常见的`InputStream`这些.
在Kotlin1.2 中也有相同功能的函数实现,那就是`use函数`. use函数是一个扩展函数,扩展自`Closeable`接口,因此,所有实现了`Closeable`的对象都可以调用use函数来达到相同的目的.并且语法还要更简单,避免了写复杂的`try-catch-finally`

函数定义:

```java

inline fun <T : Closeable?, R> T.use(block: (T) -> R): R (source)

```

例子:

```java

Graph().use { g ->  
    println(g)
}

```

同java中的`try-catch-finally`一样,无论如何,是否抛出异常,kotlin都是会执行use对象的close方法的.


