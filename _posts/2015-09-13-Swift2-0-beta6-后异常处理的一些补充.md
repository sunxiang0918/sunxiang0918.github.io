title: Swift2.0 beta5 后异常处理的一些补充
date: 2015-09-13 22:10:42
tags:
- Swift
comments: true
toc: false
---

# Swift2.0 beta5 后异常处理的一些补充

随着`XCode7 GM`在9月9号的推出,Swift2.0也要进入了GM了.随后的语法应该会逐渐的稳定下来了.其实在Swfit2.0 beta6后,Swift2对异常的处理又发生了一些变化,比如增加了一个`try?`关键字.
因此,这篇文章就再罗列一下现在Swift2.0异常处理的各种场景与方式.


## 首先是定义一个异常.
Swift2.0中 所有的异常类都是遵循`ErrorType`这个协议的.因此定义一个异常的最简单的方式就是使用枚举来实现一个这个协议:

```swift
enum AppException : ErrorType {
    case IllegalArgumentException
    case IllegalFormatException(coinsNeeded: Int)
}
```

在这个例子中我使用枚举定义了一个`AppException`的异常类,有两个case,并且借助于swift中强大的枚举类,`IllegalFormatException`case拥有一个`Int`类型的变量为`coinsNeeded`.

<!--more-->

当然,你也可以像`JAVA`中那样,从异常的基类上继承一个自定义的异常类.
在JAVA中是这样写的:

```java
public class ServerException extends Exception {
	private String code;
	private String message;
	
	public ServerException(String code) {
		this.code = code;
	}
	
	...
	setter/getter
	...
}
```

相同的逻辑在swift2中是这样的:

```swift
struct ServerException : ErrorType {
    var code:String
    var message:String?
    
    init(code:String){
        self.code = code
    }
    
    init(code:String,message:String) {
        self.code = code
        self.message = message
    }
}
```

需要注意的是,在Swift2.0 beta5之前 直接用结构体来实现`ErrorType`是会出错的.
必须在实现的结构体中增加`_domian:String` `_code:Int` 这两个计算属性才可以.这不知道是它内部实现有什么魔法了. 但是在`beta5`以后就不存在这个问题了,我们可以任意的实现`ErrorType`用来自定义异常类.

## 接着就是要使用异常了
定义完异常后,接下来肯定就是在我们的程序中使用异常了.
swift2.0中提供了 `try` `try!` `try?` `do` `catch` `throws` `throw` 这几个关键字来处理异常.我们一个一个的来说.

### 1.throw/throws
`throw`和`throws`这两个关键字 其实和JAVA中的语义是一样的. 在JAVA面试中 它们两个的区别 基本上算是必考的题.
`throw`表示的是 在程序语句中抛出一个异常.而`throws`用于定义在方法的签名上,表示这个方法可能会抛出异常.

`siwft2`中的`throws`语法与`JAVA`中的稍有不同, 差别就在于它的位置,以及类型标示.
在`JAVA`中,`throws`是位于方法签名的最后的:`访问限定符 返回类型 方法名(入参列表) throws 异常类型`.
而在swift中`throws`更多的就只是一个标示,它并不写明要抛出的异常类型是什么,只是告诉调用者,我是要抛出异常的.因此,它的位置更靠前,是在返回参数类型之前: `func 方法名(入参列表) throws ->返回类型`

在程序语句中使用`throw`抛出异常的时候,同JAVA一样,抛出的应该是一个异常类型的实例.
如果是枚举类型,并且是没有参数的.那么就可以直接写上枚举值,比如:`throw AppException.IllegalArgumentException`,如果是有参数的枚举类型或者是结构体,那么在throw后就需要传入实例的值.比如:`throw ServerException(code: "E0001")` `throw AppException.IllegalFormatException(coinsNeeded: 5)`

### 2.do/catch
这个就是swift中的异常捕捉的语法.
`do`代码块用于包裹一个代码块,其中可能会有要抛出异常的方法.`catch`代码块用于捕捉异常,并在它自身的代码块中处理异常

比如常规的用法:

```swift 
func exceptionTest() -> Void {
	do {
		print("123")
	   throw AppException.IllegalFormatException(coinsNeeded: 5)
	}catch let e {
		print("exception: \(e)")
	}
}
```

这段代码就演示了 如果使用 do-catch 代码块来捕捉一个异常,以及顺带演示了如何抛出一个带有参数的枚举类型的异常. 上面的代码 捕捉了任意类型的异常,并且使用了一个 e 变量来表示它.这样在catch块中就可以使用这个异常了.

当然,你也可以定义多个catch块,每一个catch块都指定一个要处理的异常类型,这样的用法也是很常见的.
在swift2中当然也是支持的,例如:

```swift
func exceptionTest() -> Void {
    do{
        print("123")
        throw AppException.IllegalFormatException(coinsNeeded: 5)
    }catch AppException.IllegalArgumentException {
        print("IllegalArgumentException")
    }catch AppException.IllegalFormatException(let coinsNeeded){
        print("aaaa:\(coinsNeeded)")
    }catch let e {
        print("exceptions: \(e)")
    }
}
```
需要注意的是catch代码块的顺序是从上到下匹配的.所以,通常我们会把越广泛的catch异常处理块定义到越后面. 上面的例子就很好的表现了这一点. 并且也演示了 如何接收带有参数的枚举类型的异常的值.

当然,还有一种情况就是捕捉自定义的异常结构体.它和捕捉枚举类型的异常其实是一样的.只是多了一个异常类型转换的过程:

```swift
func exceptionTest3(cass:Bool) throws {
    
    do {
        if cass {
            throw ServerException(code: "E0001")
        }else {
            throw AppException.IllegalArgumentException
        }
    }catch let er as ServerException{
        print("err:\(er.code)")
    }catch let e {
        print("exceptions:\(e)")
        throw ServerException(code: "E0001")
    }   
}
```
如上面的代码所示, 当`cass`为`true`的时候,方法会抛出一个自定义的`ServerException`异常. 而捕获这个异常的代码为`catch let er as ServerException`,也就是 它定义了一个变量`er`并且转换为`ServerException`类型,来接收这个异常. 因此异常体中就可以直接使用结构体中的成员和方法了.
同样,catch代码块的顺序是从上到下匹配的.
另外一个值得注意的地方在于,我可以在catch块中继续的抛出异常,只要有地方继续的do-catch这个异常或者是方法签名可以抛出异常即可.

因此,这又说明了一个问题,就是 如果一个方法可以抛出异常,那么它就可以直接调用其他的可能会抛出异常的方法,而不需一定要使用do-catch来捕获异常.
这样就可以一层一层的把异常传递出去.比如:

```swift
func exceptionTest2() throws ->Int {
    //可以不用do-catch 而直接调用exceptionTest 从而把异常抛出去
    exceptionTest()
    return 0
}
```

### try/try!/try?

剩下的就是这对三胞胎兄弟了. 他们的语义都是说明 他们后面的方法是可能要抛出异常的,我要尝试执行.
其中, `try`必须在`do-catch`语句中. 用于在`do-catch`语句中标识哪句话可能会抛出异常.
比如:

```swift
do {
        let result = try exceptionTest2()
        print("result:\(result)")
        if cass {
            throw ServerException(code: "E0001")
        }else {
            throw AppException.IllegalArgumentException
        }
    }catch let er as ServerException{
        print("err:\(er.code)")
    }catch let e {
        print("exceptions:\(e)")
        throw ServerException(code: "E0001")
    }
```

这句话就很清楚的表明,`exceptionTest2()`在调用的时候可能会抛出异常,我要尝试的执行这句方法.如果执行成功没有问题,那么就赋值给result.如果有问题,那么就抛出异常,由异常捕获块来处理异常.

但是,有时某个方法虽然它定义了可能抛出异常,但是在我们的使用场景中非常的确定这个方法里面是不会抛出异常的.那么我们就可以不使用 `do-catch`块来多此一举的捕获异常. 直接使用`try!`就可以了.
它就说明这个方法里面是不可能抛出异常的,我很肯定.比如:

```swift
func exceptionTest4() -> Int {
    return try! exceptionTest2()
}
```
注意上面这个例子中的方法签名上并没有标示`throws`可能抛出异常. 但是在调用`exceptionTest2()`方法的时候非常的确定是不会抛出异常的,因此就直接使用了`try!`即可.
在这种情况下,如果一旦调用的方法抛出了异常,那么整个程序就会直接崩溃,这一点需要特别的注意.

还剩下一个就是`try?` 这个是`Swift2.0 beta6`中新增加的语法.
它会尝试执行一个可能抛出异常的操作,如果操作执行成功,执行的结果就会包裹在一个可选值里面,如果操作执行失败(比如某个错误被抛出了),那么执行的结果就是nil,而`error`的内容会被抛弃.

这样做的好处是在结合`if let`,`guard` 或者`map`等链式处理的时候 非常的方便.
因为有些时候我们并不关心异常的原因,只需要知道结果是异常的就可以了.那么在这个情况下.在异常的时候,需要非常繁琐的`do-catch`语句来不断的包裹和处理异常,可能整个业务的处理逻辑都被异常处理而打乱了.比如:

```swift
import Foundation
// get the currently logged in user
func loggedInUser() -> Int? { return 0 }
// get his name
func getUserName (userId: Int) throws -> String { return "Claus" }
// create a new image post with this username. Returns the post data
func imagePostForUserName(name: String, imageURL: NSURL?) -> NSData? { return NSData() }
// post the data to a server
func postImage(data: NSData) throws -> Bool { return true }

if let uid = loggedInUser() {
    do {
	let username = try getUserName(uid)
	if let data = imagePostForUserName(username, imageURL: nil) {
	    do {
		let success = try postImage(data)
		if success {
		    print ("Submitted")
		}  
	    } catch {
		// more error handling
	    }
	}
    } catch {
	// todo: error handling
    }
}
```
而如果使用了`try?`,那么代码就被简化成了:

```swift
if let uid = loggedInUser(),
	username = try? getUserName(uid),
	data = imagePostForUserName(username, imageURL: nil),
	success = try? postImage(data)
   where success == true {
      print ("Submitted")
}
```
一句话就搞定了.简化了不少. 当然,按照上面的写法我们就无法知道他错误的信息了.

### defer

除了上面所说的那些专门处理异常的关键字. 还有一个关键字`defer`可以配合`do-catch`语句来实现JAVA中`try-catch-finally`的逻辑. 也就是一段代码,无论成功执行还是异常捕获甚至是`try-finally`,它都要在最后执行. 这个在swift中 就是使用`defer`关键字来实现的.

比如上面的`test3`的例子,稍微改一下即可:

```swift
func exceptionTest3(cass:Bool) throws {
    
    defer{
        print("finally!")
    }
    do {
        let result = try exceptionTest2()
        print("result:\(result)")
        if cass {
            throw ServerException(code: "E0001")
        }else {
            throw AppException.IllegalArgumentException
        }
    }catch let er as ServerException{
        print("err:\(er.code)")
    }catch let e {
        print("exceptions:\(e)")
        throw ServerException(code: "E0001")
    }
    
}
```
他就会在方法的执行最后打印一句`finally!`. 需要注意的是,如果你把`defer{}`放在了`do{}`块里面.那么它的执行顺序是先于`catch`代码块的.

具体更多关于`defer`的用法,可以参考我另外的一篇博客:[Swift 2.0 新特性](http://sunxiang0918.cn/2015/08/04/Swift-2-0-新特性/#4-defer关键字)


## 总结
以上就是`Swift2.0`中异常处理的一些方面.用熟悉以后,确实很大大的方便我们的编程,写出更优雅的程序.







