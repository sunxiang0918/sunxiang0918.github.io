<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[翔妖除魔的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://sunxiang0918.github.io//"/>
  <updated>2015-07-25T10:06:02.000Z</updated>
  <id>http://sunxiang0918.github.io//</id>
  
  <author>
    <name><![CDATA[翔妖除魔]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Macos 通过安装Hexo 来搭建 GitHub Pages 博客系统]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/25/hello-world/"/>
    <id>http://sunxiang0918.github.io/2015/07/25/hello-world/</id>
    <published>2015-07-25T10:06:02.000Z</published>
    <updated>2015-07-25T10:06:02.000Z</updated>
    <content type="html"><![CDATA[<p>现在越来越多的人愿意使用独立的技术博客.如果自己搭建Wordpress等,需要涉及到服务器的问题.所以,很多人选择了GitHub提供的Pages来搭建个人博客,我也赶一回潮流.在MacOS 上 使用Hexo来搭建GitHubPages博客.</p>
<h2 id="Hexo">Hexo</h2><p>hexo出自台湾大学生 <a href="http://twitter.com/tommy351" target="_blank" rel="external">tommy351</a> 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。</p>
<h3 id="安装Hexo">安装Hexo</h3><p>要安装<code>Hexo</code>需要先安装<code>Npm</code>以及<code>NodeJs</code>.<br>我在MacOS上,是使用<a href="http://brew.sh" target="_blank" rel="external">Brew</a>安装的.</p>
<ol>
<li><p>安装<strong>NodeJS</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<strong>Git</strong><br>由于我安装了XCode的,并且安装了<code>Command Line Tool</code>,因此,这一步可以省略了.否则还是在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>安装<strong>npm</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install npm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<strong>hexo</strong><br>这个就使用nodeJS的安装程序了.<br>同样在终端输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>这个步骤比较慢.因为你懂的</p>
</li>
<li><p>这个时候可以验证一下是否安装好了.<br>在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    $ node -v</span><br><span class="line">v0.<span class="number">12.7</span></span><br><span class="line">$ npm -v</span><br><span class="line">    <span class="number">2.12</span>.<span class="number">1</span></span><br><span class="line">    $ hexo -v</span><br><span class="line">    hexo: <span class="number">3.1</span>.<span class="number">1</span></span><br><span class="line">os: Darwin <span class="number">14.4</span>.<span class="number">0</span> darwin x64</span><br><span class="line">http_parser: <span class="number">2.3</span></span><br><span class="line">node: <span class="number">0.12</span>.<span class="number">7</span></span><br><span class="line">v8: <span class="number">3.28</span>.<span class="number">71.19</span></span><br><span class="line">uv: <span class="number">1.6</span>.<span class="number">1</span></span><br><span class="line">zlib: <span class="number">1.2</span>.<span class="number">8</span></span><br><span class="line">modules: <span class="number">14</span></span><br><span class="line">openssl: <span class="number">1.0</span>.<span class="number">1</span>p</span><br></pre></td></tr></table></figure>
<p>这样就说明安装完成了.<br>但是如果是显示的: <figure class="highlight"><figcaption><span>command not found ```. 说明环境变量没有设置.我也不知道为什么.但是只要补上环境变量就可以了.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    &#62; **hexo&#29615;&#22659;&#21464;&#37327;&#30340;&#35774;&#32622;:** &#22312;`~/` &#29992;&#25143;&#30340;&#26681;&#30446;&#24405;&#19979;&#21019;&#24314;&#19968;&#20010;&#30446;&#24405;:`.bash_profile`.&#20854;&#20013;&#30340;&#20869;&#23481;&#20026;:`export PATH=&#34;/usr/local/Cellar/node/0.12.7/libexec/npm/lib/node_modules/hexo/bi$`  &#20854;&#20013;&#30340;&#36335;&#24452;&#23601;&#26159;hexo&#30340;&#23433;&#35013;&#36335;&#24452;&#10;&#10;### &#20351;&#29992;Hexo&#21019;&#24314;&#21338;&#23458;&#10;&#24403;&#23433;&#35013;&#23436;&#25104;&#21518;,&#23601;&#21487;&#20197;&#24320;&#22987;&#21019;&#24314;&#21338;&#23458;&#20102;.&#10;&#10; 1. &#22312;&#26412;&#22320;&#21019;&#24314;&#21338;&#23458;&#25991;&#20214;&#22841;&#10;    &#36825;&#19968;&#27493;&#30340;&#30446;&#30340;&#26159;&#22312;&#20320;&#30340;&#26412;&#22320;&#21019;&#24314;&#19968;&#20010;&#21338;&#23458;&#30340;&#25991;&#20214;&#22841;.&#20197;&#21518;&#21338;&#23458;&#30340;source&#20197;&#21450;&#32534;&#35793;&#21518;&#30340;&#38745;&#24577;&#25991;&#20214;&#37117;&#20250;&#22312;&#36825;&#20010;&#30446;&#24405;&#20013;.&#10;&#10;    ``` bash&#10;    $ cd ~/&#10;    $ mkdir blog</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<ol>
<li><p>初始化博客文件夹<br>这一步是用于初始化hexo的一些文件的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    $ <span class="built_in">cd</span> ~/  </span><br><span class="line">    $ hexo init blog  </span><br><span class="line">    $ <span class="built_in">cd</span> blog  </span><br><span class="line">    $ ls  </span><br><span class="line">    _config.yml	node_modules	public		<span class="built_in">source</span></span><br><span class="line">db.json		package.json	scaffolds	themes</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化上下文</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的步骤完成后,就完成了hexo的初始化的过程了.<br>接着就可以开始关注于博客的编写了.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"新博客的名字"</span></span><br></pre></td></tr></table></figure>
<p>这样就在<code>_posts</code>文件夹里面新增加了一个<strong>md</strong>文件.直接对这一篇文档进行内容的编写就可以了.</p>
<p>而后,就在命令行中执行 <code>$ hexo generate</code> 就可以生成新的静态文件.新生成的文件全部放在<code>public</code>文件夹中的.</p>
<h3 id="使用Hexo部署博客到github">使用Hexo部署博客到github</h3><p>要使用github的pages功能的话,就需要创建一个 <code>xxxx.github.io</code>的<strong>repository</strong>. 其中<code>xxxx</code>表示的是你的github账号.这样github就会为你分配一个<code>xxxx.github.io</code>的地址.以后你的博客的访问地址也就是这个了.</p>
<p>有了这个地址以后,就要开始使用hexo部署了.<br>修改博客文件夹下的<code>_config.yml</code></p>
<p>主要是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/xxxx/xxxx.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>这个部分.<br>而后就在命令行中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>而后他就会自动的部署到你的github的pages中了.<br>如果报错说 未找到部署类型的话. 就需要安装<code>hexo-deployer-git</code></p>
<p>同样是在博客的目录中执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="后续">后续</h3><p>这样就搭建完毕了, 后续我会慢慢的把以前记录到 evernote的东西 精选一些转过来. </p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章记录了如何使用Hexo和github搭建个人博客]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://sunxiang0918.github.io/tags/Hexo/"/>
    
      <category term="github" scheme="http://sunxiang0918.github.io/tags/github/"/>
    
      <category term="博客" scheme="http://sunxiang0918.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="其他" scheme="http://sunxiang0918.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://sunxiang0918.github.io/2015/06/24/%E5%A6%82%E4%BD%95%E5%9C%A8Git%E4%B8%AD%E6%92%A4%E9%94%80%E4%B8%80%E5%88%87/"/>
    <id>http://sunxiang0918.github.io/2015/06/24/如何在Git中撤销一切/</id>
    <published>2015-06-23T16:00:00.000Z</published>
    <updated>2015-07-27T12:42:40.000Z</updated>
    <content type="html"><![CDATA[<p>title: &lt;转&gt;如何在Git中撤销一切<br>date: 2015-06-24 20:23:29<br>tags:</p>
<ul>
<li>GIT<br>toc: false<br>—-​</li>
</ul>
<h1 id="&lt;转&gt;如何在Git中撤销一切">&lt;转&gt;如何在Git中撤销一切</h1><p>翻译：李伟<br>审校：张帆<br>译自：<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">Github</a></p>
<p><img src="https://jf-bucket-public.oss-cn-qingdao.aliyuncs.com/jfperiodical/attached/image/20150612/2016242594.png" alt=""></p>
<p>任何一个版本控制系统中，最有用的特性之一莫过于 “撤销（undo）”操作。在Git中，“撤销”有很多种含义。<br>当你完成了一次新的提交（commit），Git会及时存储当前时刻仓库（repository）的快照（snapshot）；你能够使用Git将项目回退到任何之前的版本。<br>下文中，我将列举几个常见的、需要“撤销”的场景，并且展示如何使用Git来完成这些操作。</p>
<h3 id="一、撤销一个公共修改_Undo_a_“public”_change">一、撤销一个公共修改 Undo a “public” change</h3><p><strong>场景：</strong>你刚刚用git push将本地修改推送到了GitHub，这时你意识到在提交中有一个错误。你想撤销这次提交。</p>
<p><strong>使用撤销命令：</strong><code>git revert</code></p>
<p><strong>发生了什么：</strong>git revert将根据给定SHA的相反值，创建一个新的提交。如果旧提交是“matter”，那么新的提交就是“anti-matter”——旧提交中所有已移除的东西将会被添加进到新提交中，旧提交中增加的东西将在新提交中移除。</p>
<p>这是Git最安全、也是最简单的“撤销”场景，因为这样不会修改历史记录——你现在可以git push下刚刚revert之后的提交来纠正错误了。</p>
<h3 id="二、修改最近一次的提交信息_Fix_the_last_commit_message">二、修改最近一次的提交信息 Fix the last commit message</h3><p><strong>场景：</strong>你只是在最后的提交信息中敲错了字，比如你敲了git commit -m “Fxies bug #42”，而在执行git push之前你已经意识到你应该敲”Fixes bug #42”。</p>
<p><strong>使用撤销命令：</strong><code>git commit –amend或git commit --amend -m &quot;Fixes bug #42&quot;</code></p>
<p><strong>发生了什么：</strong>git commit –amend将使用一个包含了刚刚错误提交所有变更的新提交，来更新并替换这个错误提交。由于没有staged的提交，所以实际上这个提交只是重写了先前的提交信息。</p>
<h3 id="三、撤销本地更改_Undo_“local”_changes">三、撤销本地更改 Undo “local” changes</h3><p><strong>场景：</strong>当你的猫爬过键盘时，你正在编辑的文件恰好被保存了，你的编辑器也恰在此时崩溃了。此时你并没有提交过代码。你期望撤销这个文件中的所有修改——将这个文件回退到上次提交的状态。</p>
<p><strong>使用撤销命令：</strong><code>git checkout --</code></p>
<p><strong>发生了什么：</strong>git checkout将工作目录（working directory）里的文件修改成先前Git已知的状态。你可以提供一个期待回退分支的名字或者一个确切的SHA码，Git也会默认检出HEAD——即：当前分支的上一次提交。</p>
<p><strong>注意：</strong>用这种方法“撤销”的修改都将真正的消失。它们永远不会被提交。因此Git不能恢复它们。此时，一定要明确自己在做什么！（或许可以用git diff来确定）</p>
<h3 id="四、重置本地修改_Reset_“local”_changes">四、重置本地修改 Reset “local” changes</h3><p><strong>场景：</strong>你已经在本地做了一些提交（还没push），但所有的东西都糟糕透了，你想撤销最近的三次提交——就像它们从没发生过一样。<br><strong>使用撤销命令：</strong><code>git reset或git reset --hard</code><br><strong>发生了什么：</strong>git reset将你的仓库纪录一直回退到指定的最后一个SHA代表的提交，那些提交就像从未发生过一样。默认情况下，git reset会保留工作目录（working directory）。这些提交虽然消失了，但是内容还在磁盘上。这是最安全的做法，但通常情况是：你想使用一个命令来“撤销”所有提交和本地修改——那么请使用—hard参数吧。</p>
<h3 id="五、撤销本地后重做_Redo_after_undo_“local”">五、撤销本地后重做 Redo after undo “local”</h3><p><strong>场景：</strong>你已经提交了一些内容，并使用git reset –hard撤销了这些更改（见上面），突然意识到：你想还原这些修改！<br><strong>使用撤销命令：</strong><code>git reflog和git reset, 或者git checkout</code><br><strong>发生了什么：</strong>git reflog是一个用来恢复项目历史记录的好办法。你可以通过git reflog恢复几乎任何已提交的内容。<br>你或许对git log命令比较熟悉，它能显示提交列表。git reflog与之类似，只不过git reflog显示的是HEAD变更次数的列表。</p>
<h3 id="一些说明：">一些说明：</h3><ol>
<li>只有HEAD会改变。当你切换分支时，用git commit提交变更时，或是用git reset撤销提交时，HEAD都会改变。但当你用git checkout —时， HEAD不会发生改变。（就像上文提到的情形，那些更改根本就没有提交，因此reflog就不能帮助我们进行恢复了）</li>
<li>git reflog不会永远存在。Git将会定期清理那些“不可达（unreachable）”的对象。不要期望能够在reflog里找到数月前的提交记录。</li>
<li>reflog只是你个人的。你不能用你的reflog来恢复其他开发者未push的提交。  </li>
</ol>
<p><img src="/img/2015/06/24/1.png" alt="">  </p>
<p>因此，怎样合理使用reflog来找回之前“未完成”的提交呢？这要看你究竟要做什么：  </p>
<ol>
<li>如果你想恢复项目历史到某次提交，那请使用git reset —hard</li>
<li>如果你想在工作目录（working direcotry）中恢复某次提交中的一个或多个文件，并且不改变提交历史，那请使用git checkout—</li>
<li>如果你想确切的回滚到某次提交，那么请使用git cherry-pick。</li>
</ol>
<h3 id="六、与分支有关的那些事_Once_more,_with_branching">六、与分支有关的那些事 Once more, with branching</h3><p><strong>场景：</strong>你提交了一些变更，然后你意识到你正在master分支上，但你期望的是在feature分支上执行这些提交。<br><strong>使用撤销命令：</strong><code>git branch feature, git reset --hard origin/master, 和 git checkout feature</code><br><strong>发生了什么：</strong>你可能用的是git checkout -b来建立新的分支，这是创建和检出分支的便捷方法——但实际你并不想立刻切换分支。git branch feature会建立一个叫feature的分支，这个分支指向你最近的提交，但是你还停留在master分支上。<br>git reset —hard将master回退至origin/master，并忽略所有新提交。别担心，那些提交都还保留在feature上。<br>最后，git checkout将分支切换到feature，这个分支原封不动的保留了你最近的所有工作。</p>
<h3 id="七、事半功倍处理分支_Branch_in_time_saves_nine">七、事半功倍处理分支 Branch in time saves nine</h3><p><strong>场景：</strong>你基于master新建了一个feature分支，但是master分支远远落后与origin/master。现在master分支与origin/master同步了，你期望此刻能在feature下立刻commit代码，并且不是在远远落后master的情况下。<br><strong>使用撤销命令：</strong><code>git checkout feature和git rebase master</code><br><strong>发生了什么：</strong>你也许已经敲了命令：git reset（但是没用—hard,有意在磁盘上保存这些提交内容），然后敲了git checkout -b，之后重新提交更改，但是那样的话，你将失去本地的提交记录。不过，一个更好的方法：</p>
<p><strong>使用git rebase master可以做到一些事情：</strong></p>
<ol>
<li>首先，它定位你当前检出分支和master之间的共同祖先节点（common ancestor）。</li>
<li>然后，它将当前检出的分支重置到祖先节点（ancestor），并将后来所有的提交都暂存起来。</li>
<li>最后，它将当前检出分支推进至master末尾，同时在master最后一次提交之后，再次提交那些在暂存区的变更。</li>
</ol>
<h3 id="八、批量撤销/找回_Mass_undo/redo">八、批量撤销/找回 Mass undo/redo</h3><p><strong>场景：</strong>你开始朝一个既定目标开发功能，但是中途你感觉用另一个方法更好。你已经有十几个提交，但是你只想要其中的某几个，其他的都可以删除不要。<br><strong>使用撤销命令：</strong><code>git rebase -i</code><br><strong>发生了什么：</strong>-i将rebases设置为“交互模式（interactive mode）”。rebase开始执行的操作就像上文讨论的一样，但是在重新执行某个提交时，它会暂停下来，让你修改每一次提交。<br>rebase –i将会打开你的默认文本编辑器，然后列出正在执行的提交，就像这样：<br><img src="/img/2015/06/24/2.png" alt=""><br>前两列最关键：第一列是选择命令，它会根据第二列中的SHA码选择相应的提交。默认情况下，rebase –i会认为每个更改都正通过pick命令被提交。<br>要撤销一个提交，直接在编辑器删除对应的行就可以了。如果在你的项目不再需要这些错误的提交，你可以直接删除上图中的第1行和3-4行。<br>如果你想保留提交但修改提交信息，你可以使用reword命令。即，将命令关键字pick换成reword（或者r）。你现在可能想立刻修改提交消息，但这么做不会生效——rebase –i将忽略SHA列后的所有东西。现有的提交信息会帮助我们记住0835fe2代表什么。当你敲完rebase –i命令后，Git才开始提示你重写那些新提交消息。<br>如果你需要将2个提交合并，你可以用squash或者fixup命令，如下图：<br><img src="/img/2015/06/24/3.png" alt=""><br>squash和fixup都是“向上”结合的——那些用了这些合并命令（编者按：指squash、fixup）的提交，将会和它之前的提交合并：上图中，0835fe2和6943e85将会合并成一个提交，而38f5e4e和af67f82将会合并成另一个提交。<br>当你用squash时，Git将会提示是否填写新的提交消息；fixup则会给出列表中第一个提交的提交信息。在上图中，af67f82是一个“Ooops”信息，因为这个提交信息已经同38f5e4e一样了。但是你可以为0835fe2和6943e85合并的新提交编写提交信息。<br>当你保存并退出编辑器时，Git将会按照从上到下的顺序执行你的提交。你可以在保存这些提交之前，修改提交的执行顺序。如果有需要，你可以将af67f82和0835fe2合并，并且可以这样排序：<br><img src="/img/2015/06/24/4.png" alt="">  </p>
<h3 id="九、修复早先的提交_Fix_an_earlier_commit">九、修复早先的提交 Fix an earlier commit</h3><p><strong>场景：</strong>之前的提交里落下了一个文件，如果先前的提交能有你留下的东西就好了。你还没有push，并且这个提交也不是最近的提交，因此你不能用commit –amend。<br><strong>使用撤销命令：</strong><code>git commit --squash和git rebase --autosquash -i</code><br><strong>发生了什么：</strong>git commit –squash将会创建一个新的提交，该提交信息可能像这样“squash! Earlier commit”。（你也可以手写这些提交信息，commit –squash只是省得让你打字了）。<br>如果你不想为合并的提交编写信息，也可以考虑使用命令git commit —fixup。这种情况下，你可能会使用commit —fixup，因为你仅希望在rebase中使用之前的提交信息。<br>rebase —autosquash –i将会启动rebase交互编辑器，编辑器会列出任何已完成的squash!和fixup!提交，如下图：<br><img src="/img/2015/06/24/5.png" alt=""><br>当使用—squash和–fixup时，你或许记不清你想修复的某个提交的SHA码——只知道它可能在一个或五个提交之前。你或许可以使用Git的^和~操作符手动找回。HEAD^表示HEAD的前一次提交。HEAD~4表示HEAD前的4次提交，加起来总共是前5次提交。</p>
<h3 id="十、停止跟踪一个已被跟踪的文件_Stop_tracking_a_tracked_file">十、停止跟踪一个已被跟踪的文件 Stop tracking a tracked file</h3><p><strong>场景：</strong>你意外将application.log添加到仓库中，现在你每次运行程序，Git都提示application.log中有unstaged的提交。你在.gitignore中写上”<em>.log”，但仍旧没用——怎样告诉Git“撤销”跟踪这个文件的变化呢？<br><strong>使用撤销命令：</strong> git rm —cached application.log<br><em>*发生了什么：</em></em>尽管.gitignore阻止Git跟踪文件的变化，甚至是之前没被跟踪的文件是否存在，但是，一旦文件被add或者commit，Git会开始持续跟踪这个文件的变化。类似的，如果你用git add –f来“强制”add，或者覆盖.gitignore，Git还是会继续监视变化。所以以后最好不要使用–f来add .gitignore文件。<br>如果你希望移除那些应当被忽略的文件，git rm –cached可以帮助你，并将这些文件保留在磁盘上。因为这个文件现在被忽略了，你将不会在git status中看到它，也不会再把这个文件commit了。<br>以上就是如何在Git上撤销的方法。如果你想学习更多Git命令用法，可以移步下面相关的文档：<br>· <a href="http://git-scm.com/docs/git-checkout" target="_blank" rel="external">checkout</a><br>· <a href="http://git-scm.com/docs/git-commit" target="_blank" rel="external">commit</a><br>· <a href="http://git-scm.com/docs/git-rebase" target="_blank" rel="external">rebase</a><br>· <a href="http://git-scm.com/docs/git-reflog" target="_blank" rel="external">reflog</a><br>· <a href="http://git-scm.com/docs/git-reset" target="_blank" rel="external">reset</a><br>· <a href="http://git-scm.com/docs/git-revert" target="_blank" rel="external">revert</a><br>· <a href="http://git-scm.com/docs/git-rm" target="_blank" rel="external">rm</a></p>
<p>原文地址：<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">Github</a><br>译文地址：<a href="http://www.jointforce.com/jfperiodical/article/show/796?m=d03" target="_blank" rel="external">http://www.jointforce.com/jfperiodical/article/show/796?m=d03</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>title: &lt;转&gt;如何在Git中撤销一切<br>date: 2015-06-24 20:23:29<br>tags:</p>
<ul>
<li>GIT<br>toc: false<br>—-​</li>
</ul>
<h1 id="&lt;转&gt;如何在Gi]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Lucene进行索引部分更新缓慢原因分析]]></title>
    <link href="http://sunxiang0918.github.io/2014/07/25/%E4%BD%BF%E7%94%A8Lucene%E8%BF%9B%E8%A1%8C%E7%B4%A2%E5%BC%95%E9%83%A8%E5%88%86%E6%9B%B4%E6%96%B0%E7%BC%93%E6%85%A2%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    <id>http://sunxiang0918.github.io/2014/07/25/使用Lucene进行索引部分更新缓慢原因分析/</id>
    <published>2014-07-25T10:23:55.000Z</published>
    <updated>2015-07-27T11:05:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用Lucene进行索引部分更新缓慢原因分析">使用Lucene进行索引部分更新缓慢原因分析</h1><h2 id="问题的引出">问题的引出</h2><p>在我们的系统中,使用了<code>Lucene</code>作为全文检索引擎用作NRT近实时检索.这就牵涉到一个更新的问题.<br>在Lucene当中,其实是<strong>不存在部分更新</strong>的说法的,它仅仅支持全更新.因此,为了应用端的调用方便.在我们的FTEngine全文检索引擎中是提供了部分更新的功能的,其逻辑大体上来说,就是根据传入的<code>uniqueID</code>,在索引中找到对应的<code>Document</code>.然后再恢复它的<code>Term</code>.而后再<strong>构造全更新的Document</strong>,交由Lucene进行全更新.<br>但是,在北京台项目中,突然发现全文检索更新的很慢,往往页面都对素材修改了2个小时了,索引都还没有更新. 从而引出了这个问题.</p>
<h2 id="解决思路">解决思路</h2><p>经过最初步的分析, 发现发生这种现象多集中于有大量的归档与回迁的操作.这两个操作对索引的影响就是会一次性的大量的进行索引的部分更新. 因此就把原因怀疑到了部分更新上.</p>
<a id="more"></a>
<h2 id="分析过程">分析过程</h2><ol>
<li>修改FTEngine的源代码.在项目中,加入大量的日志,全部显示使用时间.<br><img src="/img/2014/07/25/1.png" alt=""><br><img src="/img/2014/07/25/2.png" alt="">  </li>
<li><p>发现程序在恢复<strong>没有Store</strong>的字段的Term的时候非常的慢.经过分析以及网上找问题,发现是由于我们对于Index的字段没有使用Lucene提供的<strong>TermVector</strong>功能,也就是Term的位置向量.它是以空间来换取时间,当使用了位置向量后,就相当于为每一个Term都编了号,记录了位置.这样在恢复的时候大大的提高了查询Term的性能.这样就能很快的恢复Document了.</p>
</li>
<li><p>经过修改后,再进行测试,发现有些Document的恢复还是很慢. 对比恢复的快的与慢得Document.发现他们的区别在于恢复字段的时候,如果每一个字段都是有值的,那么由于有termVector那么会非常的快.但是如果这个字段是没有值的,那么恢复Term就相当的慢.<br><img src="/img/2014/07/25/3.png" alt=""><br><img src="/img/2014/07/25/4.png" alt=""> </p>
</li>
<li><p>进一步分析,没有<strong>digitalbarcode</strong>字段,那么他恢复这个的时候是如何处理的呢?<br>代码先去找这条记录的这个字段是否有<strong>Vector</strong>向量.<br><img src="/img/2014/07/25/5.png" alt=""><br>因为该条Documnet根本就没有这个字段,所以肯定没有这个向量.所以他走到<code>else</code>中去了.<br><img src="/img/2014/07/25/6.png" alt=""><br>else中的处理是先读到该字段的所有<code>term</code>. digitalTapeBarcode大概有2万个term.然后把这些term都取出来.遍历所有的term.然后判断这个term是否是属于这个document的.<br><img src="/img/2014/07/25/7.png" alt="">  </p>
</li>
<li><p>程序的结果也符合预期:<br><img src="/img/2014/07/25/8.png" alt="">  </p>
</li>
<li><p>找到问题原因后,就着手进行修改. 由于Lucene本身没有提供根据document来查询这条记录是否有这个字段.所以我们才会进行遍历.这也是无法修改的.</p>
</li>
<li><p>但是,在这我使用了一个取巧的办法.<br><img src="/img/2014/07/25/9.png" alt=""><br>也就是认为如果在使用TermVector的情况下(现在的索引,在北京台之后的都是使用了TermVector的).<br><strong>如果在TermVector中没有找到,就认为该Document中没有这个字段,不需要恢复.</strong>也就没必要去遍历这几万次.<br><img src="/img/2014/07/25/10.png" alt=""><br><img src="/img/2014/07/25/11.png" alt="">  </p>
</li>
</ol>
<p>相同的90条记录,进行部分更新.   修改前用时 <strong>38778</strong>毫秒 ,修改后  <strong>4475</strong>毫秒. 基本认为问题解决.<br>在不修改底层到<code>Lucene</code>的情况下,只能这样了</p>
<ol>
<li>做1W条记录的批量部分更新测试:</li>
</ol>
<p>修改前: 开始时间: 2014-07-25 11:57:35,666      结束时间:2014-07-25 13:12:39,811 共用时:<strong>4504</strong>秒<br><img src="/img/2014/07/25/12.png" alt="">    </p>
<p>修改后:开始时间:2014-07-25 17:20:23,382      结束时间:2014-07-25 17:25:57,946 共用时:<strong>334</strong>秒<br><img src="/img/2014/07/25/13.png" alt=""> </p>
<ol>
<li>到此,问题基本解决</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章是记录了在我们系统中使用Lucene作为全文检索的时候,进行大量的部分更新时非常缓慢的原因分析排查过程.]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="Lucene" scheme="http://sunxiang0918.github.io/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记一次JVM优化过程]]></title>
    <link href="http://sunxiang0918.github.io/2014/06/27/%E8%AE%B0%E4%B8%80%E6%AC%A1JVM%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>http://sunxiang0918.github.io/2014/06/27/记一次JVM优化过程/</id>
    <published>2014-06-27T02:29:56.000Z</published>
    <updated>2015-07-27T10:12:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="记一次JVM优化过程">记一次JVM优化过程</h1><h2 id="问题的引出">问题的引出</h2><p>在多个系统环境中都出现了我们的DCMP在运行过程中突然停止响应,并且时间长达几分钟至几十分钟之久.期间DCMP任何功能都无法运行.严重的影响了系统的运行.因此需要分析排查问题的原因</p>
<h2 id="解决思路">解决思路</h2><p>经过最初步的分析,发现是DCMP在运行一段时间后,会执行<code>FullGC</code>. 在FullGC的过程中整个系统会停止一切响应.因此,解决该问题的思路,就是分析出DCMP平凡进行<code>FullGC</code>的原因.然后进行优化</p>
<h2 id="分析过程">分析过程</h2><ol>
<li><p>在DCMP运行的过程中,通过windows任务管理器找到进程的<code>PID</code>.然后调用JDK自带的命令: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat –gcutil PID 重复次数 间隔时间</span><br></pre></td></tr></table></figure>
<p> 获取当前JVM的内存信息:<br> <img src="/img/2014/06/27/1.png" alt=""><br> 他上面标识了JVM中每一个区的说占用百分比.</p>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>通过一段时间的观察,发现DCMP每一次<code>FullGC</code>都是由于<code>Perm</code>区内存空间占满造成的,而不是<code>Old</code>区.  在JVM定义中Perm区是<strong>持久区</strong>.用于<strong>存放ClassLoader和Class的类信息以及常量</strong>的.理论上是不会大量的增长的.因此在分段式的GC中是不会被GC的.只有在FullGC中会被GC.而我们的系统中,1G的<code>perm</code>区,仅仅需要10分钟就会被填满.这肯定是有问题的.</p>
</li>
<li><p>经过系统最小化的测试原则.也就是把能去掉的模块都去掉,仅仅保留DCMP运行的最少模块.发现<code>Perm</code>区的增长和<code>CDPLB</code><em>(我们系统中的一个组件与任务调度的服务)</em>的轮询时间高度一直.有理由相信和<code>CDPLB</code>有关.于是排查代码.发现对于一个<code>CDPLB</code>的任务,他在每一次轮询的时候都要调用ITaskRedirector的实现类进行分析获取该任务需要交由哪个执行器来处理.于是修改CDPLB的逻辑,让每一个任务在添加的时候就调用一次ITaskRedirector去获取执行器的名字.上线后,再次调用<code>jstat</code>命令发现<code>perm</code>区的增长后明显的好转.但是对于一般的情况,增速还是过快.特别是进行保存元数据的时候,会进行明显的增长.</p>
</li>
<li><p>再次分析<code>ITaskRedirector</code>实现类与保存元数据的逻辑的共性.发现都有<strong>xml</strong>转换对象的步骤.初步猜测与这个有关.于是编写测试类:<br> <img src="/img/2014/06/27/2.png" alt=""><br> 该断代码的逻辑在于读取一个临时实体的XML字符串. 然后不断的循环,一次采用<code>XStream</code>来反序列化生成临时实体对象,一次采用<code>Dom4j</code>来生成临时实体对象.两种方式交替执行.每次执行停顿<em>5000</em>毫秒.该代码执行后,通过<code>jstat</code>分析得出,每当使用<code>XStream</code>生成临时实体的时候<code>Perm</code>区都会增长<strong>0.5%</strong>左右.而使用<code>Dom4j</code>不会(<em>如果使用Dom4j的XPATH功能,会增长0.1左右</em>).由此可以断定应该是<code>Xstream</code>在反序列化XML生成对象的过程中产生了<strong>动态的代理Class</strong>.造成了<code>perm</code>区的增加.</p>
</li>
<li><p>根据网上查到的说法,<code>Xstream</code>是线程安全的,因此修改代码.把以前每调用一次序列化/反序列化 就要注册一次<code>Xstream</code>改为了<strong>缓存常量</strong>.经过这次修改,<code>Perm</code>区增长的问题基本解决.每一次的<code>FullGC</code>都不是由于<code>Perm</code>区满了引起的了.</p>
</li>
<li><p>继续使用<code>jstat</code>分析,发现系统虽然<code>FullGC</code>的<strong>频率降低</strong>了,但是每一次<code>FullGC</code>的<strong>持续时间还是很久</strong>.经过进一步的查资料,我们现在使用的是<code>Parallel GC</code>,也就是<strong>并行GC</strong>.该GC的特点是<strong>并行</strong>处理<code>Minor GC</code>.系统吞吐量优先,也就是说,它会尽量减少GC的次数,等到内存满后再进行一次FullGC.所以FullGC的时间相当的长.因此,<strong>更换GC方式为CMS GC</strong>.</p>
</li>
<li><p><code>CMS GC</code>全称<code>Concurrent Mark-Sweep GC</code>.它是一种并行的<strong>标记GC</strong>.当有部分内存需要被GC的时候,它会标记这部分内存.然后系统就不再使用这部分内存.同一时间,它开始并行的开始释放被标记的这部分内存.从而达到高响应的.它是一种高响应式的GC,它为了能减少GC的时间,通过不断的标记和交换内存来达到目的.因此对于系统的吞吐量是有一定的影响的.</p>
</li>
<li><p>决定选用CMS GC方式后,还需要决定的就是整个系统的堆大小以及每一个区的大小.<br> <img src="/img/2014/06/27/3.png" alt="">  </p>
</li>
<li><p>判断JVM是否调优有三个标准:<strong>吞吐量</strong>,<strong>延迟及响应性</strong>,<strong>内存占用</strong>.</p>
<ul>
<li><code>吞吐量</code>是对<strong>单位时间内处理工作量的度量</strong>,设计吞吐量需求时,一般不考虑它对延迟或响应时间的影响.通常情况下,增加吞吐量的代价是延迟的增加或内存使用的增加.吞吐量性能的需求的一个典型例子是:应用程序每秒需要完成2500次事务.</li>
<li><code>延迟及响应性</code>是<strong>对引用程序收到指令开始工作直到完成该工作所消耗时间的度量</strong>.通常情况下,提高响应性的代价是更低的吞吐量,或者更多的内存消耗.延迟需求的一个典型例子是应用程序应该在60ms内完成请求的处理工作</li>
<li><code>内存占用</code>是指在<strong>同等程度的吞吐量,延迟,可用性等前提下,运行应用程序所需要的内存大小</strong>.内存占用通常以运行应用程序需要的JAVA堆大小或运行应用程序所需要的总大小来表述.一般情况下可以通过增大JAVA堆的方式增加内存能够提高吞吐量,降低延迟.</li>
</ul>
</li>
<li><p>我们的DCMP系统目前暂时没有一个硬性的吞吐量或响应的要求,但是要求尽量在等量内存下达到最大吞吐量或最低响应时间.要达到这个要求有三个原则:</p>
<ol>
<li>每一次MinorGC都尽可能多的收集垃圾对象.遵守这一原则可以减少应用程序发生FullGC的频率.FullGC的持续时间总是最长的.是应用程序无法达到其延迟或吞吐量要求的罪魁祸首.</li>
<li>处理吞吐量和延迟问题时,垃圾处理器能使用的内存越大,即JAVA堆空间越大,垃圾收集效果越好.</li>
<li>在这三个性能指标(吞吐量,延迟,内存占用)中任意选择两个进行JVM调优.</li>
</ol>
</li>
<li><p>开始优化内存之前,需要理解JVM中堆的布局非常重要,它直接可以从理论上帮助我们确定应用程序使用JAVA堆的大小,微调影响垃圾收集器性能的空间大小.<br><img src="/img/2014/06/27/4.png" alt=""><br>JVM主要有三个空间,分别是:<strong>新生代</strong>,<strong>老年代</strong>以及<strong>永久区</strong>.<br>JAVA应用程序分类JAVA对象的时候,首先在新生代空间(<code>Eden</code>)中分配对象.经过一次<code>MinorGC</code>后,存活下来的对象会放入<code>S0</code>区.然后<code>S0</code>和<code>S1</code>交换.当再一次<code>MinorGC</code>后,把存活下来的对象再放入当前的<code>S0</code>区.经过几次<code>MinorGC</code>之后还保持活跃的对象会被晋升到老年代中.永久代中空间存放的是VM和JAVA类的元数据已经驻留的Strings和类静态变量.</p>
<ul>
<li>整个JVM堆大小可以使用 <code>–Xmx</code>和<code>-Xms</code>指定</li>
<li>新生代可以使用<code>-XX:NewSize</code>  <code>-XX:MaxNewSize</code>  或者 <code>–Xmn</code>指定</li>
<li>老年代空间大小会根据新生代的大小隐式的指定.即 <strong>老年代=堆大小-新生代</strong></li>
<li>持久代空间大小通过: <code>-XX:PermSize</code>   <code>-XX:MaxPerSize</code> 来指定<br>新生代,老年代,永久代这三个空间中的任何一个不能满足内存分配请求时,就会发生垃圾回收,理解这一点非常重要.</li>
</ul>
</li>
<li><p>有了理论的知识后,接下来就是根据我们系统具体的进行分析了.首选需要的就是选择JVM运行模式.毫无疑问,我们系统肯定是使用的<code>Server</code>模式.Server模式提供了更复杂的生成码优化功能,这个功能对于服务器的应用而言尤其重要</p>
</li>
<li><p>接下来就是确定内存占用.程序的内存并不是越多越好,这需要考虑成本等问题.初始堆大小通常应该是老年代活跃数据的<strong>3-4</strong>倍.永久代大小应该比永久代活跃数据大<strong>1.5-2</strong>倍.新生代大小通常应该是老年代活跃数据的<strong>1-1.5</strong>倍.</p>
</li>
<li><p>所谓的活跃数据,即<strong>应用程序运行于稳定态时,长期存活的对象在JAVA堆中占用的空间大小</strong>.换句话说,活跃数据大小是引用程序运行于稳定后,FullGC之后JAVA堆中老年代和永久代占用的空间大小.</p>
</li>
<li><p>经过在107机器上大规模的跑hotfolder入库(<em>文件分析-保存元数据</em>).我们老年代的活跃数据大概为<strong>1个G</strong>.因此调整初始化堆大小为<strong>4G</strong>,永久代<strong>346m</strong>,新生代<strong>1.5G</strong><br><img src="/img/2014/06/27/5.png" alt="">  </p>
</li>
<li><p>接下来微调新生代的大小.<br>通常情况下,<strong>新生代空间越小,MinorGC持续时间越短</strong>,不考虑这对于MinorGC持续时间的影响,减少新生代空间又会增加MinorGC的频率.因此需要取<strong>它们的中间点</strong>.分析GC数据的时候,如果发现MinorGC的间隔时间过长,修正的方法是减少新生代空间.如果Minor频率太高,修正的方法是增加新生代空间.经过GC日志的分析,新生代1.5G的空间比较合适我们的系统,每次MinorGC的平均时间为0.04秒左右.<br><img src="/img/2014/06/27/6.png" alt="">   </p>
</li>
<li><p>微调老年代的大小.<br>这一步的目标是评估FullGC引入的<code>最差停滞时间</code>以及<code>FullGC的频率</code>.<br>同年轻代一样,老年代的优化也需要采集垃圾手机的统计数据.我们关注的是FullGC的持续时间和频率.经过采样,发现了一个问题.在当前的配置情况下,当系统运行了一段时间后,会进行大量的FullGC.而不进行MinorGC. FullGC占到了所有GC的90%以上.虽然每一次FullGC的持续时间都不长,但这是不正常的,经过GC日志的分析.发现,当系统进行大量的FullGC的时候,老年区与持久区并没有被占满,也就是说FullGC不是这两个区被占满造成的.每次出发FullGC的时机都是年轻代占满,进行GC的时候.报concurrent mode failure<br><img src="/img/2014/06/27/7.png" alt=""><br>经过oracle等论坛的查询和源码的分析,发现出现这种现象有一种情况就是当<code>年轻代GC</code>的时候,他需要向<strong>老年代晋升对象</strong>,而老年代的空间如果不够年轻代晋升的对象时(<strong>这里有一个误区,也是让我疑惑了很久的地方,就是明明老年代的空间大于年轻代,为什么还会不够.原因在于CMS方式的GC是不会整理内存的,内存空间是一个一个的片段.当老年区的最大连续内存片段小于年轻代晋升的对象大小时,JVM就会认为空间不足</strong>),就会发生MinorGC失败,从而JVM尝试进行FullGC.因此,可以得出一个结论就是年轻代和老年代空间大小比过小了.在不增加堆空间大小的情况下,就只能减少年轻代的空间.因此,重新修改年轻代大小为1G.</p>
</li>
<li><p>Survivor空间调优<br><code>Survivor</code>空间也就是图上的 <code>S0</code> <code>S1</code>空间. 两个空间的大小虽然很小,但是作用很大.整个Survivor空间分成了两个部分,即<strong>S0</strong>和<strong>S1</strong>,也叫<strong>From</strong>区和<strong>To</strong>区.它相当于是一个缓存区,能提高年轻代晋升到老年代的对象的命中率.一旦完成MinorGC,Eden空间会被清空,From空间也会被清空.而To空间中保留了还是活跃的对象,之后Survivor空间交换标记为下一次MinorGC作准备.现在被清空的From区被标记成了To区,而To区被标记成From区.因此MinorGC结束时,Eden空间和一块Survivor空间被清空,另一块Survivor空间中保留经历了上一次MinorGC存货下来的活跃对象.如果MinorGC时.To区空间不足以容纳所有从Eden区和From区中复制过来的活跃对象,超出的部分就会直接晋升至老年区.这会加速FullGC的频率.调整Survivor空间的大小,让其有足够的空间容纳存活对象足够长的时间,直到几个周期之后对象老化.就能避免Survivor空间的溢出.<br>调整Survivor空间大小可以通过: <code>-XX:SurvivorRation=&lt;ratio&gt;</code> 进行调整.<br>计算公式为: <code>Survivor空间大小=-Xmn/(+XX:SurvivorRation=&lt;ration&gt;+2)</code><br>要调优Survivor空间,需要监控晋升阀值.晋升阀值决定了对象在新生代Survivor空间中保留的次数.通过在GC日志中增加<code>-XX:+PrintTenuringDistribution</code>.来监控晋升阀值.<br>增加该参数后,每一个MinorGC都会打印Survivor区中的对象大小以及保留次数:<br>比如:  </p>
<blockquote>
<p>age 1: 6115072bytes, 6115072 total<br>age 2:  286672bytes, 6401774 total<br>age 3:  115704 bytes, 6517448 total<br>age 4:   95932 bytes,  6613380 total<br>age 5:   89465 bytes,  6702845 total<br>age 6:   88322 bytes,  6791167 total<br>age 7    88201bytes,  6879368 total  </p>
</blockquote>
<p>从上表来看,年龄为<code>1</code> <code>2</code> <code>3</code>的对象非常的多,而年龄<code>4</code>开始就很少了.也就是说系统的Survivor的晋升阀值就是3.即<code>-XX:MaxTenuringThreshold=3</code>.整个年龄为3的对象为65兆.所以就配置Survivor区大小为<strong>130m</strong>.即<strong>-XX:SurvivorRatio=6</strong></p>
</li>
<li><p>CMS收集周期调优<br>确定完JVM堆以及每一个区的大小后,还需要的就是根据CMS收集策略来调整一些参数.比如:  </p>
<ul>
<li>Perm区满后是采用FullGC还是直接抛异常终止系统运行的<code>-XX:+CMSPermGenSweepingEnabled</code>参数.  </li>
<li>CMS老年代开始标记的进入周期,如果CMS周期开的太晚,就会发生失速.如果它无法以足够快的速度回收对象,就无法避免老年化空间用尽.但是如果CMS周期开始得过早,又会引起无用的消耗,影响应用程序的吞吐量.经过GC日志的分析,当老年代占用大于1.6G的时候,就会发生concurrent mode failure.因此决定CMS进入时机为老年代的60%,即: <code>-XX:CMSInitiatingOccupancyFraction=60</code></li>
<li>CMS回收不会整理内存,这就会造成老年区的内存碎片越来越多,影响效率.因此就需要指定进行几次FullGC后,整理老年区的内存.这会增加一个FullGC的时间,但是可以整体的增加系统的吞吐量.经过分析我们的系统很久才会触发一次FullGC,于是配置每一个FullGC前都进行内存整理: <code>-XX:CMSFullGCsBeforeCompaction=1</code></li>
</ul>
</li>
<li><p>到此,GC的配置已完成,然后就是进行大量的测试.现在的配置如下:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_OPTS=%JAVA_OPTS% -Xms4096m -Xmx4096m -XX:PermSize=<span class="number">346</span>m -XX:MaxPermSize=<span class="number">346</span>m -Xmn1024m  -Xss128k -server -XX:MaxTenuringThreshold=<span class="number">5</span></span><br><span class="line"><span class="built_in">set</span> JAVA_OPTS=%JAVA_OPTS% -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSPermGenSweepingEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+CMSClassUnloadingEnabled -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:SurvivorRatio=<span class="number">6</span> -XX:CMSFullGCsBeforeCompaction=<span class="number">1</span> -XX:CMSInitiatingOccupancyFraction=<span class="number">60</span> -XX:ParallelGCThreads=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> JAVA_OPTS=%JAVA_OPTS% -XX:+DisableExplicitGC</span><br></pre></td></tr></table></figure>
<p>经过3台AT导入同时导入的压力测试:<br><img src="/img/2014/06/27/8.png" alt="">  </p>
<p>系统运行<strong>52937</strong>秒,整个GC暂停时间<strong>231.71</strong>秒. 系统可用时间 <strong>99.56%</strong>.平均GC时间<strong>0.039</strong>秒,最大停顿时间<strong>2.7</strong>秒.达到系统要求.</p>
<ol>
<li><p>把同样的配置发到旺旺现场,发现系统还是响应很慢,收集GC日志后发现.他们的元数据太大.造成新生代被占满的速度太快.平凡的进行MinorGC. 平均每<strong>0.2秒</strong>就进行一个MinorGC,系统停顿<strong>0.04秒</strong>. 整个系统的可用时间只有<strong>75%</strong>.没达到吞吐量的需求.日志显示<strong>0.2秒</strong>新生代的<strong>900M</strong>空间就会被占满.但是不会平凡的进行FullGC.证明<strong>整体的GC策略是正确的</strong>,但是确实由于量的原因,<strong>4G空间不能满足要求了</strong>.所以一方面增加现场的内存配置到8G.另一方面,分析流程,发现由于AT导入速度大于我们保存元数据的速度.所以保存元数据的流程越来越多,而保存元数据没有使用CDPLB调度,所有的任务都驻留在内存中,造成了新生代增速过快.因此,修改程序让CDPLB也来调度保存元数据,同一时间只有300个任务驻留在内存中.再次观察日志.问题解决.</p>
</li>
<li><p>至此,整个DCMP的内存调优结束.</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章是记录了一次在我们的项目中遇到CG时间过长的问题排查过程.]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="JVM" scheme="http://sunxiang0918.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>