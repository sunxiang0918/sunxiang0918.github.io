<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[翔妖除魔的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://sunxiang0918.github.io//"/>
  <updated>2016-01-20T11:45:48.000Z</updated>
  <id>http://sunxiang0918.github.io//</id>
  
  <author>
    <name><![CDATA[翔妖除魔]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[<转>超越继承之路：协议混合]]></title>
    <link href="http://sunxiang0918.github.io/2016/01/20/%E8%B6%85%E8%B6%8A%E7%BB%A7%E6%89%BF%E4%B9%8B%E8%B7%AF%EF%BC%9A%E5%8D%8F%E8%AE%AE%E6%B7%B7%E5%90%88/"/>
    <id>http://sunxiang0918.github.io/2016/01/20/超越继承之路：协议混合/</id>
    <published>2016-01-20T11:29:27.000Z</published>
    <updated>2016-01-20T11:45:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="超越继承之路：协议混合">超越继承之路：协议混合</h1><p>只要你学习过面向对象的语言比如 ObjC ，都知道继承的概念，他的一个用途是在多个类之间共享代码。但是这种解决方案存在一些问题。这篇文章我们来初探一下 Swift 的协议扩展，以及如何混合使用这些协议 - Mixins，英文原文<a href="http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/#fnref2" target="_blank" rel="external">地址</a></p>
<p>如果感觉太长了，读不下去，可以直接下载代码 <a href="http://alisoftware.github.io/assets/Mixins.playground.zip" target="_blank" rel="external">Swift Playground Code</a></p>
<h2 id="继承的问题">继承的问题</h2><p>比如你有个 app，其中有大量的<code>UIViewController</code>类都要共享相同的行为，例如他们都有一个相同样式的汉堡菜单。你不想在每个<code>View Controllers</code>中都实现一遍『汉堡菜单』的逻辑（设置 <code>leftBarButtonItem</code>，按钮点击时打开/关闭菜单）</p>
<p>解决方法很简单，创建一个通用的<code>CommonViewController</code>，继承自<code>UIViewController</code>，然后实现所有的行为，接着让其他的<code>UIViewController</code>继承自这个<code>CommonViewController</code>，而不是直接继承自<code>UIViewController</code>。通过这种方式，这些 VC 将拥有这些相同的方法和行为，不需要再每次都自己实现一遍了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">setupBurgerMenu</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">onBurgerMenuTapped</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="keyword">var</span> burgerMenuIsOpen: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123; … &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">CommonViewController</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    setupBurgerMenu()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在随后的开发过程中，你突然需要一个<code>UITableViewController</code>或 <code>UICollectionViewController</code>…靠！不能使用<code>CommonViewController</code>了，因为他是 <code>UIViewController</code> 而不是<code>UITableViewController</code>！</p>
<p>我们该怎么做？新建一个<code>CommonTableViewController</code>实现和<code>CommonViewController</code>一样的功能，但只是继承改为<code>UITableViewController</code>？这会产生好多重复代码，绝对是个糟糕透顶的设计。</p>
<a id="more"></a>
<h2 id="Composition_来拯救我们啦">Composition 来拯救我们啦</h2><p>当然，政治正确的答案就是：</p>
<pre><code>使用 <span class="keyword">Composition</span>，不要使用继承啦！
</code></pre><p>这就意味着为了替代继承，我们需要创建自己的<code>UIViewController</code>，该 VC 由这些内部类的集合组成，而这些内部类负责提供相应的行为。</p>
<p>在我们的例子中，可以想象一个<code>BurgerMenuManager</code>类会提供所有必须的方法来设置汉堡菜单的图标，然后使用<code>BurgerMenuManager</code>进行交互，而我们大量的<code>UIViewControllers</code>都将会设置一个 <code>property</code> 来引用这个<code>BurgerMenuManager</code>，进而与汉堡菜单交互。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BurgerMenuManager</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">setupBurgerMenu</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">onBurgerMenuTapped</span><span class="params">()</span></span> &#123; burgerMenuIsOpen = !burgerMenuisOpen &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">burgerMenuIsOpen</span>: <span class="title">Bool</span> </span>&#123; <span class="keyword">didSet</span> &#123; … &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> menuManager: <span class="type">BurgerMenuManager</span>()</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    menuManager.setupBurgerMenu()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherViewController</span>: <span class="title">UITableViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> menuManager: <span class="type">BurgerMenuManager</span>()</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    menuManager.setupBurgerMenu()</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可悲的是这样也太笨重了吧，每次都需要引用一个中间对象<code>menuManager</code>，好麻烦~</p>
<h2 id="多重继承">多重继承</h2><p>另一个现实原因是：大部分的面向对象语言都不允许多重继承（这是因为存在一个<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="external">菱形类继承问题</a>）</p>
<p><strong>意味着一个类不能有多个父类</strong></p>
<p>假如你实现了一个模型类，用来表示科幻人物。假如你已经创建了<code>DocEmmettBrown</code>,<code>DoctorWho</code> &amp; <code>TimeLord</code>, <code>IronMan</code>, <code>Superman</code>… 然后他们如何直接关联？一些人能够时间旅行，一些能够太空旅行，还有些所有的事都能做，有些人能飞有些不能，一些是人类一些不是…</p>
<p><code>class IronMan</code>（钢铁侠）和 <code>class Superman</code>（超人）都能飞，我们可以创建一个会飞的父类 <code>class Flyer</code>，由他来提供飞行方法的实现<code>func fly()</code> 。但 <code>IronMan</code> 和 <code>DocEmmettBrown</code> 都是人类，所以我们还可以创建一个人类的父类<code>Human</code>，与此同时<code>Superman</code>和 <code>TimeLord</code> 都是外星人 <code>class Alien</code> 的子类。稍等一下… <code>IronMan</code>（钢铁侠）同时继承了 <code>Flyer</code> 和 <code>Human</code>？这在 Swift 中是不可能的（因为 Swift 也是面向对象编程的语言）</p>
<p>我们在继承中只能二选一，如果让 <code>IronMan</code> （钢铁侠）继承自 <code>Human</code>（人类），那么飞行 <code>func fly()</code> 这个方法该如何实现？我们不能显式地在 <code>Human</code>（人类）中实现飞行这个方法，因为不是所有的人都会飞啊，但是<code>Superman</code>（超人）又需要飞行方法，我们不想再重复一遍。</p>
<p>所以，我们可以在这里使用组合，如同让 <code>class SuperMan</code> 超人类包含一个<strong>飞行引擎</strong>属性 <code>var flyingEngine: Flyer</code></p>
<p>但是只是用 <code>superman.flyingEngine.fly()</code> 代替 <code>superman.fly()</code> ，看起来并不是那么优雅。</p>
<h2 id="混合_&amp;_特性">混合 &amp; 特性</h2><p>以下是 <strong>混合 &amp; 特性</strong>（Mixins &amp; Traits）施展手脚的地方</p>
<ul>
<li>通过继承，一般定义你的类是什么，比如所有的 🐶 <code>Dog</code> 都是一个动物 <code>Animal</code></li>
<li>而 <code>Traits</code> 特性，定义了你的类可以做什么，比如，所有的动物 <code>Animal</code> 都能吃 <code>eat()</code>，但人类也能吃，神秘博士 <strong>Doctor Who</strong> 虽然既不是人类也不是动物，但也能吃炸鱼条和蛋冻奶。</li>
</ul>
<p>所以对于特性来说，他们是什么并不重要，而关键在于他们能做什么</p>
<p>继承定义了这个对象是什么，而特性则定义了这个对象能做什么</p>
<p>更棒的消息是：一个类可以部署很多特性，也就是可以同时做很多事情，这是只从单一父类继承而来的子类所不可企及的，因为他们一次只能做一件事情。</p>
<p>那么在 Swift 中该如何应用？</p>
<h2 id="带默认实现的协议">带默认实现的协议</h2><p>在 Swift 2.0 中，当你定义了一个 <code>protocol</code>，可以通过 <code>extension</code> 为其附加相关的实现方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I believe I can flyyyyy ♬"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鉴于此，我们创建了一个遵守 <code>Flyer</code> 协议的类或结构体对象，该对象会免费获得 <code>fly()</code> 方法！</p>
<p>你可以根据需要随时重载这个默认实现，当然也可以什么都不做，这样就自动获得一个默认实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span>: <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="comment">// we don't implement fly() there so we get the default implementation and hear Clark sing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronMan</span>: <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="comment">// be we can also give a specific implementation if needs be</span></span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    thrusters.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"><span class="type">Protocols</span> 提供默认实现这一特性棒极了，正如你所愿将 **<span class="type">Traits</span>** 的概念带进了 <span class="type">Swift</span></span><br><span class="line"></span><br><span class="line">##同一身份，多种能力</span><br><span class="line">关于特性最赞的一点就是：特性不依赖于应用这些特性的对象。他们（特性）不关心这些类是什么，继承自何方，他们只是在这些类中定义了一些方法。</span><br><span class="line"></span><br><span class="line">这就解决了 `<span class="type">Doctor</span> <span class="type">Who</span>` 既是时间旅行者又是外星人，以及 `<span class="type">Dr</span> <span class="type">Emmett</span> <span class="type">Brown</span>` 既是时间旅行者又是人类的难题。再如钢铁侠作为一个人类，和超人作为外星人，但他们都能飞。</span><br><span class="line"></span><br><span class="line">你是谁并不能决定你的能力</span><br><span class="line"></span><br><span class="line">现在，让我们利用 **<span class="type">Traits</span>** 来实现我们的模型类吧</span><br><span class="line"></span><br><span class="line">首先，让我们定义各种各样的 **<span class="type">Traits</span>**（特性）：</span><br><span class="line"></span><br><span class="line">```<span class="built_in">swift</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TimeTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> currentDate: <span class="type">NSDate</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(date: NSDate)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着给出默认实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I believe I can flyyyyy ♬"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimeTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(date: NSDate)</span></span> &#123;</span><br><span class="line">    currentDate = date</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于定义超级英雄角色这一点上（他们是谁），我们依然先使用继承，下面来实现几个父类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>: <span class="title">Character</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> countryOfOrigin: <span class="type">String</span>?</span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, countryOfOrigin: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.countryOfOrigin = countryOfOrigin</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alien</span>: <span class="title">Character</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, species: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.species = species</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在能够同时通过他们的身份（继承）和能力（特性/协议）来定义我们的超级英雄了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeLord</span>: <span class="title">Alien</span>, <span class="title">TimeTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> currentDate = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"I'm the Doctor"</span>, species: <span class="string">"Gallifreyan"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DocEmmettBrown</span>: <span class="title">Human</span>, <span class="title">TimeTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> currentDate = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Emmett Brown"</span>, countryOfOrigin: <span class="string">"USA"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Superman</span>: <span class="title">Alien</span>, <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Clark Kent"</span>, species: <span class="string">"Kryptonian"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronMan</span>: <span class="title">Human</span>, <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Tony Stark"</span>, countryOfOrigin: <span class="string">"USA"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Superman</code>（超人）和 <code>IronMan</code>（钢铁侠）都使用相同的飞行 <code>fly()</code> 实现，即使他们继承自不同的父类（一个是外星人，另一个是人类），并且 Docotors（博士们）都懂得时间旅行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tony = <span class="type">IronMan</span>()  </span><br><span class="line">tony.fly() <span class="comment">// prints "I believe I can flyyyyy ♬"  </span></span><br><span class="line">tony.name  <span class="comment">// returns "Tony Stark"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clark = <span class="type">Superman</span>()  </span><br><span class="line">clark.fly() <span class="comment">// prints "I believe I can flyyyyy ♬"  </span></span><br><span class="line">clark.species  <span class="comment">// returns "Kryptonian"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> docBrown = <span class="type">DocEmmettBrown</span>()  </span><br><span class="line">docBrown.travelTo(<span class="type">NSDate</span>(timeIntervalSince1970: <span class="number">499161600</span>))  </span><br><span class="line">docBrown.name <span class="comment">// "Emmett Brown"  </span></span><br><span class="line">docBrown.countryOfOrigin <span class="comment">// "USA"  </span></span><br><span class="line">docBrown.currentDate <span class="comment">// Oct 26, 1985, 9:00 AM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doctorWho = <span class="type">TimeLord</span>()  </span><br><span class="line">doctorWho.travelTo(<span class="type">NSDate</span>(timeIntervalSince1970: <span class="number">1303484520</span>))  </span><br><span class="line">doctorWho.species <span class="comment">// "Gallifreyan"  </span></span><br><span class="line">doctorWho.currentDate <span class="comment">// Apr 22, 2011, 5:02 PM</span></span><br></pre></td></tr></table></figure>
<h2 id="时空探险">时空探险</h2><p>现在让我们探索一种新的空间旅行能力/特性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SpaceTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(location: String)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供一个默认实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SpaceTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(location: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Let's go to <span class="subst">\(location)</span>!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 Swift 的 <code>extensions</code> 为现有类添加共性的协议了，接下来为已定义的英雄角色添加这些能力。如果我们不计较钢铁侠在《复仇者联盟 1》『纽约之战』中英勇地抱着核弹飞到外太空的话，那么只有 Doctor（博士）和 Superman（超人）拥有空间旅行的能力：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimeLord</span>: <span class="title">SpaceTraveler</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Superman</span>: <span class="title">SpaceTraveler</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>是的，这就是需要添加超能力，现在他们可以使用 <code>travelTo()</code>飞往任何地方！代码相当整洁，不是吗？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctorWho.travelTo(<span class="string">"Trenzalore"</span>) <span class="comment">// prints "Let's go to Trenzalore!"</span></span><br></pre></td></tr></table></figure>
<h3 id="多邀请点人加入我们的派对">多邀请点人加入我们的派对</h3><p>现在让我们为更多的英雄赋予能力：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Come along, Pond!</span></span><br><span class="line"><span class="keyword">let</span> amy = <span class="type">Human</span>(name: <span class="string">"Amelia Pond"</span>, countryOfOrigin: <span class="string">"UK"</span>)  </span><br><span class="line"><span class="comment">// Damn, isn't she not a Time and Space Traveler too? Which doesn't make her a TimeLord, though</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Astraunaut</span>: <span class="title">Human</span>, <span class="title">SpaceTraveler</span> </span>&#123;&#125;  </span><br><span class="line"><span class="keyword">let</span> neilArmstrong = <span class="type">Astraunaut</span>(name: <span class="string">"Neil Armstrong"</span>, countryOfOrigin: <span class="string">"USA"</span>)  </span><br><span class="line"><span class="keyword">let</span> laika = <span class="type">Astraunaut</span>(name: <span class="string">"Laïka"</span>, countryOfOrigin: <span class="string">"Russia"</span>)  </span><br><span class="line"><span class="comment">// Wait, Laïka is a Dog, right?</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilleniumFalconPilot</span>: <span class="title">Human</span>, <span class="title">SpaceTraveler</span> </span>&#123;&#125;  </span><br><span class="line"><span class="keyword">let</span> hanSolo = <span class="type">MilleniumFalconPilot</span>(name: <span class="string">"Han Solo"</span>)  </span><br><span class="line"><span class="keyword">let</span> chewbacca = <span class="type">MilleniumFalconPilot</span>(name: <span class="string">"Chewie"</span>)  </span><br><span class="line"><span class="comment">// Wait, isn't MilleniumFalconPilot defined as "Human"?!</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spock</span>: <span class="title">Alien</span>, <span class="title">SpaceTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Spock"</span>, species: <span class="string">"Vulcan"</span>)</span><br><span class="line">    <span class="comment">// Woops not 100% right</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呼叫休斯顿，我们遇到一个问题。<code>Laika</code> 不是人类也不是 <code>Chewie</code>，<code>Spock</code> 是半人类半瓦肯星人，所以这些定义都是错的。</p>
<p>我们理所应当地认为人类 <code>Human</code> 和外星人 <code>Alien</code> 都可以抽象为单独的类，如果我们继承了这些类，就会被看做是强制认同了这种身份类型。可惜在科幻小说中并不是这样，这才是困扰我们的问题所在。</p>
<p>这也是为什么我们需要在 Swift 中使用 Protocols 并提供协议默认实现的原因。它能帮助我们移除由类继承所带来的限制。</p>
<p>如果将 <code>Human</code> 和 <code>Alien</code> 由类改为协议，会获得到以下优势：</p>
<ul>
<li>我们可以定义一个 <code>MilleniumFalconPilot</code> （飞行器）类型而不用强迫他是一个人类，接着让 <code>Chewie</code> 来驾驶</li>
<li>我们可以定义 <code>Laïka</code> 是一个宇航员 <code>Astronaut</code>，即使她并不是一个人类</li>
<li>我们可以定义 <code>Spock</code> 既是人类 <code>Human</code> 又是外星人 <code>Alien</code></li>
<li>我们甚至可以将继承完全从我们的例子中移除，用结构体 <code>structs</code> 代替类 <code>classes</code> 来定义我们的类型。结构体并不支持继承，但可以遵从多个协议。</li>
</ul>
<h2 id="协议无处不在">协议无处不在</h2><p>至此可以公布我们的解决方案了：就是完全用协议来取代继承，毕竟，我们并不在乎这些超级英雄是什么？只关心他们有哪些超能力罢了。</p>
<p>我打包了一份 <strong>Playground</strong> 代码，你可以点这里下载。我用两页的篇幅演示了完全用 <code>Protocol</code> 和 <code>Structs</code> 是如何实现这一切的，别犹豫，打开看一看！</p>
<p>当然，这并不意味着你必须不惜一切代价避免继承（不要都听 Dalek 的，他们毕竟缺乏感情）。继承仍然有其用武之地，比如 <code>UILabel</code> 是 <code>UIView</code> 子类，你依然能感受到其中的逻辑性。但是，这并不妨碍我们去探索一片新天地 <strong>Mixins &amp; Protocols</strong>（附带默认实现）</p>
<h2 id="总结">总结</h2><p>你在 Swift 之路走得越远，就越能意识到这其实是一门<strong>面向协议编程</strong>的语言，Swift 中大范围应用的<strong>协议</strong>远比 OC 中要强大的多。毕竟，像 <code>Equatable</code>，<code>CustomStringConvertible</code> 以及 <code>-able</code> 这种 Swift 标准库中的协议其实也是混合在一起使用的（Mixins）</p>
<p>通过 Swift 的协议和附带的默认实现，你可以实现 <strong>Mixins &amp; Traits</strong>（混合 &amp; 特性），不仅如此，你还可以实现抽象类的功能，这一切都会让你的编码之路会更加灵活。</p>
<p>采取 <strong>Mixins &amp; Traits</strong> 方式组织的代码不仅定义了这些类型能做什么，还说明了他们是什么。更重要的，你可以按需有选择地部署能力。这有点像你去超市购物，为类型挑选他们喜欢的能力放进购物车中，而并不去关心这些类型继承自何方。</p>
<p>回到最初的例子中，你可以创建一个 <code>protocol BurgerMenuManager</code> 以及一个默认实现，然后简单地让你的 <code>View Controllers</code>（UIViewController 或 UITableViewController…）遵从这个协议就好啦，该 VC 会自动获取所有定义在 <code>BurgerMenuManager</code> 中的能力，而不用去担心 <code>UIViewController</code> 的父类是什么！</p>
<p>关于 <code>Protocol Extensions</code> 还能说很多，<strong>Don’t Panic</strong> 我会在今后的文章中徐徐道来，协议扩展可以在很多方面增强你的代码。这篇文章够长啦，今后再写啦，别走开马上回来~</p>
<hr>
<p>原文链接:<a href="http://chengway.in/chao-yue-ji-cheng-zhi-lu-xie-yi-hun-he/" target="_blank" rel="external">http://chengway.in/chao-yue-ji-cheng-zhi-lu-xie-yi-hun-he/</a></p>
<p>PS:现在JAVA的JDK1.8中也支持了接口的默认实现,也就是说,JAVA也可以面向协议来编程了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="超越继承之路：协议混合">超越继承之路：协议混合</h1><p>只要你学习过面向对象的语言比如 ObjC ，都知道继承的概念，他的一个用途是在多个类之间共享代码。但是这种解决方案存在一些问题。这篇文章我们来初探一下 Swift 的协议扩展，以及如何混合使用这些协议 - Mixins，英文原文<a href="http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/#fnref2">地址</a></p>
<p>如果感觉太长了，读不下去，可以直接下载代码 <a href="http://alisoftware.github.io/assets/Mixins.playground.zip">Swift Playground Code</a></p>
<h2 id="继承的问题">继承的问题</h2><p>比如你有个 app，其中有大量的<code>UIViewController</code>类都要共享相同的行为，例如他们都有一个相同样式的汉堡菜单。你不想在每个<code>View Controllers</code>中都实现一遍『汉堡菜单』的逻辑（设置 <code>leftBarButtonItem</code>，按钮点击时打开/关闭菜单）</p>
<p>解决方法很简单，创建一个通用的<code>CommonViewController</code>，继承自<code>UIViewController</code>，然后实现所有的行为，接着让其他的<code>UIViewController</code>继承自这个<code>CommonViewController</code>，而不是直接继承自<code>UIViewController</code>。通过这种方式，这些 VC 将拥有这些相同的方法和行为，不需要再每次都自己实现一遍了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">setupBurgerMenu</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">onBurgerMenuTapped</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="keyword">var</span> burgerMenuIsOpen: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123; … &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">CommonViewController</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    setupBurgerMenu()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在随后的开发过程中，你突然需要一个<code>UITableViewController</code>或 <code>UICollectionViewController</code>…靠！不能使用<code>CommonViewController</code>了，因为他是 <code>UIViewController</code> 而不是<code>UITableViewController</code>！</p>
<p>我们该怎么做？新建一个<code>CommonTableViewController</code>实现和<code>CommonViewController</code>一样的功能，但只是继承改为<code>UITableViewController</code>？这会产生好多重复代码，绝对是个糟糕透顶的设计。</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in JAVA(一)]]></title>
    <link href="http://sunxiang0918.github.io/2016/01/10/Akka-in-JAVA-1/"/>
    <id>http://sunxiang0918.github.io/2016/01/10/Akka-in-JAVA-1/</id>
    <published>2016-01-10T08:46:28.000Z</published>
    <updated>2016-01-20T11:46:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Akka_in_JAVA(一)">Akka in JAVA(一)</h1><h2 id="AKKA简介">AKKA简介</h2><h3 id="什么是AKKA">什么是AKKA</h3><p>Akka是一个由<code>Scala</code>编写的,能兼容<code>Sacala</code>和<code>JAVA</code>的,用于编写高可用和高伸缩性的<code>Actor模型</code>框架.它基于了事件驱动的并发处理模式,性能非常的高,并且有很高的可用性.大大的简化了我们在应用系统中开发并发处理的过程.它在各个领域都有很好的表现.</p>
<h3 id="使用AKKA的好处">使用AKKA的好处</h3><p>就如上面简介中所说的,AKKA把并发操作的各种复杂的东西都统一的做了封装.我们主要关心的是业务逻辑的实现,只需要少量的关心<code>Actor模型</code>的串联即可构建出高可用,高性能,高扩展的应用.</p>
<h3 id="Akka_for_JAVA">Akka for JAVA</h3><p>由于AKKA是使用<code>Scala</code>编写的,而<code>Scala</code>是一种基于JVM的语言.因此<code>JAVA</code>对AKKA的支持也是很不错的.Akka自身又是采用微内核的方式来实现的,这就意味着能很容易的在自己的项目中应用AKKA,只需要引入几个akka的Lib包即可.而官方直接就提供了<code>Maven</code>库供我们在JAVA中使用AKKA.<br>这些AKKA的依赖包主要有:</p>
<ul>
<li><strong>akka-actor</strong>:最核心的依赖包,里面实现了Actor模型的大部分东西</li>
<li><strong>akka-agent</strong>:代理/整合了Scala中的一些STM特性</li>
<li><strong>akka-camel</strong>:整合了Apache的Camel</li>
<li><strong>akka-cluster</strong>:akka集群依赖,封装了集群成员的管理和路由</li>
<li><strong>akka-kernel</strong>:akka的一个极简化的应用服务器,可以脱离项目单独运行.</li>
<li><strong>akka-osgi</strong>:对OSGI容器的支持,有akka的最基本的Bundle</li>
<li><strong>akka-remote</strong>:akka远程调用</li>
<li><strong>akka-slf4j</strong>:Akka的日志事件监听</li>
<li><strong>akka-testkit</strong>:Akka的各种测试工具</li>
<li><strong>akka-zeromq</strong>:整合ZeroMQ<br>其中最总要的就是<code>akka-actor</code>,最简单的AKKA使用的话,只需要引入这个包就可以了.</li>
</ul>
<a id="more"></a>
<h2 id="Actor模型">Actor模型</h2><h3 id="什么是Actor">什么是Actor</h3><p>既然说AKKA是一个<code>Actor模型</code>框架,那么就需要搞清楚什么是<code>Actor模型</code>.<code>Actor模型</code>是由<code>Carl Hewitt</code>于上世纪70年代提出的,目的是为了解决分布式编程中的一系列问题而产生.<br>在<code>Actor模型</code>中,<strong>一切都可以抽象为Actor</strong>.<br>而Actor是封装了状态和行为的对象,他们的唯一通讯方式就是交换消息,交换的消息放在接收方的邮箱(Inbox)里.也就是说Actor之间并不直接通信,而是通过了消息来相互沟通,每一个Actor都把它要做的事情都封装在了它的内部.<br>每一个Actor是可以有状态也可以是无状态的,理论上来讲,每一个Actor都拥有属于自己的轻量级线程,保护它不会被系统中的其他部分影响.因此,我们在编写Actor时,就不用担心并发的问题.<br>通过Actor能够简化锁以及线程管理,Actor具有以下的特性:</p>
<ul>
<li>提供了一种高级的抽象,能够封装状态和操作.简化并发应用的开发.</li>
<li>提供了异步的非阻塞的/高性能的事件驱动模型</li>
<li>超级轻量级的线程事件处理能力.</li>
</ul>
<p>要在JAVA中实现一个<code>Actor</code>也非常的简单,直接继承<code>akka.actor.UntypedActor</code>类,然后实现<code>public void onReceive(Object message) throws Exception</code>方法即可.</p>
<h3 id="Actor系统">Actor系统</h3><p>光有一个一个独立的Actor显然是不行的.Akka中还有一个<code>Actor System</code>.<br><code>Actor System</code>统管了<code>Actor</code>,是Actor的系统工厂或管理者,掌控了Actor的生命周期.</p>
<p><img src="/img/2016/01/10/1.png" alt=""><br>如上图所示,我们可以通过<code>ActorSystem.create</code>来创建一个ActorSystem的实例.然后通过<code>actorOf</code>等方法来获取<code>ActorRef</code>对象.<code>ActorRef</code>即为<code>Actor Reference</code>.它是Actor的一个引用,主要的作用是发送消息给它表示的Actor.而Actor可以通过访问<code>self()</code>或<code>sender()</code>方法来获取到自身或消息发送者的Actor引用.通过引用发送消息.在Akka中,Actor之间永远都不能直接的通信,必须通过他们的代理<code>ActorRef</code>建立通信.</p>
<h3 id="Actor路径">Actor路径</h3><p>为了实现一切事物都是Actor,为了能把一个复杂的事物划分的更细致.Akka引入了父子Actor.也就是Actor是有树形结构的关系的.这样的父子结构就能递归的把任何复杂的事物原子化.这也是Actor模型的精髓所在.这样做不仅使任务本身被清晰地划分出结构,而且最终的Actor也能按照他们明确的消息类型以及处理流程来进行解析.这样的递归结构使得消息能够在正确的层次进行处理.</p>
<p><img src="/img/2016/01/10/2.png" alt=""></p>
<p>为了能管理父子结构的Actor,Akka又引入了<code>Actor Path</code>,也就是Actor路径.<br>Actor路径使用类似于URL的方式来描述一个Actor,<code>Actor Path</code>在一个<code>Actor System</code>中是唯一的.通过路径,可以很明确的看出某个Actor的父级关系是怎样的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//本地Actor</span><br><span class="line"><span class="string">"akka://my-sys/user/service-a/worker1"</span></span><br><span class="line"></span><br><span class="line">//远程Actor</span><br><span class="line"><span class="string">"akka.tcp://my-sys@host.example.com:2552/user/service-b"</span></span><br><span class="line"></span><br><span class="line">//集群Actor服务</span><br><span class="line"><span class="string">"cluster://my-cluster/service-c"</span></span><br></pre></td></tr></table></figure>
<p>以上三种就是Akka中支持的<code>Actor</code>路径. 每一个通过ActorSystem创建出来的Actor都会有一个这样的路径.也可以通过这个路径从ActorSystem中获取一个<code>Actor</code>.</p>
<p>当我们创建一个ActorSystem的时候,AKKA会为该System默认的创建三个Actor,并处于不同的层次:</p>
<p><img src="/img/2016/01/10/3.png" alt=""><br>其中的<code>root guardian</code>是所有Actor的父.<br>而<code>User</code>Actor是所有用户创建的Actor的父.它的路径是<code>/user</code>,通过system.actorOf()创建出来的Actor都算是用户的Actor,也都是这个Actor的子.<br><code>System</code>Actor是所有系统创建的Actor的父.它的路径是<code>/system</code>,主要的作用是提供了一系列的系统的功能.</p>
<p>当我们查找一个Actor的时候,可以使用ActorSystem.actorSelection()方法.并且可以使用绝对路径或者相对路径来获取.如果是相对路径,那么<code>..</code>表示的是父Actor.比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActorSelection selection = system.actorSelection(<span class="string">"../brother"</span>);</span><br><span class="line">ActorRef actor = selection.anchor();</span><br><span class="line">selection.tell(xxx);</span><br></pre></td></tr></table></figure>
<p>同时,也可以通过通配符来查询逻辑的Actor层级,比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActorSelection selection = system.actorSelection(<span class="string">"../*"</span>);</span><br><span class="line">selection.tell(xxx);</span><br></pre></td></tr></table></figure>
<p>这个就表示把消息发送给当前Actor之外的所有同级的Actor.</p>
<h2 id="Hello_AKKA_Demo">Hello AKKA Demo</h2><p>原理讲了这么多,那么我们就来看一看一个最简单的Akka的例子吧.<br>这个是一个最简单的打招呼的例子,这个例子中,定义了招呼,打招呼的人两个对象或者说消息.然后定义了执行打招呼和打印招呼两个Actor.然后通过ActorSystem整合整个打招呼的过程.</p>
<p><strong>Greet.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 用于表示执行打招呼这个操作的消息</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:43</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Greeting.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 招呼体,里面有打的什么招呼</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:44</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Greeting</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WhoToGreet.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 打招呼的人</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:41</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhoToGreet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String who;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhoToGreet</span><span class="params">(String who)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.who = who;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Greeter.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 打招呼的Actor</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:40</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String greeting = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> WhoToGreet)</span><br><span class="line">            greeting = <span class="string">"hello, "</span> + ((WhoToGreet) message).who;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Greet)</span><br><span class="line">            <span class="comment">// 发送招呼消息给发送消息给这个Actor的Actor</span></span><br><span class="line">            getSender().tell(<span class="keyword">new</span> Greeting(greeting), getSelf());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> unhandled(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GreetPrinter.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印招呼</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:45</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetPrinter</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Greeting)</span><br><span class="line">            System.out.println(((Greeting) message).message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DemoMain.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:39</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ActorSystem system = ActorSystem.create(<span class="string">"helloakka"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个到greeter Actor的管道</span></span><br><span class="line">        <span class="keyword">final</span> ActorRef greeter = system.actorOf(Props.create(Greeter.class), <span class="string">"greeter"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建邮箱</span></span><br><span class="line">        <span class="keyword">final</span> Inbox inbox = Inbox.create(system);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先发第一个消息,消息类型为WhoToGreet</span></span><br><span class="line">        greeter.tell(<span class="keyword">new</span> WhoToGreet(<span class="string">"akka"</span>), ActorRef.noSender());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正的发送消息,消息体为Greet</span></span><br><span class="line">        inbox.send(greeter, <span class="keyword">new</span> Greet());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待5秒尝试接收Greeter返回的消息</span></span><br><span class="line">        Greeting greeting1 = (Greeting) inbox.receive(Duration.create(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(<span class="string">"Greeting: "</span> + greeting1.message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送第三个消息,修改名字</span></span><br><span class="line">        greeter.tell(<span class="keyword">new</span> WhoToGreet(<span class="string">"typesafe"</span>), ActorRef.noSender());</span><br><span class="line">        <span class="comment">// 发送第四个消息</span></span><br><span class="line">        inbox.send(greeter, <span class="keyword">new</span> Greet());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待5秒尝试接收Greeter返回的消息</span></span><br><span class="line">        Greeting greeting2 = (Greeting) inbox.receive(Duration.create(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(<span class="string">"Greeting: "</span> + greeting2.message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新创建一个Actor的管道</span></span><br><span class="line">        ActorRef greetPrinter = system.actorOf(Props.create(GreetPrinter.class));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用schedule 每一秒发送一个Greet消息给 greeterActor,然后把greeterActor的消息返回给greetPrinterActor </span></span><br><span class="line">        system.scheduler().schedule(Duration.Zero(), Duration.create(<span class="number">1</span>, TimeUnit.SECONDS), greeter, <span class="keyword">new</span> Greet(), system.dispatcher(), greetPrinter);</span><br><span class="line">        <span class="comment">//system.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是整个Demo的所有代码,并不多.接下来我们就分析一下这个程序.</p>
<p>首先是定义的几个消息.在Akka中传递的消息必须实现<code>Serializable</code>接口.<code>WhoToGreet</code>消息表示了打招呼的人,<code>Greeting</code>表示了招呼的内容,而<code>Greet</code>表示了打招呼这个动作.</p>
<p>接着就是两个最重要的Actor了.<code>GreetPrinter</code>非常简单,接收到消息后,判断消息的类型,如果是<code>Greeting</code>招呼内容,那么就直接打印消息到控制台.而<code>Greeter</code>这个Actor稍微复杂点,它消费两种不同的消息,如果是<code>WhoToGreet</code>,那么就把要打招呼的人记录到自己的上下文中,如果是<code>Greet</code>,那么就构造出招呼的内容,并把消息反馈回sender.</p>
<p>最后,再来分析下DemoMain.</p>
<ol>
<li>一来,先创建了一个<code>ActorSystem</code>,</li>
<li>然后创建了一个<code>Greeter</code>Actor的实例,命名为<code>greeter</code>.</li>
<li>接着,为这个Actor,显示的创建了一个<code>邮箱</code>.</li>
<li>而后,调用<code>greeter.tell(new WhoToGreet(&quot;akka&quot;), ActorRef.noSender());</code>,表示给greeter这个Actor发送一个消息,消息的内容是<code>WhoToGreet</code>,发送者是空.这就意味着在greeter这个Actor内部,调用sender是不能获取到发送者的.通过这个动作,就把消息限定为了单向的.</li>
<li>再然后,通过<code>inbox.send(greeter, new Greet());</code>,使用邮箱显示的发送一个Greet消息给greeter.这是给Actor发送消息的另外一种方法,这种方法通常会有更高的自主性,能完成更多更复杂的操作.但是调用起来比直接使用<code>ActorRef</code>来的复杂.</li>
<li><code>Greeting greeting1 = (Greeting) inbox.receive(Duration.create(5, TimeUnit.SECONDS));</code>表示的就是尝试在5秒钟内,从<code>Inbox</code>邮箱中获取到反馈消息.如果5秒内没有获取到,那么就抛出<code>TimeoutException</code>异常. 由于我们在greeter这个Actor中有处理,接收到<code>Greet</code>消息后,就构造一个<code>Greeting</code>消息给<code>sender</code>,因此这个地方是能够正确的获取到消息的反馈的.</li>
<li>后面的操作都是一样的,就不再重复描述.</li>
<li>只有最后一个代码稍微有点不一样<code>system.scheduler().schedule(Duration.Zero(), Duration.create(1, TimeUnit.SECONDS), greeter, new Greet(), system.dispatcher(), greetPrinter);</code>,这个使用了<code>ActorSystem</code>中的调度功能.每一秒钟给greeter这个Actor发送一个<code>Greet</code>消息,并指定消息的发送者是<code>greetPrinter</code>.这样每隔一秒钟,greeter就会收到<code>Greet</code>消息,然后构造成<code>Greeting</code>消息,又返回给<code>GreetPrinter</code>这个Actor,这个Actor接收到消息后,打印出来.形成一个环流.</li>
</ol>
<h2 id="Actor调用">Actor调用</h2>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Akka_in_JAVA(一)">Akka in JAVA(一)</h1><h2 id="AKKA简介">AKKA简介</h2><h3 id="什么是AKKA">什么是AKKA</h3><p>Akka是一个由<code>Scala</code>编写的,能兼容<code>Sacala</code>和<code>JAVA</code>的,用于编写高可用和高伸缩性的<code>Actor模型</code>框架.它基于了事件驱动的并发处理模式,性能非常的高,并且有很高的可用性.大大的简化了我们在应用系统中开发并发处理的过程.它在各个领域都有很好的表现.</p>
<h3 id="使用AKKA的好处">使用AKKA的好处</h3><p>就如上面简介中所说的,AKKA把并发操作的各种复杂的东西都统一的做了封装.我们主要关心的是业务逻辑的实现,只需要少量的关心<code>Actor模型</code>的串联即可构建出高可用,高性能,高扩展的应用.</p>
<h3 id="Akka_for_JAVA">Akka for JAVA</h3><p>由于AKKA是使用<code>Scala</code>编写的,而<code>Scala</code>是一种基于JVM的语言.因此<code>JAVA</code>对AKKA的支持也是很不错的.Akka自身又是采用微内核的方式来实现的,这就意味着能很容易的在自己的项目中应用AKKA,只需要引入几个akka的Lib包即可.而官方直接就提供了<code>Maven</code>库供我们在JAVA中使用AKKA.<br>这些AKKA的依赖包主要有:</p>
<ul>
<li><strong>akka-actor</strong>:最核心的依赖包,里面实现了Actor模型的大部分东西</li>
<li><strong>akka-agent</strong>:代理/整合了Scala中的一些STM特性</li>
<li><strong>akka-camel</strong>:整合了Apache的Camel</li>
<li><strong>akka-cluster</strong>:akka集群依赖,封装了集群成员的管理和路由</li>
<li><strong>akka-kernel</strong>:akka的一个极简化的应用服务器,可以脱离项目单独运行.</li>
<li><strong>akka-osgi</strong>:对OSGI容器的支持,有akka的最基本的Bundle</li>
<li><strong>akka-remote</strong>:akka远程调用</li>
<li><strong>akka-slf4j</strong>:Akka的日志事件监听</li>
<li><strong>akka-testkit</strong>:Akka的各种测试工具</li>
<li><strong>akka-zeromq</strong>:整合ZeroMQ<br>其中最总要的就是<code>akka-actor</code>,最简单的AKKA使用的话,只需要引入这个包就可以了.</li>
</ul>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在IOS中使用swift调用系统相机]]></title>
    <link href="http://sunxiang0918.github.io/2016/01/02/%E5%9C%A8IOS%E4%B8%AD%E4%BD%BF%E7%94%A8swift%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA/"/>
    <id>http://sunxiang0918.github.io/2016/01/02/在IOS中使用swift调用系统相机/</id>
    <published>2016-01-02T12:03:41.000Z</published>
    <updated>2016-01-10T13:48:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在IOS中使用swift调用系统相机">在IOS中使用swift调用系统相机</h1><p>在IOS的APP开发中,很容易就会遇到使用拍照或录制视频的功能.如果要求并不是太多的话,最简单方式就是调用系统自带的图像获取器<code>UIImagePickerController</code>. </p>
<p>由于<code>UIImagePickerController</code>继承自<code>UINavigationController</code>,所以它的<code>delegate</code>需要实现<code>UIImagePickerControllerDelegate</code>和<code>UINavigationControllerDelegate</code>两个协议.</p>
<h2 id="基本知识">基本知识</h2><p>要使用这个类主要要做以下几件事情:</p>
<ol>
<li>首先要创建一个全局的<code>UIImagePickerController</code>实例.</li>
<li>判断设备是否支持数据来源:<ul>
<li><code>UIImagePickerController.isSourceTypeAvailable(.Camera)</code></li>
<li><code>UIImagePickerController.isSourceTypeAvailable(.PhotoLibrary)</code></li>
<li><code>UIImagePickerController.isSourceTypeAvailable(.SavedPhotosAlbum)</code></li>
</ul>
</li>
<li><p>然后指定数据的来源.一共有三种来源:</p>
<ul>
<li><code>UIImagePickerControllerSourceType.PhotoLibrary</code>    来自系统图库</li>
<li><code>UIImagePickerControllerSourceType.Camera</code>       来自相机</li>
<li><code>UIImagePickerControllerSourceType.SavedPhotosAlbum</code>      来自相册</li>
</ul>
</li>
<li><p>如果数据来源是相机,那么还需要设置相机的捕获模式<code>cameraCaptureMode</code>. 主要分为<code>.Photo</code>和<code>.Video</code></p>
</li>
<li><p>实现各种代理方法接收保存和获取图像的方法.</p>
</li>
<li><p>设置媒体类型,<code>UIImagePickerController</code>根据这个的值来决定选择或拍摄的媒体类型.这个是一个[String] 字符串数组.多个值就表明了可以在拍摄的界面上切换.需要注意的是这个<code>mediaTypes</code>的定义是在<code>MobileCoreService</code>框架下的.当然也可以直接使用<code>String</code>的常量来描述.常用的媒体类型为:</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">常量名</th>
<th style="text-align:center">常量值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kUTTypeImage</td>
<td style="text-align:center">public.image</td>
<td style="text-align:center">照片</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeMovie</td>
<td style="text-align:center">public.movie</td>
<td style="text-align:center">音视频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeVideo</td>
<td style="text-align:center">public.video</td>
<td style="text-align:center">纯视频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeAudio</td>
<td style="text-align:center">public.audio</td>
<td style="text-align:center">纯音频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeLivePhoto</td>
<td style="text-align:center">com.apple.live-photo</td>
<td style="text-align:center">IOS9的动态照片(关于动态图片后面再单独开博文来说)</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>除了上面说的几个设置外,在使用<code>UIImagePickerController</code>过程中可能还用得到的设置主要有:</p>
<ul>
<li><strong>modalTransitionStyle</strong>:        取景框出现效果</li>
<li><strong>allowsEditing</strong>:    是否允许编辑,只有在<code>showsCameraControls</code>属性为<code>true</code>时才有效</li>
<li><strong>showsCameraControls</strong>:  是否显示拍照时的工具栏,如果要自定义拍摄界面,需要把这个工具栏隐藏掉</li>
<li><strong>videoMaximumDuration</strong>: 录制视频的时长, 默认是10秒</li>
<li><strong>videoQuality</strong>:  视频质量,枚举定义在<code>UIImagePickerControllerQualityType</code>中</li>
<li><strong>cameraDevice</strong>: 前置,还是后置摄像头,枚举定义在<code>UIImagePickerControllerCameraDevice</code></li>
<li><strong>cameraFlashMode</strong>:闪光灯模式,枚举定义在<code>UIImagePickerControllerCameraFlashMode</code></li>
</ul>
<p>有了这些准备,就可以开始来实现一个最简单的DEMO了.</p>
<h2 id="Demo">Demo</h2><p>DEMO很简单,在一个APP上增加一个按钮,点击这个按钮,打开系统自带的摄像头.然后可以进行拍摄,最后把拍摄结果保存到相册中.</p>
<ol>
<li><p>首先先创建一个<code>UIImagePickerController</code>:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imagePickerController:<span class="type">UIImagePickerController</span> = <span class="type">UIImagePickerController</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>给某个ViewController上增加<code>UIImagePickerControllerDelegate</code>和<code>UINavigationControllerDelegate</code>两个协议.</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">UIImagePickerControllerDelegate</span>,<span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">		imagePickerController.delegate = <span class="keyword">self</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后设置PickerController的初始值:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">imagePickerController.modalTransitionStyle = .<span class="type">FlipHorizontal</span></span><br><span class="line">   imagePickerController.allowsEditing = <span class="literal">true</span>	<span class="comment">//是否允许编辑</span></span><br><span class="line">   imagePickerController.sourceType = .<span class="type">Camera</span>	<span class="comment">//数据来源为摄像头</span></span><br><span class="line">    imagePickerController.videoMaximumDuration = <span class="number">15</span>      <span class="comment">//模式录制视频长度,单位秒</span></span><br><span class="line">    imagePickerController.mediaTypes = [<span class="string">"public.image"</span>,<span class="string">"public.movie"</span>]        <span class="comment">//允许的相机类型(拍照,摄像....)</span></span><br><span class="line">    imagePickerController.videoQuality = .<span class="type">TypeHigh</span>		     <span class="comment">//视频质量</span></span><br><span class="line">    imagePickerController.cameraCaptureMode = .<span class="type">Photo</span>		<span class="comment">//初始摄像头的模式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置界面按钮的事件响应,在相应中增加打开<code>imagePickerController</code>视图的方法:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.presentViewController(imagePickerController, animated: <span class="literal">true</span>) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现完成照片或视频的拍摄回调代理方法:<code>func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject])</code>:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject])</span></span> &#123;</span><br><span class="line">	  <span class="comment">//获取媒体的类型</span></span><br><span class="line">       <span class="keyword">let</span> mediaType = info[<span class="type">UIImagePickerControllerMediaType</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//如果媒体是照片</span></span><br><span class="line">       <span class="keyword">if</span> mediaType == kUTTypeImage <span class="keyword">as</span> <span class="type">String</span> &#123;</span><br><span class="line">           <span class="comment">//获取到拍摄的照片, UIImagePickerControllerEditedImage是经过剪裁过的照片,UIImagePickerControllerOriginalImage是原始的照片</span></span><br><span class="line">           <span class="keyword">let</span> image = info[<span class="type">UIImagePickerControllerEditedImage</span>] <span class="keyword">as</span>! <span class="type">UIImage</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//调用方法保存到图像库中</span></span><br><span class="line">           <span class="type">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>,<span class="string">"image:didFinishSavingWithError:contextInfo:"</span>, <span class="literal">nil</span>)</span><br><span class="line">           </span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//视频</span></span><br><span class="line">           <span class="comment">//获取到视频的临时路径</span></span><br><span class="line">           <span class="keyword">let</span> urlStr =  (info[<span class="type">UIImagePickerControllerMediaURL</span>] <span class="keyword">as</span>! <span class="type">NSURL</span>).path</span><br><span class="line">           <span class="comment">//启动异步线程保存视频到图像库中</span></span><br><span class="line">           dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">           <span class="comment">//调用方法保存到图像库中</span></span><br><span class="line">               <span class="type">UISaveVideoAtPathToSavedPhotosAlbum</span>(urlStr!, <span class="keyword">self</span>, <span class="string">"video:didFinishSavingWithError:contextInfo:"</span>, <span class="literal">nil</span>)</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//关闭照相框</span></span><br><span class="line">       <span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现完成保存后的结果回调方法<code>func image(image: UIImage, didFinishSavingWithError error: NSError?, contextInfo:UnsafePointer&lt;Void&gt;)</code>:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">image</span><span class="params">(image: UIImage, didFinishSavingWithError error: NSError?, contextInfo:UnsafePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> ac = <span class="type">UIAlertController</span>(title: <span class="string">"Saved!"</span>, message: <span class="string">"成功保存照片到图库"</span>, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">           ac.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">           presentViewController(ac, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> ac = <span class="type">UIAlertController</span>(title: <span class="string">"Save error"</span>, message: error?.localizedDescription, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">           ac.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">           presentViewController(ac, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现完成保存视频后的结果回调方法<code>func video(videoPath: String, didFinishSavingWithError error: NSError?, contextInfo:UnsafePointer&lt;Void&gt;)</code>:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">video</span><span class="params">(videoPath: String, didFinishSavingWithError error: NSError?, contextInfo:UnsafePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> ac = <span class="type">UIAlertController</span>(title: <span class="string">"Saved!"</span>, message: <span class="string">"成功保存视频到图库"</span>, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">           ac.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">           presentViewController(ac, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> ac = <span class="type">UIAlertController</span>(title: <span class="string">"Save error"</span>, message: error?.localizedDescription, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">           ac.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">           presentViewController(ac, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样就完成了打开系统相机,并把拍摄的结果放入系统默认的相薄中的全部功能了.</p>
<h2 id="自定义相薄">自定义相薄</h2><p>到目前为止照片等都是保存到系统默认的<code>相机胶卷</code>这个相薄中. 但是像<code>QQ</code> <code>微信</code>这些应用都是可以把图片存放到自己的相薄中的.这就要求程序中对相薄进行操作了.</p>
<p>在IOS9中,要操作相薄的话,需要引入<code>import Photos</code>库.然后使用<code>PHPhotoLibrary</code>这个类.</p>
<p>先说创建相薄:</p>
<ol>
<li><p>首先需要定义一个<code>PHAssetCollection</code>对象:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">var</span> assetCollection:<span class="type">PHAssetCollection</span>?</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增一个创建相薄的方法<code>createAlbum</code>: </p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createAlbum</span><span class="params">()</span></span> &#123;</span><br><span class="line">	 <span class="comment">//创建一个FetchOptions,属性选择器</span></span><br><span class="line">       <span class="keyword">let</span> fetchOptions = <span class="type">PHFetchOptions</span>()</span><br><span class="line">       <span class="comment">//指定相薄的名称</span></span><br><span class="line">       fetchOptions.predicate = <span class="type">NSPredicate</span>(format: <span class="string">"title = %@"</span>, <span class="string">"测试用"</span>)</span><br><span class="line">       <span class="comment">//获取相薄的对象</span></span><br><span class="line">       <span class="keyword">let</span> collection = <span class="type">PHAssetCollection</span>.fetchAssetCollectionsWithType(.<span class="type">Album</span>, subtype: .<span class="type">Any</span>, options: fetchOptions)</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//如果查询出的第一个对象存在,那么就说明相薄已经存在了,直接赋值</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = collection.firstObject &#123;</span><br><span class="line">           assetCollection =  collection.firstObject <span class="keyword">as</span>? <span class="type">PHAssetCollection</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       	  <span class="comment">//否则需要创建一个新的相薄</span></span><br><span class="line">           <span class="keyword">var</span> assetCollectionPlaceholder:<span class="type">PHObjectPlaceholder</span>!</span><br><span class="line">           <span class="comment">//调用performChanges方法来创建相薄</span></span><br><span class="line">           <span class="type">PHPhotoLibrary</span>.sharedPhotoLibrary().performChanges(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">               <span class="comment">//根据title来创建一个相薄的请求</span></span><br><span class="line">               <span class="keyword">let</span> createAlbumRequest = <span class="type">PHAssetCollectionChangeRequest</span>.creationRequestForAssetCollectionWithTitle(<span class="string">"测试用"</span>)</span><br><span class="line">               <span class="comment">//获取出请求中的placeholder</span></span><br><span class="line">               assetCollectionPlaceholder = createAlbumRequest.placeholderForCreatedAssetCollection</span><br><span class="line">               &#125;) &#123; (success, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                   <span class="comment">//创建完成的回调</span></span><br><span class="line">                   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                       <span class="type">NSLog</span>(<span class="string">"Error creating album: <span class="subst">\(error)</span>"</span>);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   	<span class="comment">//如果创建成功.那么就要获取到PHAssetCollection,只有有了这个才能把照片存放到这个相薄中</span></span><br><span class="line">                       <span class="keyword">let</span> collectionFetchResult = <span class="type">PHAssetCollection</span>.fetchAssetCollectionsWithLocalIdentifiers([assetCollectionPlaceholder.localIdentifier], options: <span class="literal">nil</span>)</span><br><span class="line">                       <span class="keyword">self</span>.assetCollection =  collectionFetchResult.firstObject <span class="keyword">as</span>? <span class="type">PHAssetCollection</span></span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建完成相薄后,就可以保存照片到相薄中了: </p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject])</span></span> &#123;</span><br><span class="line">       <span class="keyword">let</span> mediaType = info[<span class="type">UIImagePickerControllerMediaType</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//尝试创建相薄</span></span><br><span class="line">       createAlbum()</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> mediaType == kUTTypeImage <span class="keyword">as</span> <span class="type">String</span> &#123;</span><br><span class="line">           <span class="comment">//图片</span></span><br><span class="line">           <span class="keyword">let</span> image = info[<span class="type">UIImagePickerControllerEditedImage</span>] <span class="keyword">as</span>! <span class="type">UIImage</span></span><br><span class="line">           <span class="comment">//使用线程同步     </span></span><br><span class="line">                  dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), &#123;</span><br><span class="line">               <span class="comment">//保存到自定义的相薄中</span></span><br><span class="line">               <span class="type">PHPhotoLibrary</span>.sharedPhotoLibrary().performChanges(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                   <span class="comment">//根据相片得到保存的请求</span></span><br><span class="line">                   <span class="keyword">let</span> assetRequest = <span class="type">PHAssetChangeRequest</span>.creationRequestForAssetFromImage(image)</span><br><span class="line">                   <span class="comment">//找到placehodler</span></span><br><span class="line">                   <span class="keyword">let</span> assetPlaceholder = assetRequest.placeholderForCreatedAsset</span><br><span class="line">                   <span class="comment">//创建photosAsset</span></span><br><span class="line">                   <span class="keyword">let</span> photosAsset = <span class="type">PHAsset</span>.fetchAssetsInAssetCollection(<span class="keyword">self</span>.assetCollection!, options: <span class="literal">nil</span>)</span><br><span class="line">                   <span class="comment">//实例化 保存事件</span></span><br><span class="line">                   <span class="keyword">if</span> <span class="keyword">let</span> albumChangeRequest = <span class="type">PHAssetCollectionChangeRequest</span>(forAssetCollection: <span class="keyword">self</span>.assetCollection!, assets: photosAsset) &#123;</span><br><span class="line">                   	<span class="comment">//执行相薄照片的保存</span></span><br><span class="line">                       albumChangeRequest.addAssets([assetPlaceholder!])</span><br><span class="line">                   &#125;</span><br><span class="line">                   </span><br><span class="line">                   &#125;, completionHandler: &#123; (success, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                       dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">                           <span class="type">NSLog</span>(<span class="string">"Adding Image to Library -&gt; %@"</span>, (success ? <span class="string">"Sucess"</span>:<span class="string">"Error!"</span>))</span><br><span class="line">                           <span class="comment">//</span></span><br><span class="line">                           <span class="keyword">if</span> !success &#123;</span><br><span class="line">                               <span class="comment">//表示没有保存成功,尝试保存到系统自带的里面</span></span><br><span class="line">                               <span class="comment">//保存到图库</span></span><br><span class="line">                               <span class="type">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>,<span class="string">"image:didFinishSavingWithError:contextInfo:"</span>, <span class="literal">nil</span>)</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//保存陈红</span></span><br><span class="line">                           <span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">                       &#125;)</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;)</span><br><span class="line">           </span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//视频</span></span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如此就能保存相片到自定义的相薄中了,其实对相薄还可以有其他的操作,比如列出所有相薄的名字,删除相薄等等.这个具体的参考<code>PHPhotoLibrary</code>类即可.</p>
<h2 id="总结">总结</h2><p>本文简单的介绍了一下,如何调用系统自带的相机和相册来进行照片和视频的拍摄.同时也介绍了如何自定义相薄,为以后更高级的拍摄功能做了准备.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在IOS中使用swift调用系统相机">在IOS中使用swift调用系统相机</h1><p>在IOS的APP开发中,很容易就会遇到使用拍照或录制视频的功能.如果要求并不是太多的话,最简单方式就是调用系统自带的图像获取器<code>UIImagePickerController</code>. </p>
<p>由于<code>UIImagePickerController</code>继承自<code>UINavigationController</code>,所以它的<code>delegate</code>需要实现<code>UIImagePickerControllerDelegate</code>和<code>UINavigationControllerDelegate</code>两个协议.</p>
<h2 id="基本知识">基本知识</h2><p>要使用这个类主要要做以下几件事情:</p>
<ol>
<li>首先要创建一个全局的<code>UIImagePickerController</code>实例.</li>
<li>判断设备是否支持数据来源:<ul>
<li><code>UIImagePickerController.isSourceTypeAvailable(.Camera)</code></li>
<li><code>UIImagePickerController.isSourceTypeAvailable(.PhotoLibrary)</code></li>
<li><code>UIImagePickerController.isSourceTypeAvailable(.SavedPhotosAlbum)</code></li>
</ul>
</li>
<li><p>然后指定数据的来源.一共有三种来源:</p>
<ul>
<li><code>UIImagePickerControllerSourceType.PhotoLibrary</code>    来自系统图库</li>
<li><code>UIImagePickerControllerSourceType.Camera</code>       来自相机</li>
<li><code>UIImagePickerControllerSourceType.SavedPhotosAlbum</code>      来自相册</li>
</ul>
</li>
<li><p>如果数据来源是相机,那么还需要设置相机的捕获模式<code>cameraCaptureMode</code>. 主要分为<code>.Photo</code>和<code>.Video</code></p>
</li>
<li><p>实现各种代理方法接收保存和获取图像的方法.</p>
</li>
<li><p>设置媒体类型,<code>UIImagePickerController</code>根据这个的值来决定选择或拍摄的媒体类型.这个是一个[String] 字符串数组.多个值就表明了可以在拍摄的界面上切换.需要注意的是这个<code>mediaTypes</code>的定义是在<code>MobileCoreService</code>框架下的.当然也可以直接使用<code>String</code>的常量来描述.常用的媒体类型为:</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">常量名</th>
<th style="text-align:center">常量值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kUTTypeImage</td>
<td style="text-align:center">public.image</td>
<td style="text-align:center">照片</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeMovie</td>
<td style="text-align:center">public.movie</td>
<td style="text-align:center">音视频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeVideo</td>
<td style="text-align:center">public.video</td>
<td style="text-align:center">纯视频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeAudio</td>
<td style="text-align:center">public.audio</td>
<td style="text-align:center">纯音频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeLivePhoto</td>
<td style="text-align:center">com.apple.live-photo</td>
<td style="text-align:center">IOS9的动态照片(关于动态图片后面再单独开博文来说)</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再见2015]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/31/%E5%86%8D%E8%A7%812015/"/>
    <id>http://sunxiang0918.github.io/2015/12/31/再见2015/</id>
    <published>2015-12-31T14:13:48.000Z</published>
    <updated>2016-01-01T16:12:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="再见2015">再见2015</h1><p>时光匆匆,转眼2015年就要过去了.2015开年的事情仿佛刚过去没有多久,2016又要来了.今年是忙碌的一年,不管是在生活上还是在工作上都发生了很多的变化.本文将回顾一下作为程序猿的自己在今年的成长,做一个简单的总结.</p>
<h2 id="博客">博客</h2><p>今年年中,自己在github.io上搭建了自己的个人博客,并且把以前的一些文章从evernote上迁移了过来.以前,从来没有写博客的习惯,一个是觉得写博客比较麻烦,因为可能不是自己一个人看,不能像在evernote上那样随便乱写.还有一个就是觉得东西有个地方保存就好了,没必要分享出来.不过,最后还是决定把博客搭建出来,既能锻炼自己的书写,也能强迫自己把东西记录的更规范更细致,最后也能分享给有需要的人.从事了5年的软件行业了,渐渐的开始理解开源人的心态了,也从各位开源的大神中得到了很多的好处,是时候把自己力所能及的东西分享出来了.</p>
<p>今年一共写了<a href="/archives/2015">43篇博客</a>,从数量上来说不算多.主要涉及的是<code>JAVA研发体系</code>以及<code>Swift</code>方面的内容.<br>对于明年,目标是60篇博客,内容上更有深度与广度.希望能够达成.</p>
<a id="more"></a>
<h2 id="阅读">阅读</h2><p>今年阅读的书不多,更大的变化是技术类的书从以前的只阅读实体书,到渐渐的开始接受电子书了.</p>
<table>
<thead>
<tr>
<th style="text-align:left">书名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">完成度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://book.douban.com/subject/26274206/" target="_blank" rel="external">写给大忙人看的JAVA SE8</a></td>
<td style="text-align:center">实体书</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://book.douban.com/subject/26261153/" target="_blank" rel="external">Spark大数据处理</a></td>
<td style="text-align:center">实体书</td>
<td style="text-align:center">60%</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://book.douban.com/subject/2347790/" target="_blank" rel="external">敏捷软件开发 原则,模式与实践</a></td>
<td style="text-align:center">实体书</td>
<td style="text-align:center">重读</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="external">The Swift Programming Language</a></td>
<td style="text-align:center">电子书</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://leanpub.com/swifter" target="_blank" rel="external">SWIFTER 100个Swift必备Tips</a></td>
<td style="text-align:center">电子书</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></td>
<td style="text-align:center">电子书</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">快学Scala</td>
<td style="text-align:center">PDF电子书</td>
<td style="text-align:center">40%</td>
</tr>
</tbody>
</table>
<h2 id="团队实践">团队实践</h2><p>今年由于公司新开项目的原因,能够有机会对团队的运作有较大的改变.<br>首先,终于把所有的代码都从SVN上迁移到了GIT上.这个过程看似简单,其实是比较麻烦的.当一个团队在SVN上都搞了5年了,然后更换了整个工作的流程,并不是想象中的这么容易的.要让十多号人都熟悉GIT的概念,熟悉基于分支的开发模式.终于彻底贯彻了我在2012年摘抄到evernote上&lt;<a href="/2012/08/18/A-successful-Git-branching-model/">A successful Git branching model</a>&gt;这篇文章上所描述的工作模式.感觉到了GIT的强大与方便.<br>其次,尝试在项目中引入SCRUM敏捷开发,由于团队人数不多,需求比较灵活.因此,尝试了引入SCRUM敏捷开发,并且使用了Teambition作为管理工具,每天进行站立会议,阶段评审等等.就目前执行了3个多月的效果来看,一半的一半.一半的成功是坚持了站立会议,阶段任务制定,阶段成果评审等等,确实清晰了当前的项目状态.一半的失败是没有坚持下来使用Teambition工具,并且任务墙也没有坚持下来.除了让所有团队成员事无巨细的拆分任务和记录任务状态不容易外,自己对于Scrum的不熟悉也是一个原因.搞了这么多年的瀑布式开发,开发的习惯还没有更改过来.<br>希望明年会有进步,把任务墙的机制彻底的落实下来.</p>
<h2 id="JAVA">JAVA</h2><p>今年在JAVA方面主要的进步是在于扩展了大数据方面的知识.以前搞了这么久的JAVA,一直停留在了JAVA语言本身,各种业务逻辑,J2EE,检索引擎这些上面.而今年开始有机会接触了<code>Hadoop</code>,<code>HBase</code>,<code>HIVE</code>,<code>Spark</code>这些东西,虽然还很基础.不过总算也是入门了.<br>明年的目标就是以项目作为机会深入的了解大数据,以及数据挖掘方面的东西.</p>
<h2 id="互联网技术">互联网技术</h2><p>今年还有一个显著的变化就是接触了大量的互联网的技术.公司的新项目是一个类似于互联网的项目,因此需要掌握一些以前接触比较少的互联网技术.比如:<code>mongoDB</code>,<code>Kafka</code>,<code>Redis</code>,<code>Zabbix</code>,<code>ELK</code>,<code>S3</code>,<code>ceph</code>等等.相较于以前的项目,变化还是相当的大的.接触了很多新颖的东西,也趟了很多的坑.总的来说就是痛并快乐着.<br>互联网的趋势势必会席卷整个IT行业,你在哪一个垂直行业都是躲不了的.这也是件好事.就我个人而言,也比较高兴的,找到了以前学习软件的时候的那种兴奋感.<code>勿忘初心,重新学习</code>一直作为我整个2015年写在QQ签名上的座右铭.</p>
<h2 id="其他语言">其他语言</h2><p>2015年还有一个重大的变化就是我开始把眼界从JAVA的生态环境中跳出去.接触了更多的语言以及它们的一些思想.其实搞软件的不能只关注于自己的那一小块圈子,在其他语言中也有很多可以借鉴和启发你的东西,就算暂时没有,开拓开拓眼界也是好的,指不定哪天就会用上呢.</p>
<p>在年中,接触到<code>Kafka</code>的时候了解到了它是使用<code>scala</code>写的,和<code>JRuby</code>,<code>JPtyhon</code>这些类似,它是基于JVM上的一门新的语言.其实这门语言已经出来很久了,不过一直不算很广泛.这次在<code>Kafka</code>和<code>akka</code>中看到使用了<code>scala</code>,于是就去了解了一下.然后就被它的语法所吸引了,它解决了JAVA很多以前很烦琐的东西.JAVA由于一直要兼容以前版本的东西,所以这几年变化一直不大.哪怕最新的JDK1.8新增了很多的东西,但是整个体系还是在那摆着的.比如闭包的实现,完全比不上其他的语言,要实现一个闭包还需要提前的定义一个接口.而<code>scala</code>真是解决了这些的问题,它以简洁的语法漂亮的增加了我们的效率,并且还兼容了大部分的JAVA库,要知道这些JAVA库可是JAVA现在一直坐稳第一语言最大的依仗.C#语言本身其实经过这几年的发展已经比JAVA要优秀了,但是背后缺少了开源社区的支持,以及长年累月积累起来的各种库,始终在5 6名左右徘徊.因此,明年的目标就是继续学习<code>scala</code>,争取能拿<code>scala</code>写一些东西出来.</p>
<p>在年底,由于<code>codis</code>和<code>docker</code>的原因,近距离的接触到了<code>golang</code>,这个被google誉为下一代开发语言的语言.也大致的了解了一下,它的一些思想确实比较先进,比如<code>协程</code>,<code>严格的书写格式</code>等等.不过由于时间和精力的原因并未有太深入,现在还停留在大致能看懂别人的源码的程度.明年的目标是系统的学习一下<code>golang</code>.我对这门语言还是比较看好的,它从语言级别就支持多并发的特性,是比较适合于大数据高并发的系统的.</p>
<p>贯穿整年,得益于Apple对开源的态度,以及IOS9对IOS开发者真机调试的免费开放(是的,这个理由就是这么low,真的是被这个吸引了,可以自己给自己的手机开发APP了).我深入的学习了<code>Swfit</code>,这是从2012年在公司项目上使用<code>Objective-C</code>写过一个<code>MacOS</code>上的工具外,时隔3年又一次投入Apple的怀抱,这次的感觉很好.由于从大学开始就一直学习的是<code>JAVA</code>和<code>Python</code>,对于自己手动的管理内存实在是头痛.因此,信仰没有抵过现实,把<code>MacOS</code>上的工具开发完成后,就再没有接触过<code>Objective-C</code>了.<br>但是,在2014年WWDC上看了Swift的演示,我一下就被吸引了.类似于动态语言的语法,静态语言的本质,各种语法糖以及现代语言的思想,无不吸引了我.再加上年底的开源,更是把Swfit推上了一个小高潮.<br>现在Swfit已经是我第二熟悉的语言了,又时甚至会想要是JAVA有 Swfit的这个特性就好了~<br>基于Swfit,今年断断续续的写了两个完整的应用以及几个框架或代码片段.也算是入了Swift的门了.第三个应用也在筹划的阶段.明年的目标就是更加的熟悉Swift以及IOS的开发,不指望以后靠IOS吃饭,自娱自乐写点有意思的应用还是不错的.</p>
<h2 id="DevOps">DevOps</h2><p>以前在这方面接触的最多的就是 搭建了 Maven+Jenkins进行持续化集成,并且一直使用了3年.<br>今年开始涉及了云计算以及容器化技术.开始在各种云上实验各种东西.并且把Docker引入了今年公司的新项目中.Docker可以说是今年获得的最重要的技能之一.</p>
<h2 id="开源">开源</h2><p>单独把这个写出来,也是想说明现在对于开源越来越有认同感.自己也在<a href="http://git.oschina.net" target="_blank" rel="external">Git@oschina</a>以及<a href="https://github.com/sunxiang0918" target="_blank" rel="external">github.com</a>上分享了几个东西.有<code>Swift</code>的,也有<code>JAVA</code>的.其中拿来练手而写的<a href="http://git.oschina.net/xycm/ZhiHuDaily-Swift" target="_blank" rel="external">ZhiHuDaily-Swift</a>更是拿到了<code>git@OSC</code>上<code>Swift</code>分类下最高的Star数以及收到了知乎官方的电邮(当然不是法律侵权这些),这让我非常的高兴,更加的坚定了开源的决心.<br>明年的目标是希望能参与一个他人的开源项目,或是协作,或是<code>pull request</code>.现在Swift开源了,要是能在<code>Swfit</code>上留下自己的印记,那可是很值得开心的,加油!</p>
<h2 id="总结">总结</h2><p>总结今年的成长,比去年的多姿多彩,涉及了更多的方面.并且成功的进入了IOS Programmer的世界,也算是圆了资深脑残果粉的一个心愿.其他技术方面,很多东西都只能算是入了个门,更多的精彩和挑战还在后面.<br><strong>期待2016!再见2015!</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="再见2015">再见2015</h1><p>时光匆匆,转眼2015年就要过去了.2015开年的事情仿佛刚过去没有多久,2016又要来了.今年是忙碌的一年,不管是在生活上还是在工作上都发生了很多的变化.本文将回顾一下作为程序猿的自己在今年的成长,做一个简单的总结.</p>
<h2 id="博客">博客</h2><p>今年年中,自己在github.io上搭建了自己的个人博客,并且把以前的一些文章从evernote上迁移了过来.以前,从来没有写博客的习惯,一个是觉得写博客比较麻烦,因为可能不是自己一个人看,不能像在evernote上那样随便乱写.还有一个就是觉得东西有个地方保存就好了,没必要分享出来.不过,最后还是决定把博客搭建出来,既能锻炼自己的书写,也能强迫自己把东西记录的更规范更细致,最后也能分享给有需要的人.从事了5年的软件行业了,渐渐的开始理解开源人的心态了,也从各位开源的大神中得到了很多的好处,是时候把自己力所能及的东西分享出来了.</p>
<p>今年一共写了<a href="/archives/2015">43篇博客</a>,从数量上来说不算多.主要涉及的是<code>JAVA研发体系</code>以及<code>Swift</code>方面的内容.<br>对于明年,目标是60篇博客,内容上更有深度与广度.希望能够达成.</p>]]>
    
    </summary>
    
      <category term="其他" scheme="http://sunxiang0918.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>Swift-LOG输出]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/30/Swift-LOG%E8%BE%93%E5%87%BA/"/>
    <id>http://sunxiang0918.github.io/2015/12/30/Swift-LOG输出/</id>
    <published>2015-12-30T14:17:30.000Z</published>
    <updated>2015-12-30T14:23:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="LOG输出">LOG输出</h1><p>Log 输出是程序开发中很重要的组成部分，虽然它并不是直接的业务代码，但是却可以忠实地反映我们的程序是如何工作的，以及记录程序运行的过程中发生了什么。</p>
<p>在 Swift 中，最简单的输出方法就是使用 print，在我们关心的地方输出字符串和值。但是这并不够，试想一下当程序变得非常复杂的时候，我们可能会输出很多内容，而想在其中寻找到我们希望的输出其实并不容易。我们往往需要更好更精确的输出，这包括输出这个 log 的文件，调用的行号以及所处的方法名字等等。</p>
<p>我们当然可以在 print 的时候将当前的文件名字和那些必要的信息作为参数同我们的消息一起进行打印：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"文件名:Test.swift, 方法名:method，这是一条输出"</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是这显然非常麻烦，每次输入文件名和方法名不说，随着代码的改变，这些 Log 的位置也可能发生改变，这时我们可能还需要不断地去维护这些输出，代价实在太大。</p>
<p>在 Swift 中，编译器为我们准备了几个很有用的编译符号，用来处理类似这样的需求，它们分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FILE</td>
<td style="text-align:left">String</td>
<td style="text-align:left">包含这个符号的文件的路径</td>
</tr>
<tr>
<td style="text-align:left">LINE</td>
<td style="text-align:left">Int</td>
<td style="text-align:left">符号出现处的行号</td>
</tr>
<tr>
<td style="text-align:left">COLUMN</td>
<td style="text-align:left">Int</td>
<td style="text-align:left">符号出现处的列</td>
</tr>
<tr>
<td style="text-align:left">FUNCTION</td>
<td style="text-align:left">String</td>
<td style="text-align:left">包含这个符号的方法名字</td>
</tr>
</tbody>
</table>
<p>因此，我们可以通过使用这些符号来写一个好一些的 Log 输出方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printLog</span><span class="generics">&lt;T&gt;</span><span class="params">(message: T,  </span><br><span class="line">                    file: String = <span class="keyword">__FILE__</span>,</span><br><span class="line">                  method: String = <span class="keyword">__FUNCTION__</span>,</span><br><span class="line">                    line: Int = <span class="keyword">__LINE__</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\((file <span class="keyword">as</span> NSString)</span>.lastPathComponent)[<span class="subst">\(line)</span>], <span class="subst">\(method)</span>: <span class="subst">\(message)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在进行 log 的时候我们只需要使用这个方法就能完成文件名，行号以及方法名的输出了。最棒的是，我们不再需要对这样的输出进行维护，无论在哪里它都能正确地输出各个参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    printLog(<span class="string">"这是一条输出"</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Test.swift[62], method(): 这是一条输出</span></span><br></pre></td></tr></table></figure>
<p>另外，对于 log 输出更多地其实是用在程序开发和调试的过程中的，过多的输出有可能对运行的性能造成影响。在 Release 版本中关闭掉向控制台的输出也是软件开发中一种常见的做法。如果我们在开发中就注意使用了统一的 log 输出的话，这就变得非常简单了。使用<a href="http://swifter.tips/condition-compile" target="_blank" rel="external">条件编译</a>的方法，我们可以添加条件，并设置合适的编译配置，使 printLog 的内容在 Release 时被去掉，从而成为一个空方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printLog</span><span class="generics">&lt;T&gt;</span><span class="params">(message: T,  </span><br><span class="line">                    file: String = <span class="keyword">__FILE__</span>,</span><br><span class="line">                  method: String = <span class="keyword">__FUNCTION__</span>,</span><br><span class="line">                    line: Int = <span class="keyword">__LINE__</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\((file <span class="keyword">as</span> NSString)</span>.lastPathComponent)[<span class="subst">\(line)</span>], <span class="subst">\(method)</span>: <span class="subst">\(message)</span>"</span>)</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版本的 LLVM 编译器在遇到这个空方法时，甚至会直接将这个方法整个去掉，完全不去调用它，从而实现零成本。</p>
<hr>
<p>原文链接: <a href="http://swifter.tips/log/" target="_blank" rel="external">http://swifter.tips/log/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="LOG输出">LOG输出</h1><p>Log 输出是程序开发中很重要的组成部分，虽然它并不是直接的业务代码，但是却可以忠实地反映我们的程序是如何工作的，以及记录程序运行的过程中发生了什么。</p>
<p>在 Swift 中，最简单的输出方法就是使用 print，在我们关心的地方输出字符串和值。但是这并不够，试想一下当程序变得非常复杂的时候，我们可能会输出很多内容，而想在其中寻找到我们希望的输出其实并不容易。我们往往需要更好更精确的输出，这包括输出这个 log 的文件，调用的行号以及所处的方法名字等等。</p>
<p>我们当然可以在 print 的时候将当前的文件名字和那些必要的信息作为参数同我们的消息一起进行打印：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"文件名:Test.swift, 方法名:method，这是一条输出"</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Swift中使用随机数]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/27/%E5%9C%A8Swift%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>http://sunxiang0918.github.io/2015/12/27/在Swift中使用随机数/</id>
    <published>2015-12-27T12:27:49.000Z</published>
    <updated>2015-12-27T13:11:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Swift中使用随机数">在Swift中使用随机数</h1><p>在我们的开发过程中,有时需要产生一些随机数.而Swift中并没有像JAVA中一样提供一个专门的<code>Random</code>类来集中的生成随机数.<br>在Swift中,提供了几个全局的函数来生成随机数.一个是<code>random()</code>,还有一个是<code>arc4random()</code>,以及专门生成浮点的<code>srand48(Int)</code>和<code>drand48()</code>.<br>这些方法并没有进行封装,其实并不符合面向对象的思想.并且如果想要限制生成的随机数的最大最小值也不得行.因此,我们有必要对他们进行一个封装.</p>
<a id="more"></a>
<h2 id="arc4random()">arc4random()</h2><p>arc4random 是一个非常优秀的随机数算法,它会返回给我们一个任意的整数,如果我们想要在某一个范围里的话,做一次取模运算取余数就可以了.但是由于<code>arc4random()</code>函数返回的值无论上什么平台上都是返回一个<code>UInt32</code>(无符号32位整数)的值.因此,在32位的平台上进行<code>Int(arc4random())</code>转换的话,就有一半的几率出现转换越界,这就会造成程序的崩溃.</p>
<p>因此,在这种情况下,我们可以使用<code>arc4random_uniform</code>这个改良的<code>arc4random</code>函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">arc4random_uniform</span><span class="params">(<span class="number">_</span>: UInt32)</span></span> -&gt; <span class="type">UInt32</span></span><br></pre></td></tr></table></figure>
<p>这个函数接收一个UInt32的数字n作为输入,返回一个0到n-1之间的随机数.那么,只要我们传入的n不超过Int的范围,就可以避免像上面一样的转换越界的问题了.</p>
<p>因此,我们Int的随机数生成函数可以写成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Int = <span class="number">0</span>, <span class="number">_</span> upper: Int = Int.<span class="built_in">max</span>)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lower + <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(upper - lower + <span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(range: Range&lt;Int&gt;)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random(range.startIndex, range.endIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码使用了<code>扩展</code>,对Int类型增加了一个扩展,并实现了<code>random(lower: Int = 0, _ upper: Int = Int.max) -&gt; Int</code>和<code>random(range: Range&lt;Int&gt;) -&gt; Int</code>两个方法.这样,如果我们需要一个整数的随机数的话,就可以这样调用了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span>.random()</span><br><span class="line"><span class="type">Int</span>.random(<span class="number">0</span>, <span class="number">50</span>)</span><br><span class="line"><span class="type">Int</span>.random(<span class="number">20</span>...<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p>这里不得不夸一下<code>扩展</code>机制,真心方便.它可以不修改原有类的源码的情况下,给这个类增加新的功能.这就大大的增加了编写代码的方便.毕竟很多时候最开始时是考虑不周全的,我们并不能给某个类增加所有的方法,到后面进行修改的时候,就必然牵涉到修改源码.如果源码是自己写的还好,如果源码不是自己写的或者根本就没有源码了.那么给这个类增加方法就非常的不方便了.JAVA中有大量的<code>XXXXUtils</code>类,其实干的就是这个事情,比如<code>StringUtils</code>,由于JAVA中的<code>String</code>类是不能继承和修改的,因此就只有定义了一个工具类,里面就是对String做了一堆的扩展.调用的时候更不符合面向对象的思想.全是<code>StringUtils.xxxx(sourceStr,destStr)</code>这样的.</p>
<h2 id="其他类型的随机数">其他类型的随机数</h2><p>除了整数的随机数以外,浮点的随机数也是很常用的.因此我们同样可以对浮点数进行扩展.这里就有两种思路,第一种是继续使用<code>arc4random()</code>函数,把生成的随机整数转换成为浮点数.还有一种就是调用<code>srand48(Int)</code>和<code>drand48()</code>直接生成随机浮点数.这两个方案都是差不多的,不过由于每次调用<code>drand48()</code>前都需要调用<code>srand48(Int)</code>设置随机初始化的种子,因此我个人更倾向于使用<code>arc4random()</code>.于是就有以下的方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>.random(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Double = <span class="number">0</span>, <span class="number">_</span> upper: Double = <span class="number">100</span>)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">Double</span>(arc4random()) / <span class="number">0xFFFFFFFF</span>) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Float</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Float = <span class="number">0</span>, <span class="number">_</span> upper: Float = <span class="number">100</span>)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">Float</span>(arc4random()) / <span class="number">0xFFFFFFFF</span>) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">CGFloat</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: CGFloat = <span class="number">0</span>, <span class="number">_</span> upper: CGFloat = <span class="number">1</span>)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(<span class="type">Float</span>(arc4random()) / <span class="type">Float</span>(<span class="type">UINT32_MAX</span>)) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样集中常用数据类型的随机数的生成就都有了,并且使用起来也非常的方便.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bool</span>.random()</span><br><span class="line"><span class="type">Double</span>.random(<span class="number">1.5</span>,<span class="number">10.8</span>)</span><br><span class="line"><span class="type">Float</span>.random()</span><br><span class="line"><span class="type">CGFloat</span>.random()</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在Swift中使用随机数">在Swift中使用随机数</h1><p>在我们的开发过程中,有时需要产生一些随机数.而Swift中并没有像JAVA中一样提供一个专门的<code>Random</code>类来集中的生成随机数.<br>在Swift中,提供了几个全局的函数来生成随机数.一个是<code>random()</code>,还有一个是<code>arc4random()</code>,以及专门生成浮点的<code>srand48(Int)</code>和<code>drand48()</code>.<br>这些方法并没有进行封装,其实并不符合面向对象的思想.并且如果想要限制生成的随机数的最大最小值也不得行.因此,我们有必要对他们进行一个封装.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ELK初实践]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/21/ELK%E5%88%9D%E5%AE%9E%E8%B7%B5/"/>
    <id>http://sunxiang0918.github.io/2015/12/21/ELK初实践/</id>
    <published>2015-12-21T12:07:47.000Z</published>
    <updated>2015-12-22T03:00:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ELK(ElasticSearch+Logstash+Kiabana)初实践">ELK(ElasticSearch+Logstash+Kiabana)初实践</h1><p>ELK是由<a href="https://www.elastic.co" target="_blank" rel="external">elastic</a>公司维护的开源的实时日志采集与分析三剑客.它能够在分布式的架构下,使用<a href="https://www.elastic.co/products/logstash" target="_blank" rel="external">Logstash</a>实时的采集各种不同来源的日志,并通过清洗/ETL转换,形成有意义的数据,存入到<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="external">ElasticSearch</a>全文检索引擎中,再通过<a href="https://www.elastic.co/products/kibana" target="_blank" rel="external">Kiabana</a>呈现出来.<br>我们可以通过这套开源系统实时的了解服务器的软硬件信息,业务负载,错误异常等等.同时也能统一收集日志并做归档处理.当管理的机器非常多的时候这就非常的有意义了.</p>
<p><img src="/img/2015/12/21/1.png" alt=""></p>
<a id="more"></a>
<h2 id="ElasticSearch">ElasticSearch</h2><p>Elasticsearch是一个基于<a href="https://lucene.apache.org/core/" target="_blank" rel="external">Apache Lucene(TM)</a>的开源搜索引擎.与Solr类似,它隐藏了Lucene的复杂性.并提供大量分布式的功能.使用者能够很简单的就构建起一个全文检索引擎,并提供出<code>Restful</code>的API.而不需要编写任何的代码.</p>
<h3 id="安装">安装</h3><p>Elasticsearch的安装非常的简单,它只依赖JAVA的运行环境.最简的运行方式就是直接下载它编译好了的压缩包.然后解压即可用.<br>(默认JAVA运行环境已经配置完成)</p>
<ol>
<li>从<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="external">https://www.elastic.co/downloads/elasticsearch</a>下载最新的运行包.</li>
<li>使用<code>tar -xvf elasticsearch-2.1.0.tar.gz</code>解压</li>
<li>在<code>elasticsearch-2.1.0</code>文件夹下执行<code>./bin/elasticsearch</code></li>
<li><p>在浏览器中访问<a href="http://127.0.0.1:9200" target="_blank" rel="external">http://127.0.0.1:9200</a>.如果得到一个JSON的结果,就表明ES启动成功</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> "<span class="attribute">name</span>" : <span class="value"><span class="string">"Hood"</span></span>,</span><br><span class="line"> "<span class="attribute">cluster_name</span>" : <span class="value"><span class="string">"elasticsearch"</span></span>,</span><br><span class="line"> "<span class="attribute">version</span>" : <span class="value">&#123;</span><br><span class="line">   "<span class="attribute">number</span>" : <span class="value"><span class="string">"2.1.0"</span></span>,</span><br><span class="line">   "<span class="attribute">build_hash</span>" : <span class="value"><span class="string">"72cd1f1a3eee09505e036106146dc1949dc5dc87"</span></span>,</span><br><span class="line">   "<span class="attribute">build_timestamp</span>" : <span class="value"><span class="string">"2015-11-18T22:40:03Z"</span></span>,</span><br><span class="line">   "<span class="attribute">build_snapshot</span>" : <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">   "<span class="attribute">lucene_version</span>" : <span class="value"><span class="string">"5.3.1"</span></span><br><span class="line"> </span>&#125;</span>,</span><br><span class="line"> "<span class="attribute">tagline</span>" : <span class="value"><span class="string">"You Know, for Search"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想要一个监控界面来控制和了解ES的话,可以下载<a href="https://www.elastic.co/products/marvel" target="_blank" rel="external">marvel</a>.<code>Marvel</code>是Elasticsearch的管理和监控工具，在开发环境下免费使用.它包含了一个叫做Sense的交互式控制台，使用户方便的通过浏览器直接与Elasticsearch进行交互.不过这个东西不能进行商用.另外一个可视化的插件是<a href="https://github.com/mobz/elasticsearch-head.git" target="_blank" rel="external">Header</a>,同样是一个ES的管理和监控的工具,不过它的功能稍微要少一些.</p>
</li>
<li>安装<code>Header</code>的话非常简单,直接在es的<code>bin</code>目录中执行<code>sudo ./plugin install mobz/elasticsearch-head</code>即可,它会自动的下载并解压安装包到<code>plugins</code>目录.</li>
<li><p>安装完成后,在浏览器中浏览<a href="http://localhost:9200/_plugin/head/" target="_blank" rel="external">http://localhost:9200/_plugin/head/</a></p>
<p> <img src="/img/2015/12/21/2.png" alt="Header主界面"></p>
</li>
<li><p>安装<code>Marvel</code>稍微要麻烦一点,最新的<code>Marvel2.X</code>需要依赖<code>Kiabana</code>了.首先需要安装<code>License</code>模块:<code>./plugin install license</code>,然后在ES中安装<code>marvel-agent</code>:<code>./plugin install marvel-agent</code>,最后需要在<code>Kiabana</code>中安装<code>marvel</code>:<code>./kibana plugin --install elasticsearch/marvel/latest</code></p>
</li>
<li><p>安装完成后,启动<code>Elasticsearch</code>和<code>Kiabana</code>.然后在浏览器中浏览<a href="http://localhost:5601/app/marvel" target="_blank" rel="external">http://localhost:5601/app/marvel</a>即可.</p>
<p> <img src="/img/2015/12/21/3.png" alt="Marvel主界面"></p>
</li>
</ol>
<p>剩下的<code>Elasticsearch</code>的其他使用,我会另开博文来讲述,这里主要是讲ELK的整合使用~</p>
<h2 id="Kiabana">Kiabana</h2><p>Kibana是一个基于浏览器页面的<code>Elasticsearch</code>前端展示工具,提供了非常牛逼的图表和表现能力。Kibana全部使用HTML语言和Javascript编写的.因此可以部署到任意的Web容器中去.当然,官网上下载的安装包中已经内置了一个Web容器,直接运行即可.</p>
<h3 id="安装-1">安装</h3><ol>
<li>从<a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="external">https://www.elastic.co/downloads/kibana</a>下载最新的运行包.</li>
<li>使用<code>tar -xvf kibana-4.3.0-darwin-x64.tar.gz</code>解压</li>
<li><p>修改<code>/config/kibana.yml</code>文件,指定<code>Elasticsearch</code>的访问地址:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The Elasticsearch instance to use for all your queries.</span></span><br><span class="line">elasticsearch.url: <span class="string">"http://localhost:9200"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kibana-4.3.0-darwin-x64</code>文件夹下执行<code>./kibana</code>即可. 他会自动的在ES中创建它自己所需的索引文件.</p>
</li>
<li><p>在浏览器中打开<a href="http://127.0.0.1:5601/app/kibana" target="_blank" rel="external">http://127.0.0.1:5601/app/kibana</a>即可.这个时候就可以在界面的<code>Discover</code>中进行索引的查询了.</p>
<p> <img src="/img/2015/12/21/4.png" alt=""></p>
</li>
<li><p>同时,也可以使用<code>Visualize</code>功能,建立不同的报表.我们对日志的处理也主要就是通过记录的不同维度,建立不同的图表.然后订阅到<code>Dashboard</code>中.这样就能对日志进行实时的监控和分析.</p>
<p> <img src="/img/2015/12/21/5.png" alt=""></p>
</li>
</ol>
<h2 id="Logstash">Logstash</h2><p>Logstash是一个应用程序日志、事件的传输、处理、管理和搜索的平台.你可以用它来统一对应用程序日志进行收集管理.这点上它的功能其实和<code>Flume</code>是有点类似的.<br><img src="/img/2015/12/21/6.png" alt=""></p>
<h3 id="安装-2">安装</h3><p>Logstash是使用JRuby写的,因此需要依赖JAVA的运行环境.</p>
<ol>
<li>从<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">https://www.elastic.co/downloads/logstash</a>下载最新的运行包.</li>
<li>使用<code>tar -xvf logstash-2.1.0.tar.gz</code>解压</li>
<li>在<code>logstash-2.1.0</code>文件夹下执行<code>./bin/logstash agent -f logstash.conf</code>即可.</li>
</ol>
<p>这里主要是使用了<code>agent</code>模式运行,采集日志的配置记录到<code>logstash.conf</code>文件中. 接下来就介绍一下<code>logstash.conf</code>这个文件.</p>
<h3 id="配置">配置</h3><p>Logstash的日志采集过程主要有三个部分,分别是<code>Input</code> <code>Filter</code>和<code>Output</code>.对应了日志的收集,日志的整理和日志的输出,同时在Filter的前后允许配置<code>Codec</code>也就是编解码.每一个过程都提供了非常多的插件来辅助处理.具体有哪些插件可以访问<a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html" target="_blank" rel="external">Input</a>,<a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" target="_blank" rel="external">Filter</a>,<a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html" target="_blank" rel="external">Output</a>以及<a href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html" target="_blank" rel="external">Codec</a>.</p>
<p>比如最简单的一个conf文件为:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input &#123; stdin &#123; &#125; &#125;</span><br><span class="line">output &#123;</span><br><span class="line">   stdout &#123; codec=&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它指定了日志采集的输入源为命令行输入,不经过任何的处理,输出源为控制台输出,输出的时候编码为ruby的debug格式</p>
<p>执行这个采集的效果就是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/local/logstash-2.1.0/bin/logstash agent -f logstash-simple.conf</span></span><br><span class="line">Logstash startup completed</span><br><span class="line">hello World </span><br><span class="line">&#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"helloWorld"</span>,</span><br><span class="line">     <span class="string">"@version"</span> =&gt; <span class="string">"1"</span>,</span><br><span class="line">   <span class="string">"@timestamp"</span> =&gt; <span class="string">"2015-12-14T12:08:28.688Z"</span>,</span><br><span class="line">         <span class="string">"host"</span> =&gt; <span class="string">"localhost"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来看一个复杂点的例子,这个是我们测试环境抓取业务日志的conf配置:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">    	type =&gt; <span class="string">"my_app"</span></span><br><span class="line">        path =&gt; <span class="string">"/Applications/tomcat7/logs/fpLog/ALL/fpServer.log"</span></span><br><span class="line">        tags =&gt; [ <span class="string">"my_app"</span>, <span class="string">"logback"</span> ]</span><br><span class="line">        sincedb_path =&gt; <span class="string">"./sincedb"</span>	<span class="comment"># sincedb会记录日志文件的inode信息及当前读了多少bytes,以确保logstash停掉重启后可接着之前的位置继续收集日志</span></span><br><span class="line">		sincedb_write_interval =&gt; <span class="number">10</span>	<span class="comment"># 写sincedb的频率,logstash停止时会自动将当前收集位置记录到sincedb</span></span><br><span class="line">		<span class="comment">#start_position =&gt; "beginning"	# 注意,一定要设为beginning,默认是end.因为如果在logstash停掉期间,日志被rotate了两次,意味着有一整个日志文件是完全没有sincedb记录,logstash重启后就直接从start_position开始读,所以一定要设置为beginning.对于有sincedb记录的,logstash会接着停掉时的sincedb记录的位置继续收集日志</span></span><br><span class="line">		discover_interval =&gt; <span class="number">10</span></span><br><span class="line">		stat_interval =&gt; <span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> [message] =~ <span class="string">"^\[.+?\]"</span> &#123;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		drop&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	grok &#123;</span><br><span class="line">		match =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"\[(?&lt;log_id&gt;.*?)\] (?&lt;log_level&gt;\w+)  %&#123;TIMESTAMP_ISO8601:log_time&#125; (?&lt;system&gt;\w+) \[(?&lt;thread_name&gt;.+?)\] (?&lt;class_name&gt;.+)\- (?&lt;content&gt;.*)"</span> &#125;</span><br><span class="line">		remove_field =&gt; [ <span class="string">"message"</span> ]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	date &#123;</span><br><span class="line">    	match =&gt; [ <span class="string">"log_time"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>, <span class="string">"ISO8601"</span> ]</span><br><span class="line">    	timezone =&gt; <span class="string">"Asia/Shanghai"</span></span><br><span class="line">    	target =&gt; <span class="string">"@timestamp"</span></span><br><span class="line">    	remove_field =&gt; [ <span class="string">"log_time"</span> ]</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> [content] =~ <span class="string">"^\&#123;.*?\&#125;$"</span> &#123;</span><br><span class="line">  	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  		drop&#123;&#125;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">	json &#123;</span><br><span class="line">        source =&gt; <span class="string">"content"</span></span><br><span class="line">        target =&gt; <span class="string">"jsoncontent"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">	stdout &#123;&#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">  		hosts =&gt; <span class="string">"localhost:9200"</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先来看看Input{}. 他使用了<code>file</code>插件,从文件读取读取日志,并且给日志增加了一个Type属性用于区别来源.同时,1秒一次的监控日志的变化,把已扫描了的日志偏移量记录到<code>./sincedb</code>中去.</li>
<li>接下来就是filter{}了.<ul>
<li>一来,使用if语句,正则匹配<code>[]</code>开头的日志行,这个符合这个正则的日志才予以保留,其他的日志直接删除掉.</li>
<li>而后使用了grok插件,这个插件最重要的功能就是进行ETL转换,把非结构化的日志,转换成结构化的对象. 它使用正则表达式,以及<code>&lt;xxxx&gt;</code>的形式用来匹配和挖取有用的变量.</li>
<li>比如这个例子中的:<code>\[(?&lt;log_id&gt;.*?)\] (?&lt;log_level&gt;\w+)  %{TIMESTAMP_ISO8601:log_time} (?&lt;system&gt;\w+) \[(?&lt;thread_name&gt;.+?)\] (?&lt;class_name&gt;.+)\- (?&lt;content&gt;.*)</code>就是用来匹配<code>[1450580425858_394] INFO  2015-12-20 11:00:25.873 XXXXXX [myScheduler-4] c.s.j.s.c.c.AbstractTaskDispatcher- {&quot;site&quot;:&quot;unknown_site&quot;,&quot;tags&quot;:[&quot;unknown_tag&quot;],&quot;throwable&quot;:&quot;&quot;,&quot;detail&quot;:&quot;扫描模式,fileanalysis组件调度器,开始恢复上次待分配的任务.isChangePriority=false&quot;,&quot;time&quot;:&quot;2015-12-20 11:00:25.873&quot;,&quot;system&quot;:&quot;XXXXXX&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;source&quot;:&quot;unknown_source&quot;,&quot;extends&quot;:{},&quot;tool&quot;:&quot;unknown_tool&quot;,&quot;user&quot;:&quot;unknown_user&quot;,&quot;client_ip&quot;:&quot;unknown_ip&quot;,&quot;ip&quot;:&quot;172.16.129.7&quot;}</code>日志的.</li>
<li>通过grok插件的处理,这个时候日志事件就变为一个结构化的数据了.针对这个数据我们就可以进行很多其他的处理.</li>
<li>下面使用了<code>date</code>插件来处理日期.它定义了日期的标准格式,以及时区.然后把解析出来的时间赋值给模型上的某个字段.</li>
<li>接下来,再次使用<code>if</code>语句,对模型中的<code>content</code>字段再次进行清洗,对于不是JSON格式的日志,直接删除.</li>
<li>最后,使用<code>json</code>插件,把<code>content</code>字段JSON化.<br>最后使用output{}把转换好的日志输出到两个地方,一个是控制台,另外一个就是前文所说的<code>elasticsearch</code>了.</li>
</ul>
</li>
</ul>
<p>当我们执行这个日志采集Agent后,他就会不断的监控日志文件.一旦日志文件有变化,他就会采集到,并做处理,然后发送到es中. 最后我们就可以使用kibana来进行查看了.</p>
<h2 id="总结">总结</h2><p>本文主要介绍了ELK的作用,以及安装. 以一个简单的配置例子,介绍了ELK整合的常用方式以及效果.<br>通过ELK,可以把以前很麻烦的分布式日志的收集和整理简单化了.<br>更高级的功能,随着我使用的深入,会继续更新博文.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ELK(ElasticSearch+Logstash+Kiabana)初实践">ELK(ElasticSearch+Logstash+Kiabana)初实践</h1><p>ELK是由<a href="https://www.elastic.co">elastic</a>公司维护的开源的实时日志采集与分析三剑客.它能够在分布式的架构下,使用<a href="https://www.elastic.co/products/logstash">Logstash</a>实时的采集各种不同来源的日志,并通过清洗/ETL转换,形成有意义的数据,存入到<a href="https://www.elastic.co/products/elasticsearch">ElasticSearch</a>全文检索引擎中,再通过<a href="https://www.elastic.co/products/kibana">Kiabana</a>呈现出来.<br>我们可以通过这套开源系统实时的了解服务器的软硬件信息,业务负载,错误异常等等.同时也能统一收集日志并做归档处理.当管理的机器非常多的时候这就非常的有意义了.</p>
<p><img src="/img/2015/12/21/1.png" alt=""></p>]]>
    
    </summary>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="日志挖掘" scheme="http://sunxiang0918.github.io/tags/%E6%97%A5%E5%BF%97%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>如何关闭OSX 10.11 SIP]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/10/%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%ADOSX-10-11-SIP/"/>
    <id>http://sunxiang0918.github.io/2015/12/10/如何关闭OSX-10-11-SIP/</id>
    <published>2015-12-10T14:27:09.000Z</published>
    <updated>2015-12-10T14:35:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何关闭OSX_10-11_SIP_(System_Integrity_Protection)">如何关闭OSX 10.11 SIP (System Integrity Protection)</h1><p>2015.10.8 01:50更新：实在忍不住，看完池老师的公众号，就升级了。问题果然是有的，池老师你还我睡眠时间，又整到凌晨……</p>
<ol>
<li>关于Homebrew的安装参考链接</li>
<li>Cocoapods使用这个命令安装sudo gem install -n /usr/local/bin cocoapods原因是原来使用的/usr/bin这个目录被rootless保护了，那个-n参数作用是把二进制文件安装到指定目录，参考stackoverflow解决Cocoapods无法安装 注意stackoverflow中提到的使用这个参数「rootless=0」就不要用了，该方法apple官方已经封了，要停用rootless就用我下述的方法（也是官方推荐方法）</li>
<li>……暂时就这些，有问题在更新，或者留言给我你的问题，我看看能不能解决</li>
</ol>
<p>注意：SIP功能是Apple在OSX上推出的系统完整性保护功能，对于普通MAC用户来说是一项安全保护功能，如果不了解他的作用请不要随意关闭，对于开发者来说，因为会使用到很多的第三方辅助工具（例如：Cocoapods、Homebrew），而这些工具可能会修改系统目录，在这些工具未推出适应OSX 10.11的版本时，有必要临时关闭SIP以确保开发工具的使用。</p>
<p>建议：普通用户随意，开发者目前请谨慎升级，如果你已经升级，相信你可能需要恶心一阵了，因为有些工具没有更新不能正常使用或部分功能失效，甚至在关闭SIP后也有点问题，当然你只要耐心等待软件更新和网友的智慧或是自己动手丰衣足食，很多问题还是可以解决的。</p>
<a id="more"></a>
<ol>
<li><p><strong>进入RecoveryHD</strong><br>开机按住<code>Option</code>键在出现的启动选择菜单中选择<code>RecoveryHD</code>进入恢复模式</p>
</li>
<li><p><strong>使用csrutil命令</strong><br>打开终端Terminal，键入<code>csrutil</code>可以显示该命令的使用方法</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">usage: csrutil &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">Modify the System Integrity Protection configuration. All configuration changes apply to the entire machine.</span><br><span class="line">Available commands:</span><br><span class="line"></span><br><span class="line">    clear</span><br><span class="line">        Clear the existing configuration. Only available <span class="keyword">in</span> Recovery OS.</span><br><span class="line">    <span class="built_in">disable</span></span><br><span class="line">        Disable the protection on the machine. Only available <span class="keyword">in</span> Recovery OS.</span><br><span class="line">    <span class="built_in">enable</span></span><br><span class="line">        Enable the protection on the machine. Only available <span class="keyword">in</span> Recovery OS.</span><br><span class="line">    status</span><br><span class="line">        Display the current configuration.</span><br><span class="line"></span><br><span class="line">    netboot</span><br><span class="line">        add &lt;address&gt;</span><br><span class="line">            Insert a new IPv4 address <span class="keyword">in</span> the list of allowed NetBoot sources.</span><br><span class="line">        list</span><br><span class="line">            Print the list of allowed NetBoot sources.</span><br><span class="line">        remove &lt;address&gt;</span><br><span class="line">            Remove an IPv4 address from the list of allowed NetBoot sources.</span><br></pre></td></tr></table></figure>
<p> 可以看到在正常系统模式下中仅可以用status命令查询SIP状态</p>
</li>
<li><p><strong>常用参数</strong></p>
<ul>
<li>clear：清除配置设置，等同于完全开启SIP(<code>仅在恢复模式下有效</code>)</li>
<li>disable：关闭SIP(<code>仅在恢复模式下有效</code>)</li>
<li>enable：开启SIP(<code>仅在恢复模式下有效</code>)</li>
<li>status：查询SIP状态</li>
</ul>
</li>
<li><p><strong>常用参数进阶</strong><br>除了可以完全关闭/打开，还可以进行单项和多项组合关闭相关功能，用法如下</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil <span class="built_in">enable</span> [--without kext|fs|debug|dtrace|nvram] [--no-internal]</span><br></pre></td></tr></table></figure>
<p> 单项使用：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo csrutil <span class="built_in">enable</span> –without fs：Filesystem Protections <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without kext：Kext Signing <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without debug：Debugging Restrictions <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without nvram：NVRAM Protections <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without dtrace：DTrace Restrictions <span class="built_in">disable</span></span><br></pre></td></tr></table></figure>
<p> 组合使用：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo csrutil <span class="built_in">enable</span> –without kext –without fs：Filesystem Protections and Kext Signing are disabled</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更多详情请参考：<br><a href="http://cms.35g.tw/coding/關閉-osx-10-11-sip-system-integrity-protection-功能/zh-hans/" target="_blank" rel="external">可丁丹尼@一路往前走2.0</a><br><a href="https://pikeralpha.wordpress.com/2015/08/19/csrutil-updated/" target="_blank" rel="external">csrutil updated in DP7</a><br><a href="http://www.idelta.info/archives/sip-rootless-internal-in-el-capitan/" target="_blank" rel="external">SIP/Rootless Internal in El Capitan</a></p>
<hr>
<p>原文链接:<a href="http://www.jianshu.com/p/0572336a0771" target="_blank" rel="external">http://www.jianshu.com/p/0572336a0771</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="如何关闭OSX_10-11_SIP_(System_Integrity_Protection)">如何关闭OSX 10.11 SIP (System Integrity Protection)</h1><p>2015.10.8 01:50更新：实在忍不住，看完池老师的公众号，就升级了。问题果然是有的，池老师你还我睡眠时间，又整到凌晨……</p>
<ol>
<li>关于Homebrew的安装参考链接</li>
<li>Cocoapods使用这个命令安装sudo gem install -n /usr/local/bin cocoapods原因是原来使用的/usr/bin这个目录被rootless保护了，那个-n参数作用是把二进制文件安装到指定目录，参考stackoverflow解决Cocoapods无法安装 注意stackoverflow中提到的使用这个参数「rootless=0」就不要用了，该方法apple官方已经封了，要停用rootless就用我下述的方法（也是官方推荐方法）</li>
<li>……暂时就这些，有问题在更新，或者留言给我你的问题，我看看能不能解决</li>
</ol>
<p>注意：SIP功能是Apple在OSX上推出的系统完整性保护功能，对于普通MAC用户来说是一项安全保护功能，如果不了解他的作用请不要随意关闭，对于开发者来说，因为会使用到很多的第三方辅助工具（例如：Cocoapods、Homebrew），而这些工具可能会修改系统目录，在这些工具未推出适应OSX 10.11的版本时，有必要临时关闭SIP以确保开发工具的使用。</p>
<p>建议：普通用户随意，开发者目前请谨慎升级，如果你已经升级，相信你可能需要恶心一阵了，因为有些工具没有更新不能正常使用或部分功能失效，甚至在关闭SIP后也有点问题，当然你只要耐心等待软件更新和网友的智慧或是自己动手丰衣足食，很多问题还是可以解决的。</p>]]>
    
    </summary>
    
      <category term="MAC" scheme="http://sunxiang0918.github.io/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nutch2.3 安装与部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/08/Nutch2-3-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/12/08/Nutch2-3-安装与部署/</id>
    <published>2015-12-08T14:15:32.000Z</published>
    <updated>2015-12-08T15:26:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Nutch2-3_安装与部署">Nutch2.3 安装与部署</h1><p><a href="http://nutch.apache.org" target="_blank" rel="external">Nutch</a>是由JAVA开发的开源的全文检索引擎.不过更多的被用来当成Web爬虫来使用.现在Nutch分为了1.x和2.x两个版本在维护.而这两个版本的最主要的区别在于底层存储的抽象.1.x版本是基于Hadoop架构的,底层存储只能使用HDFS.而2.x版本通过<a href="http://gora.apache.org" target="_blank" rel="external">Apache Gora</a>对底层存储做了抽象,能访问HBase,MYSQL,MongoDB,Solr,AvroStore等等.</p>
<p>但是从2.X开始,官方就只提供源码的下载了,不再提供编译后的发布版本,因此就需要我们自己去进行编译.</p>
<a id="more"></a>
<h2 id="编译">编译</h2><p>为了简便起见,我们准备底层的存储使用mongoDB. 因此,这个演示是基于 Nutch+MongoDB的.</p>
<ol>
<li><p>下载源码<br> 从官网上下载<a href="http://www.apache.org/dyn/closer.lua/nutch/2.3/apache-nutch-2.3-src.tar.gz" target="_blank" rel="external">http://www.apache.org/dyn/closer.lua/nutch/2.3/apache-nutch-2.3-src.tar.gz</a>.然后执行命令 <code>tar -xvf apache-nutch-2.3-src.tar.gz</code>进行解压.</p>
</li>
<li><p>修改<code>$NUTCH_HOME/conf/nutch-site.xml</code>,增加以下内容:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>storage.data.store.class<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>org.apache.gora.mongodb.store.MongoStore<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">description</span>&gt;</span>Default class for storing data<span class="tag">&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>http.agent.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>My Nutch Spider<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>$NUTCH_HOME/conf/gora.properties</code>,在最下面找到<code># MongoDBStore properties  #</code>,然后打开注释:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################</span></span><br><span class="line"><span class="comment"># MongoDBStore properties  #</span></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line">gora.datastore.default=org.apache.gora.mongodb.store.MongoStore</span><br><span class="line">gora.mongodb.override_hadoop_configuration=<span class="literal">false</span></span><br><span class="line">gora.mongodb.mapping.file=/gora-mongodb-mapping.xml</span><br><span class="line">gora.mongodb.servers=localhost:<span class="number">27017</span></span><br><span class="line">gora.mongodb.db=mytestdatabase</span><br><span class="line"><span class="comment">#gora.mongodb.login=login</span></span><br><span class="line"><span class="comment">#gora.mongodb.secret=secret</span></span><br></pre></td></tr></table></figure>
<p> 注意,如果你的mongo数据库没有auth,最后两行需要注释掉.</p>
</li>
<li><p>修改<code>$NUTCH_HOME/ivy/ivy.xml</code>.去掉下面的注释,使用gora-hbase:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Uncomment this to use MongoDB as Gora backend. --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">dependency</span> <span class="attribute">org</span>=<span class="value">"org.apache.gora"</span> <span class="attribute">name</span>=<span class="value">"gora-mongodb"</span> <span class="attribute">rev</span>=<span class="value">"0.5"</span> <span class="attribute">conf</span>=<span class="value">"*-&gt;default"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> 这个地方需要特别注意一下,这里虽然使用了<code>gora-mongodb-0.5</code>,但是这个版本其实是有问题的,会在后面抓取记录保存到MongoDB的时候报:<code>java.lang.IllegalArgumentException: can&#39;t serialize class
org.apache.avro.util.Utf8</code>的异常,开始折腾了我很久.最后发现了这个是<code>gora-mongodb-0.5</code>自身的一个<a href="https://issues.apache.org/jira/browse/GORA-388" target="_blank" rel="external">Bug</a>,在0.6中是被修复了的.因此,我最开始想把整个gora升级成为0.6,结果Nutch不能执行.因此,目前阶段如果你底层想要使用MongoDB进行存储的话,需要单个把<code>gora-mongodb</code>升级到<code>0.6</code>版本,而其他的不动.</p>
</li>
<li><p>接下来就是编译了,直接在<code>$NUTCH_HOME</code>根目录上执行<code>ant runtime</code>即可.<br> 但是这个速度不得不吐槽.非常的坑爹,基本上下了我3个多小时.不知道是什么原因,我平时使用JAVA的Maven环境的时候下载其实是非常的快的.但是IVY的依赖下载就非常非常非常的慢.理论上他们是同一个网络地址啊. 为了能加速那么一丢丢.可以把<code>$NUTCH_HOME/ivy/ivysettings.xml</code>中的<code>repo.maven.org</code>给替换成国内的镜像.比如:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"repo.maven.org"</span></span><br><span class="line">   <span class="attribute">value</span>=<span class="value">"http://maven.oschina.net/content/groups/public/"</span></span><br><span class="line">   <span class="attribute">override</span>=<span class="value">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 其他的两个不能替换,我换了以后会找不到包的.</p>
<p> 如果你的编译长时间的停在<code>[ivy:resolve] :: loading settings :: file = $NUTCH_HOME/ivy/ivysettings.xml</code>.那么你可以把进程杀了重新执行一次<code>ant runtime</code>.可能执行个十来次就能编译成功了.</p>
<p> 最终,会显示:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">job:</span><br><span class="line">     [jar] Building jar: <span class="variable">$NUTCH_HOME</span>/build/apache-nutch-<span class="number">2.3</span>.job</span><br><span class="line">runtime:</span><br><span class="line">    [copy] Copying <span class="number">1</span> file to <span class="variable">$NUTCH_HOME</span>/nutch/runtime/deploy</span><br><span class="line">    [copy] Copying <span class="number">2</span> files to <span class="variable">$NUTCH_HOME</span>/nutch/runtime/<span class="built_in">local</span>/lib</span><br><span class="line">BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure>
<p> 然后会在你的<code>$NUTCH_HOME</code>目录下,创建<code>runtime</code>和<code>build</code>目录. 其中的<code>runtime</code>目录即为你编译好了的<code>Nutch2.3</code>.</p>
<p> 如果在编译过程中出现<code>Could not load definitions from resource org/sonar/ant/antlib.xml.It could not be found.</code>的警告的话,不要着急,这个错误不影响你最后的编译是否成功.如果你有强迫症,见不得有警告的话.那么可以到<a href="http://search.maven.org" target="_blank" rel="external">Maven</a>中下载<code>sonar-ant-task-2.2.jar</code>包,然后放入<code>$NUTCH_HOME/lib</code>,然后修改<code>$NTUCH_HOME/build.xml</code>即可:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Define the Sonar task if this hasn't been done in a common script --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">taskdef</span> <span class="attribute">uri</span>=<span class="value">"antlib:org.sonar.ant"</span> <span class="attribute">resource</span>=<span class="value">"org/sonar/ant/antlib.xml"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classpath</span> <span class="attribute">path</span>=<span class="value">"$&#123;ant.library.dir&#125;"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classpath</span> <span class="attribute">path</span>=<span class="value">"$&#123;mysql.library.dir&#125;"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classpath</span>&gt;</span><span class="tag">&lt;<span class="title">fileset</span> <span class="attribute">dir</span>=<span class="value">"lib/"</span> <span class="attribute">includes</span>=<span class="value">"sonar*.jar"</span> /&gt;</span><span class="tag">&lt;/<span class="title">classpath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">taskdef</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="部署">部署</h2><p>其实编译完成后的<code>runtime</code>文件夹就已经是一个完整的可以运行的环境了.<br>我们在这里做一个简单的测试:使用Nutch爬取<a href="http://www.cnbeta.com" target="_blank" rel="external">cnbeta</a>中的新闻文章.</p>
<ol>
<li><p>在<code>$NUTCH_HOME/runtime/local</code>下创建一个文件<code>seed.txt</code>. 里面就是需要爬取的网站,一行一个.我们在这里只写一行:<code>www.cnbeta.com</code></p>
</li>
<li><p>修改<code>$NUTCH_HOME/runtime/cong/automaton-urlfilter.txt</code>文件,这个文件就是URL的过滤.避免爬取到不需要的网站.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># accept anything else</span></span><br><span class="line">+^http://www.cnbeta.com/$</span><br><span class="line">+^http://www.cnbeta.com/articles/\d\.htm$</span><br><span class="line"><span class="comment"># skip everything else</span></span><br><span class="line">-.</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在命令行中执行<code>$NUTCH_HOME/runtime/bin/crawl seed.txt test 2</code>.<br> 这个时候就会开始爬取目标网站了.你会看到很多的日志信息:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	fetching http://www.cnbeta.com/topics/<span class="number">8</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">71</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">28</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">464</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">72</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">27</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">455</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">73</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">68</span> <span class="number">102</span> kb/s, <span class="number">26</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">83</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">49</span>/<span class="number">50</span> spinwaiting/active, <span class="number">73</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">0</span> kb/s, <span class="number">25</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">74</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">25</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">444</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">75</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">68</span> <span class="number">102</span> kb/s, <span class="number">24</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/commentrss.php (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">76</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">0</span> kb/s, <span class="number">23</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">197</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">77</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">22</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br></pre></td></tr></table></figure>
<p> 等一段时间后,爬取就完成了.然后打开Mongo数据库,就会看到有一个<code>mytestdatabase</code>的库.里面有一个<code>test_webpage</code>的表,其中的东西就是爬虫爬取的内容了.随便抓取一个举例:</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">	&#123;</span><br><span class="line">  "_id": "com.cnbeta.www:http/articles/447355.htm",</span><br><span class="line">  "status": 2,</span><br><span class="line">  "fetchTime": NumberLong(1449587050404),</span><br><span class="line">  "fetchInterval": 2592000,</span><br><span class="line">  "retriesSinceFetch": 0,</span><br><span class="line">  "score": 0.0,</span><br><span class="line">  "inlinks": &#123;</span><br><span class="line">    "http://www·cnbeta·com/": ""</span><br><span class="line">  &#125;,</span><br><span class="line">  "markers": &#123;</span><br><span class="line">    "_gnmrk_": "1449586889-28161",</span><br><span class="line">    "_ftcmrk_": "1449586889-28161",</span><br><span class="line">    "dist": "1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "metadata": &#123;</span><br><span class="line">    "_rs_": BinData(0, "AAABzw==")</span><br><span class="line">  &#125;,</span><br><span class="line">  "batchId": "1449586889-28161",</span><br><span class="line">  "baseUrl": "http://www.cnbeta.com/articles/447355.htm",</span><br><span class="line">  "prevFetchTime": NumberLong(1449586888595),</span><br><span class="line">  "protocolStatus": &#123;</span><br><span class="line">    "code": 1,</span><br><span class="line">    "args": [</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">    "lastModified": NumberLong(0)</span><br><span class="line">  &#125;,</span><br><span class="line">  "content": BinData(0, "XXXXXX网页的内容,太长了,就省略了"),</span><br><span class="line">  "contentType": "application/xhtml+xml",</span><br><span class="line">  "headers": &#123;</span><br><span class="line">    "Vary": "Accept-Encoding",</span><br><span class="line">    "Date": "Tue, 08 Dec 2015 15:04:10 GMT",</span><br><span class="line">    "Last-Modified": "Sun, 06 Dec 2015 02:11:14 GMT",</span><br><span class="line">    "Content-Encoding": "gzip",</span><br><span class="line">    "Content-Type": "text/html",</span><br><span class="line">    "Accept-Ranges": "bytes",</span><br><span class="line">    "Connection": "close",</span><br><span class="line">    "Server": "grid-cache/1.4.4",</span><br><span class="line">    "X-CDNZZ-FCACHE": "EXPIRED"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这就是爬取下来的内容.就可以通过我们进一步处理了.<br> 而这个字段的定义是在<code>$NUTCH_HOME/runtime/local/conf/gora-mongodb-mapping.xml</code>中定义的.</p>
</li>
</ol>
<h2 id="结束语">结束语</h2><p>这样,一个最简单的Nutch的运行环境就搭建成功了.更多的更高级的功能,我们后面再慢慢来试验.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Nutch2-3_安装与部署">Nutch2.3 安装与部署</h1><p><a href="http://nutch.apache.org">Nutch</a>是由JAVA开发的开源的全文检索引擎.不过更多的被用来当成Web爬虫来使用.现在Nutch分为了1.x和2.x两个版本在维护.而这两个版本的最主要的区别在于底层存储的抽象.1.x版本是基于Hadoop架构的,底层存储只能使用HDFS.而2.x版本通过<a href="http://gora.apache.org">Apache Gora</a>对底层存储做了抽象,能访问HBase,MYSQL,MongoDB,Solr,AvroStore等等.</p>
<p>但是从2.X开始,官方就只提供源码的下载了,不再提供编译后的发布版本,因此就需要我们自己去进行编译.</p>]]>
    
    </summary>
    
      <category term="Nutch" scheme="http://sunxiang0918.github.io/tags/Nutch/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="爬虫" scheme="http://sunxiang0918.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Linux上运行Swift]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/05/%E5%9C%A8Linux%E4%B8%8A%E8%BF%90%E8%A1%8CSwift/"/>
    <id>http://sunxiang0918.github.io/2015/12/05/在Linux上运行Swift/</id>
    <published>2015-12-05T15:26:26.000Z</published>
    <updated>2015-12-05T16:29:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Linux上运行Swift">在Linux上运行Swift</h1><p>盼星星盼月亮,等了半年,终于在12月的头几天,苹果开源了<code>Swift</code>语言.并建立了一个<a href="http://swift.org" target="_blank" rel="external">Swift.org</a>社区以及<a href="http://github.com/apple" target="_blank" rel="external">Github</a>来维护.开源以后,最大的好处当然是有更多的人来参与Swift语言的发展,让Swift语言增加更多的新的特性,更多的开源框架,工作在更多的平台上面.这对于一个开发语言来说无疑是一个很好的消息.而对于我来说,除了在编写代码的时候能更了解Swift某些函数的参数意义和工作的原理(作为一个JAVA Coder,平时如果遇到搞不定的问题或者是不明白的地方,习惯了直接翻它的源码来了解原委的)外,让我基本上抛弃了<code>Python</code>脚本,平时有什么小东西小程序需要写一下的话,现在可以直接写一个Swift文件,然后在命令行直接调用<code>swift xxx.swift</code>或者<code>swiftc -O xxxx.swift</code>即可.</p>
<h2 id="在Linux上安装Swift">在Linux上安装Swift</h2><p>前面废话说了这么多.现在就来看看如何在Linux上安装Swift的运行环境.MACOS上的就不用说了,直接安装一个Xcode就可以了.</p>
<a id="more"></a>
<h3 id="环境">环境</h3><p>目前Swift提供了<code>Ubuntu</code>上编译好了的安装包. 因此需要Ubuntu14.04以上的操作系统.<br>同时,Swift的编译环境还需要<code>clang</code>.这个也是需要安装的.</p>
<ol>
<li><p>由于<code>clang</code>目前才出来,比较的新.因此在<code>cn.archive.ubuntu.com</code>上还没有,需要切换到官方源上去.</p>
<ol>
<li>备份原来的源列表 <code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></li>
<li><p>使用编辑器打开<code>sources.list</code>文件,修改里面的内容为:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-security main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-updates main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-proposed main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-backports main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-security main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-updates main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-proposed main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后更新一下源 <code>sudo apt-get update</code></p>
</li>
<li><p>安装<code>clang</code></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install clang libicu-dev</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>下载,并安装<code>Swift</code></p>
<ol>
<li>在<a href="https://swift.org/download/" target="_blank" rel="external">官方网站</a>上下载与你操作系统对应的安装包.比如我用的<code>Ubuntu 14.10</code>操作系统,那么就下载<a href="https://swift.org/builds/ubuntu1404/swift-2.2-SNAPSHOT-2015-12-01-b/swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu14.04.tar.gz" target="_blank" rel="external">swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu14.04.tar.gz</a></li>
<li><p>下载后,解压到本地目录.由于它都是安排好了目录的.都是<code>/usr</code>下面.因此.只需要拷贝到/usr下面即可.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -R /swift/usr/ /</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样,Swift的运行环境就算是安装完成了.我们可以输入<code>swift --version</code>来做验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Parallels-Virtual-Platform:~$ swift --versionSwift version <span class="number">2.2</span>-dev (LLVM <span class="number">46</span>be9ff861, Clang <span class="number">4</span>deb154edc, Swift <span class="number">778</span>f82939c)Target: x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="在命令行中执行一个简单程序">在命令行中执行一个简单程序</h2><p>既然安装完成了运行环境,那么接下来我们就试着编写一个最简单的程序.然后执行.</p>
<ol>
<li>创建一个<code>test.swift</code>文件.</li>
<li>在其中写上</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Hello Swift!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<ol>
<li>保存文件后,在命令行中执行 <code>swift test.swift</code>.即可得到程序执行的结果.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Parallels-Virtual-Platform:~$ swift test.swift</span><br><span class="line">Hello Swift!</span><br></pre></td></tr></table></figure>
<ol>
<li>我们也可以把这个文件直接编译成可执行的程序:<code>swift -O test.swift</code>.执行了这个命令后,会在当前目录生成一个<code>test</code>可执行文件. 直接在命令行中执行<code>./test</code>也是可以得到结果的.</li>
</ol>
<p>Swift的命令行程序与其他的语言不同,它不需要一个特殊约定的<code>main</code>函数. 只要你执行的命令的作用于是全局的,那么在就会在执行的时候按顺序的先执行这些全局作用于的语句.相当于它的全局作用域就是一个大的<code>main</code>函数.<br>又由于一个Swift文件中可以写很多的类或方法,不想<code>JAVA</code>一样,一个<code>java</code>文件只能有一个公开的类.因此,对于一个简单的小程序来说,我们完全可以把所有的代码都写在一个<code>swift</code>文件中,然后进行执行,不用考虑什么包依赖等等,非常的方便.</p>
<h2 id="在命令行中执行一个多文件编译的程序">在命令行中执行一个多文件编译的程序</h2><p>当然,除了最最简单的只有1个文件的程序外,更多的程序都是有代码结构的,都是由多个<code>swift</code>文件组成的.<br>在这种情况下,就需要使用<code>swift build</code>命令来 多文件协同编译了.</p>
<ol>
<li><p>这种情况下的swift程序源码需要按照一定的约定来创建.</p>
<ol>
<li>项目的名称即为目录的名称. 比如我现在有个<code>TestProgram</code>的项目,那么就需要创建一个<code>TestProgram</code>的目录.</li>
<li>在这个目录下创建一个<code>Package.swift</code>文件,这个文件是必须的,它用于提供给包管理器进行包依赖的信息.这就类似于JAVA中的<code>package-info.java</code></li>
<li>创建一个<code>Sources</code>文件夹,所有的源码都应该放在这里</li>
<li>在<code>Sources</code>文件夹下,创建一个<code>main.swift</code>文件,这个就是应用的入口文件.</li>
<li><p>最终,项目的结构就是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/TestProgram</span><br><span class="line">/TestProgram/Package.swift</span><br><span class="line">/TestProgram/Sources/main.swift</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>为了体现多文件协同编译,现在再在<code>Sources</code>目录下新增加一个文件<code>Hello.swif</code></p>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(a:<span class="params">(name:String)</span></span></span>-&gt;<span class="type">Void</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> args = <span class="type">Process</span>.arguments</span><br><span class="line">		<span class="keyword">if</span> args.<span class="built_in">count</span> &gt;= <span class="number">2</span>&#123;</span><br><span class="line">			a(name:args[<span class="number">1</span>])</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"Hello Swift!"</span>)</span><br><span class="line">		&#125;       &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>然后在<code>main.swift</code>中编写:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello(&#123;name <span class="keyword">in</span> <span class="built_in">print</span>(<span class="string">"Hello <span class="subst">\(name)</span> on Linux!"</span>)&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到项目的根目录<code>/TestProgram</code>.执行<code>swift build</code>编译即可.正确的话它会输出以下信息</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Parallels-Virtual-Platform:~/TestProject$ swift buildCompiling Swift Module <span class="string">'TestProject'</span> (<span class="number">2</span> sources)Linking Executable:  .build/debug/TestProjectroot@Parallels-Virtual-Platform:~/TestProject$ .build/debug/TestProject</span><br></pre></td></tr></table></figure>
<p> 需要注意的是,<code>swift build</code>会在工程目录下生成一个<code>.build</code>文件夹,里面就是编译后的可执行的文件,默认是使用的<code>debug target</code>. 并且<code>Linux</code>下编译的可执行文件是不能直接在<code>OSX</code>上使用的,反之亦然.</p>
</li>
<li><p>直接调用<code>.build/debug/TestProject</code> 便可执行程序.</p>
</li>
<li><p>第二步的代码中有一句<code>let args = Process.arguments</code>.我们可以通过此函数获取命令行的输入,它肯定是一个大于等于1的数组,第一个元素就是程序自己的名字.后面是用户在命令行中输入的参数,并且不仅仅限于<code>main.swift</code>才能获取,任何的Swift文件中都可以取得这个值.因此,我们刚才的程序也可以这样输入:<code>.build/debug/TestProject SUN</code>.那么程序的<code>args[1]</code>即为<code>SUN</code>.</p>
</li>
<li>由于Swift不需要像<code>JAVA</code>或者<code>OC</code>一样,如果源码在两个源文件中就需要编写一堆无用的<code>import</code>语句,只要在同一个项目中,<code>Swift</code>的不同源文件定义的类或函数都可以直接的调用,只有在跨工程或<code>Framework</code>的时候,才需要<code>import Package</code>.这大大的方便了我们编写项目.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在Linux上运行Swift">在Linux上运行Swift</h1><p>盼星星盼月亮,等了半年,终于在12月的头几天,苹果开源了<code>Swift</code>语言.并建立了一个<a href="http://swift.org">Swift.org</a>社区以及<a href="http://github.com/apple">Github</a>来维护.开源以后,最大的好处当然是有更多的人来参与Swift语言的发展,让Swift语言增加更多的新的特性,更多的开源框架,工作在更多的平台上面.这对于一个开发语言来说无疑是一个很好的消息.而对于我来说,除了在编写代码的时候能更了解Swift某些函数的参数意义和工作的原理(作为一个JAVA Coder,平时如果遇到搞不定的问题或者是不明白的地方,习惯了直接翻它的源码来了解原委的)外,让我基本上抛弃了<code>Python</code>脚本,平时有什么小东西小程序需要写一下的话,现在可以直接写一个Swift文件,然后在命令行直接调用<code>swift xxx.swift</code>或者<code>swiftc -O xxxx.swift</code>即可.</p>
<h2 id="在Linux上安装Swift">在Linux上安装Swift</h2><p>前面废话说了这么多.现在就来看看如何在Linux上安装Swift的运行环境.MACOS上的就不用说了,直接安装一个Xcode就可以了.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MYSQL支持utf8mb4]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/02/MYSQL%E6%94%AF%E6%8C%81utf8mb4/"/>
    <id>http://sunxiang0918.github.io/2015/12/02/MYSQL支持utf8mb4/</id>
    <published>2015-12-02T14:41:52.000Z</published>
    <updated>2015-12-02T14:59:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MYSQL支持utf8mb4">MYSQL支持utf8mb4</h1><p>MYSQL默认的utf8字符集采用了3个字节来进行保存.这就存在了一个问题,那就是有部分的UTF8的字符其实是保存不进MYSQL的,比如现在流行的emoji表情,这和以前的认知是不同的.为了避免以后出现问题,找了这方面的信息.推荐如果有保存扩展字符的用户,提前就把MYSQL的字符集给修改了.具体MYSQL的默认utf8支持哪些字符编码,可以参见这个:<a href="http://witmax.cn/unicode-list.html" target="_blank" rel="external">Unicode编码表</a>,前126行就是它支持的,后面的就是不支持的.</p>
<p>发现这个问题其实相当的偶然,在知乎上看到了一个问题<a href="http://www.zhihu.com/question/35901422/answer/64960598" target="_blank" rel="external">为什么知乎不支持non-BMP的汉字？</a>.突然发现了这个问题,一验证果然如此.<br>具体来说就是MYSQL的utf8字符集只使用了3个字节来保存字符.因此UTF8扩展区的字符就无法保存.这个在MYSQL5.5后引入了<code>utf8mb4</code>的字符集来解决这个问题,它使用了4个字节来存储字符,扩展了存储的数量.因此,如果各位是使用的MYSQL5.5以上的版本,推荐在可能存入扩展字符的字段上设置字符集为utf8mb4.虽然这样可能会造成空间的浪费,但是比以后在上线的系统上升级数据库的风险要小的多.</p>
<a id="more"></a>
<h2 id="修改方法">修改方法</h2><h3 id="MYSQL服务器端">MYSQL服务器端</h3><p>只需要修改数据库的配置文件 <code>/etc/my.cnf</code>,增加或修改以下两行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">character-set-server=utf8mb4 </span><br><span class="line">collation_server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>
<p>然后重启数据库即可.<br>对于已有的表,执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span></span><br></pre></td></tr></table></figure>
<p>即可.</p>
<h3 id="客户端">客户端</h3><p>由于JDBC的MYSQL驱动现在不支持显示的设置<code>utf8mb4</code>字符集,所以不能在url连接上增加<code>characterEncoding=utf8mb4</code>.<br>那么就只能采取以下的三种方法了(都需要高版本的JDBC驱动):</p>
<ol>
<li>在服务器上设置了<code>character-set-server=utf8mb4</code>后,在客户端url上不显示的设置字符集,它会自动继承服务器的设置</li>
<li>在执行SQL之前,运行<code>set names utf8mb4</code>.例如:<code>connection.prepareStatement(&quot;set names utf8mb4&quot;).executeQuery();</code></li>
<li>设置MYSQL的 init_connect参数,设置<code>set names utf8mb4</code>.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MYSQL支持utf8mb4">MYSQL支持utf8mb4</h1><p>MYSQL默认的utf8字符集采用了3个字节来进行保存.这就存在了一个问题,那就是有部分的UTF8的字符其实是保存不进MYSQL的,比如现在流行的emoji表情,这和以前的认知是不同的.为了避免以后出现问题,找了这方面的信息.推荐如果有保存扩展字符的用户,提前就把MYSQL的字符集给修改了.具体MYSQL的默认utf8支持哪些字符编码,可以参见这个:<a href="http://witmax.cn/unicode-list.html">Unicode编码表</a>,前126行就是它支持的,后面的就是不支持的.</p>
<p>发现这个问题其实相当的偶然,在知乎上看到了一个问题<a href="http://www.zhihu.com/question/35901422/answer/64960598">为什么知乎不支持non-BMP的汉字？</a>.突然发现了这个问题,一验证果然如此.<br>具体来说就是MYSQL的utf8字符集只使用了3个字节来保存字符.因此UTF8扩展区的字符就无法保存.这个在MYSQL5.5后引入了<code>utf8mb4</code>的字符集来解决这个问题,它使用了4个字节来存储字符,扩展了存储的数量.因此,如果各位是使用的MYSQL5.5以上的版本,推荐在可能存入扩展字符的字段上设置字符集为utf8mb4.虽然这样可能会造成空间的浪费,但是比以后在上线的系统上升级数据库的风险要小的多.</p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="Mysql" scheme="http://sunxiang0918.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在自己的App中嵌入onePassword密码管理]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/30/%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84App%E4%B8%AD%E5%B5%8C%E5%85%A5onePassword%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    <id>http://sunxiang0918.github.io/2015/11/30/在自己的App中嵌入onePassword密码管理/</id>
    <published>2015-11-30T11:36:31.000Z</published>
    <updated>2015-12-02T15:19:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在自己的App中嵌入onePassword密码管理">在自己的App中嵌入onePassword密码管理</h1><p><a href="https://agilebits.com/onepassword/" target="_blank" rel="external">1Password</a>是一个密码管理软件,它可以方便和安全的管理你的密码.它提供反钓鱼保护功能和卓越的密码管理,并具有自动生成强密码功能.所有的机密资料,包括密码,身份卡和信用卡,都是保存在一个安全的地方.在OSX和IOS系统上非常的流行.在我的博文<a href="/2015/09/21/MacOS下JAVA开发使用经验(一">MacOS下JAVA开发使用经验(一)</a> )也有介绍.<br>自从我的账号被CSDN泄露的干干净净以后的一段时间里,我的其他账号是不是的就会收到更改密码的邮件.于是,一下狠心购买了<code>1Password</code>,并且把我所有的差不多200多个账号的密码通过<code>1Password</code>都给改成了14位的随机字符,以后就不用担心一个密码丢失导致其他的账号也丢失了(1Password自己本身在它的网上没有所谓的用户名密码,密码是通过加密文件整体在WIFI或iCloud中同步的.).但是这就带来了一个麻烦,就是我的密码都变成了类似于这样的<code>RxCa9vdBUB3fCU</code>的字符串.当使用safari这些的时候还好,它有浏览器的插件可以自动填充.遇到一些App,就只能手动的输入了(类似于光大银行和QQ不允许粘贴密码).这相当的麻烦,又容易出错.因此,自己开发APP的时候,就特别的注意了在输入密码的地方要与<code>1Password</code>的整合,这点网易系的APP就做的比较好,<code>网易云音乐</code>和<code>考拉海淘</code>就是支持了<code>1Password</code>的.<br>要在自己的App中引入<code>1Password</code>其实也不麻烦,可以说是相当的简单.<code>1Password</code>在<code>GitHub</code>上开源了App与它的软件交互的扩展<a href="https://github.com/AgileBits/onepassword-app-extension" target="_blank" rel="external">1PasswordExtension</a>.我们通过这个扩展就可以在自己的App中嵌入<code>1Password</code>的密码管理了.</p>
<a id="more"></a>
<h2 id="导入1PasswordExtension扩展">导入1PasswordExtension扩展</h2><p>这个可以使用<code>cocoaPods</code>. 在项目的<code>Pods</code>文件中增加<code>pod &#39;1PasswordExtension&#39;</code>,然后执行<code>pod install</code>即可.由于它已经兼容了<code>swift</code>了,所以不需要特别的再链接OC的头文件了.</p>
<h2 id="使用1Password进行登陆框的填充">使用1Password进行登陆框的填充</h2><p>这个过程也非常的简单.</p>
<ol>
<li>在登录的页面上增加一个按钮,<code>1PasswordExtension</code>内置好了它的图片,你可以直接使用.</li>
<li>给这个按钮增加点击的事件.</li>
<li><p>在Controller类中增加事件的实现,调用<code>public func findLoginForURLString(URLString: String, forViewController viewController: UIViewController, sender: AnyObject?, completion: (([NSObject : AnyObject]?, NSError?) -&gt; Void)?)</code>方法:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OnePasswordExtension</span>.sharedExtension().findLoginForURLString(<span class="string">""</span>, forViewController: <span class="keyword">self</span>, sender: sender) &#123; (_loginDictionary, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">			   <span class="comment">//loginDictionary中即用调用1Password后,用户选择的用户名和密码</span></span><br><span class="line">               guard <span class="keyword">let</span> loginDictionary = _loginDictionary <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> loginDictionary.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">               		<span class="comment">//如果用户点的是取消,这里就是0</span></span><br><span class="line">                   <span class="keyword">if</span> error!.code != <span class="type">Int</span>(<span class="type">AppExtensionErrorCodeCancelledByUser</span>) &#123;</span><br><span class="line">                       <span class="comment">//<span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//把用户名和密码赋值给输入框即可.更进一步的可以直接激活登录操作</span></span><br><span class="line">               view?.userNameField.text = loginDictionary[<span class="type">AppExtensionUsernameKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">               view?.passwordField.text = loginDictionary[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">               </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p> 效果如图:</p>
<p> <img src="/img/2015/11/30/1.PNG" alt=""><br> <img src="/img/2015/11/30/2.PNG" alt=""></p>
</li>
<li><p>如果更想进一步,只有当判断到安装了<code>1Password</code>程序,按钮才出现的话.可以调用<code>view?.onePasswordButton.hidden = !OnePasswordExtension.sharedExtension().isAppExtensionAvailable()</code>.这个方法会判断系统中是否有应用程序能处理<code>org-appextension-feature-password-management</code>这个特性.如果有程序可以执行,那么就返回<code>true</code>. 需要注意的是:在IOS9中你需要给<code>Info.plist</code>文件中增加一行记录:<br> <img src="/img/2015/11/30/3.png" alt=""><br> 更多的信息可以参见<a href="https://developer.apple.com/videos/wwdc/2015/?id=703" target="_blank" rel="external">Privacy and Your Apps session</a></p>
</li>
</ol>
<h2 id="使用1Password进行新用户的注册">使用1Password进行新用户的注册</h2><p>同使用1Password进行用户登陆差不多,新用户的注册也是很简单的.</p>
<ol>
<li>在登录的页面上增加一个按钮,<code>1PasswordExtension</code>内置好了它的图片,你可以直接使用.</li>
<li>给这个按钮增加点击的事件.</li>
<li><p>在Controller类中增加事件的实现,调用<code>public func storeLoginForURLString(URLString: String, loginDetails loginDetailsDictionary: [NSObject : AnyObject]?, passwordGenerationOptions: [NSObject : AnyObject]?, forViewController viewController: UIViewController, sender: AnyObject?, completion: (([NSObject : AnyObject]?, NSError?) -&gt; Void)?)</code>方法</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造1Password新注册用户页面的一些信息</span></span><br><span class="line"><span class="keyword">let</span> newLoginDetails:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="type">AppExtensionTitleKey</span>: <span class="string">"ACME"</span>,</span><br><span class="line">		<span class="type">AppExtensionUsernameKey</span>: <span class="keyword">self</span>.usernameTextField.text!,</span><br><span class="line">		<span class="type">AppExtensionPasswordKey</span>: <span class="keyword">self</span>.passwordTextField.text!,</span><br><span class="line">		<span class="type">AppExtensionNotesKey</span>: <span class="string">"Saved with the ACME app"</span>,</span><br><span class="line">		<span class="type">AppExtensionSectionTitleKey</span>: <span class="string">"ACME Browser"</span>,</span><br><span class="line">		<span class="type">AppExtensionFieldsKey</span>: [</span><br><span class="line">			<span class="string">"firstname"</span> : <span class="keyword">self</span>.firstnameTextField.text!,</span><br><span class="line">			<span class="string">"lastname"</span> : <span class="keyword">self</span>.lastnameTextField.text!</span><br><span class="line">			<span class="comment">// Add as many string fields as you please.</span></span><br><span class="line">		]</span><br><span class="line">	]</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置密码生成规则</span></span><br><span class="line">	<span class="keyword">let</span> passwordGenerationOptions:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="comment">// 密码最小长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMinLengthKey</span>: (<span class="number">8</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 最大密码长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMaxLengthKey</span>: (<span class="number">30</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 是否必须包含数字</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireDigitsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 字符必须包含符号</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireSymbolsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Here are all the symbols available in the the 1Password Password Generator:</span></span><br><span class="line">		<span class="comment">// !@#$%^&amp;*()_-+=|[]&#123;&#125;'\";.,&gt;?/~`</span></span><br><span class="line">		<span class="comment">// The string for AppExtensionGeneratedPasswordForbiddenCharactersKey should contain the symbols and characters that you wish 1Password to exclude from the generated password.</span></span><br><span class="line">		<span class="comment">//生成密码的时候排除的字符</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordForbiddenCharactersKey</span>: <span class="string">"!@#$%/0lIO"</span></span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用1Password,打开它的页面输入用户注册信息</span></span><br><span class="line">	<span class="type">OnePasswordExtension</span>.sharedExtension().storeLoginForURLString(<span class="string">"https://www.acme.com"</span>, loginDetails: newLoginDetails, passwordGenerationOptions: passwordGenerationOptions, forViewController: <span class="keyword">self</span>, sender: sender) &#123; (loginDictionary, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">		<span class="keyword">if</span> loginDictionary == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> error!.code != <span class="type">Int</span>(<span class="type">AppExtensionErrorCodeCancelledByUser</span>) &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"Error invoking 1Password App Extension for find login: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把用户输入的注册信息返回给界面组件</span></span><br><span class="line">		<span class="keyword">self</span>.usernameTextField.text = loginDictionary?[<span class="type">AppExtensionUsernameKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.passwordTextField.text = loginDictionary?[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.firstnameTextField.text = loginDictionary?[<span class="type">AppExtensionReturnedFieldsKey</span>]?[<span class="string">"firstname"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.lastnameTextField.text = loginDictionary?[<span class="type">AppExtensionReturnedFieldsKey</span>]?[<span class="string">"lastname"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p> 效果如图:</p>
<p> <img src="/img/2015/11/30/4.PNG" alt=""><br> <img src="/img/2015/11/30/5.PNG" alt=""></p>
</li>
</ol>
<h2 id="使用1Password进行密码的修改">使用1Password进行密码的修改</h2><p>既然有新用户的注册以及登陆,那么密码管理中还有一个就是密码的修改.</p>
<ol>
<li>在登录的页面上增加一个按钮,<code>1PasswordExtension</code>内置好了它的图片,你可以直接使用.</li>
<li>给这个按钮增加点击的事件.</li>
<li><p>在Controller类中增加事件的实现,调用<code>public func changePasswordForLoginForURLString(URLString: String, loginDetails loginDetailsDictionary: [NSObject : AnyObject]?, passwordGenerationOptions: [NSObject : AnyObject]?, forViewController viewController: UIViewController, sender: AnyObject?, completion: (([NSObject : AnyObject]?, NSError?) -&gt; Void)?)</code></p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造1Password修改密码页面的一些信息</span></span><br><span class="line"><span class="keyword">let</span> newLoginDetails:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="type">AppExtensionTitleKey</span>: <span class="string">"ACME"</span>, <span class="comment">// Optional, used for the third schenario only</span></span><br><span class="line">		<span class="type">AppExtensionUsernameKey</span>: <span class="string">"aUsername"</span>, <span class="comment">// Optional, used for the third schenario only</span></span><br><span class="line">		<span class="type">AppExtensionPasswordKey</span>: changedPassword,</span><br><span class="line">		<span class="type">AppExtensionOldPasswordKey</span>: oldPassword,</span><br><span class="line">		<span class="type">AppExtensionNotesKey</span>: <span class="string">"Saved with the ACME app"</span>, <span class="comment">// Optional, used for the third schenario only</span></span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置密码生成规则</span></span><br><span class="line">	<span class="keyword">let</span> passwordGenerationOptions:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="comment">// 密码最小长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMinLengthKey</span>: (<span class="number">8</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 最大密码长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMaxLengthKey</span>: (<span class="number">30</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 是否必须包含数字</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireDigitsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 字符必须包含符号</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireSymbolsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Here are all the symbols available in the the 1Password Password Generator:</span></span><br><span class="line">		<span class="comment">// !@#$%^&amp;*()_-+=|[]&#123;&#125;'\";.,&gt;?/~`</span></span><br><span class="line">		<span class="comment">// The string for AppExtensionGeneratedPasswordForbiddenCharactersKey should contain the symbols and characters that you wish 1Password to exclude from the generated password.</span></span><br><span class="line">		<span class="comment">//生成密码的时候排除的字符</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordForbiddenCharactersKey</span>: <span class="string">"!@#$%/0lIO"</span></span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用1Password,打开它的页面输入密码修改信息OnePasswordExtension.sharedExtension().changePasswordForLoginForURLString("https://www.acme.com", loginDetails: newLoginDetails, passwordGenerationOptions: passwordGenerationOptions, forViewController: self, sender: sender) &#123; (loginDictionary, error) -&gt; Void in</span></span><br><span class="line">		<span class="keyword">if</span> loginDictionary == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> error!.code != <span class="type">Int</span>(<span class="type">AppExtensionErrorCodeCancelledByUser</span>) &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"Error invoking 1Password App Extension for find login: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//把用户的修改返还给界面</span></span><br><span class="line">		<span class="keyword">self</span>.oldPasswordTextField.text = loginDictionary?[<span class="type">AppExtensionOldPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.freshPasswordTextField.text = loginDictionary?[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.confirmPasswordTextField.text = loginDictionary?[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p> 效果如图:</p>
<p> <img src="/img/2015/11/30/6.PNG" alt=""><br> <img src="/img/2015/11/30/7.PNG" alt=""></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在自己的App中嵌入onePassword密码管理">在自己的App中嵌入onePassword密码管理</h1><p><a href="https://agilebits.com/onepassword/">1Password</a>是一个密码管理软件,它可以方便和安全的管理你的密码.它提供反钓鱼保护功能和卓越的密码管理,并具有自动生成强密码功能.所有的机密资料,包括密码,身份卡和信用卡,都是保存在一个安全的地方.在OSX和IOS系统上非常的流行.在我的博文<a href="/2015/09/21/MacOS下JAVA开发使用经验(一">MacOS下JAVA开发使用经验(一)</a> )也有介绍.<br>自从我的账号被CSDN泄露的干干净净以后的一段时间里,我的其他账号是不是的就会收到更改密码的邮件.于是,一下狠心购买了<code>1Password</code>,并且把我所有的差不多200多个账号的密码通过<code>1Password</code>都给改成了14位的随机字符,以后就不用担心一个密码丢失导致其他的账号也丢失了(1Password自己本身在它的网上没有所谓的用户名密码,密码是通过加密文件整体在WIFI或iCloud中同步的.).但是这就带来了一个麻烦,就是我的密码都变成了类似于这样的<code>RxCa9vdBUB3fCU</code>的字符串.当使用safari这些的时候还好,它有浏览器的插件可以自动填充.遇到一些App,就只能手动的输入了(类似于光大银行和QQ不允许粘贴密码).这相当的麻烦,又容易出错.因此,自己开发APP的时候,就特别的注意了在输入密码的地方要与<code>1Password</code>的整合,这点网易系的APP就做的比较好,<code>网易云音乐</code>和<code>考拉海淘</code>就是支持了<code>1Password</code>的.<br>要在自己的App中引入<code>1Password</code>其实也不麻烦,可以说是相当的简单.<code>1Password</code>在<code>GitHub</code>上开源了App与它的软件交互的扩展<a href="https://github.com/AgileBits/onepassword-app-extension">1PasswordExtension</a>.我们通过这个扩展就可以在自己的App中嵌入<code>1Password</code>的密码管理了.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为自己的APP增加OpenIn功能]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/27/%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84APP%E5%A2%9E%E5%8A%A0OpenIn%E5%8A%9F%E8%83%BD/"/>
    <id>http://sunxiang0918.github.io/2015/11/27/为自己的APP增加OpenIn功能/</id>
    <published>2015-11-27T01:55:25.000Z</published>
    <updated>2015-11-30T09:56:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为自己的APP增加OpenIn功能">为自己的APP增加OpenIn功能</h1><p>在做App的时候,可能会遇到你的程序可以打开某种类型的文档.比如用户在safari中下载了一个torrent类型的文件,然后需要直接使用你写的App打开.那么这个时候就需要在编写App的时候进行文档类型的注册了.</p>
<p><img src="/img/2015/11/27/1.png" alt=""></p>
<a id="more"></a>
<h2 id="1-在Info-plist中注册文档类型">1.在Info.plist中注册文档类型</h2><p>首先要做的就是在Info.plist中增加文档类型的注册,表示这个程序能处理哪些文档.</p>
<p>这里有两种方式,一种是通过项目的Info栏直接增加<code>Document Types</code>和<code>Exported UTIs</code>.<br>就像这样:</p>
<p><img src="/img/2015/11/27/3.png" alt=""></p>
<p>还有一种就是直接修改info.plist文件:</p>
<p><img src="/img/2015/11/27/2.png" alt=""></p>
<p>其xml为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleDocumentTypes<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>LSItemContentTypes<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>cn.sunxiang0918.transmission.torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleTypeRole<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>Viewer<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleTypeName<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>torrent file<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>LSHandlerRank<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>Owner<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTExportedTypeDeclarations<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTTypeConformsTo<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>public.data<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTTypeIdentifier<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>cn.sunxiang0918.transmission.torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTTypeTagSpecification<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">key</span>&gt;</span>public.mime-type<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>application/torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">key</span>&gt;</span>public.filename-extension<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里稍作解释.</p>
<ul>
<li><strong>CFBundleDocumentTypes</strong>:为注册文档类型以及角色</li>
<li><strong>UTExportedTypeDeclarations</strong>:为注册处理类型与方式</li>
<li><strong>LSItemContentTypes</strong>:自己定义的一种文档的唯一串</li>
<li><strong>CFBundleTypeName</strong>:文档的类型名字</li>
<li><strong>UTTypeTagSpecification</strong>:指定文档的类型以及后缀名</li>
</ul>
<p>通过这个的指定,现在程序就能关联到某种文档文件了.</p>
<h2 id="处理文档的打开操作">处理文档的打开操作</h2><p>有了与文档的关联后,还需要进行的操作就是当用户指定APP打开文档后需要执行的操作了.</p>
<p><del>在<code>AppDelegate</code>这个程序的入口类中,有一个方法:<code>func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject) -&gt; Bool</code>.<br>我们只要重载这个方法就可以了.<br>这个方法中最总要的两个入参就是<code>openURL url: NSURL</code>以及<code>sourceApplication: String?</code><br>它说明了是哪一个其他程序传过来的文档,以及文档目前的路径是什么.<br>当有了这个参数后,我们就可以直接读取文档的内容了.</del><code>IOS9废弃</code></p>
<p>在<code>AppDelegate</code>这个程序的入口类中,有一个方法:<code>func application(application: UIApplication, openURL url: NSURL, options: [String : AnyObject]) -&gt; Bool</code>.<br>我们只要重载这个方法就可以了.<br>这个方法中最重要的两个入参就是<code>openURL url: NSURL</code>以及<code>options: [String : AnyObject]</code><br>它说明了是哪一个其他程序传过来的文档,以及文档目前的路径是什么.<br>当有了这个参数后,我们就可以直接读取文档的内容了.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, openURL url: NSURL,options: [String : AnyObject])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> encrypteddata = <span class="type">NSData</span>(contentsOfURL: url)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> base64 = encrypteddata!.base64EncodedStringWithOptions(<span class="type">NSDataBase64EncodingOptions</span>(rawValue: <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//尝试删除文件</span></span><br><span class="line">            try <span class="type">NSFileManager</span>.defaultManager().removeItemAtURL(url)</span><br><span class="line">        &#125; catch <span class="keyword">let</span> e &#123;</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>NSData(contentsOfURL: url)</code>可以读取文档的二进制的内容.<br>文档读取后可以通过<code>NSFileManager.defaultManager().removeItemAtURL(url)</code>删除磁盘上的文档.<br>最后返回一个true,表示是这个程序是能处理这个文档的.</p>
<p>到此,我们的自己的程序就能打开任意的文档并进行相应的处理了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为自己的APP增加OpenIn功能">为自己的APP增加OpenIn功能</h1><p>在做App的时候,可能会遇到你的程序可以打开某种类型的文档.比如用户在safari中下载了一个torrent类型的文件,然后需要直接使用你写的App打开.那么这个时候就需要在编写App的时候进行文档类型的注册了.</p>
<p><img src="/img/2015/11/27/1.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift中使用NSUserDefaults保存自定义对象]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/24/Swift%E4%B8%AD%E4%BD%BF%E7%94%A8NSUserDefaults%E4%BF%9D%E5%AD%98%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sunxiang0918.github.io/2015/11/24/Swift中使用NSUserDefaults保存自定义对象/</id>
    <published>2015-11-24T03:32:07.000Z</published>
    <updated>2015-11-24T04:08:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift中使用NSUserDefaults保存自定义对象">Swift中使用NSUserDefaults保存自定义对象</h1><p>NSUserDefaults适合存储轻量级的本地客户端数据,比如保存一些系统的基本配置等东西,使用NSUserDefaults是首选,它非常的简单,不依赖其他的什么东西,屏蔽了Plist文件的读写等等.</p>
<p>但是NSUserDefaults支持的数据格式比较有限,只支持了<code>Int</code>、<code>Float</code>、<code>Double</code>，<code>String</code>，<code>NSDate</code>，<code>NSArray</code>，<code>NSDictionary</code>，<code>Bool</code>.不支持自定义对象的存取.</p>
<p>这个特性对于简单的数值来说还算比较容易.只需要简单的操作(一个Value 一个Key ),例如，想要保存一个NSString的对象，代码实现为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().setInteger(<span class="number">10</span>, forKey: <span class="string">"aaa"</span>)</span><br><span class="line"><span class="comment">//取</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().integerForKey(<span class="string">"aaaa"</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是涉及到复杂的对象的时候,就需要我们进行特殊的处理了.</p>
<p>其实这个特殊处理也很简单,既然<code>NSUserDefaults</code>支持<code>NSDate</code>类型的数据.那么我们在存取自定义对象的时候,就可以预先把我们的自定义对象转换成为<code>NSData</code>类型的即可.</p>
<p>在Swift中如果要把一个自定义对象能转换成为<code>NSData</code>.需要在自定义对象上实现<code>NSObject</code>和<code>NSCoding</code>协议,并且实现<code>func encodeWithCoder(aCoder: NSCoder)</code>和<code>init?(coder aDecoder: NSCoder)</code>方法,比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Foundation</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SiteInfoVO</span> : <span class="title">NSObject</span>,<span class="title">NSCoding</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> url:<span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> userName:<span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> password:<span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(url:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@objc</span> internal <span class="func"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(aCoder: NSCoder)</span></span> &#123;</span><br><span class="line">        aCoder.encodeObject(url, forKey: <span class="string">"url"</span>)</span><br><span class="line">        aCoder.encodeObject(userName, forKey: <span class="string">"userName"</span>)</span><br><span class="line">        aCoder.encodeObject(password, forKey: <span class="string">"password"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@objc</span> internal required <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        url = aDecoder.decodeObjectForKey(<span class="string">"url"</span>) <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">        </span><br><span class="line">        userName = aDecoder.decodeObjectForKey(<span class="string">"userName"</span>) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        password = aDecoder.decodeObjectForKey(<span class="string">"password"</span>) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用<code>NSKeyedUnarchiver</code>类来进行转换了.</p>
<p>那么保存一个自定义对象到<code>NSUserDefaults</code>就变为了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _value = <span class="type">SiteInfoVO</span>(url:<span class="string">"123"</span>)</span><br><span class="line"><span class="keyword">let</span> modelData:<span class="type">NSData</span> = <span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject(_value)</span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().setObject(modelData, forKey: <span class="string">"defaultName"</span>)</span><br></pre></td></tr></table></figure>
<p>而读取一个自定义对象就成为了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">NSUserDefaults</span>.standardUserDefaults().objectForKey(<span class="string">"defaultName"</span>) <span class="keyword">as</span>? <span class="type">NSData</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> _data = data &#123;</span><br><span class="line">   <span class="keyword">let</span> model = <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(_data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们可以给<code>NSUserDefaults</code>增加一个扩展,把编解码自定义对象进行一次封装:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Foundation</span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">NSUserDefaults</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">modelForKey</span><span class="params">(defaultName: String)</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> obj = <span class="keyword">self</span>.objectForKey(defaultName) <span class="keyword">as</span>? <span class="type">NSData</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> tmp = obj &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">arrayModelForKey</span><span class="params">(defaultName: String)</span></span> -&gt; [<span class="type">AnyObject</span>]? &#123;</span><br><span class="line">        <span class="keyword">let</span> obj = <span class="keyword">self</span>.objectForKey(defaultName) <span class="keyword">as</span>? [<span class="type">NSData</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> result:[<span class="type">AnyObject</span>]?</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> _obj = obj &#123;</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> tmp <span class="keyword">in</span> _obj &#123;</span><br><span class="line">                <span class="keyword">let</span> myModel = <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(tmp)</span><br><span class="line">                result?.append(myModel!)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">setModel</span><span class="params">(value: AnyObject?, forKey defaultName: String)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        guard <span class="keyword">let</span> _value = value <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.setObject(<span class="literal">nil</span>, forKey: defaultName)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> modelData:<span class="type">NSData</span> = <span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject(_value)</span><br><span class="line">        <span class="keyword">self</span>.setObject(modelData, forKey: defaultName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">setArrayModels</span><span class="params">(value: [AnyObject]?, forKey defaultName: String)</span></span> &#123;</span><br><span class="line">        guard <span class="keyword">let</span> _value = value <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.setObject(<span class="literal">nil</span>, forKey: defaultName)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> data:[<span class="type">NSData</span>] = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> _value &#123;</span><br><span class="line">            data.append(<span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject(v))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.setObject(data, forKey: defaultName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:按照这个思路,其实把自定义对象转换成JSON字符串等都是可以的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift中使用NSUserDefaults保存自定义对象">Swift中使用NSUserDefaults保存自定义对象</h1><p>NSUserDefaults适合存储轻量级的本地客户端数据,比如保存一些系统的基本配置等东西,使用NSUserDefaults是首选,它非常的简单,不依赖其他的什么东西,屏蔽了Plist文件的读写等等.</p>
<p>但是NSUserDefaults支持的数据格式比较有限,只支持了<code>Int</code>、<code>Float</code>、<code>Double</code>，<code>String</code>，<code>NSDate</code>，<code>NSArray</code>，<code>NSDictionary</code>，<code>Bool</code>.不支持自定义对象的存取.</p>
<p>这个特性对于简单的数值来说还算比较容易.只需要简单的操作(一个Value 一个Key ),例如，想要保存一个NSString的对象，代码实现为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().setInteger(<span class="number">10</span>, forKey: <span class="string">"aaa"</span>)</span><br><span class="line"><span class="comment">//取</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().integerForKey(<span class="string">"aaaa"</span>)</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker1.9新特性-跨物理机的多容器网络连接]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/09/Docker1-9%E6%96%B0%E7%89%B9%E6%80%A7-%E8%B7%A8%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84%E5%A4%9A%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    <id>http://sunxiang0918.github.io/2015/11/09/Docker1-9新特性-跨物理机的多容器网络连接/</id>
    <published>2015-11-09T13:47:08.000Z</published>
    <updated>2015-12-29T06:00:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Docker1-9新特性-跨物理机的多容器网络连接">Docker1.9新特性-跨物理机的多容器网络连接</h1><p>近日，Docker公司正式发布Docker 1.9版本。他带来了很多新的特性,其中最重要的新特性无疑就是多宿主机互联功能.</p>
<p>在今年6月份的DockerCon上，互联曾经作为测试版本的特性被提出。目前，该特性正式集成在了Docker引擎的稳定版中，并将在产品中使用。其主要功能是为跨宿主机创建Docker引擎中的虚拟网络提供支持。用户可以把其所属的容器挂载到网络中，并控制网络拓扑和通信方式。此外，系统还允许用户在不修改应用的情况下直接与任何网络进行集成。</p>
<p>那么,我们现在就来试一试如何简单的实现多宿主机互联功能.</p>
<h2 id="原理">原理</h2><p>Docker新的网络拓扑是采用的<code>overlay network</code>模式的网络.<br>它需要一个分布式的<code>Key-Value Storage</code>作为辅助的存储.当前Docker支持<code>Consul</code>,<code>Etcd</code>和<code>ZooKeeper</code>.当创建网络之前,你首先是需要安装并运行<code>KVS</code>.然后在启动Docker的时候加上一定的参数,这样Docker就会把网络拓扑信息保存在<code>KVS</code>上,形成全局唯一的网络.</p>
<p><img src="/img/2015/11/09/1.png" alt=""></p>
<a id="more"></a>
<h2 id="安装Docker1-9前的准备">安装Docker1.9前的准备</h2><p>由于Docker1.9多宿主机联网的功能设计为可插拔式，毫无保留兼容<code>VXLAN</code>或者IPVLAN等技术。使用ovs（Open vSwitch）和VXLAN隧道进行实现。因此,需要操作系统支持<code>VXLAN</code>.而在<code>Kernel3.16</code>以下支持这个是有问题的,虽然看得到网络,但是使用这个网络启动容器的时候会报:<code>subnet sandbox join failed for &quot;10.0.0.0/24&quot;: error creating vxlan interface: file exists</code>,这个问题具体可以参见<a href="https://github.com/docker/docker/issues/14145" target="_blank" rel="external">Issues14145</a>.因此我们首先就是需要把操作系统的内核升级.具体的升级方法可以参考我之前的博文<a href="/2015/11/08/升级CentOS7的Linux内核/">升级CentOS7的Linux内核</a>.</p>
<p>然后还需要关闭Selinux. 直接编辑<code>/etc/selinux/config</code>文件中设置<code>SELINUX=disabled</code> ，然后重启服务器。</p>
<p>还需要做的就是关闭防火墙:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br></pre></td></tr></table></figure>
<h2 id="安装Docker1-9">安装Docker1.9</h2><p>接下来就是安装最新的Docker1.9了. 在安装最新版之前,需要把旧的版本删除了.<br>然后在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>
<p>等他执行完成后,最新版就安装完成了.</p>
<h2 id="启动Zookeeper">启动Zookeeper</h2><p>这里我使用<code>Zookeeper</code>来做试验,官网上的是使用<code>Consul</code>做的演示,如果想使用<code>Consul</code>可以看<a href="http://docs.docker.com/engine/userguide/networking/get-started-overlay/" target="_blank" rel="external">这里</a>.</p>
<p>安装<code>Zookeeper</code>集群就不在这里细说了,可以参考之前的博文<a href="/2014/09/20/zookeeper-集群部署/">zookeeper 集群部署</a>.</p>
<p>安装完后启动<code>zookeeper</code>.  这里假设 我的ZK的地址为:<code>10.211.55.2:2181</code></p>
<h2 id="启动Docker服务">启动Docker服务</h2><p>接下来就是需要启动Docker服务了.<br>以前的启动方式是:<code>service docker start</code>.<br>但是这样就不会增加<code>KVS</code>的参数,因此我们需要手动的启动Docker服务:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker daemon --cluster-store=zk://<span class="number">10.211</span>.<span class="number">55.2</span>:<span class="number">2181</span> --cluster-advertise=eth0:<span class="number">2376</span></span><br></pre></td></tr></table></figure>
<p>这里主要有两个参数:</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">—cluster-store=PROVIDER://URL</td>
<td style="text-align:center">这个指的就是KVS的存储位置,比如zookeeper的就是:zk://xxxx,Consul的就是 consul://xxxxx</td>
</tr>
<tr>
<td style="text-align:center">—cluster-advertise=HOST_IP</td>
<td style="text-align:center">这个就是本机Docker服务需要对外公布的集群地址,可以直接写网卡地址</td>
</tr>
</tbody>
</table>
<p>使用上面的参数启动后,Docker会在Zookeeper上建立一个目录.里面存放的就是网络的配置信息.</p>
<p><img src="/img/2015/11/09/2.png" alt=""></p>
<p>直接把所有宿主机上的Docker都像这样的方式启动.</p>
<p>如果你想直接使用<code>service docker start</code>方式启动的话,需要修改<code>/usr/lib/systemd/system/docker.service</code>这个文件.在<code>ExecStart=/usr/bin/docker daemon</code>后面加上<code>--cluster-store=zk://10.211.55.2:2181 --cluster-advertise=eth0:2376</code>.然后执行<code>systemctl daemon-reload</code>,重新加载<code>docker.service</code>即可. 以后就可以在命令行中直接输入<code>service docker start</code>启动带1.9跨网的Docker服务了.注意,一定要先启动Zookeeper哦!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network.target docker.socket</span><br><span class="line">Requires=docker.socket</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/docker daemon --cluster-store=zk://<span class="number">10.211</span>.<span class="number">55.2</span>:<span class="number">2181</span> --cluster-advertise=eth0:<span class="number">2376</span> --insecure-registry <span class="number">172.16</span>.<span class="number">129.222</span>:<span class="number">5000</span> -H fd://</span><br><span class="line">MountFlags=slave</span><br><span class="line">LimitNOFILE=<span class="number">1048576</span></span><br><span class="line">LimitNPROC=<span class="number">1048576</span></span><br><span class="line">LimitCORE=infinity</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<h2 id="创建网络">创建网络</h2><p>Docker1.9新增加了一个命令<code>network</code>,用于配置网络.在Docker1.9中,它把网络也当成了一种类似于容器的东西.可以创建,查询,删除网络.</p>
<p>比如在单机下 可以输入<code>docker network create my-single-net</code>创建一个网络.<br>然后在启动容器的时候使用:<code>docker run -itd --net=my-single-net --name web nginx</code>来使一个容器使用指定的网络来通信. 只要是在<strong>同一个网络</strong>下的容器,他们之间都可以通过<strong>容器的名字</strong>进行互联.而不需要像以前一样,写一堆的<code>-Link</code>了.<br>而对于不同的网络之间也可以使用<code>docker network connect</code>命令来使两个网络之间进行互联.<br>比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create app</span><br><span class="line">docker run -itd --name myapp --net=app myapp</span><br><span class="line">docker network connect app web</span><br></pre></td></tr></table></figure>
<p>这样,就可以在容器中使用<code>myapp.app</code>来访问其他的容器.</p>
<p>铺垫了这么多,现在我们就来创建<code>overlay</code>类型的网络.<br>直接在终端中输入:<code>docker network create --driver overlay my-net</code><br>这个命令就可以创建一个<code>overlay</code>类型的网络,Docker接收到命令后会自动的在ZK上创建相应的节点.<br>那么这个时候,在其他机器上通过输入<code>docker network ls</code>就应该能看到这个网络了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7_with_kernel4 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER</span><br><span class="line"><span class="number">65</span>a73f31fd82        my-net              overlay</span><br><span class="line"><span class="number">8</span>dc2d1533977        docker_gwbridge     bridge</span><br><span class="line"><span class="number">4</span>e4dcdfbe708        none                null</span><br><span class="line"><span class="number">53509</span>e0d8617        host                host</span><br><span class="line">a1dd3a2d90ce        bridge              bridge</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7_with_kernel4_2 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER</span><br><span class="line"><span class="number">65</span>a73f31fd82        my-net              overlay</span><br><span class="line"><span class="number">1</span>fac52653a98        host                host</span><br><span class="line"><span class="number">8</span>dc2d1533977        docker_gwbridge     bridge</span><br><span class="line">cc8810e5a932        bridge              bridge</span><br><span class="line"><span class="number">59</span>ae81d5b75f        none                null</span><br></pre></td></tr></table></figure>
<p>正如上面所显示的.两台不同的宿主机上 现在都有一个ID为<code>65a73f31fd82</code>的<code>overlay</code>类型的网络了.</p>
<p>这个时候如果是调用<code>ifconfig</code>命令来查看宿主机的网络配置,会发现他现在是有<code>docker0</code>,<code>docker_gwbridge</code>,<code>eth0</code>等几个网卡的.其中<code>docker_gwbridge</code>其实就是一个桥接网卡,它就负责了多个宿主机间的通信.</p>
<p><img src="/img/2015/11/09/3.png" alt=""></p>
<h2 id="启动容器">启动容器</h2><p>既然网络已经配置好了,那么接下来要做的就是 启动容器了.这里我们已启动<code>jplock/zookeeper</code>容器为例,在跨宿主机的Docker中创建一个<code>Zookeeper</code>的集群.</p>
<p>一号宿主机(10.211.55.13):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jplock/zookeeper</span><br><span class="line">docker run --name zookeeper1 --privileged=<span class="literal">true</span> -p <span class="number">2181</span>:<span class="number">2181</span> -p <span class="number">2888</span>:<span class="number">2888</span> -p <span class="number">3888</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br><span class="line">docker run --name zookeeper3 --privileged=<span class="literal">true</span> -p <span class="number">2182</span>:<span class="number">2181</span> -p <span class="number">2882</span>:<span class="number">2888</span> -p <span class="number">3882</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br></pre></td></tr></table></figure></p>
<p>二号宿主机(10.211.55.16):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jplock/zookeeper</span><br><span class="line">docker run --name zookeeper2 --privileged=<span class="literal">true</span> -p <span class="number">2181</span>:<span class="number">2181</span> -p <span class="number">2888</span>:<span class="number">2888</span> -p <span class="number">3888</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br><span class="line">docker run --name zookeeper4 --privileged=<span class="literal">true</span> -p <span class="number">2182</span>:<span class="number">2181</span> -p <span class="number">2882</span>:<span class="number">2888</span> -p <span class="number">3882</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br></pre></td></tr></table></figure></p>
<p>这样就在每一个宿主机上启动了两个<code>Zookeeper</code>的容器,并且都使用了相同的<code>my-net</code>网络.</p>
<p>这个时候使用<code>docker exec -ti zookeeper1 /bin/bash</code>进入到容器当中.使用<code>ip address show</code>命令查看容器的IP的话,会显示为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">3</span>cfba8da9b6f:/opt/zookeeper<span class="comment"># ip address show</span></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> qdisc noqueue state UNKNOWN group default</span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127.0</span>.<span class="number">0.1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::<span class="number">1</span>/<span class="number">128</span> scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">6</span>: eth0@<span class="keyword">if</span>7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1450</span> qdisc noqueue state UP group default</span><br><span class="line">    link/ether <span class="number">02</span>:<span class="number">42</span>:<span class="number">0</span>a:<span class="number">00</span>:<span class="number">00</span>:<span class="number">03</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">10.0</span>.<span class="number">0.3</span>/<span class="number">24</span> scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::<span class="number">42</span>:aff:fe00:<span class="number">3</span>/<span class="number">64</span> scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">8</span>: eth1@<span class="keyword">if</span>9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc noqueue state UP group default</span><br><span class="line">    link/ether <span class="number">02</span>:<span class="number">42</span>:ac:<span class="number">12</span>:<span class="number">00</span>:<span class="number">02</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">172.18</span>.<span class="number">0.2</span>/<span class="number">16</span> scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::<span class="number">42</span>:acff:fe12:<span class="number">2</span>/<span class="number">64</span> scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>其中的<code>eth0</code>就是容器全局唯一的一个<code>IP地址</code>.</p>
<p>这个时候再调用<code>cat /etc/hosts</code>来查看容器的<code>hosts</code>配置,会发现:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">3</span>cfba8da9b6f:/opt/zookeeper<span class="comment"># cat /etc/hosts</span></span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.3</span>	<span class="number">3</span>cfba8da9b6f</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>	localhost</span><br><span class="line">::<span class="number">1</span>	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::<span class="number">0</span>	ip6-localnet</span><br><span class="line">ff00::<span class="number">0</span>	ip6-mcastprefix</span><br><span class="line">ff02::<span class="number">1</span>	ip6-allnodes</span><br><span class="line">ff02::<span class="number">2</span>	ip6-allrouters</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.2</span>	zookeeper1</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.2</span>	zookeeper1.my-net</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.4</span>	zookeeper3</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.4</span>	zookeeper3.my-net</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.5</span>	zookeeper4</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.5</span>	zookeeper4.my-net</span><br></pre></td></tr></table></figure>
<p>Docker每启动一个容器,就会在相同网络下的其他容器的Hosts中加入hosts.因此,这个时候其实4个ZooKeeper的网络都是通的了,并且通过<code>容器名</code>.<code>网络名</code>是可以直接访问的.</p>
<p>这个时候在宿主机上使用<code>docker network inspect my-net</code>命令就可以查看<code>my-net</code>网络当前的状况,有什么容器在使用这个网络等等信息.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my-net"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"65a73f31fd820732ebbf665072311c36e2938105a3b42b26597340fc217ff47c"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"global"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"overlay"</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"0d790e0dafd8af213fa81e98c5833539f000dfd5c2c35065e9dbc07d1b40dc7b"</span>: &#123;</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"6434fc9a7a477779e73874d2ec508b4c139d3cb5cd56c7e0ded8d3d5b0bf6457"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:00:00:04"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"10.0.0.4/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"20a8b20914b11c52b6285ebe4414cf492d1bc71001919c62a5a1e7bc5018fa0c"</span>: &#123;</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"14cf4810b09849ae0b197fabd52d155bcaee5debd68a3d982027c5856ba84afe"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:00:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"10.0.0.2/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样,Docker很简单的就实现了多宿主机的网络互通,每一个容器只需要通过全局唯一的<code>容器名</code>就可以访问任意一个在<strong>相同网络</strong>中的容器了.</p>
<p><img src="/img/2015/11/09/4.png" alt=""></p>
<h2 id="注意">注意</h2><p>目前还有一个问题,就是采用这种模式的情况下,其实容器的IP地址还是会改变的.因为它其实是在容器启动的时候,在ZK中去询问一个可用的IP地址,然后创建一个临时节点保存容器名和IP地址的映射. 当容器关闭后,这个IP地址就被释放了出来.下一次再申请可用的IP地址的时候,IP地址可能就变化了.这点需要我们在开发的时候注意,如果程序是依赖于IP地址的话,可能每次重启就会出现问题.尽量的使用Hosts来代替IP地址.</p>
<p>如果确实有固定IP的需求,这个还需要再进一步的研究.</p>
<p><img src="/img/2015/11/09/5.png" alt=""></p>
<hr>
<p>参考文章:<br><a href="http://blog.docker.com/2015/11/docker-multi-host-networking-ga/" target="_blank" rel="external">http://blog.docker.com/2015/11/docker-multi-host-networking-ga/</a><br><a href="https://github.com/docker/libnetwork/issues/" target="_blank" rel="external">https://github.com/docker/libnetwork/issues/</a></p>
<p><a href="http://qiita.com/simota/items/06ad3400224e98d43fc5" target="_blank" rel="external">http://qiita.com/simota/items/06ad3400224e98d43fc5</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Docker1-9新特性-跨物理机的多容器网络连接">Docker1.9新特性-跨物理机的多容器网络连接</h1><p>近日，Docker公司正式发布Docker 1.9版本。他带来了很多新的特性,其中最重要的新特性无疑就是多宿主机互联功能.</p>
<p>在今年6月份的DockerCon上，互联曾经作为测试版本的特性被提出。目前，该特性正式集成在了Docker引擎的稳定版中，并将在产品中使用。其主要功能是为跨宿主机创建Docker引擎中的虚拟网络提供支持。用户可以把其所属的容器挂载到网络中，并控制网络拓扑和通信方式。此外，系统还允许用户在不修改应用的情况下直接与任何网络进行集成。</p>
<p>那么,我们现在就来试一试如何简单的实现多宿主机互联功能.</p>
<h2 id="原理">原理</h2><p>Docker新的网络拓扑是采用的<code>overlay network</code>模式的网络.<br>它需要一个分布式的<code>Key-Value Storage</code>作为辅助的存储.当前Docker支持<code>Consul</code>,<code>Etcd</code>和<code>ZooKeeper</code>.当创建网络之前,你首先是需要安装并运行<code>KVS</code>.然后在启动Docker的时候加上一定的参数,这样Docker就会把网络拓扑信息保存在<code>KVS</code>上,形成全局唯一的网络.</p>
<p><img src="/img/2015/11/09/1.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://sunxiang0918.github.io/tags/Docker/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[升级CentOS7的Linux内核]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/08/%E5%8D%87%E7%BA%A7CentOS7%E7%9A%84Linux%E5%86%85%E6%A0%B8/"/>
    <id>http://sunxiang0918.github.io/2015/11/08/升级CentOS7的Linux内核/</id>
    <published>2015-11-08T07:56:29.000Z</published>
    <updated>2015-12-29T05:59:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="升级CentOS7的Linux内核">升级CentOS7的Linux内核</h1><p>默认刚安装的CentOS7的内核是3.10的.</p>
<p>这个可以在 终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="number">3.10</span>.<span class="number">0</span>-<span class="number">229</span>.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>来确认.</p>
<p>由于我需要试验docker1.9中的新功能.而它的新功能需要<code>vxlan</code>的相关功能.而这个在3.16以上版本才正确.因此,就需要给CentOS7升级内核.</p>
<a id="more"></a>
<h2 id="步骤">步骤</h2><ol>
<li><p>首先在命令行中输入:<code>uname -r</code> 来确定你现在的版本是什么</p>
</li>
<li><p>而后输入:<code>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</code> 导入Key</p>
</li>
<li><p>输入:<code>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</code>来安装elrepo的yum源</p>
</li>
<li><p>在这个源中,保留了内核的最新两个版本.应用名字叫:<code>kernel-ml</code>.因此 我们输入:<code>yum --enablerepo=elrepo-kernel install kernel-ml -y</code>.就可以安装最新的内核了.</p>
</li>
<li><p>而后输入<code>awk -F\&#39; &#39;$1==&quot;menuentry &quot; {print $2}&#39; /etc/grub2.cfg</code> 可以查看启动CentOS的顺序.</p>
</li>
<li><p>如果想自动的进入第一个内核就是最新的话,可以输入:<code>grub2-set-default 0</code></p>
</li>
<li><p>这样,重启的话.系统就会是最新的内核了.</p>
</li>
</ol>
<p>PS: 如果不想安装最新的内核版本.而是想选一个早先的版本的话.可以访问这个地址:<a href="http://dfw.mirror.rackspace.com" target="_blank" rel="external">dfw.mirror.rackspace.com</a>.他里面有很多版本的镜像.找到你想要的版本的rpm.直接下载下来.然后上传到Centos中.然后执行<code>yum localinstall xxxx.rpm -y</code> 就可以本地安装内核了. 剩下的操作和在线的是一样的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="升级CentOS7的Linux内核">升级CentOS7的Linux内核</h1><p>默认刚安装的CentOS7的内核是3.10的.</p>
<p>这个可以在 终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="number">3.10</span>.<span class="number">0</span>-<span class="number">229</span>.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>来确认.</p>
<p>由于我需要试验docker1.9中的新功能.而它的新功能需要<code>vxlan</code>的相关功能.而这个在3.16以上版本才正确.因此,就需要给CentOS7升级内核.</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://sunxiang0918.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive1.2的部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/04/Hive1-2%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/11/04/Hive1-2的部署/</id>
    <published>2015-11-04T14:55:26.000Z</published>
    <updated>2015-11-04T15:14:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Hive1-2的部署">Hive1.2的部署</h1><h2 id="简介">简介</h2><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
<p>听起来HBase与Hive有些类似，概念也有点模糊，那我们先了解下他们之间有什么区别：</p>
<p>HBase是一种分布式、面向列的NoSQL数据库，基于HDFS存储，以表的形式存储数据，表由行和列组成，列划分到列族中。HBase不提供类SQL查询语言，要想像SQL这样查询数据，可以使用Phonix，让SQL查询转换成hbase的扫描和对应的操作，也可以使用现在说讲Hive仓库工具，让HBase作为Hive存储。</p>
<p>Hive是运行在Hadoop之上的数据仓库，将结构化的数据文件映射为一张数据库表，提供简单类SQL查询语言，称为HQL，并将SQL语句转换成MapReduce任务运算。有利于利用SQL语言查询、分析数据，适于处理不频繁变动的数据。Hive底层可以是HBase或者HDFS存储的文件。</p>
<p>两者都是基于Hadoop上不同的技术，相互结合使用，可处理企业中不同类型的业务，利用Hive处理非结构化离线分析统计，利用HBase处理在线查询。</p>
<p>由于HDFS不能存储元数据,因此Hive需要一个辅助的关系数据库来保存它的元数据信息.<br>可以使用它本地的derby数据库,也可以使用本地或远程的MYSQL数据库来存储.通常我们都是存放在MYSQL中的.</p>
<a id="more"></a>
<h2 id="部署">部署</h2><p>由于Hive是运行在Hadoop之上的数据仓库.它的所有数据都是存放在Hadoop兼容的存储上的.因此它本身的集群其实就是启动N多个相同的Hive节点就可以了.也就是说,我们可以完全安装修改一台的Hive.然后直接把整个Hive文件夹拷贝到其他机器上即可.</p>
<ol>
<li>在MYSQL中创建一个独立的database.命名为<code>hive</code></li>
<li>解压<code>apache-hive-1.2.1-bin.tar.gz</code>到/home/hadoop/下 然后改名为<code>hive</code></li>
<li><p>修改环境变量  </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/hadoop/hadoop  </span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/home/hadoop/hive  </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HIVE_HOME</span>/bin  </span><br><span class="line"><span class="built_in">export</span> CLASS_PATH=<span class="variable">$CALSSPATH</span>:<span class="variable">$HIVE_HOME</span>/lib</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>hive/conf</code>下 拷贝 <code>hive_env.sh.template</code> 改名成 <code>hive_env.sh</code></p>
</li>
<li><p>修改这个文件里面的HADOOP_HOME和HIVE_CONF_DIR</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Set HADOOP_HOME to point to a specific hadoop install directory</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/hadoop/hadoop-<span class="number">2.6</span>.<span class="number">0</span></span><br><span class="line">	<span class="comment">#Hive Configuration Directory can be controlled by:</span></span><br><span class="line"><span class="built_in">export</span> HIVE_CONF_DIR=/home/hadoop/apache-hive-<span class="number">1.2</span>.<span class="number">0</span>-bin/conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>在hive/conf下 拷贝 hive-default.xml.template 改名成 hive-site.xml</p>
</li>
<li><p>修改里面的所有内容为:(因为会先自动的加载hive-default.xml里面的所有内容,所以hive-site里面的内容就是自定义的配置)</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>jdbc:mysql://10.211.55.2:3306/hive<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>驱动名<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>root<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>用户名<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>admin<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>密码<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/hive/warehouse<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>数据路径（相对hdfs）<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>放入mysql的驱动到 hive/lib中 比如: <code>mysql-connector-java-5.1.31-bin.jar</code></p>
</li>
<li>找到一个叫<code>jline-2.12.jar</code>的文件，复制他，去hadoop主目录将<code>hadoop/yarn/lib</code>下的<code>jline0.9.94.jar</code>替换成刚刚复制的,否则会出现包冲突.</li>
<li>切换到hive/bin,输入 <code>bin/hive --service metastore</code><br>当显示<code>Starting Hive Metastore Server</code>就表示启动成功了.</li>
</ol>
<h2 id="验证">验证</h2><p>启动以后,在终端中输入<code>JPS</code>.可以 看到一个 <code>RunJar</code>的服务,这就表示启动成功了.</p>
<p>然后再输入<code>./hive</code>可以进入hive的命令行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HMaster0 ~]<span class="comment"># hive</span></span><br><span class="line">Logging initialized usingconfiguration <span class="keyword">in</span> file:/opt/apache-hive-<span class="number">1.2</span>.<span class="number">0</span>-bin/conf/hive-log4j.properties</span><br><span class="line">hive&gt; show databases;</span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">Time taken: <span class="number">0.986</span> seconds,Fetched: <span class="number">1</span> row(s)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建一个测试库</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create database <span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个hive_test的表,并指定字段分隔符为tab建</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table hive_<span class="built_in">test</span>(id int,name string) row format delimited fields terminated by <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从本地文件中导入数据到Hive表中</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; load data <span class="built_in">local</span> inpath <span class="string">'/home/hadoop/hive/examples/files/kv1.txt'</span> overwrite into table hive_<span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行最简单的查询</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * from hive_<span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到此,Hive的最简单的安装就结束了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hive1-2的部署">Hive1.2的部署</h1><h2 id="简介">简介</h2><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
<p>听起来HBase与Hive有些类似，概念也有点模糊，那我们先了解下他们之间有什么区别：</p>
<p>HBase是一种分布式、面向列的NoSQL数据库，基于HDFS存储，以表的形式存储数据，表由行和列组成，列划分到列族中。HBase不提供类SQL查询语言，要想像SQL这样查询数据，可以使用Phonix，让SQL查询转换成hbase的扫描和对应的操作，也可以使用现在说讲Hive仓库工具，让HBase作为Hive存储。</p>
<p>Hive是运行在Hadoop之上的数据仓库，将结构化的数据文件映射为一张数据库表，提供简单类SQL查询语言，称为HQL，并将SQL语句转换成MapReduce任务运算。有利于利用SQL语言查询、分析数据，适于处理不频繁变动的数据。Hive底层可以是HBase或者HDFS存储的文件。</p>
<p>两者都是基于Hadoop上不同的技术，相互结合使用，可处理企业中不同类型的业务，利用Hive处理非结构化离线分析统计，利用HBase处理在线查询。</p>
<p>由于HDFS不能存储元数据,因此Hive需要一个辅助的关系数据库来保存它的元数据信息.<br>可以使用它本地的derby数据库,也可以使用本地或远程的MYSQL数据库来存储.通常我们都是存放在MYSQL中的.</p>]]>
    
    </summary>
    
      <category term="Hive" scheme="http://sunxiang0918.github.io/tags/Hive/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hbase分布式部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/03/Hbase%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/11/03/Hbase分布式部署/</id>
    <published>2015-11-03T15:12:39.000Z</published>
    <updated>2015-11-03T15:30:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Hbase分布式部署">Hbase分布式部署</h1><p>HBase的安装首先是有两个先决条件的,第一个就是需要zookeeper的支持,另外一个就是需要HDFS的支持了.<br>因此,安装Hbase的头两部就是安装<code>zookeeper</code>和<code>hadoop</code></p>
<p>这两个东西的安装可以参考我以前的博文:<a href="http://sunxiang0918.cn/2015/11/03/Hadoop全分布式部署/" target="_blank" rel="external">Hadoop全分布式部署</a>以及<a href="http://sunxiang0918.cn/2014/09/20/zookeeper-集群部署/" target="_blank" rel="external">zookeeper 集群部署</a>.这里就不再复述了.</p>
<h2 id="环境">环境</h2><p>环境: centos7 + hadoop2.6.2 + hbase1.1.2</p>
<p>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h2 id="安装步骤">安装步骤</h2><ol>
<li>首先还是需要把<code>hbase-1.1.2-bin.tar.gz</code>拷贝到几台机器上.然后使用<code>tar -xvf</code>命令解压,并重命名为hbase.  当前路径也就是 <code>/home/hadoop/hbase</code></li>
</ol>
<a id="more"></a>
<ol>
<li><p>配置<code>conf/hbase-site.xml</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="pi">&lt;?xml version="1.0"?&gt;</span>  </span><br><span class="line">	<span class="pi">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://master:9000/hbase<span class="tag">&lt;/<span class="title">value</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>区域服务器使用存储HBase数据库数据的目录,服务器名称不能填IP，不然会报错<span class="tag">&lt;/<span class="title">description</span>&gt;</span>          </span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>              </span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span>                </span><br><span class="line">     <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="title">name</span>&gt;</span>                 </span><br><span class="line">     <span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span>                     </span><br><span class="line">     <span class="tag">&lt;<span class="title">description</span>&gt;</span>指定HBase运行的模式： false: 单机模式或者为分布式模式   true: 全分布模式 <span class="tag">&lt;/<span class="title">description</span>&gt;</span>             </span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>                                                   </span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span>                                                     </span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="title">name</span>&gt;</span>                                                       </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span> master,slave01, slave02 <span class="tag">&lt;/<span class="title">value</span>&gt;</span>                                                           </span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>ZooKeeper集群服务器的位置<span class="tag">&lt;/<span class="title">description</span>&gt;</span>                                                                 </span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>                                                                  </span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 完整的配置可以看<a href="http://hbase.apache.org/book.html#config.files" target="_blank" rel="external">此处</a></p>
</li>
<li><p>配置数据服务器的地址<br> 也就是修改<code>/conf/regionservers</code>,把三台机器的host都写进去</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">slave01</span><br><span class="line">slave02</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置HBase的JDK<br> 修改<code>/conf/hbase-env.sh</code>文件.<br> 打开注释 <code>export JAVA_HOME=xxxxxxx</code> 这里指向JDK的目录,要求是JDK1.7+</p>
</li>
<li><p>配置ZK的使用方式.默认情况下是使用的hbase内置的ZK,这个在集群下是不行的.因此我们需要给他改成使用外部的集群的ZK.<br> 修改<code>/conf/hbase-env.sh</code>文件最后面.<br> 打开注释 <code>export HBASE_MANAGES_ZK=false</code> 这里的false指的就是使用外部的Zookeeper</p>
</li>
<li><p>所有其他的机器都这样配置</p>
</li>
<li><p>在主节点上 启动,验证<br> 配置好上面的这些东西后,就可以在主节点上启动hbase了.<br> 直接在<code>bin</code>中 输入 <code>./start-hbase.sh</code> 即可启动.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	starting master, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-master-master.out</span><br><span class="line">slave01: starting regionserver, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-regionserver-slave01.out</span><br><span class="line">slave02: starting regionserver, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-regionserver-slave02.out</span><br><span class="line">master: starting regionserver, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-regionserver-master.out</span><br></pre></td></tr></table></figure>
<p> 出现上面的东西 就说明是启动完成了.<br> 这个时候使用<code>jps</code>命令 应该可以看到有一个 <code>HMaster</code> 和 <code>HRegionServer</code> 服务.<br> 而在其他的从节点上 应该看得到<code>HRegionServer</code>服务.</p>
<p> 这个时候随便在某一台机器上输入 <code>./hbase shell</code> 进入hbase的终端,并输入<code>status</code>的话,应该可以看到集群的状态:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	[hadoop@master bin]$ ./hbase shell</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">03</span> <span class="number">23</span>:<span class="number">02</span>:<span class="number">05</span>,<span class="number">690</span> WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library <span class="keyword">for</span> your platform... using <span class="built_in">builtin</span>-java classes <span class="built_in">where</span> applicable</span><br><span class="line">HBase Shell; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list of supported commands.</span><br><span class="line">Type <span class="string">"exit&lt;RETURN&gt;"</span> to leave the HBase Shell</span><br><span class="line">Version <span class="number">1.1</span>.<span class="number">2</span>, rcc2b70cf03e3378800661ec5cab11eb43fafe0<span class="built_in">fc</span>, Wed Aug <span class="number">26</span> <span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> PDT <span class="number">2015</span></span><br><span class="line">hbase(main):<span class="number">001</span>:<span class="number">0</span>&gt; status</span><br><span class="line"><span class="number">3</span> servers, <span class="number">0</span> dead, <span class="number">0.6667</span> average load</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code><span class="label">同时也可以通过在浏览器中输入: `http://master:</span><span class="number">16010</span><span class="escape">` </span>打开<span class="escape">`H</span>Base<span class="escape">`的</span>管理页面.也是可以的
</code></pre><p>到此,最简单的HBASE集群就搭建成功了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hbase分布式部署">Hbase分布式部署</h1><p>HBase的安装首先是有两个先决条件的,第一个就是需要zookeeper的支持,另外一个就是需要HDFS的支持了.<br>因此,安装Hbase的头两部就是安装<code>zookeeper</code>和<code>hadoop</code></p>
<p>这两个东西的安装可以参考我以前的博文:<a href="http://sunxiang0918.cn/2015/11/03/Hadoop全分布式部署/">Hadoop全分布式部署</a>以及<a href="http://sunxiang0918.cn/2014/09/20/zookeeper-集群部署/">zookeeper 集群部署</a>.这里就不再复述了.</p>
<h2 id="环境">环境</h2><p>环境: centos7 + hadoop2.6.2 + hbase1.1.2</p>
<p>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h2 id="安装步骤">安装步骤</h2><ol>
<li>首先还是需要把<code>hbase-1.1.2-bin.tar.gz</code>拷贝到几台机器上.然后使用<code>tar -xvf</code>命令解压,并重命名为hbase.  当前路径也就是 <code>/home/hadoop/hbase</code></li>
</ol>]]>
    
    </summary>
    
      <category term="Hbase" scheme="http://sunxiang0918.github.io/tags/Hbase/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop全分布式部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/03/Hadoop%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/11/03/Hadoop全分布式部署/</id>
    <published>2015-11-03T09:23:25.000Z</published>
    <updated>2015-11-03T11:59:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Hadoop全分布式部署步骤">Hadoop全分布式部署步骤</h1><h2 id="环境">环境</h2><p>环境: centos7 +hadoop2.6.2<br>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h1 id="安装步骤:">安装步骤:</h1><h2 id="安装虚拟机,_保证机器能上网">安装虚拟机, 保证机器能上网</h2><ol>
<li>修改hosts文件,把机器都加上</li>
<li>修改机器的hostname文件: <code>sudo nano /etc/hostname</code>,需要注意的是这个文件是必须要改的,否则默认安装出来的centos都叫localhost. 这个在组建集群后,是会有问题的.</li>
</ol>
<h2 id="在机器上安装JDK-">在机器上安装JDK.</h2><ol>
<li>如果已经安装了openJDK,不想要的话,可以先删除:<ol>
<li><code>rpm -qa | grep java</code>  查看有哪些java相关的包</li>
<li><code>yum -y remove java</code>  删除openJDK</li>
<li><code>rpm -e —nodeps xxxxxxx</code>  再手动删除一些第一部显示的还与openJDK相关的包</li>
</ol>
</li>
<li><p>下载oracle的 jdk. 解压到一个目录</p>
<ol>
<li><p>然后修改/etc/profile. 在最后面增加:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.<span class="number">7.0</span>_51`</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行 <code>source /etc/profile</code> 刷新新的环境变量</p>
</li>
</ol>
</li>
</ol>
<a id="more"></a>
<h2 id="在虚拟机系统中增加hadoop用户">在虚拟机系统中增加hadoop用户</h2><ol>
<li><code>user add hadoop</code></li>
<li><code>passwd hadoop</code>  </li>
<li>为了方便,把hadoop用户加入 root用户组<br>用root登陆,然后输入:  <code>usermod -g  root hadoop</code><br>然后使用 <code>id hadoop</code> 验证一下.如果是:<code>uid=502(hadoop) gid=0(root) 组=0(root)</code>  就是对的</li>
</ol>
<h2 id="配置ssh免密码登陆">配置ssh免密码登陆</h2><p>hadoop工作的时候,各节点需要相互通讯,正常情况下需要输入用户名密码,这个需要人工参与.不方便. 为了让节点能自动通过安全认证,需要配置ssh免密码登陆</p>
<ol>
<li>先在master上，生成公钥、私钥对<br>以hadoop身份登录到系统<br><code>cd</code> (进入个人主目录，默认为/home/hadoop)<br><code>ssh-keygen -t rsa -P &#39;&#39;</code> (注：最后是二个单引号)   即：以rsa算法，生成公钥、私钥对，-P ‘’表示空密码。该命令运行完后，会在个人主目录下生成.ssh目录，里面会有二个文件id_rsa（私钥） ,id_rsa.pub(公钥)  </li>
<li>导入公钥      <code>cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys</code><br>执行完以后，可以在本机上测试下，用ssh连接自己，即：<code>ssh localhost</code> (或ssh master)，如果不幸还是提示要输入密码，说明还没起作用，还有一个关键的操作 <code>chmod 600 .ssh/authorized_keys</code> (修改文件权限，否则不起作用)<br>然后再测试下 ssh localhost ，如果不需要输入密码，就连接成功，表示ok，一台机器已经搞定了。</li>
<li>在其它机器上生成公钥、密钥，并将公钥文件复制到master<ol>
<li>以hadoop身份登录其它二台机器 slave01、slave02，执行 <code>ssh-keygen -t rsa -P &#39;&#39;</code> 生成公钥、密钥</li>
<li>然后用scp命令，把公钥文件发放给master（即：刚才已经搞定的那台机器）<br>slave01上：   <code>scp .ssh/id_rsa.pub hadoop@master:/home/hadoop/id_rsa_01.pub</code><br>slave02上：   <code>scp .ssh/id_rsa.pub hadoop@master:/home/hadoop/id_rsa_02.pub</code><br>这二行执行完后，回到master中，查看下/home/hadoop目录，应该有二个新文件id_rsa_01.pub、id_rsa_02.pub，<br>然后在master上，导入这二个公钥<br><code>cat id_rsa_01.pub &gt;&gt; .ssh/authorized_keys</code><br><code>cat id_rsa_02.pub &gt;&gt; .ssh/authorized_keys</code><br>这样，master这台机器上，就有所有3台机器的公钥了。</li>
</ol>
</li>
<li>将master上的“最全”公钥，复制到其它机器<ol>
<li>继续保持在master上，<br> <code>scp .ssh/authorized_keys hadoop@slave01:/home/hadoop/.ssh/authorized_keys</code><br> <code>scp .ssh/authorized_keys hadoop@slave02:/home/hadoop/.ssh/authorized_keys</code></li>
<li>修改其它机器上authorized_keys文件的权限<br>slave01以及slave02机器上，均执行命令    <code>chmod 600 .ssh/authorized_keys</code></li>
</ol>
</li>
<li>验证<br>在每个虚拟机上，均用 ssh 其它机器的hostname 验证下，如果能正常无密码连接成功，表示ok</li>
</ol>
<h2 id="上传并解压hadoop2-6-2">上传并解压hadoop2.6.2</h2><p>上传hadoop到 <code>/home/hadoop</code><br>执行 <code>tar -xvf hadoop-2.6.2.tar.gz</code><br>然后改名字为 hadoop   <code>mv hadoop2.6.2/ hadoop</code></p>
<h2 id="修改配置">修改配置</h2><p>一共7个文件需要修改:<br>$HADOOP_HOME/etc/hadoop/hadoop-env.sh</p>
<p>$HADOOP_HOME/etc/hadoop/yarn-env.sh</p>
<p>$HADOOP_HOME/etc/hadoop/core-site.xml</p>
<p>$HADOOP_HOME/etc/hadoop/hdfs-site.xml</p>
<p>$HADOOP_HOME/etc/hadoop/mapred-site.xml</p>
<p>$HADOOP_HOME/etc/hadoop/yarn-site.xml</p>
<p>$HADOOP_HOME/etc/hadoop/slaves</p>
<h3 id="hadoop-env-sh_、yarn-env-sh">hadoop-env.sh 、yarn-env.sh</h3><p>这二个文件主要是修改JAVA_HOME后的目录，改成实际本机jdk所在目录位置<br>nano etc/hadoop/hadoop-env.sh<br>找到下面这行的位置，改成（jdk目录位置，大家根据实际情况修改）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/hadoop/jdk</span><br></pre></td></tr></table></figure>
<p>在 hadoop-env.sh中 , 加上这句:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_PREFIX=/home/hadoop/hadoop</span><br></pre></td></tr></table></figure>
<h3 id="core-site-xml">core-site.xml</h3><p>修改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="pi">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>core-site.xml的完整参数请参考<br><a href="http://hadoop.apache.org/docs/r2.6.2/hadoop-project-dist/hadoop-common/core-default.xml" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.6.2/hadoop-project-dist/hadoop-common/core-default.xml</a></p>
<h3 id="hdfs-site-xml">hdfs-site.xml</h3><p>修改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="pi">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.datanode.ipc.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>0.0.0.0:50020<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.datanode.http.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>0.0.0.0:50075<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>2<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dfs.replication表示数据副本数，一般不大于datanode的节点数。<br>hdfs-site.xml的完整参数请参考<br><a href="http://hadoop.apache.org/docs/r2.6.2/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.6.2/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml</a></p>
<h3 id="mapred-site-xml">mapred-site.xml</h3><p>修改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="pi">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mapred-site.xml的完整参数请参考<br><a href="http://hadoop.apache.org/docs/r2.6.2/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.6.2/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml</a></p>
<h3 id="yarn-site-xml">yarn-site.xml</h3><p>修改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>yarn-site.xml的完整参数请参考<br><a href="http://hadoop.apache.org/docs/r2.6.2/hadoop-yarn/hadoop-yarn-common/yarn-default.xml" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.6.2/hadoop-yarn/hadoop-yarn-common/yarn-default.xml</a></p>
<h3 id="slaves文件修改">slaves文件修改</h3><p>slaves文件暂时不管（可以先用mv slaves slaves.bak 将它改名）</p>
<h3 id="启动master节点">启动master节点</h3><ol>
<li>第一次启动先初始化namenod:<br><code>$HADOOP_HOME/bin/hdfs namenode –format</code><br>当等到:出现 <code>INFO common.Storage: Storage directory /home/hadoop/tmp/dfs/name has been successfully formatted.</code> 就表示格式化成功.</li>
<li>启动dfs:<br>执行<code>$HADOOP_HOME/sbin/start-dfs.sh</code><br>启动完成后,输入 <code>jps</code>查看进程.如果看到有<code>SecondaryNameNode</code>和<code>NameNode</code> 就表示master节点OK了.</li>
<li>启动yarn:<br>执行<code>$HADOOP_HOME/sbin/start-yarn.sh</code><br>启动完成后,输入<code>jps</code>查看进程.如果看到有<code>ResourceManager</code> 就表示OK了</li>
</ol>
<h3 id="修改slaves节点">修改slaves节点</h3><ol>
<li>恢复刚才备份的slaves文件. </li>
<li>修改这个文件,加入其他slaves节点的ip或host</li>
<li>运行<code>HADOOP_HOME/sbin/stop-dfs.sh</code>和<code>HADOOP_HOME/sbin/stop-yarn.sh</code> 停止服务</li>
<li>拷贝master上的hadoop目录到slave01和slave02上:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r hadoop hadoop@slave01:/home/hadoop/</span><br><span class="line">scp -r hadoop hadoop@slave02:/home/hadoop/</span><br></pre></td></tr></table></figure>
<h3 id="启动整个集群-">启动整个集群.</h3><p>在master节点上,启动:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP_HOME</span>/sbin/start-dfs.sh</span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>如果正常的话, 会有<code>SecondaryNameNode</code>,<code>NameNode</code>,<code>ResourceManager</code> 三个进程.<br>而slave01的机器上会有<code>DataNode</code>,<code>NodeManager</code> 两个节点.</p>
<p>这个时候 主节点的 50070和 8088 也可以用浏览器访问了: <code>http://master:50070/</code>   <code>http://master:8088/</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hadoop全分布式部署步骤">Hadoop全分布式部署步骤</h1><h2 id="环境">环境</h2><p>环境: centos7 +hadoop2.6.2<br>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h1 id="安装步骤:">安装步骤:</h1><h2 id="安装虚拟机,_保证机器能上网">安装虚拟机, 保证机器能上网</h2><ol>
<li>修改hosts文件,把机器都加上</li>
<li>修改机器的hostname文件: <code>sudo nano /etc/hostname</code>,需要注意的是这个文件是必须要改的,否则默认安装出来的centos都叫localhost. 这个在组建集群后,是会有问题的.</li>
</ol>
<h2 id="在机器上安装JDK-">在机器上安装JDK.</h2><ol>
<li>如果已经安装了openJDK,不想要的话,可以先删除:<ol>
<li><code>rpm -qa | grep java</code>  查看有哪些java相关的包</li>
<li><code>yum -y remove java</code>  删除openJDK</li>
<li><code>rpm -e —nodeps xxxxxxx</code>  再手动删除一些第一部显示的还与openJDK相关的包</li>
</ol>
</li>
<li><p>下载oracle的 jdk. 解压到一个目录</p>
<ol>
<li><p>然后修改/etc/profile. 在最后面增加:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.<span class="number">7.0</span>_51`</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行 <code>source /etc/profile</code> 刷新新的环境变量</p>
</li>
</ol>
</li>
</ol>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://sunxiang0918.github.io/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转> 为 Key-Value 数据库实现MVCC 事务]]></title>
    <link href="http://sunxiang0918.github.io/2015/10/23/%E4%B8%BA-Key-Value-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0MVCC-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://sunxiang0918.github.io/2015/10/23/为-Key-Value-数据库实现MVCC-事务/</id>
    <published>2015-10-23T03:12:50.000Z</published>
    <updated>2015-10-23T03:21:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为_Key-Value_数据库实现MVCC_事务">为 Key-Value 数据库实现MVCC 事务</h1><p>ACID 是软件领域使用最广泛的技术之一，它是关系数据库的基石，是企业级中间件不可或缺的部分，但通常通过黑盒的方式提供。但是在许多情况下，这种古老的事务方式已经不能够适应现代大规模系统和NoSQL数据库的需要了，现代系统要求更高的性能要求，更大的数据量，更高的可用性。在这种情况下，传统的事务模型被定制的事务或者半事务模型所取代，而在这些模型中事务性并不像以往那样被看重。</p>
<p>在本文中我们会讨论一下key-value数据库的无锁事务操作，这种技术可以广泛应用于任何一种数据库系统。在GridDynamics中，我们就用这种技术在Oracle Coherence上实现了一个轻量级的非标准的事务机制。在第一部分我们会通过几个重要的用例来了解两种简单的方法，在第二部分我们会研究更多更通用的方法，比如说PostgreSQL的MVCC实现。</p>
<h2 id="原子性缓存切换，读提交隔离">原子性缓存切换，读提交隔离</h2><p>让我们从一个简单易于实现的方法开始，这个方法适用于读远多于写的系统。比如说电子商务系统中每天要进行的数据更新，一些管理性操作例如无效货品的修复以及缓存更新。</p>
<p>最简单的例子是把所有数据都加载进缓存里，然后通过一个代理接口来执行诸如 get() 和 put() 这样的操作。这个接口会与两个缓存打交道，A和B，按照以下逻辑运行（图 1）：</p>
<ul>
<li>任何时候只能有一个缓存处于可用状态，代理接口会把所有的请求路由给它（图1.1）。</li>
<li>更新数据的时候把新数据加载到目前不可用的缓存中（图1.2）。</li>
<li>更新进程切换标志哪个缓存可用的标记（图1.3），代理接口开始把新的读请求分发到新标记为可用的缓存。</li>
<li>缓存切换阶段的事务可以依据不用的持久性和隔离性要求来分别处理。如果允许“不可重复读” ，那么切换很简单，老数据会被立刻清理掉。否则，代理接口会维护一个仍未结束的事务列表，并把属于这个列表中的每一个请求都路由到原来的缓存中。只有当列表中的所有事物都提交或者放弃之后老数据才会被清空。<a id="more"></a>
</li>
</ul>
<p><img src="/img/2015/10/23/1.png" alt=""><br>Fig.1 Cache Switch</p>
<p>相同的技术也可用于部分更新。依据存储方式的不同也有多种实现方法，我们来看一个有三个缓存简单例子。这个例子中的框架遇上一个类似，但是代理接口按照以下逻辑运行（图 2）：</p>
<ul>
<li>用户请求被路由到主缓存（”PRIMARY”缓存）（图 2.1）</li>
<li>新增数据和更新数据加载进2号缓存（“NEW”缓存），删除项的key放入3号缓存（”DELETE”缓存）（图2.2）</li>
<li>提交进程（特指写事务）切换全局标示，这个标示会告诉代理接口先去”NEW”和”DELETE”缓存去查找所请求的数据，如果在这两个区域中没有发现再去”PRIMARY”缓存查找（图2.3）。换句话说，在这一步所有的请求都被改派到了更新过的数据中查找。</li>
<li>提交进程将 NEW 和 DELETE 区域的变化传递给PRIMARY。也即在PRIMARY缓存区以非原子的方式更新、增加、删除数据项（图2.4）。</li>
<li>最后，所有的提交进程把全局标识切换回来，所有的请求仍然路由到 PRIMARY 缓存区域（图2.5）。</li>
<li>在第4步，可以把老数据拷贝到另一个缓存区，这样就可以支持回滚操作。即使是全量更新也可以用这种方法。</li>
</ul>
<p><img src="/img/2015/10/23/2.png" alt=""><br>Fig.2 Partial Cache Switch</p>
<p>从上面的两个例子我们可以看出，专用于读的数据快照避免了数据更新的干扰，大大降低了复杂性。在一个写密集型的环境中就不容易做到这一点了。在下一节我们会讨论一种非常好的方法可以完美的解决这个问题。</p>
<p>MVCC 事务，可重复读隔离</p>
<p>事物间的隔离可以通过给数据项加上版本号来实现。有许多方法能做到这一点，下面我们会介绍一种与PostgreSQL  的事务处理方法非常相似的办法。</p>
<p>正如前面所说，每个事务可以对应于一个部分数据快照。在同一时间，每一个数据项都有他自己的生命周期 - 从加入缓存到移出缓存或者被更新（被新版本所取代）。所以可以通过给每条数据打两个时间戳来实现隔离，每个事物通过开始时间（两个时间戳之一，译者注）来找出在事务开始时处于可见状态的数据。但在实践中常用一个单调递增的计数来代替时间戳：</p>
<ul>
<li>当新事务开始的时候：<ul>
<li>它会获得一个全局唯一且单调递增的事务ID ，也叫 XID。</li>
<li>进程里保存着所有事务的XID.</li>
</ul>
</li>
<li>缓存里的每个数据项有两个额外标记，xmin 和 xmax。按照以下规则赋值：<ul>
<li>当数据项被某个事务建立的时候， xmin 设置为该事务的XID ，xmax 无值。</li>
<li>当数据被某个事务移除的时候，xmin 不变，xmax 设置为该事务的XID。数据并没有真的从缓存中清除，只是被标记为已删除。</li>
<li>当数据被某个事务更新的时候，老数据仍然保存在缓存里，xmax 被赋值为事务的XID，同时增加一条新的数据，新数据的 xmin 也赋值为XID 并且xmax 为空。换句话说更新操作等于一次删除加一次增加。</li>
</ul>
</li>
<li>如果以下两个条件成立，那么数据对于某次事务是可见的：<ul>
<li>xmin 有值并且小于或等于当前事务ID。</li>
<li>xmax 为空，或者等于未提交事务（放弃的或者还未完成的）的XID ，或者大于当前事务ID。</li>
</ul>
</li>
<li>xmin 和 xmax 可以存储两个位标记，表明事务是否放弃或者提交，这样才能进行上面的检查（xmax 是否等于未提交事务的ID）。<br>逻辑如下图所示：</li>
</ul>
<p><img src="/img/2015/10/23/3.png" alt=""><br>Fig.3 PostgeSQL-like MVCC</p>
<p>这种方法的缺点是废弃数据的移除有些繁琐。因为不同事务看到的数据版本不同，决定何时将数据标为不可见或者移除是比较复杂的。不过也有两种以上的方法能够做到，第一种是PostgreSQL中使用的，第二种是Oracle使用的：</p>
<ul>
<li>所有的版本都存储在同一个key-value空间中，对版本数量没有限制（也即可以储存任意多的版本，译者注）。由一个后台进程来回收老版本数据，这个回收可以按计划调度执行也可以再读或者写的时候触发。</li>
<li>主key-value 空间只储存最新的版本，之前的版本储存在另外的地方，且储存老版本的空间大小是固定的。 最新的版本会指向之前的版本，但是却不能够由此上溯到之前的任意版本， 因为存储老版本数据的区域大小是固定的， 太早的版本会被移除。如果某个事务不能够找到指定版本的数据就会失败。 </li>
</ul>
<hr>
<p><strong>原文链接:</strong><a href="http://my.oschina.net/juliashine/blog/111624" target="_blank" rel="external">http://my.oschina.net/juliashine/blog/111624</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为_Key-Value_数据库实现MVCC_事务">为 Key-Value 数据库实现MVCC 事务</h1><p>ACID 是软件领域使用最广泛的技术之一，它是关系数据库的基石，是企业级中间件不可或缺的部分，但通常通过黑盒的方式提供。但是在许多情况下，这种古老的事务方式已经不能够适应现代大规模系统和NoSQL数据库的需要了，现代系统要求更高的性能要求，更大的数据量，更高的可用性。在这种情况下，传统的事务模型被定制的事务或者半事务模型所取代，而在这些模型中事务性并不像以往那样被看重。</p>
<p>在本文中我们会讨论一下key-value数据库的无锁事务操作，这种技术可以广泛应用于任何一种数据库系统。在GridDynamics中，我们就用这种技术在Oracle Coherence上实现了一个轻量级的非标准的事务机制。在第一部分我们会通过几个重要的用例来了解两种简单的方法，在第二部分我们会研究更多更通用的方法，比如说PostgreSQL的MVCC实现。</p>
<h2 id="原子性缓存切换，读提交隔离">原子性缓存切换，读提交隔离</h2><p>让我们从一个简单易于实现的方法开始，这个方法适用于读远多于写的系统。比如说电子商务系统中每天要进行的数据更新，一些管理性操作例如无效货品的修复以及缓存更新。</p>
<p>最简单的例子是把所有数据都加载进缓存里，然后通过一个代理接口来执行诸如 get() 和 put() 这样的操作。这个接口会与两个缓存打交道，A和B，按照以下逻辑运行（图 1）：</p>
<ul>
<li>任何时候只能有一个缓存处于可用状态，代理接口会把所有的请求路由给它（图1.1）。</li>
<li>更新数据的时候把新数据加载到目前不可用的缓存中（图1.2）。</li>
<li>更新进程切换标志哪个缓存可用的标记（图1.3），代理接口开始把新的读请求分发到新标记为可用的缓存。</li>
<li>缓存切换阶段的事务可以依据不用的持久性和隔离性要求来分别处理。如果允许“不可重复读” ，那么切换很简单，老数据会被立刻清理掉。否则，代理接口会维护一个仍未结束的事务列表，并把属于这个列表中的每一个请求都路由到原来的缓存中。只有当列表中的所有事物都提交或者放弃之后老数据才会被清空。]]>
    
    </summary>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
</feed>