<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[翔妖除魔的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://sunxiang0918.github.io//"/>
  <updated>2015-08-06T02:57:37.000Z</updated>
  <id>http://sunxiang0918.github.io//</id>
  
  <author>
    <name><![CDATA[翔妖除魔]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Swift 2.0 新特性]]></title>
    <link href="http://sunxiang0918.github.io/2015/08/04/Swift-2-0-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://sunxiang0918.github.io/2015/08/04/Swift-2-0-新特性/</id>
    <published>2015-08-04T13:35:51.000Z</published>
    <updated>2015-08-06T02:57:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift_2-0_新特性">Swift 2.0 新特性</h1><p><code>Swift2.0</code> 算是一个大得版本更新.新增或修改了很多的特性.出来这么久了,我也把我练手写的知乎日报全部转换成了<code>Swfit2.0</code>.其中还是遇到了一些问题.因此,趁有空,就尝试总结一下<code>Swift2.0</code>的一些新特性或新的变化.</p>
<p>PS:本文写的时候采用的是 Swift2.0+Xcode7 beta4 的环境.</p>
<h2 id="1-guard语句">1.guard语句</h2><p><code>Swift2.0</code>中新引入了一个关键字<code>guard</code>用于条件的判断处理.它和<code>if</code>语句比较类似,都是通过一个<code>boolean</code>值来决定流程的走向.但是与<code>if</code>语句不同的是.<code>guard</code>语句只会有一个代码块.没有像<code>if else</code>那样有多个<code>guard else</code>.</p>
<p>那么<code>guard</code>到底有何作用呢?<code>guard</code>允许在一个代码周期中提前退出.也就是说,在<code>guard</code>关键字后接一个布尔表达式,只有当值为<code>false</code>的时候,才会执行<code>else</code>后的内容.如果值为<code>true</code>,那么就跳过这个<code>guard</code>代码块.</p>
<p><code>guard</code>语句最常见的用法就是替代<code>if</code>做参数的合法性校验.<br>比如在以前:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing</span><span class="params">(a:String?,b:String?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>	<span class="keyword">let</span> _a = a &#123;</span><br><span class="line">		<span class="keyword">if</span>	<span class="keyword">let</span> _b = b &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"<span class="subst">\(_a)</span>:<span class="subst">\(_b)</span>"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// print("\(_a):(_b)")  //这个地方不能访问_a和_b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向上面的例子那样,如果每一个参数都使用<code>if</code>语句来判断,那么这样的代码写起来非常的繁琐.读起来也不是很清晰.基于这种的情况,<code>Swift2.0</code>增加了<code>guard</code>关键字.把上面的代码改成使用<code>guard</code>的写法就会成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing2</span><span class="params">(a:String?,b:String?)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    guard <span class="keyword">let</span> _a = a <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guard <span class="keyword">let</span> _b = b <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(_a)</span>:<span class="subst">\(_b)</span>"</span>)	<span class="comment">//这个地方是可以访问_a和_b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写比起以前使用<code>if</code>来做判断,代码的可读性更强了.并且<code>Optaion</code>类型的变量的解包可以在全局可见了.这在网络编程中解析JSON等是非常有用的.</p>
<p><code>guard</code>除了用于入参的校验和可选类型的解包外.还可以用于抛出异常以及结合<code>available</code>做函数的检查:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">guard name != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">	throw <span class="type">IllegalArgumentException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard #available(iOS <span class="number">8</span>, *) <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2-协议扩展">2.协议扩展</h2><p>在之前的<code>Swift</code>中,协议(<code>Protocol</code>)其实相当于JAVA中的接口,可以定义若干的方法以及属性.然后其他的类、结构体、枚举等都继承这个协议.然后有各自的实现.而现在,在<code>Swift2.0</code>中,可以对协议进行扩展(<code>extension</code>),就和给一般的<code>Class</code>进行扩展一样.并且,同<code>JDK1.8</code>一样,现在协议允许拥有默认的<strong>方法实现</strong>了.这样就大大的增加了编程的灵活度.避免了当需要修改协议时候，需要修改全部实现该协议的类.<br>举一个例子:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明一个协议 要求实现 说话的方法</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展协议 增加 walk 方法, 并默认实现</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		sayHello()</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"walk"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个Lily类遵循Person协议</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lily</span> : <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实现协议中定义的方法</span></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"hello!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个Lily对象</span></span><br><span class="line"><span class="keyword">let</span> lily = <span class="type">Lily</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候lily类可以直接调用协议中的两个方法</span></span><br><span class="line">lily.sayHello()</span><br><span class="line">lily.walk()</span><br></pre></td></tr></table></figure>
<p>在<code>swift2.0</code>中很多的协议都被苹果公司增加了扩展. 比如<code>CollectionType</code>这个协议.所有的集合类型都遵循了这个协议,然后在<code>swift2.0</code>中增加了若干的扩展:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;T&gt;</span><span class="params">(@noescape transform: <span class="params">(<span class="keyword">Self</span>.Generator.Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(@noescape includeElement: <span class="params">(<span class="keyword">Self</span>.Generator.Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Self</span>.<span class="type">Generator</span>.<span class="type">Element</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> last: <span class="type">Self</span>.<span class="type">Generator</span>.<span class="type">Element</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(element: <span class="keyword">Self</span>.Generator.Element)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Index</span>?</span><br></pre></td></tr></table></figure>
<p>等等.</p>
<p>这样就可以在不改变原有协议的基础上给协议增加了若干的方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">42</span>, <span class="number">45</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 1</span></span><br><span class="line"><span class="built_in">find</span>(<span class="built_in">filter</span>(<span class="built_in">map</span>(numbers, &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;), &#123; $<span class="number">0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;), <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 2</span></span><br><span class="line">numbers.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;.indexOf(<span class="number">90</span>) <span class="comment">// returns 2</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Available检查">3.Available检查</h2><p>由于在苹果的生态环境中,基本上每一年都会推出新的<code>OS</code>,每年在发布会上都会说新的操作系统又新增了好多好多的<code>API</code>.好处当然是增加了很多功能,坏处也是显而易见的—-不同版本间的<code>API</code>存在兼容的问题.比如我们调用了一个<code>IOS9</code>中新增的方法,那么这个应用程序运行在了<code>IOS8</code>上,这个时候如果我们不进行系统的版本测试的话,那么我们的应用就会直接的崩溃掉,这显然不是我们所期望的.</p>
<p>为了解决这个问题,在<code>Swift2.0</code>中新引入了<code>#available</code>.配合Available检查,新的<code>Swift</code>编译器,也会在编译的时候就进行检测,当我们在低版本的OS中使用高版本的<code>API</code>的时候,编译器会直接的报错.而当编译器帮我们检测到<code>API</code>版本问题后,接下来就需要我们使用<code>#available</code>语法进行处理了.</p>
<p><code>#available</code>的使用语法是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #abailable(platform name version,...,*)&#123;</span><br><span class="line">	<span class="comment">//执行对应APIS</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">//执行之前老版本APIS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的<code>platform name version</code>表示的是在平台的版本,允许有多个.<br>后面的* 表示的是其他平台,例如<code>Watch OS</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS9,<span class="type">OSX</span> <span class="number">10.11</span>,*)&#123;</span><br><span class="line">	<span class="comment">//使用iOS 9以上的 API接口 以及使用 OS X10.11以上的API接口</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">//使用老版本接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用一套代码来完成不同平台的正确编译与运行了.这对我们现在的开发有了很大的便利.</p>
<h2 id="4-defer关键字">4.defer关键字</h2><p>由于我是学<code>JAVA</code>的,所以当学习<code>Swift</code>的时候就思考过一个问题:在<code>Swift</code>中有没有类似于<code>JAVA</code>中<code>try/finally</code>的语法.也就是说无论前面的代码如何执行,在离开这个代码块之前,一定要执行一段逻辑.很遗憾的是我在<code>swift1</code>中没有发现类似的语法.而在<code>Swift2.0</code>中,Apple提供了这个功能,也就是新引入的<code>defer</code>关键字.</p>
<p><code>defer</code>关键字允许包括一个代码块.然后让这段代码块延迟到<code>defer</code>所在域的最后执行.这样说起来有第一点抽象,看一个例子就明白了.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> throws &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = open(filename)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = try file.readline() &#123;</span><br><span class="line">            <span class="comment">// Work with the file.</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        close(file) <span class="keyword">is</span> called here, at the end of the scope.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有一个问题,那就是如果file.readline方法抛出异常的时候,那么 这段代码最后的close(file)方法可能就不会执行了,这就造成了资源的未关闭问题.</p>
<p>那么如果我们使用<code>defer</code>来修正这个问题,就会这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> throws &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = open(filename)</span><br><span class="line">        defer &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = try file.readline() &#123;</span><br><span class="line">            <span class="comment">// Work with the file.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中,有一个<code>defer</code>代码块.其中编写了文件关闭的逻辑. 而这段逻辑就会在整个<code>if</code>作用域的最后执行,无论是程序是正常的走出<code>if</code>,还是由于异常而跳出<code>if</code>.这样就保证了无论如何程序都会关闭文件.</p>
<p>这里有一个地方需要注意的是多个<code>defer</code>的调用顺序,如果是在不同的作用域中,那么<code>defer</code>的执行顺序是从里到外的.而如果是在同一个作用域中,<code>defer</code>的执行顺序是自下而上的.这和平时的代码调用顺序是相反的.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">aaa</span><span class="params">(a:Boolean)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"1-1"</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"1-2"</span>)</span><br><span class="line">	defer&#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"1-3"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>	a &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"2-1"</span>)</span><br><span class="line">		defer&#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"2-2"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"2-3"</span>)</span><br><span class="line">		defer&#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"2-4"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aaa(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>上面这段代码最后打印出来的信息是:</p>
<blockquote>
<p>1-1<br>1-2<br>2-1<br>2-3<br>2-4<br>2-2<br>1-3<br>大家注意一下这个的打印顺序,体会一下就明白了.</p>
</blockquote>
<h2 id="5-异常处理">5.异常处理</h2><p>上面说完了类似于<code>JAVA</code>中的<code>try-finally</code>,下面就来说说<code>try-catch</code>.<br>在<code>Swift1</code>中是没有异常处理以及抛出异常的,如果要处理异常.大多数情况下都是使用<code>NSError</code>或者闭包回调的方式来处理的.这些方法都没法像<code>JAVA</code>中的<code>try-catch</code>一样方便简洁的处理异常.虽然现在在<code>JAVA</code>界中现在有人觉得随意的抛出异常是一种不负责任的做法,会导致程序的可读性降低,并且开始反思有没有一种更好的方式来处理异常,但就目前来说,无疑是最好的方式.</p>
<p>在<code>Swift2.0</code>中,苹果提供了<code>throws</code> <code>throw</code> <code>do</code> <code>catch</code> <code>try</code> 这几个关键字来处理异常.</p>
<ul>
<li><code>throws</code>关键字写在一个方法签名的后面,返回值前,用于标识这个方法是会抛出异常的.</li>
<li><code>throw</code>关键字用于在代码块中抛出一个异常</li>
<li><code>do</code>关键字用于包裹一个代码块,形成一个<code>do-catch</code>作用域,来捕获异常</li>
<li><code>catch</code>关键字用于捕获某种异常,并且申明异常的处理逻辑</li>
<li><code>try</code>关键字用于调用某个会抛出异常的方法前,用于标识会尝试调用这个方法</li>
</ul>
<p>例如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个异常类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AppException</span> : <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">IllegalArgumentException</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">IllegalFormatException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个方法,可能会抛出异常</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing</span><span class="params">(age:Int)</span></span> throws -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">	<span class="comment">// 检测入参是否合法,如果不合法就抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line">		throw <span class="type">AppException</span>.<span class="type">IllegalArgumentException</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 合法 执行业务逻辑</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"age:<span class="subst">\(age)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试执行方法</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tryDoing</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		try doSomeThing(-<span class="number">1</span>)</span><br><span class="line">	&#125; catch e &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"error: <span class="subst">\(e)</span>"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先,需要定义一个异常,和<code>JAVA</code>中所有的异常都需要实现<code>Throwable</code>接口一样,在<code>Swift2</code>中异常是需要遵循<code>ErrorType</code>协议. 这里只是定义了一个异常的枚举.</li>
<li>然后定义一个方法,并用<code>throws</code>关键字来标志这个函数会抛出异常.但是这个关键字后面不需要申明到底抛出什么异常</li>
<li>接着在方法中使用<code>throw</code>抛出一个异常.这个和<code>JAVA</code>类似.</li>
<li>在调用<code>doSomeThing</code>方法的地方使用<code>do-catch</code>来捕获异常.注意的是,这个地方apple又任性了一把,没有使用其他语言中通常使用的<code>try-catch</code>.</li>
<li>在具体调用会抛出异常的方法时,使用<code>try</code>关键字来标识.这样做有一个好处,就是可以一眼就看出在一个代码域中到底是哪可能会抛出异常.而不是将所有的代码都混在<code>try-catch</code>作用域中.</li>
<li><p>在<code>do-catch</code>语法中,同<code>try-catch</code>一样,也是允许有多个<code>catch</code>代码块的.比如:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	try doSomeThing(-<span class="number">1</span>)</span><br><span class="line">&#125;catch <span class="type">AppException</span>.<span class="type">IllegalArgumentException</span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"xxx"</span>) </span><br><span class="line">&#125;catch <span class="type">AppException</span>.<span class="type">IllegalFormatException</span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"aaaa"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同可选类型的解包一样.<code>try</code>也支持<code>try!</code>的写法.用于表示在明确的知道某一个throwing的方法不会抛出异常的情况下,使用<code>try!</code>就可以不用捕捉异常了.比如:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try! doSomeThing(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当然,现在<code>Swift2.0</code>中的异常捕获还有完善的地方,比如还没有区分运行时异常,非运行时异常,错误等等.但这已经是一个好的开始,期望在以后的版本中继续完善.</p>
<h2 id="6-print改变">6.print改变</h2><p>Apple已经把它的简洁的基因发挥到了极致了.居然想到了把从C语言就开始的<code>println</code>与<code>print</code>函数统一成了一个<code>func print&lt;T&gt;(value: T, appendNewline: Bool)</code>函数.第二个参数就是用于表示是否起新的一行. 默认是<code>true</code>.<br>以后学编程的第一个例子再也不是</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="7-do-while语句重命名">7.do-while语句重命名</h2><p>由于<code>do</code>关键字已经被用于了异常的捕获了.如果这个地方再使用<code>do-while</code>就有可能产生歧义.因此,apple也把这个从C语言开始就有的语法给改了名字:<code>repeat-while</code>.幸好,只是改了一个名字,还是同样的配方,还是同样的味道 ^.^</p>
<h2 id="8-重新可以使用performSelector">8.重新可以使用performSelector</h2><p><code>performSelector</code>方法在<code>Swift1</code>中被Apple认为有安全的问题而去掉了.然后,为了实现相同的功能,广大码农想了千奇百怪的办法.比如使用<code>NSThread.detachNewThreadSelector:</code>,比如<code>NSTimer.scheduledTimerWithTimeInterval:</code>,又比如<code>sendAction:</code>.<br>不过在<code>Swift2.0</code>中,Apple又在<code>NSObjectProtocol</code>协议中恢复了这个方法的调用.<br>现在可以方便的使用了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector, withObject object: AnyObject!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector, withObject object1: AnyObject!, withObject object2: AnyObject!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;!</span><br></pre></td></tr></table></figure>
<p>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.performSelector(<span class="string">"action"</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.performSelectorInBackground(<span class="string">"action"</span>, withObject: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>注意,这个方法在<code>Playground</code>中还是不能使用哈.</p>
<h2 id="9-更强的语言结构性">9.更强的语言结构性</h2><p>由于<code>扩展协议</code>功能的出现,Apple把大量原来非面向对象的全局函数都封装到了各个协议中.让整个<code>Swift2</code>的语言结构性更强了.比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">42</span>, <span class="number">45</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 1</span></span><br><span class="line"><span class="built_in">find</span>(<span class="built_in">filter</span>(<span class="built_in">map</span>(numbers, &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;), &#123; $<span class="number">0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;), <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 2</span></span><br><span class="line">numbers.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;.indexOf(<span class="number">90</span>) <span class="comment">// returns 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift 1</span></span><br><span class="line"><span class="keyword">if</span>	<span class="built_in">contains</span>(numbers,<span class="number">6</span>) &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift 2</span></span><br><span class="line"><span class="keyword">if</span>	numbers.<span class="built_in">contains</span>(<span class="number">6</span>) &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"Swift"</span></span><br><span class="line"><span class="comment">//Swift 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="built_in">count</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift 2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = str.characters.<span class="built_in">count</span></span><br></pre></td></tr></table></figure>
<h2 id="10-枚举的递归">10.枚举的递归</h2><p>在Swift中枚举类型是非常的强大的.它不仅可以拥有自己的属性,自己的方法.还可以遵循协议.极端点来说上来说,光使用枚举和结构体,就能把一个程序写完.<br>在<code>Swift2.0</code>中枚举又得到了增强,现在可以递归的定义枚举类型了.<br>什么叫递归的枚举喃?就是在枚举定义中引用自己,看一个例子就明白了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">indirect <span class="class"><span class="keyword">enum</span> <span class="title">Tree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Leaf</span>(<span class="type">T</span>)</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Branch</span>(<span class="keyword">left</span>: <span class="type">Tree</span>&lt;<span class="type">T</span>&gt;, <span class="keyword">right</span>: <span class="type">Tree</span>&lt;<span class="type">T</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了没,在定义Tree.Branch枚举的时候允许传入两个参数,并且这两个参数又是Tree枚举的.这就形成了枚举的递归.这样做有什么用呢?它其实扩大了枚举的使用场景.通过枚举就可以构建很复杂的数据结构和业务逻辑了.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: 定义一个计算的协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Evaluate</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//: 定义一个计算表达式的枚举</span></span><br><span class="line">indirect <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> : <span class="title">Evaluate</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//表示数  </span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)</span><br><span class="line">  <span class="comment">//表示加法</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>,<span class="type">ArithmeticExpression</span>)</span><br><span class="line">  <span class="comment">//表示乘法</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>,<span class="type">ArithmeticExpression</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//实现Evaluate协议</span></span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  	<span class="comment">//进行计算</span></span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Number</span>(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Addition</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.evaluate() + <span class="keyword">right</span>.evaluate()</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Multiplication</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.evaluate() * <span class="keyword">right</span>.evaluate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluate (3 + 8) * 3</span></span><br><span class="line"><span class="keyword">let</span> three = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> eight = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.<span class="type">Addition</span>(three, eight)</span><br><span class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.<span class="type">Multiplication</span>(sum,three)</span><br><span class="line"><span class="built_in">print</span>(product.evaluate())		<span class="comment">//这里打印结果 33</span></span><br></pre></td></tr></table></figure>
<h2 id="11-增强化的模式匹配">11.增强化的模式匹配</h2><p>在<code>Swift2.0</code>中强化了模式匹配,现在对于控制流增加了很多种组合.比如:<br><code>if/case</code> <code>while/case</code> <code>guard/case</code> <code>for-in/case</code>等等,并且上述的语法都允许像<code>switch</code>/<code>case</code>那样后面接上<code>where</code>做判断.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SignUpFormField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FirstName</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">LastName</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">EmailAddress</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">DOB</span>(<span class="type">NSDate</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift1</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">bornBeforeTaylorSwift</span><span class="params">(signUpFormField: SignUpFormField)</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> signUpFormField &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">DOB</span>(<span class="keyword">let</span> otherBday)</span><br><span class="line">        <span class="keyword">where</span> taylorSwiftsBday.compare(otherBday) == .<span class="type">OrderedDescending</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Fun fact: You were born before Taylor Swift!"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift2</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">bornBeforeTaylorSwift</span><span class="params">(signUpFormField: SignUpFormField)</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">DOB</span>(<span class="keyword">let</span> otherBday) = signUpFormField</span><br><span class="line">        <span class="keyword">where</span> taylorSwiftsBday.compare(otherBday) == .<span class="type">OrderedDescending</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Fun fact: You were born before Taylor Swift!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子说明,<code>if/case</code>的用法,它和<code>switch</code>中的<code>case</code>其实是一样的.如果满足case后的条件,那么就执行<code>if</code>中的操作.这样像上例那样只有一个分支的枚举选择,就不需要使用<code>switch</code>语句了.</p>
<p>增强的模式匹配不光是可以用在枚举类型上.对于<code>可选类型</code>的解包操作同样的奏效.比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someNumber:<span class="type">Int</span>? = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用case的方式解包</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> x? = someNumber &#123;</span><br><span class="line">	<span class="comment">//这里的x已经不是可选类型了</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"someNumber is <span class="subst">\(x)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayOfNumbers:[<span class="type">Int</span>?] = [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">nil</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">nil</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift1</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arrayOfNumbers &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> _x = x &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"Found a number <span class="subst">\(_x)</span>"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift2.0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> x? <span class="keyword">in</span> arrayOfNumbers &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Found a number <span class="subst">\(x)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接一步就搞定了,比以前方便了.</p>
<h2 id="结束语">结束语</h2><p><code>Swift2.0</code>是一个大版本,有着许多优化与改动.经过这一次的改变,<code>Swift2.0</code>变得更加的友好、方便、安全,大大的增加了我们的开发体验.这里只介绍了其中的一些大点的改动,更多的API方面的变化等着我们继续的去挖掘.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift_2-0_新特性">Swift 2.0 新特性</h1><p><code>Swift2.0</code> 算是一个大得版本更新.新增或修改了很多的特性.出来这么久了,我也把我练手写的知乎日报全部转换成了<code>Swfit2.0</code>.其中还是遇到了一些问题.因此,趁有空,就尝试总结一下<code>Swift2.0</code>的一些新特性或新的变化.</p>
<p>PS:本文写的时候采用的是 Swift2.0+Xcode7 beta4 的环境.</p>
<h2 id="1-guard语句">1.guard语句</h2><p><code>Swift2.0</code>中新引入了一个关键字<code>guard</code>用于条件的判断处理.它和<code>if</code>语句比较类似,都是通过一个<code>boolean</code>值来决定流程的走向.但是与<code>if</code>语句不同的是.<code>guard</code>语句只会有一个代码块.没有像<code>if else</code>那样有多个<code>guard else</code>.</p>
<p>那么<code>guard</code>到底有何作用呢?<code>guard</code>允许在一个代码周期中提前退出.也就是说,在<code>guard</code>关键字后接一个布尔表达式,只有当值为<code>false</code>的时候,才会执行<code>else</code>后的内容.如果值为<code>true</code>,那么就跳过这个<code>guard</code>代码块.</p>
<p><code>guard</code>语句最常见的用法就是替代<code>if</code>做参数的合法性校验.<br>比如在以前:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing</span><span class="params">(a:String?,b:String?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>	<span class="keyword">let</span> _a = a &#123;</span><br><span class="line">		<span class="keyword">if</span>	<span class="keyword">let</span> _b = b &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"<span class="subst">\(_a)</span>:<span class="subst">\(_b)</span>"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// print("\(_a):(_b)")  //这个地方不能访问_a和_b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向上面的例子那样,如果每一个参数都使用<code>if</code>语句来判断,那么这样的代码写起来非常的繁琐.读起来也不是很清晰.基于这种的情况,<code>Swift2.0</code>增加了<code>guard</code>关键字.把上面的代码改成使用<code>guard</code>的写法就会成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing2</span><span class="params">(a:String?,b:String?)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    guard <span class="keyword">let</span> _a = a <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guard <span class="keyword">let</span> _b = b <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(_a)</span>:<span class="subst">\(_b)</span>"</span>)	<span class="comment">//这个地方是可以访问_a和_b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写比起以前使用<code>if</code>来做判断,代码的可读性更强了.并且<code>Optaion</code>类型的变量的解包可以在全局可见了.这在网络编程中解析JSON等是非常有用的.</p>
<p><code>guard</code>除了用于入参的校验和可选类型的解包外.还可以用于抛出异常以及结合<code>available</code>做函数的检查:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">guard name != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">	throw <span class="type">IllegalArgumentException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard #available(iOS <span class="number">8</span>, *) <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift中多线程的使用方法]]></title>
    <link href="http://sunxiang0918.github.io/2015/08/02/swift%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://sunxiang0918.github.io/2015/08/02/swift中多线程的使用方法/</id>
    <published>2015-08-02T14:34:44.000Z</published>
    <updated>2015-08-02T14:55:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="swift中多线程的使用方法">swift中多线程的使用方法</h1><h2 id="概述">概述</h2><p>多线程可能是每一个程序开发都会遇到的问题.在swift中,苹果并没有重新开发出一套线程框架,而是继续使用ObjectiveC原有的一套线程框架.<br>目前在swift中最常用的线程方案主要有<code>NSThread</code>,<code>GCD</code>,<code>NSOperation&amp;NSOperationQueue</code>三套方案.所以,接下来会分别的描述下这些方案的使用方法以及例子.</p>
<h2 id="NSThread">NSThread</h2><p><code>NSThread</code>是苹果封装的一套完全面向对象的多线程框架.相比其他的两种方案,这种方案更轻量.你可以直接操作线程对象,很直观和方便.但是,由于<code>NSThread</code>只是一个轻量级的封装.所以需要自己管理线程的生命周期，线程同步。并且线程同步对数据的加锁会有一定的系统开销.因此这套方案使用的频率并不高.通常都是用来获取线程的信息<br><a id="more"></a></p>
<h3 id="NSThread的创建">NSThread的创建</h3><p><code>NSThread</code>主要有两种直接创建的方式:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">detachNewThreadSelector</span>(<span class="title">selector</span>: <span class="title">Selector</span>, <span class="title">toTarget</span> <span class="title">target</span>: <span class="title">AnyObject</span>, <span class="title">withObject</span> <span class="title">argument</span>: <span class="title">AnyObject</span>?)</span><br><span class="line"></span><br><span class="line"><span class="title">convenience</span> <span class="title">init</span>(<span class="title">target</span>: <span class="title">AnyObject</span>, <span class="title">selector</span>: <span class="title">Selector</span>, <span class="title">object</span> <span class="title">argument</span>: <span class="title">AnyObject</span>?)</span></span><br></pre></td></tr></table></figure>
<p>第一个方法是<code>NSThread</code>的类方法,可以直接创建并自动启动<code>NSThread</code>线程.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"action:"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>第二个方法是<code>NSThread</code>的构造函数,可以直接实例化一个<code>NSThread</code>实例,然后在需要的时候再调用<code>start()</code>方法启动线程.比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thread = <span class="type">NSThread</span>(target: <span class="keyword">self</span>, selector: <span class="string">"action:"</span>, object: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>
<p>除了上述的两种直接创建的方式外,还有一种使用<code>NSObject</code>的方法创建并自动启动<code>NSThread</code>的方式.<br>那就是使用:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">performSelectorOnMainThread</span><span class="params">(aSelector: Selector, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector, onThread thr: NSThread, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">performSelectorInBackground</span><span class="params">(aSelector: Selector, withObject arg: AnyObject?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NSObjectProtocol</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector, withObject object: AnyObject!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.performSelector(<span class="string">"action"</span>, withObject: <span class="literal">nil</span>)         <span class="keyword">self</span>.performSelectorInBackground(<span class="string">"action"</span>, withObject: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong>这种方法在<code>swift2.0</code>中,才能使用swift调用.以前苹果一直以安全为由,禁止Swift调用,只能是ObjectiveC调用.</p>
<h3 id="NSThread的其他方法">NSThread的其他方法</h3><p>除了最常用的<code>NSThread</code>创建和启动的方法外.它还内置了一些很方便的方法.使用这些方法,能完整的控制线程的操作与信息.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">currentThread</span>() -&gt; <span class="title">NSThread</span>	//获取当前线程对象</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">isMultiThreaded</span>() -&gt; <span class="title">Bool</span>		//判断是否是多线程</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">sleepUntilDate</span>(<span class="title">date</span>: <span class="title">NSDate</span>)		//休眠当前线程到某个时间</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">sleepForTimeInterval</span>(<span class="title">ti</span>: <span class="title">NSTimeInterval</span>)	//休眠当前线程<span class="title">ti</span>时间,单位是秒</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">exit</span>()		//中断当前线程</span><br><span class="line"></span><br><span class="line">//获取和设置当前线程的优先级</span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">threadPriority</span>() -&gt; <span class="title">Double</span></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">setThreadPriority</span>(<span class="title">p</span>: <span class="title">Double</span>) -&gt; <span class="title">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="title">var</span> <span class="title">name</span>: <span class="title">String</span>?		//线程的名字</span><br><span class="line"></span><br><span class="line"><span class="title">var</span> <span class="title">isMainThread</span>: <span class="title">Bool</span> </span>&#123; <span class="keyword">get</span> &#125;		<span class="comment">//是否是主线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的执行状态</span></span><br><span class="line"><span class="keyword">var</span> executing: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> finished: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> cancelled: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span>		<span class="comment">//取消计划中的线程</span></span><br></pre></td></tr></table></figure>
<p>具体的信息可以参见苹果的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/" target="_blank" rel="external">API</a></p>
<p>以上就是最简单的<code>NSThread</code>的介绍,更多复杂的使用方法,比如两个线程的同步,线程间的通信,线程的顺序执行等等,我会新开一篇文章来描述的.</p>
<h2 id="GCD">GCD</h2><p>全称<code>Grand Central Dispatch</code>.是苹果公司开发的一种多核并行运行的技术.它会更合理的使用现代多核CPU的内核.并且与<code>NSThread</code>不同的是,它能自动的管理线程的生命周期,不再需要我们来关心了,我们只需要关心线程的执行内容就可以了.</p>
<h3 id="设计">设计</h3><p><code>GCD</code>的工作原理是让程序多个平行队列的任务,根据可使用的处理资源,安排他们在任何当前可用的处理器内核上执行.<br>从这里就可以看出,<code>GCD</code>引入了两个非常重要的概念,那就是<code>队列</code>以及<code>任务</code>.<br><strong>任务:</strong>即需要执行的动作.也就是<code>Task</code>.在GCD中是一个<code>Block</code>中文称为<code>闭包</code>.它封装了一段代码用来表示这个线程要干什么.<br><strong>队列:</strong>用于存放任务的一个池子.<code>GCD</code>会不断的从队列中取未执行的任务,然后执行.在<code>GCD</code>中队列分为了<code>同步队列</code>和<code>异步队列</code>.他们的区别主要是在于在执行过程中会不会阻塞当前的线程,直到<code>Block</code>中的任务执行完毕.而不管是<code>同步队列</code>还是<code>异步队列</code>,GCD都是采用<code>FIFO</code>先进先出的方式来一个一个的取任务的.只是异步队列会把每一个取出来的任务放入一个新的线程中执行,然后马上又去取下一个任务.需要注意的是,异步队列能同时执行的任务是有限制的,GCD会根据系统资源自动的控制并行执行的数量,并不会把所有的任务都马上执行.</p>
<h3 id="创建">创建</h3><p>在swift中队列的创建可以使用<code>dispatch_queue_create</code>函数.<br>它的方法签名是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_queue_create</span><span class="params">(label: UnsafePointer&lt;Int8&gt;, <span class="number">_</span> attr: dispatch_queue_attr_t!)</span></span> -&gt; dispatch_queue_t!</span><br></pre></td></tr></table></figure>
<p>第一个参数是队列的标志.第二个参数是队列的属性,如果是同步队列那么就传入<code>DISPATCH_QUEUE_SERIAL</code>或者<code>nil</code>,如果是异步队列那么就传入<code>DISPATCH_QUEUE_CONCURRENT</code><br>比如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#21516;&#27493;&#38431;&#21015;&#10;let serialQueue = dispatch_queue_create(&#34;testSerialQueue&#34;, nil);&#10;let serialQueue2 = dispatch_queue_create(&#34;testSerialQueue2&#34;, DISPATCH_QUEUE_SERIAL)&#10;//&#24322;&#27493;&#38431;&#21015;&#10;let concurrentQueue = dispatch_queue_create(&#34;test concurrentQueue&#34;, DISPATCH_QUEUE_CONCURRENT)</span><br></pre></td></tr></table></figure>
<p>除了上述的手动创建队列外,GCD中还内置了两个全局的队列.</p>
<ul>
<li><p>一个是<code>主队列</code>,这是一个特殊的<code>同步队列</code>.主要是用来在UI上执行一些变化操作的.</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue()</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个是<strong>全局的异步队列</strong>,这个是系统预先提供的一个异步队列.我们可以直接使用.</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="执行">执行</h3><p>队列创建好了后,就可以开始执行任务了.<br>对应同步和异步两种,可以分别调用<code>dispatch_sync</code>和<code>dispatch_async</code> 来执行任务.</p>
<p>它们的方法签名是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_sync</span><span class="params">(queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_async</span><span class="params">(queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个参数就是创建的任务队列. 第二个参数就是表示任务的闭包.这个闭包通常都是<code>()-&gt;Void</code>的.</p>
<p>在调用这两个方法的时候,一定要有<code>任务</code>和<code>队列</code>的概念.一定要牢记在同一个队列中的任务必须一个一个的执行完毕然后才执行下一个.</p>
<p>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"before sync"</span>)</span><br><span class="line">dispatch_sync(mainQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in sync"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after sync"</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码在只会在控制台打印一句<code>before sync</code>.出现这种情况的原因在于调用了主队列用作了同步任务的执行线程. 那么在调用<code>dispatch_sync</code>方法的时候,这个方法会阻塞当前线程直到闭包执行完毕,而当前线程又正好是主线程.因此就会出现一种死锁的情况:在主线程的执行主队列同步任务,会把主线程先阻塞了,然后等待主线程的闭包任务完成.要解决这个问题也很简单,就是把任务的执行队列改为新生成的一个队列<code>let queue = dispatch_queue_create(&quot;1231&quot;, nil)</code>而不是使用主队列即可.</p>
<p>同样的,执行同步任务的嵌套也有可能会出现死锁的情况:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"before sync1"</span>)</span><br><span class="line">dispatch_sync(queue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in sync1"</span>)</span><br><span class="line">    dispatch_sync(queue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"in sync2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after sync1"</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码也只会在控制台打印出<code>before sync1</code>,<code>print(&quot;in sync1&quot;)</code> 两句.原因同样是因为在sync1中调用<code>dispatch_sync</code>会把queue队列线程给阻塞了.然后等待<code>sync2</code>在queue队列线程上执行完毕,这样就造成了死锁.</p>
<h3 id="组执行">组执行</h3><p>在<code>GCD</code>中还可以把一些任务添加到一个任务组里去.这样就能实现监听一组任务是否完成.然后完成后通知执行其他的操作.</p>
<p>组操作的方法签名:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务组</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_group_create</span><span class="params">()</span></span> -&gt; dispatch_group_t!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行任务组</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_group_async</span><span class="params">(group: dispatch_group_t, <span class="number">_</span> queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务组完成后的通知</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_group_notify</span><span class="params">(group: dispatch_group_t, <span class="number">_</span> queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步等待线程组执行完成</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_group_wait</span><span class="params">(group: dispatch_group_t, <span class="number">_</span> timeout: dispatch_time_t)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure>
<p>线程组的执行<strong>没有同步的方式</strong>,只有异步的方式.其实也很好理解,如果是同步的方式也就不存在线程组的通知了,反正都是顺序执行的.</p>
<p>下面是线程组调用的例子:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = dispatch_group_create()</span><br><span class="line"><span class="keyword">let</span> asyncQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, asyncQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">NSThread</span>.currentThread())</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in async1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, asyncQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">NSThread</span>.currentThread())</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in async2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, asyncQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">NSThread</span>.currentThread())</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in async3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, asyncQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"finfish group execute"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行完<code>async1</code> <code>async2</code> <code>async3</code> 后,会执行<code>notify</code>中的任务</p>
<h3 id="Barrier执行">Barrier执行</h3><p>在GCD中还提供了两个阻塞队列执行的方法.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_barrier_async</span><span class="params">(queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_barrier_sync</span><span class="params">(queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br></pre></td></tr></table></figure>
<p>这两个方法体现了队列的<code>FIFO</code>先进先出的原则:当它前面的任务执行结束后它才会执行,而且在它后面的任务要等它执行了后再执行.换句话说,这个方法会阻塞这个queue队列(注意是阻塞队列的任务,而不是阻塞当前线程),等到这个队列中排在它之前的任务全部执行完成后,再执行自己的任务.而后取消任务的阻塞.使这个队列中后面的任务继续异步或同步的执行.需要注意的是,如果传入的队列类型不是<code>DISPATCH_QUEUE_CONCURRENT</code>,那么这个方法和普通的<code>dispatch_async</code>或<code>dispatch_sync</code>没区别.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_queue_create(<span class="string">"a concurrent queue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(concurrentQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"barrier_async"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NSOperation&amp;NSOperationQueue">NSOperation&amp;NSOperationQueue</h2><p><code>NSOperation</code>是苹果公司在GCD之上推出的一个多线程框架,是对GCD的操作做了一层封装.它面向对象的提供了对象的操作,这对我们使用起来更好的理解了.特别是从<code>JAVA</code> <code>.NET</code>这些纯粹面向对象的语言转过来的,更容易使用了.</p>
<p>既然是对<code>GCD</code>的封装,那么GCD中最重要的两个概念<code>任务</code>与<code>队列</code>.同样在这套方案中是有实现的.</p>
<ul>
<li>任务对应的是<code>NSOperation</code>,即要执行的任务封装到一个<code>NSOperation</code>实例中.</li>
<li>队列对应的是<code>NSOperationQueue</code>,即执行的任务会添加到一个<code>NSOperationQueue</code>实例中.</li>
</ul>
<h3 id="创建任务">创建任务</h3><p>由于<code>NSOperation</code>是一个抽象类,因此创建任务主要由两种方式:</p>
<ol>
<li>实例化它的子类<code>NSBlockOperation</code>.然后调用<code>start()</code>启动任务.它会默认在<strong>当前队列</strong>中<strong>同步执行</strong>.</li>
<li>继承<code>NSOperation</code>,自己写实现. 其实如果熟悉JAVA的人,就能发现<code>NSOperation</code>和JAVA中的<code>Runnable</code>接口非常的类似,和<code>Runnable</code>接口的<code>run()</code>方法类似,<code>NSOperation</code>类也有一个<code>main</code>方法被设计用来扩展的.只要继承至这个类,然后重写<code>main</code>方法就可以了.</li>
</ol>
<p>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="keyword">let</span> operation = <span class="type">NSBlockOperation</span> &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in blockOperation"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加执行的闭包</span></span><br><span class="line">operation.addExecutionBlock &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in addExecutionBlock"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始任务</span></span><br><span class="line">operation.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种继承的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">customOperation</span>:<span class="title">NSOperation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"in customOperation"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化任务</span></span><br><span class="line"><span class="keyword">let</span> custom = customOperation()</span><br><span class="line"><span class="comment">//开始任务</span></span><br><span class="line">custom.start()</span><br></pre></td></tr></table></figure>
<p>另外对于NSBlockOperation任务,除了在初始化的时候可以传入一个闭包外.还可以在<code>start</code>方法前,调用<code>func addExecutionBlock(block: () -&gt; Void)</code>来增加执行的闭包.这些增加的闭包,会在调用<code>start</code>方法时,<strong>并发</strong>的执行</p>
<p>除此之外,<code>NSOperation</code>可以通过调用<code>func addDependency(op: NSOperation)</code>和<code>func removeDependency(op: NSOperation)</code>增加或删除依赖.只有<strong>所有依赖的对象都已经完成操作</strong>，当前<code>NSOperation</code>对象才会开<strong>始执行操作</strong>。这样就能控制并发线程执行下的任务顺序</p>
<h3 id="创建队列">创建队列</h3><p><code>NSOperationQueue</code>是用来创建执行队列的. 因为在默认的情况下<code>NSOperation</code>的<code>start()</code>方法会在<code>当前线程</code> <code>同步执行</code>的,也就是说会阻塞当前线程执行任务. 要想在其他线程中执行任务的话,这就需要使用<code>NSOperationQueue</code>了.</p>
<p>创建执行队列的方法也很简单,就是调用<code>NSOperationQueue</code>的构造函数初始化一个<code>NSOperationQueue</code>实例即可.<br>初始化以后,直接调用<code>func addOperation(op: NSOperation)</code>即可添加和自动执行任务了.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> custom = customOperation()</span><br><span class="line"><span class="comment">//custom.start()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> operationQueue = <span class="type">NSOperationQueue</span>()</span><br><span class="line"></span><br><span class="line">operationQueue.addOperation(custom)</span><br></pre></td></tr></table></figure>
<p>需要注意的是,如果把上面的注释去掉,那么程序就会报错:<code>operation is finished and cannot be enqueued</code>.也就是说执行过一次的任务就不能再一次加入到operationQueue中了.</p>
<p>另外一个需要注意的地方就是:<code>NSOperationQueue</code>是不区分同步还是异步队列的.它默认都是异步的.你只要设置最大并发数<code>maxConcurrentOperationCount</code>就可以了.如果你设置成<strong>1</strong>,那自然就是同步执行的了.</p>
<h2 id="总结">总结</h2><p>以上就是Swift中多线程的基本用法,掌握这些知识对于开发一个高性能的应用非常重要.<br>更多的信息可以参考下<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html" target="_blank" rel="external">官方文档</a>.<br>而更多的用法我会另开文章来说明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="swift中多线程的使用方法">swift中多线程的使用方法</h1><h2 id="概述">概述</h2><p>多线程可能是每一个程序开发都会遇到的问题.在swift中,苹果并没有重新开发出一套线程框架,而是继续使用ObjectiveC原有的一套线程框架.<br>目前在swift中最常用的线程方案主要有<code>NSThread</code>,<code>GCD</code>,<code>NSOperation&amp;NSOperationQueue</code>三套方案.所以,接下来会分别的描述下这些方案的使用方法以及例子.</p>
<h2 id="NSThread">NSThread</h2><p><code>NSThread</code>是苹果封装的一套完全面向对象的多线程框架.相比其他的两种方案,这种方案更轻量.你可以直接操作线程对象,很直观和方便.但是,由于<code>NSThread</code>只是一个轻量级的封装.所以需要自己管理线程的生命周期，线程同步。并且线程同步对数据的加锁会有一定的系统开销.因此这套方案使用的频率并不高.通常都是用来获取线程的信息<br>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>Swift局部SCOPE]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/29/Swift%E5%B1%80%E9%83%A8SCOPE/"/>
    <id>http://sunxiang0918.github.io/2015/07/29/Swift局部SCOPE/</id>
    <published>2015-07-29T02:06:40.000Z</published>
    <updated>2015-07-29T03:02:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="局部SCOPE">局部SCOPE</h1><p>C 系语言中在方法内部我们是可以任意添加成对的大括号 {} 来限定代码的作用范围的。这么做一般来说有两个好处，首先是超过作用域后里面的临时变量就将失效，这不仅可以使方法内的命名更加容易，也使得那些不被需要的引用的回收提前进行了，可以稍微提高一些代码的效率；另外，在合适的位置插入括号也利于方法的梳理，对于那些不太方便提取为一个单独方法，但是又应该和当前方法内的其他部分进行一些区分的代码，使用大括号可以将这样的结构进行一个相对自然的划分。</p>
<p>举一个不失一般性的例子，虽然我个人不太喜欢使用代码手写 UI，但钟情于这么做的人还是不在少数。如果我们要在 Objective-C 中用代码构建 UI 的话，我们一般会选择在 -loadView 里写一些类似这样的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *titleLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    titleLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    titleLabel<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">    [view addSubview:titleLabel];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    textLabel<span class="variable">.text</span> = <span class="string">@"Text"</span>;</span><br><span class="line">    [view addSubview:textLabel];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在这里只添加了两个 view，就已经够让人心烦的了。真实的界面当然会比这个复杂很多，想想看如果有十来个 view 的话，这段代码会变成什么样子吧。我们需要考虑对各个子 view 的命名，以确保它们的意义明确。如果我们在上面的代码中把某个配置 textLabel 的代码写错成了 titleLabel 的话，编译器也不会给我们任何警告。这种 bug 是非常难以发现的，因此在类似这种一大堆代码但是又不太可能进行重用的时候，我更推荐使用局部 scope 将它们分隔开来。比如上面的代码建议加上括号重写为以下形式，这样至少编译器会提醒我们一些低级错误，我们也可能更专注于每个代码块：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>)];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UILabel</span> *titleLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">                initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">        titleLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">        titleLabel<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">        [view addSubview:titleLabel];    </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">                initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">        textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">        textLabel<span class="variable">.text</span> = <span class="string">@"Text"</span>;</span><br><span class="line">        [view addSubview:textLabel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，直接使用大括号的写法是不支持的，因为这和闭包的定义产生了冲突。如果我们想类似地使用局部 scope 来分隔代码的话，一个不错的选择是定义一个接受 ()-&gt;() 作为函数的全局方法，然后执行它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">local</span><span class="params">(closure: <span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用时，可以利用尾随闭包的特性模拟局部 scope：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="type">UIView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>))</span><br><span class="line"></span><br><span class="line">    local &#123;</span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>))</span><br><span class="line">        titleLabel.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">        titleLabel.text = <span class="string">"Title"</span></span><br><span class="line">        view.addSubview(titleLabel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    local &#123;</span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>))</span><br><span class="line">        textLabel.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">        textLabel.text = <span class="string">"Text"</span></span><br><span class="line">        view.addSubview(textLabel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.view = view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Objective-C 中还有一个很棒的技巧是使用 GNU C 的<a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs" target="_blank" rel="external">声明扩展</a>来在限制局部作用域的时候同时进行赋值，运用得当的话，可以使代码更加紧凑和整洁。比如上面的 titleLabel 如果我们需要保留一个引用的话，在 Objective-C 中可以写为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.titleLabel</span> = (&#123;</span><br><span class="line">    <span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    label<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    label<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">    [view addSubview:label];</span><br><span class="line">    label;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Swift 里当然没有 GNU C 的扩展，但是使用匿名的闭包的话，写出类似的代码也不是难事：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">titleLabel = &#123;</span><br><span class="line">    <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="type">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>))</span><br><span class="line">    label.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">    label.text = <span class="string">"Title"</span></span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(label)</span><br><span class="line">    <span class="keyword">return</span> label</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>这也是一种隔离代码的很好的方式。</p>
<hr>
<p>原文链接:<a href="http://swifter.tips/local-scope/" target="_blank" rel="external">http://swifter.tips/local-scope/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="局部SCOPE">局部SCOPE</h1><p>C 系语言中在方法内部我们是可以任意添加成对的大括号 {} 来限定代码的作用范围的。这么做一般来说有两个好处，首先是超过作用域后里面的临时变量就将失效，这不仅可以使方法内的命名更加容易，也使得那些不被需要的引用的回收提前进行了，可以稍微提高一些代码的效率；另外，在合适的位置插入括号也利于方法的梳理，对于那些不太方便提取为一个单独方法，但是又应该和当前方法内的其他部分进行一些区分的代码，使用大括号可以将这样的结构进行一个相对自然的划分。</p>
<p>举一个不失一般性的例子，虽然我个人不太喜欢使用代码手写 UI，但钟情于这么做的人还是不在少数。如果我们要在 Objective-C 中用代码构建 UI 的话，我们一般会选择在 -loadView 里写一些类似这样的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *titleLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    titleLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    titleLabel<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">    [view addSubview:titleLabel];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    textLabel<span class="variable">.text</span> = <span class="string">@"Text"</span>;</span><br><span class="line">    [view addSubview:textLabel];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<翻译>Swift2.0中字符串的设计]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/29/Swift2-0%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://sunxiang0918.github.io/2015/07/29/Swift2-0中字符串的设计/</id>
    <published>2015-07-28T16:19:28.000Z</published>
    <updated>2015-07-28T16:22:27.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift2-0中字符串的设计">Swift2.0中字符串的设计</h1><p>Swift中提供了一个高性能的,兼容Unicode的字符串实现作为其标准库中的一部分.在Swift2中,<code>String</code>类型不再实现<code>CollectionType</code>协议.在以前<code>String</code>字符串是一个由<code>Character</code>字符组成的集合,其表现类似于一个数组.而现在,<code>String</code>则是提供了一个<code>characters</code>属性用来暴露字符集合.</p>
<p>为什么会有这样的变化呢?尽管把字符串当做一个字符的集合看起来更自然.但是其实<code>String</code>字符串类型的操作与<code>Array</code>,<code>Set</code>或者<code>Dictionary</code>等集合一直都是完全不同的.但自从Swift2增加了协议扩展后,针对这些差异有必要进行一些根本性的变化了.</p>
<a id="more"></a>
<h2 id="Different_Than_the_Sum_of_Its_Parts">Different Than the Sum of Its Parts</h2><h4 id="每一个部分和的不同计算">每一个部分和的不同计算</h4><p>当你给一个集合增加一个元素的时候,你期望的是这个集合将包含这个元素.换句话说,当你给一个数组增加一个值后,这个数组将会包含这个值.这同样适用于<code>Set</code>和<code>Dictionary</code>.但是,当你给字符串增加一个组合标记字符(<em>combining mark character</em>)的时候,这个字符串内容本身会发生变化.</p>
<p>比如以字符串<code>cafe</code>为例,它由<code>c</code>,<code>a</code>,<code>f</code>,<code>e</code>四个字符组成:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters: [<span class="type">Character</span>] = [<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"f"</span>, <span class="string">"e"</span>]</span><br><span class="line"><span class="keyword">var</span> string: <span class="type">String</span> = <span class="type">String</span>(letters)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(letters.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">print</span>(string) <span class="comment">// cafe</span></span><br><span class="line"><span class="built_in">print</span>(string.characters.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>这个时候如果你给字符串增加一个组合重音字符<code>U+0301</code>也就是<code>´</code>.这个字符串仍然只有四个字符,但是最后一个字符现在变成了<code>é</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> acuteAccent: <span class="type">Character</span> = <span class="string">"\u&#123;0301&#125;"</span> <span class="comment">// ´ COMBINING ACUTE ACCENT' (U+0301)</span></span><br><span class="line"></span><br><span class="line">string.append(acuteAccent)</span><br><span class="line"><span class="built_in">print</span>(string.characters.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">print</span>(string.characters.last!) <span class="comment">// é</span></span><br></pre></td></tr></table></figure>
<p>这个时候,这个字符串的<code>characters</code>属性中并没有包含原来的小写字符<code>e</code>,并且也没有包含新加的组合重音字符<code>´</code>.相反的,现在字符串包含了加上了重音符的小写字符<code>é</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string.characters.<span class="built_in">contains</span>(<span class="string">"e"</span>) <span class="comment">// false</span></span><br><span class="line">string.characters.<span class="built_in">contains</span>(<span class="string">"´"</span>) <span class="comment">// false</span></span><br><span class="line">string.characters.<span class="built_in">contains</span>(<span class="string">"é"</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果其他的集合操作也像字符串那样.那么,它们的结果就会有令人出乎意料的表现.比如把<code>UIColor.redColor()</code>和<code>UIColor.greenColor()</code>放入到一个<code>Set</code>集合中,那么这个时候集合中就应该会包含一个<code>UIColor.yellowColor()</code></p>
<h2 id="Judged_by_the_Contents_of_Its_Characters">Judged by the Contents of Its Characters</h2><h4 id="判断字符内容的相等">判断字符内容的相等</h4><p>另外一个字符串与集合不同的地方在于他们判断相等的方式.</p>
<ul>
<li>两个数组只有当他们有相同数量的元素,并且每一个相同下标的元素都相同,那么这两个数组才相等.</li>
<li>两个Set只有当他们有相同数量的元素,并且在一个Set中的所有元素都在第二个Set中都存在,那么这两个Set才相等.</li>
<li>两个Dictonary只有当他们有相同的<code>Key</code>和<code>Value</code>Set,那么这两个字典才相等.</li>
</ul>
<p>但是,<code>String</code>字符串的相等是基于一种<em>规则相等(canonically equivalent)</em>的方式.当字符拥有相同的语义和表现的时候,我们就认为字符是<em>规则相等</em>的.这个时候,两个字符背后的<code>Unicode</code>有可能是不一样的.</p>
<p>比如朝鲜的文字系统,它是由24个字母,<em>Jamo</em>,元音以及辅音组成的.当我们写字的时候会把这些元素进行组合.比如,字<code>가</code>([ga])是由两个字符<code>ᄀ</code>([g])和<code>ᅡ</code>([a])组成.这在Swift中,无论两个字符串是由分解的字符或者是由预组合的字符序列组成的.只要他们的语义和表现是相同的,那么就认为它们是相同的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decomposed = <span class="string">"\u&#123;1100&#125;\u&#123;1161&#125;"</span> <span class="comment">// ᄀ + ᅡ</span></span><br><span class="line"><span class="keyword">let</span> precomposed = <span class="string">"\u&#123;AC00&#125;"</span> <span class="comment">// 가</span></span><br><span class="line"></span><br><span class="line">decomposed == precomposed <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这再次说明,字符串的这种行为与Swift中其他的集合类型是完全不同的.否则如果一个数组中有<code>🐟</code>和<code>🍚</code>两个值,那么他们就是被认为是与<code>🍣</code>相等的.</p>
<h2 id="Depends_on_Your_Point_of_View">Depends on Your Point of View</h2><h4 id="选择何种表现取决于你的使用">选择何种表现取决于你的使用</h4><p>字符串并不是一个集合,但是它确实又提供了一些与<code>CollectionType</code>协议相同的表现</p>
<ul>
<li><code>characters</code>是一个<code>Character</code>字符值或扩展字元簇(<em><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html" target="_blank" rel="external">extended grapheme clusters</a></em>)的集合.</li>
<li><code>unicodeScalars</code> 是一个Unicode纯量(<em><a href="http://www.unicode.org/glossary/#unicode_scalar_value" target="_blank" rel="external">Unicode scalar values</a></em>)的集合</li>
<li><code>uft8</code> 是一个UTF-8字符集编码的集合</li>
<li><code>uft16</code> 是一个UTF-16字符集编码的集合</li>
</ul>
<p>如果我们把前面<code>café</code>这个例子中的[c,a,f,e]和[´]这几个字符,用字符串中的这几个属性来表示.那么他们就应该是如下表所示:<br><img src="/img/2015/07/29/1.png" alt=""></p>
<ul>
<li><code>characters</code>属性表示的是扩展字元簇.它与用户所直观看到的字符是相近的(由c,a,f,é四个字符组成).这是因为一个字符串必须能迭代整个串中的每一个位置(每一个位置都被成为一个代码点(<em>code point</em>)),以便能在<code>O(n)</code>时间复杂度上执行存取该属性的操作,并获取字符串的边界.当处理一个包含了人类可读的文字或者高度地域敏感的Unicode编码算法,比如用作<code>localizedStandardCompare(_:)</code>方法的入参或者<code>localizedLowercaseString</code>属性的值的时候,应该使用这种逐个字符的处理方式.</li>
<li><code>unicodeScalars</code>属性暴露了字符串中基本Unicode纯量的存储.当一个原始的字符串是由预组合字符(<em> precomposed character</em>)<code>é</code>组成,而不是由分解成的两个字符<code>e</code>+<code>´</code>组成,那么你应该更倾向于使用这个API来进行更底层的字符串数据的操作.</li>
<li><code>utf8</code>和<code>utf16</code>属性分别被用来提供UTF-8与UTF-16的代码点的操作.这些值通常被用于在写入真正的文件系统的时候转换成某些特定的编码.UTF-8编码通常被用作许多POSIX字符串API的处理.而UTF-16则是更多的用于<code>Cocoa&amp;Cocoa Touch</code>框架,以计算字符串的长度与偏移量.</li>
</ul>
<p>有关如何在Swift中使用字符串以及字符的更多信息,可以阅读<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" target="_blank" rel="external">The Swift Programming Language</a>和<a href="https://developer.apple.com/library/prerelease/ios//documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/swift/struct/s:SS" target="_blank" rel="external">Swift Standard Library Reference</a>.</p>
<hr>
<p>原文链接:<a href="https://developer.apple.com/swift/blog/?id=30" target="_blank" rel="external">Strings in Swift 2</a><br>翻译:<a href="http://sunxiang0918.github.io/">翔妖除魔</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift2-0中字符串的设计">Swift2.0中字符串的设计</h1><p>Swift中提供了一个高性能的,兼容Unicode的字符串实现作为其标准库中的一部分.在Swift2中,<code>String</code>类型不再实现<code>CollectionType</code>协议.在以前<code>String</code>字符串是一个由<code>Character</code>字符组成的集合,其表现类似于一个数组.而现在,<code>String</code>则是提供了一个<code>characters</code>属性用来暴露字符集合.</p>
<p>为什么会有这样的变化呢?尽管把字符串当做一个字符的集合看起来更自然.但是其实<code>String</code>字符串类型的操作与<code>Array</code>,<code>Set</code>或者<code>Dictionary</code>等集合一直都是完全不同的.但自从Swift2增加了协议扩展后,针对这些差异有必要进行一些根本性的变化了.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Macos 通过安装Hexo 来搭建 GitHub Pages 博客系统]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/25/hello-world/"/>
    <id>http://sunxiang0918.github.io/2015/07/25/hello-world/</id>
    <published>2015-07-25T10:06:02.000Z</published>
    <updated>2015-07-25T10:06:02.000Z</updated>
    <content type="html"><![CDATA[<p>现在越来越多的人愿意使用独立的技术博客.如果自己搭建Wordpress等,需要涉及到服务器的问题.所以,很多人选择了GitHub提供的Pages来搭建个人博客,我也赶一回潮流.在MacOS 上 使用Hexo来搭建GitHubPages博客.</p>
<h2 id="Hexo">Hexo</h2><p>hexo出自台湾大学生 <a href="http://twitter.com/tommy351" target="_blank" rel="external">tommy351</a> 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。</p>
<h3 id="安装Hexo">安装Hexo</h3><p>要安装<code>Hexo</code>需要先安装<code>Npm</code>以及<code>NodeJs</code>.<br>我在MacOS上,是使用<a href="http://brew.sh" target="_blank" rel="external">Brew</a>安装的.</p>
<ol>
<li><p>安装<strong>NodeJS</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<strong>Git</strong><br>由于我安装了XCode的,并且安装了<code>Command Line Tool</code>,因此,这一步可以省略了.否则还是在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>安装<strong>npm</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install npm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<strong>hexo</strong><br>这个就使用nodeJS的安装程序了.<br>同样在终端输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>这个步骤比较慢.因为你懂的</p>
</li>
<li><p>这个时候可以验证一下是否安装好了.<br>在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    $ node -v</span><br><span class="line">v0.<span class="number">12.7</span></span><br><span class="line">$ npm -v</span><br><span class="line">    <span class="number">2.12</span>.<span class="number">1</span></span><br><span class="line">    $ hexo -v</span><br><span class="line">    hexo: <span class="number">3.1</span>.<span class="number">1</span></span><br><span class="line">os: Darwin <span class="number">14.4</span>.<span class="number">0</span> darwin x64</span><br><span class="line">http_parser: <span class="number">2.3</span></span><br><span class="line">node: <span class="number">0.12</span>.<span class="number">7</span></span><br><span class="line">v8: <span class="number">3.28</span>.<span class="number">71.19</span></span><br><span class="line">uv: <span class="number">1.6</span>.<span class="number">1</span></span><br><span class="line">zlib: <span class="number">1.2</span>.<span class="number">8</span></span><br><span class="line">modules: <span class="number">14</span></span><br><span class="line">openssl: <span class="number">1.0</span>.<span class="number">1</span>p</span><br></pre></td></tr></table></figure>
<p>这样就说明安装完成了.<br>但是如果是显示的: <code>hexo: command not found</code>. 说明环境变量没有设置.我也不知道为什么.但是只要补上环境变量就可以了.</p>
<blockquote>
<p><strong>hexo环境变量的设置:</strong> 在<code>~/</code> 用户的根目录下创建一个目录:<code>.bash_profile</code>.其中的内容为:<code>export PATH=&quot;/usr/local/Cellar/node/0.12.7/libexec/npm/lib/node_modules/hexo/bi$</code>  其中的路径就是hexo的安装路径</p>
</blockquote>
</li>
</ol>
<h3 id="使用Hexo创建博客">使用Hexo创建博客</h3><p>当安装完成后,就可以开始创建博客了.</p>
<ol>
<li><p>在本地创建博客文件夹<br>这一步的目的是在你的本地创建一个博客的文件夹.以后博客的source以及编译后的静态文件都会在这个目录中.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/</span><br><span class="line">$ mkdir blog</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>初始化博客文件夹<br>这一步是用于初始化hexo的一些文件的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    $ <span class="built_in">cd</span> ~/  </span><br><span class="line">    $ hexo init blog  </span><br><span class="line">    $ <span class="built_in">cd</span> blog  </span><br><span class="line">    $ ls  </span><br><span class="line">    _config.yml	node_modules	public		<span class="built_in">source</span></span><br><span class="line">db.json		package.json	scaffolds	themes</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化上下文</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的步骤完成后,就完成了hexo的初始化的过程了.<br>接着就可以开始关注于博客的编写了.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"新博客的名字"</span></span><br></pre></td></tr></table></figure>
<p>这样就在<code>_posts</code>文件夹里面新增加了一个<strong>md</strong>文件.直接对这一篇文档进行内容的编写就可以了.</p>
<p>而后,就在命令行中执行 <code>$ hexo generate</code> 就可以生成新的静态文件.新生成的文件全部放在<code>public</code>文件夹中的.</p>
<h3 id="使用Hexo部署博客到github">使用Hexo部署博客到github</h3><p>要使用github的pages功能的话,就需要创建一个 <code>xxxx.github.io</code>的<strong>repository</strong>. 其中<code>xxxx</code>表示的是你的github账号.这样github就会为你分配一个<code>xxxx.github.io</code>的地址.以后你的博客的访问地址也就是这个了.</p>
<p>有了这个地址以后,就要开始使用hexo部署了.<br>修改博客文件夹下的<code>_config.yml</code></p>
<p>主要是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/xxxx/xxxx.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>这个部分.<br>而后就在命令行中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>而后他就会自动的部署到你的github的pages中了.<br>如果报错说 未找到部署类型的话. 就需要安装<code>hexo-deployer-git</code></p>
<p>同样是在博客的目录中执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="后续">后续</h3><p>这样就搭建完毕了, 后续我会慢慢的把以前记录到 evernote的东西 精选一些转过来. </p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章记录了如何使用Hexo和github搭建个人博客]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://sunxiang0918.github.io/tags/Hexo/"/>
    
      <category term="github" scheme="http://sunxiang0918.github.io/tags/github/"/>
    
      <category term="博客" scheme="http://sunxiang0918.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="其他" scheme="http://sunxiang0918.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>G1垃圾收集器入门]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/23/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://sunxiang0918.github.io/2015/07/23/G1垃圾收集器入门/</id>
    <published>2015-07-23T00:37:28.000Z</published>
    <updated>2015-07-28T01:52:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="G1垃圾收集器入门">G1垃圾收集器入门</h1><h2 id="说明">说明</h2><hr>
<p><strong>concurrent</strong>: 并发, 多个线程协同做同一件事情(有状态)</p>
<p><strong>parallel</strong>: 并行, 多个线程各做各的事情(互相间无共享状态)</p>
<p>参考: <a href="http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html" target="_blank" rel="external">What’s the difference between concurrency and parallelism</a></p>
<h2 id="概述">概述</h2><h3 id="目的">目的</h3><p>本文介绍如何使用G1,及在 Hotspot JVM 中怎么使用G1垃圾收集器。 您将了解 G1 收集器的内部原理, 切换为 G1 收集器的命令行参数, 以及让其记录GC日志的选项。</p>
<h3 id="需要的时间">需要的时间</h3><p>大约 1 个小时</p>
<h3 id="简介">简介</h3><p>本文涵盖了Java虚拟机(JVM, Java Virtual Machine)中 G1 的基础知识。</p>
<ol>
<li>第一部分, 简单概述JVM的同时介绍了垃圾收集和性能.</li>
<li>接下来讲述了 Hotspot JVM 中 CMS 收集器是如何工作的.</li>
<li>接着再一步一步地指导在 Hotspot JVM 中使用G1进行垃圾回收的工作方式.</li>
<li>之后的一个小节介绍 G1 垃圾收集器可用的命令行参数.</li>
<li>最后,您将了解如何配置使G1收集器记录日志.</li>
</ol>
<h3 id="硬件与软件环境需求">硬件与软件环境需求</h3><p>下面是 硬件与软件环境需求 清单:</p>
<ul>
<li>一台PC机, 运行 Windows XP 以上操作系统, Mac OS X 或者 Linux 都可以. 注意,因为作者在Windows 7上进行开发和测试, 尚未在所有平台上完成测试。 但在 OS X和Linux 上应该也是正常的。最好配置了多核CPU.</li>
<li>Java 7 Update 9 或更高版本</li>
<li>最新的 Java 7 Demos and Samples Zip 文件</li>
</ul>
<h3 id="准备条件">准备条件</h3><p>在开始学习本教程之前, 你需要:</p>
<ul>
<li><p>下载并安装最新的 Java JDK (JDK 7 u9 或 以后的版本): Java 7 JDK 下载页面</p>
</li>
<li><p>下载并安装 Demos and Samples (示例与样例) zip 文件, 下载页面和JDK相同. 然后解压到合适的位置. 如:C:\javademos</p>
</li>
</ul>
<a id="more"></a>
<h2 id="Java_技术_和_JVM">Java 技术 和 JVM</h2><h3 id="Java_概述">Java 概述</h3><p>Java 是 Sun Microsystems 公司在1995年发布的一门编程语言. 同时也是一个运行Java程序的底层平台. 提供工具、游戏和企业应用程序支持。Java 运行在全世界超过8.5亿的PC,以及数十亿的智能设备上,包括 mobile 和 TV. Java 是由许多关键部件组成的一个整体, 统称为Java平台。</p>
<h3 id="JRE(Java_Runtime_Edition)">JRE(Java Runtime Edition)</h3><p>一般来说下载了Java以后, 你就得到了一个Java运行时: Java Runtime Environment (JRE). JRE 由Java虚拟机 Java Virtual Machine (JVM), Java 平台核心类(core classes), 以及 Java平台支持库组成. 必须有这三大组件的支持才能在你的电脑上运行 Java 程序. 例如 Java 7, 可以在操作系统上作为桌面应用程序运行, 还可以通过 Java Web Start 从Web上安装, 或者是作为嵌入式Web程序在浏览器中运行 (通过 JavaFX).</p>
<h3 id="Java_编程语言">Java 编程语言</h3><p>Java 是一门面向对象编程语言(object-oriented programming language), 包涵以下特性.</p>
<ul>
<li>Platform Independence - Java 应用程序被编译为字节码(bytecode)存放到 class 文件中, 由JVM加载. 因为程序在 JVM 中运行, 所以可以跨平台运行在各种操作系统/设备上.</li>
<li>Object-Oriented - Java 是一门面向对象的语言, 继承了 C 和 C++ 的很多特性,并在此基础上进行扩充和优化.</li>
<li>Automatic Garbage Collection - Java对内存进行 自动分配(allocates) 和自动释放(deallocates). 所以程序不再执行这一繁琐的任务(其实自动内存回收,更多的好处是减少了编程需要重复处理的这种细节,另一个例子是对JDBC的封装).</li>
<li>Rich Standard Library - Java包含大量的标准对象,可以执行诸如输入输出(input/output), 网络操作以及日期处理等任务.</li>
</ul>
<h3 id="JDK(Java_Development_Kit)">JDK(Java Development Kit)</h3><p>JDK 是用来开发Java程序的一系列工具集. 通过JDK, 你可以编译用Java语言书写的程序, 并在 JVM 中运行. 另外, JDK 还提供了打包(packaging)和分发(distributing)程序的工具.</p>
<p>JDK 和 JRE 使用同样的 Java Application Programming Interfaces (<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="external">Java API</a>).Java API 是预先打包好以供程序员用来开发程序的类库集合. 通过 Java API 使得很多常规任务可以很轻松的就完成,如 字符串操作(string manipulation), 时间日期处理(date/time processing), 网络编程(networking), 以及实现各种数据结构(data structures, 如 lists, maps, stacks, and queues).</p>
<h3 id="JVM(Java_Virtual_Machine)">JVM(Java Virtual Machine)</h3><p>Java Virtual Machine (JVM) 是一台抽象的计算机(abstract computing machine). JVM 本质是一个程序, 但在运行于JVM上的程序看来, 他就像一台真实机器一样. 这样, Java程序就能使用相同的接口和库. 每种特定操作系统上的 JVM 实现, 都将 Java 程序指令转换为本地机器的指令(instructions)和命令(commands). 由此,实现了Java程序的平台独立性.</p>
<p>Java虚拟机的第一个原型实现,由 Sun Microsystems, Inc. 完成, 在一台手持设备上用软件模拟了 Java虚拟机指令集, 类似于今天的 PDA(Personal Digital Assistant). Oracle 当前在移动设备,桌面系统和服务器上都提供了Java虚拟机实现, 但Java虚拟机不限制使用任何特定的技术,硬件,或操作系统。JVM也不一定都是基于软件的,你可以直接在硬件CPU上实现JVM指令, 还可以芯片上实现,或者采用 microcode 的方式来实现.</p>
<p>Java 虚拟机完全不关心Java语言的细节, 只识别 class 文件这种特定的二进制格式. 一个 class 文件包含 Java虚拟机指令(或称之为字节码 bytecode) 及符号变量表(symbol table), 还有一些辅助信息.</p>
<p>基于安全性考虑, Java虚拟机对 class 文件中的代码执行 强语法检查和组成结构规范限制. 既然虚拟机有这种特征, 那么任何一门编程语言,只要能编译为合法的 class 文件，都可以加载到 Java虚拟机 里面执行。由于具有通用性,跨平台特性, 其他语言的实现者可以把Java虚拟机作为该语言的加载执行工具。(1) <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-1.html" target="_blank" rel="external">The Java Virtual Machine</a></p>
<h2 id="探索_JVM_体系架构">探索 JVM 体系架构</h2><h3 id="Hotspot_架构">Hotspot 架构</h3><p>HotSpot JVM 有一个稳定强悍的架构, 支持强大的功能与特性, 具备实现高性能和大规模可伸缩性的能力。例如,HotSpot JVM JIT编译器能动态进行优化生成。换句话说,他们运行Java程序时,会针对底层系统架构动态生成高性能的本地机器指令。此外,通过成熟的演进和运行时环境的持续工程,加上多线程垃圾收集器,HotSpot JVM即使实在大型计算机系统上也能获得很高的伸缩性.</p>
<p><img src="/img/2015/07/23/01_1_JVM_Arch_CN.png" alt="HotSpot JVM: Architecture"></p>
<p>JVM 的主要组件包括: 类加载器(class loader), 运行时数据区(runtime data areas), 以及执行引擎(execution engine).</p>
<h3 id="Hotspot_关键部分">Hotspot 关键部分</h3><p>与性能(performance)有关的部分是 JVM 最重要的组件,下图中用高亮的颜色来显示.</p>
<p><img src="/img/2015/07/23/01_2_Key_Hotspot_Components_CN.png" alt=""></p>
<p>对JVM进行性能调优时有三大组件需要重点关注。堆(Heap)是存放对象的内存空间。这个区域由JVM启动时选择的垃圾收集器进行管理。大多数调优参数都是调整堆内存的大小,以及根据实际情况选择最合适的垃圾收集器. JIT编译器也对性能有很大的影响, 但新版本的JVM调优中很少需要关注.</p>
<h2 id="性能基础">性能基础</h2><p>大多数情况下对 Java 程序进行调优, 主要关注两个目标之一: 响应速度(responsiveness) 和/或 吞吐量(throughput). 下面的教程中我们将讲述这些概念.</p>
<h3 id="响应能力(Responsiveness)">响应能力(Responsiveness)</h3><p>响应能力就是程序或系统对一个请求的响应有多迅速. 比如:</p>
<ul>
<li>程序UI响应速度有多灵敏</li>
<li>网站页面响应有多快</li>
<li>数据库查询有多快<br>对响应速度要求很高的系统, 较大的停顿时间(large pause times) 是不可接受的. 重点是在非常短的时间周期内快速响应.</li>
</ul>
<h3 id="吞吐量(Throughput)">吞吐量(Throughput)</h3><p>吞吐量关注在一个特定时间段内应用系统的最大工作量。衡量吞吐量的指标/示例包括:</p>
<ul>
<li>给定时间内完成的事务数.</li>
<li>每小时批处理系统能完成的作业(jobs)数量.</li>
<li>每小时能完成多少次数据库查询</li>
</ul>
<p>在吞吐量方面优化的系统, 停顿时间长(High pause times)也是可以接受的。由于高吞吐量应用运行时间长,所以此时更关心的是如何尽可能快地完成整个任务，而不考虑快速响应。</p>
<h2 id="G1_垃圾收集器(Garbage_Collector)">G1 垃圾收集器(Garbage Collector)</h2><h3 id="G1_垃圾收集器">G1 垃圾收集器</h3><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 在Oracle JDK 7 update 4 及以上版本中得到完全支持, 专为以下应用程序设计:</p>
<ul>
<li>可以像CMS收集器一样,GC操作与应用的线程一起并发执行</li>
<li>紧凑的空闲内存区间且没有很长的GC停顿时间.</li>
<li>需要可预测的GC暂停耗时.</li>
<li>不想牺牲太多吞吐量性能.</li>
<li>启动后不需要请求更大的Java堆.</li>
</ul>
<p>G1的长期目标是取代CMS(Concurrent Mark-Sweep Collector, 并发标记-清除). 因为特性的不同使G1成为比CMS更好的解决方案. 一个区别是,G1是一款压缩型的收集器.G1通过有效的压缩完全避免了对细微空闲内存空间的分配,不用依赖于regions，这不仅大大简化了收集器，而且还消除了潜在的内存碎片问题。除压缩以外，G1的垃圾收集停顿也比CMS容易估计，也允许用户自定义所希望的停顿参数(pause targets)</p>
<h3 id="G1_操作概述">G1 操作概述</h3><p>上一代的垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation).</p>
<p><img src="/img/2015/07/23/02_1_HeapStructure_CN.png" alt=""></p>
<p>内存中的每个对象都存放在这三个区域中的一个.</p>
<p>而 G1 收集器采用一种不同的方式来管理堆内存.</p>
<p><img src="/img/2015/07/23/02_2_G1HeapAllocation_CN.png" alt=""></p>
<p>堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性。</p>
<p>G1执行垃圾回收的处理方式与CMS相似. G1在全局标记阶段(global marking phase)并发执行, 以确定堆内存中哪些对象是存活的。标记阶段完成后,G1就可以知道哪些heap区的empty空间最大。它会首先回收这些区,通常会得到大量的自由空间. 这也是为什么这种垃圾收集方法叫做Garbage-First(垃圾优先)的原因。顾名思义, G1将精力集中放在可能布满可收回对象的区域, 可回收对象(reclaimable objects)也就是所谓的垃圾. G1使用暂停预测模型(pause prediction model)来达到用户定义的目标暂停时间,并根据目标暂停时间来选择此次进行垃圾回收的heap区域数量.</p>
<p>被G1标记为适合回收的heap区将使用转移(evacuation)的方式进行垃圾回收. G1将一个或多个heap区域中的对象拷贝到其他的单个区域中,并在此过程中压缩和释放内存. 在多核CPU上转移是并行执行的(parallel on multi-processors), 这样能减少停顿时间并增加吞吐量. 因此,每次垃圾收集时, G1都会持续不断地减少碎片, 并且在用户给定的暂停时间内执行. 这比以前的方法强大了很多. CMS垃圾收集器(Concurrent Mark Sweep,并发标记清理)不进行压缩. ParallelOld 垃圾收集只对整个堆执行压缩,从而导致相当长的暂停时间。</p>
<p>需要强调的是, G1并不是一款实时垃圾收集器(real-time collector). 能以极高的概率在设定的目标暂停时间内完成,但不保证绝对在这个时间内完成。 基于以前收集的各种监控数据, G1会根据用户指定的目标时间来预估能回收多少个heap区. 因此,收集器有一个相当精确的heap区耗时计算模型,并根据该模型来确定在给定时间内去回收哪些heap区.</p>
<p><strong>注意 G1</strong>分为两个阶段: 并发阶段(concurrent, 与应用线程一起运行, 如: 细化 refinement、标记 marking、清理 cleanup) 和 并行阶段(parallel, 多线程执行, 如: 停止所有JVM线程, stop the world). 而 FullGC(完整垃圾收集)仍然是单线程的, 但如果进行适当的调优,则应用程序应该能够避免 full GC。</p>
<h3 id="G1_的内存占用(Footprint)">G1 的内存占用(Footprint)</h3><p>如果从 ParallelOldGC 或者 CMS收集器迁移到 G1, 您可能会看到JVM进程占用更多的内存(a larger JVM process size). 这在很大程度上与 “accounting” 数据结构有关, 如 Remembered Sets 和 Collection Sets.</p>
<p><strong>Remembered Sets</strong> 简称 RSets, 跟踪指向某个heap区内的对象引用. 堆内存中的每个区都有一个 RSet. RSet 使heap区能并行独立地进行垃圾集合. RSets的总体影响小于5%.</p>
<p><strong>Collection Sets</strong> 简称 CSets, 收集集合, 在一次GC中将执行垃圾回收的heap区. GC时在CSet中的所有存活数据(live data)都会被转移(复制/移动). 集合中的heap区可以是 Eden, survivor, 和/或 old generation. CSets所占用的JVM内存小于1%.</p>
<h3 id="推荐使用_G1_的场景(Recommended_Use_Cases)">推荐使用 G1 的场景(Recommended Use Cases)</h3><p>G1的首要目标是为需要大量内存的系统提供一个保证GC低延迟的解决方案. 也就是说堆内存在6GB及以上,稳定和可预测的暂停时间小于0.5秒.</p>
<p>如果应用程序具有如下的一个或多个特征,那么将垃圾收集器从CMS或ParallelOldGC切换到G1将会大大提升性能.</p>
<ul>
<li>Full GC 次数太频繁或者消耗时间太长.</li>
<li>对象分配的频率或代数提升(promotion)显著变化.</li>
<li>受够了太长的垃圾回收或内存整理时间(超过0.5~1秒)</li>
</ul>
<p><strong>注意: </strong>如果正在使用CMS或ParallelOldGC,而应用程序的垃圾收集停顿时间并不长,那么继续使用现在的垃圾收集器是个好主意. 使用最新的JDK时并不要求切换到G1收集器。</p>
<h2 id="CMS的GC概述">CMS的GC概述</h2><h3 id="分代GC(Generational_GC)与_CMS">分代GC(Generational GC)与 CMS</h3><p>并发标记清理(CMS, Concurrent Mark Sweep)收集器(也称为多并发低暂停的收集器)回收老年代内存(tenured generation). 它将垃圾回收中的绝大部分工作与应用程序的线程一起并发执行,以期能最小化暂停时间. 通常多并发低暂停收集器收集器不复制或也不压缩存活的对象. 垃圾回收不移动存活的对象, 如果产生内存碎片问题,就会分配/占用更大的堆内存空间。</p>
<p><strong>注意: </strong>年轻代使用的CMS收集器也和并行收集器采用一样的算法.</p>
<h3 id="CMS_垃圾收集阶段划分(Collection_Phases)">CMS 垃圾收集阶段划分(Collection Phases)</h3><p>CMS收集器在老年代堆内存的回收中执行分为以下阶段:</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1) 初始标记 (Initial Mark)</td>
<td>(Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable).对象在旧一代“标志”可以包括这些对象可能可以从年轻一代。暂停时间一般持续时间较短,相对小的收集暂停时间.</td>
</tr>
<tr>
<td>(2) 并发标记 (Concurrent Marking)</td>
<td>在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象. 调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态.</td>
</tr>
<tr>
<td>(3) 再次标记(Remark)</td>
<td>(Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的.</td>
</tr>
<tr>
<td>(4) 并发清理(Concurrent Sweep)</td>
<td>回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动.</td>
</tr>
<tr>
<td>(5) 重置(Resetting)</td>
<td>清理数据结构,为下一个并发收集做准备.</td>
</tr>
</tbody>
</table>
<h3 id="CMS的GC步骤">CMS的GC步骤</h3><p>接下来,让我们一步步地讲述CMS收集器的操作.</p>
<h4 id="1-_CMS的堆内存结构(Heap_Structure)">1. CMS的堆内存结构(Heap Structure)</h4><p>堆内存被分为3个空间.</p>
<p><img src="/img/2015/07/23/03_1_CMS_Heap_Structure_CN.png" alt=""></p>
<p>年轻代(Young generation)分为 1个新生代空间(Eden)和2个存活区(survivor spaces). 老年代(Old generation)是一大块连续的空间, 垃圾回收(Object collection)就地解决(is done in place), 除了 Full GC, 否则不会进行压缩(compaction).</p>
<h4 id="2-_CMS年轻代(Young)_GC_的工作方式">2. CMS年轻代(Young) GC 的工作方式</h4><p>年轻代(young generation)用高亮的绿色表示, 老年代(old generation)用蓝色表示。如果程序运行了一段时间,那么 CMS 看起来就像下图这个样子. 对象散落在老年代中的各处地方.</p>
<p><img src="/img/2015/07/23/03_2_How_yong_GC_Works_CN.png" alt=""></p>
<p>在使用 CMS 时, 老年代的对象回收就地进行(deallocated in place). 他们不会被移动到其他地方. 除了 Full GC, 否则内存空间不会进行压缩.</p>
<h4 id="3-_年轻代垃圾回收(Young_Generation_Collection)">3. 年轻代垃圾回收(Young Generation Collection)</h4><p>Eden区和survivor区中的存活对象被拷贝到另一个空的survivor 区. 存活时间更长,达到阀值的对象会被提升到老年代(promoted to old generation).</p>
<p><img src="/img/2015/07/23/03_3_Yong_Generation_Collection_CN.png" alt=""></p>
<h4 id="4-_年轻代(Young)_GC_之后">4. 年轻代(Young) GC 之后</h4><p>年轻代(Young)进行一次垃圾回收之后, Eden 区被清理干净(cleared),两个 survivor 区中的一个也被清理干净了. 如下图所示:</p>
<p><img src="/img/2015/07/23/03_4_After_Young_GC_CN.png" alt=""></p>
<p>图中新提升的对象用深蓝色来标识. 绿色的部分是年轻代中存活的对象,但还没被提升到老年代中.</p>
<h4 id="5-_CMS的老年代回收(Old_Generation_Collection)">5. CMS的老年代回收(Old Generation Collection)</h4><p>两次stop the world事件发生在: 初始标记(initial mark)以及重新标记(remark)阶段. 当老年代达到一定的占有率时,CMS垃圾回收器就开始工作.</p>
<p><img src="/img/2015/07/23/03_5_Old_Generation_Collection_in_CMS_CN.png" alt=""></p>
<p>(1) 初始标记(Initial mark)阶段的停顿时间很短,在此阶段存活的(live,reachable,可及的) 对象被记下来. (2) 并发标记(Concurrent marking)在程序继续运行的同时找出存活的对象. 最后, 在第(3)阶段(remark phase), 查找在第(2)阶段(concurrent marking)中错过的对象.</p>
<h4 id="6-_老年代回收_-_并发清理(Concurrent_Sweep)">6. 老年代回收 - 并发清理(Concurrent Sweep)</h4><p>在前面阶段未被标记的对象将会就地释放(deallocated in place). 此处没有压缩(compaction).</p>
<p><img src="/img/2015/07/23/03_6_Concurrent_Sweep_CN.png" alt=""></p>
<p><strong>备注:</strong> 未标记(Unmarked)的对象 == 已死对象(Dead Objects)</p>
<h4 id="7-_老年代回收_-_清理之后(After_Sweeping)">7. 老年代回收 - 清理之后(After Sweeping)</h4><p>在第(4)步(Sweeping phase)之后, 可以看到很多内存被释放了. 还应该注意到,这里并没有执行内存压缩整理(no compaction).</p>
<p><img src="/img/2015/07/23/03_7_After_Sweeping_CN.png" alt=""></p>
<p>最后, CMS 收集器进入(move through)第(5)阶段, 重置(resetting phase), 然后等候下一次的GC阀值到来(GC threshold).</p>
<h2 id="G1垃圾收集器概述">G1垃圾收集器概述</h2><h3 id="一步步介绍G1">一步步介绍G1</h3><p>G1收集器采用一种不同的方式来分配堆. 下面通过图解的方式一步步地讲述G1系统.</p>
<h4 id="1-_G1的堆内存结构">1. G1的堆内存结构</h4><p>堆内存被划分为固定大小的多个区域.</p>
<p><img src="/img/2015/07/23/04_1_G1_Heap_Structure_CN.png" alt=""></p>
<p>每个heap区(Region)的大小在JVM启动时就确定了. JVM 通常生成 2000 个左右的heap区, 根据堆内存的总大小,区的size范围允许为 1Mb 到 32Mb.</p>
<h4 id="2-_G1_堆空间分配">2. G1 堆空间分配</h4><p>实际上,这些区域(regions)被映射为逻辑上的 Eden, Survivor, 和 old generation(老年代)空间.</p>
<p><img src="/img/2015/07/23/02_2_G1HeapAllocation_CN.png" alt=""></p>
<p>图中的颜色标识了每一个区域属于哪个角色. 存活的对象从一块区域转移(复制或移动)到另一块区域。设计成 heap 区的目的是为了并行地进行垃圾回收(的同时停止/或不停止其他应用程序线程).</p>
<p>如图所示,heap区可以分配为 Eden, Survivor, 或 old generation(老年代)区. 此外,还有第四种类型的对象被称为巨无霸区域(Humongous regions),这种巨无霸区是设计了用来保存比标准heap区大50%及以上的对象, 它们存储在一组连续的区中. 最后一个类型是堆内存中的未使用区(unused areas).</p>
<p><strong>备注:</strong> 截止英文原文发表时,巨无霸对象的回收还没有得到优化. 因此,您应该尽量避免创建太大(大于32MB?)的对象.</p>
<h4 id="3-_G1中的年轻代(Young_Generation)">3. G1中的年轻代(Young Generation)</h4><p>堆被分为大约2000个区. 最小size为1 Mb, 最大size为 32Mb. 蓝色的区保存老年代对象,绿色区域保存年轻代对象.</p>
<p><img src="/img/2015/07/23/04_3_Young_Generation_in_G1_CN.png" alt=""></p>
<p>注意G1中各代的heap区不像老一代垃圾收集器一样要求各部分是连续的.</p>
<h4 id="4-_G1中的一次年轻代GC">4. G1中的一次年轻代GC</h4><p>存活的对象被转移(copied or moved)到一个/或多个存活区(survivor regions). 如果存活时间达到阀值,这部分对象就会被提升到老年代(promoted to old generation regions).</p>
<p><img src="/img/2015/07/23/04_4_A_Young_GC_in_G1_CN.png" alt=""></p>
<p>此时会有一次 stop the world(STW)暂停. 会计算出 Eden大小和 survivor 大小,给下一次年轻代GC使用. 清单统计信息(Accounting)保存了用来辅助计算size. 诸如暂停时间目标之类的东西也会纳入考虑.</p>
<p>这种方法使得调整各代区域的尺寸很容易, 让其更大或更小一些以满足需要.</p>
<h4 id="5-_G1的一次年轻代GC完成后">5. G1的一次年轻代GC完成后</h4><p>存活对象被转移到存活区(survivor regions) 或 老年代(old generation regions).</p>
<p><img src="/img/2015/07/23/04_5_End_of_Young_GC_with_G1_CN.png" alt=""></p>
<p>刚刚被提升上来的对象用深绿色显示. Survivor 区用绿色表示.</p>
<p>总结起来,G1的年轻代收集归纳如下:</p>
<ul>
<li>堆一整块内存空间,被分为多个heap区(regions).</li>
<li>年轻代内存由一组不连续的heap区组成. 这使得在需要时很容易进行容量调整.</li>
<li>年轻代的垃圾收集,或者叫 young GCs, 会有 stop the world 事件. 在操作时所有的应用程序线程都会被暂停(stopped).</li>
<li>年轻代 GC 通过多线程并行进行.</li>
<li>存活的对象被拷贝到新的 survivor 区或者老年代.</li>
</ul>
<h3 id="Old_Generation_Collection_with_G1">Old Generation Collection with G1</h3><p>和 CMS 收集器相似, G1 收集器也被设计为用来对老年代的对象进行低延迟(low pause)的垃圾收集. 下表描述了G1收集器在老年代进行垃圾回收的各个阶段.</p>
<h4 id="G1_收集阶段_-_并发标记周期阶段(Concurrent_Marking_Cycle_Phases)">G1 收集阶段 - 并发标记周期阶段(Concurrent Marking Cycle Phases)</h4><p>G1 收集器在老年代堆内存中执行下面的这些阶段. 注意有些阶段也是年轻代垃圾收集的一部分.</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1) 初始标记(Initial Mark)</td>
<td>(Stop the World Event,所有应用线程暂停) 此时会有一次 stop the world(STW)暂停事件. 在G1中, 这附加在(piggybacked on)一次正常的年轻代GC. 标记可能有引用指向老年代对象的survivor区(根regions).</td>
</tr>
<tr>
<td>(2) 扫描根区域(Root Region Scanning)</td>
<td>扫描 survivor 区中引用到老年代的引用. 这个阶段应用程序的线程会继续运行. 在年轻代GC可能发生之前此阶段必须完成.</td>
</tr>
<tr>
<td>(3) 并发标记(Concurrent Marking)</td>
<td>在整个堆中查找活着的对象. 此阶段应用程序的线程正在运行. 此阶段可以被年轻代GC打断(interrupted).</td>
</tr>
<tr>
<td>(4) 再次标记(Remark)</td>
<td>(Stop the World Event,所有应用线程暂停) 完成堆内存中存活对象的标记. 使用一个叫做 snapshot-at-the-beginning(SATB, 起始快照)的算法, 该算法比CMS所使用的算法要快速的多.</td>
</tr>
<tr>
<td>(5) 清理(Cleanup)</td>
<td>(Stop the World Event,所有应用线程暂停,并发执行)</td>
</tr>
</tbody>
</table>
<p>在存活对象和完全空闲的区域上执行统计(accounting). (Stop the world)<br>擦写 Remembered Sets. (Stop the world)<br>重置空heap区并将他们返还给空闲列表(free list). (Concurrent, 并发)|<br>|(*) 拷贝(Copying)|    (Stop the World Event,所有应用线程暂停) 产生STW事件来转移或拷贝存活的对象到新的未使用的heap区(new unused regions). 只在年轻代发生时日志会记录为 <code>[GC pause (young)]</code>. 如果在年轻代和老年代一起执行则会被日志记录为 <code>[GC Pause (mixed)]</code>.|</p>
<h3 id="G1老年代收集步骤">G1老年代收集步骤</h3><p>顺着定义的阶段,让我们看看G1收集器如何处理老年代(old generation).</p>
<h4 id="6-_初始标记阶段(Initial_Marking_Phase)">6. 初始标记阶段(Initial Marking Phase)</h4><p>存活对象的初始标记被固定在年轻代垃圾收集里面. 在日志中被记为 GC pause (young)(inital-mark)。</p>
<p><img src="/img/2015/07/23/04_6_Initial_Marking_Phase_CN.png" alt=""></p>
<h4 id="7-_并发标记阶段(Concurrent_Marking_Phase)">7. 并发标记阶段(Concurrent Marking Phase)</h4><p>如果找到空的区域(如用红叉“X”标示的区域), 则会在 Remark 阶段立即移除. 当然,”清单(accounting)”信息决定了活跃度(liveness)的计算.</p>
<p><img src="/img/2015/07/23/04_7_Concurrent_Marking_Phase_CN.png" alt=""></p>
<h4 id="8-_再次标记阶段(Remark_Phase)">8. 再次标记阶段(Remark Phase)</h4><p>空的区域被移除并回收。现在计算所有区域的活跃度(Region liveness).</p>
<p><img src="/img/2015/07/23/04_8_Remark_Phase_CN.png" alt=""></p>
<h4 id="9-_拷贝/清理阶段(Copying/Cleanup)">9. 拷贝/清理阶段(Copying/Cleanup)</h4><p>G1选择“活跃度(liveness)”最低的区域, 这些区域可以最快的完成回收. 然后这些区域和年轻代GC在同时被垃圾收集 . 在日志被标识为 [GC pause (mixed)]. 所以年轻代和老年代都在同一时间被垃圾收集.</p>
<p><img src="/img/2015/07/23/04_9_Copying_Cleanup_Phase_CN.png" alt=""></p>
<h4 id="10-拷贝/清理之后(After_Copying/Cleanup)">10.拷贝/清理之后(After Copying/Cleanup)</h4><p>所选择的区域被收集和压缩到下图所示的深蓝色区域和深绿色区域.</p>
<p><img src="/img/2015/07/23/04_10_After_Copying_Cleanup_Phase_CN.png" alt=""></p>
<h3 id="老年代GC(Old_Generation_GC)总结">老年代GC(Old Generation GC)总结</h3><p>总结下来,G1对老年代的GC有如下几个关键点:</p>
<ul>
<li>并发标记清理阶段(Concurrent Marking Phase)<ul>
<li>活跃度信息在程序运行的时候被并行计算出来</li>
<li>活跃度(liveness)信息标识出哪些区域在转移暂停期间最适合回收.</li>
<li>不像CMS一样有清理阶段(sweeping phase).</li>
</ul>
</li>
<li>再次标记阶段(Remark Phase)<ul>
<li>使用的 Snapshot-at-the-Beginning (SATB, 开始快照) 算法比起 CMS所用的算法要快得多.</li>
<li>完全空的区域直接被回收.</li>
</ul>
</li>
<li>拷贝/清理阶段(Copying/Cleanup Phase)<ul>
<li>年轻代与老年代同时进行回收.</li>
<li>老年代的选择基于其活跃度(liveness).</li>
</ul>
</li>
</ul>
<h2 id="命令行参数与最佳实践">命令行参数与最佳实践</h2><h3 id="命令行参数与最佳实践-1">命令行参数与最佳实践</h3><p>在本节中,让我们看看G1的各种命令行选项.</p>
<h3 id="命令行基本参数">命令行基本参数</h3><p>要启用 G1 收集器请使用: <code>-XX:+UseG1GC</code></p>
<p>下面是启动 Java2Demo示例程序的命令行示例. Java2Demo位于下载 JDK demos and samples 后解压的文件夹中:</p>
<p><code>java -Xmx50m -Xms50m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar c:\javademos\demo\jfc\Java2D\Java2demo.jar</code></p>
<h3 id="关键命令行开关">关键命令行开关</h3><p><strong>-XX:+UseG1GC</strong> - 让 JVM 使用 G1 垃圾收集器.</p>
<p><strong>-XX:MaxGCPauseMillis=200</strong> - 设置最大GC停顿时间(GC pause time)指标(target). 这是一个软性指标(soft goal), JVM 会尽力去达成这个目标. 所以有时候这个目标并不能达成. 默认值为 200 毫秒.</p>
<p><strong>-XX:InitiatingHeapOccupancyPercent=45</strong> - 启动并发GC时的堆内存占用百分比. G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比例。值为 0 则表示“一直执行GC循环)’. 默认值为 45 (例如, 全部的 45% 或者使用了45%).</p>
<h3 id="最佳实践">最佳实践</h3><p>在使用 G1 作为垃圾收集器时,你应该遵循下面这些最佳实践的指导.</p>
<h4 id="不要设置年轻代的大小(Young_Generation_Size)">不要设置年轻代的大小(Young Generation Size)</h4><p>假若通过 -Xmn 显式地指定了年轻代的大小, 则会干扰到 G1收集器的默认行为.</p>
<ul>
<li>G1在垃圾收集时将不再关心暂停时间指标. 所以从本质上说,设置年轻代的大小将禁用暂停时间目标.</li>
<li>G1在必要时也不能够增加或者缩小年轻代的空间. 因为大小是固定的,所以对更改大小无能为力.</li>
</ul>
<h4 id="响应时间指标(Response_Time_Metrics)">响应时间指标(Response Time Metrics)</h4><p>设置 <code>XX:MaxGCPauseMillis=&lt;N&gt;</code> 时不应该使用平均响应时间(ART, average response time) 作为指标,而应该考虑使用目标时间的90%或者更大作为响应时间指标. 也就是说90%的用户(客户端/?)请求响应时间不会超过预设的目标值. 记住,暂停时间只是一个目标,并不能保证总是得到满足.</p>
<h4 id="什么是转移失败(Evacuation_Failure)?">什么是转移失败(Evacuation Failure)?</h4><p>对 survivors 或 promoted objects 进行GC时如果JVM的heap区不足就会发生提升失败(promotion failure). 堆内存不能继续扩充,因为已经达到最大值了. 当使用 -XX:+PrintGCDetails 时将会在GC日志中显示 <strong>to-space overflow</strong> (to-空间溢出)。</p>
<p><strong>这是很昂贵的操作!</strong></p>
<ul>
<li>GC仍继续所以空间必须被释放.</li>
<li>拷贝失败的对象必须被放到正确的位置(tenured in place).</li>
<li>CSet指向区域中的任何 RSets 更新都必须重新生成(regenerated).</li>
<li>所有这些步骤都是代价高昂的.</li>
</ul>
<h4 id="如何避免转移失败(Evacuation_Failure)">如何避免转移失败(Evacuation Failure)</h4><p>要避免避免转移失败, 考虑采纳下列选项.</p>
<ul>
<li>增加堆内存大小<ul>
<li>增加 <strong>-XX:G1ReservePercent=n</strong>, 其默认值是 10.</li>
<li>G1创建了一个假天花板(false ceiling),在需要更大 ‘to-space’ 的情况下会尝试从保留内存获取(leave the reserve memory free).</li>
</ul>
</li>
<li>更早启动标记周期(marking cycle)</li>
<li>通过采用 <strong>-XX:ConcGCThreads=n</strong> 选项增加标记线程(marking threads)的数量.</li>
</ul>
<h4 id="G1_的_GC_参数完全列表">G1 的 GC 参数完全列表</h4><p>下面是完整的 G1 的 GC 开关参数列表. 在使用时请记住上面所述的最佳实践.</p>
<table>
<thead>
<tr>
<th>选项/默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseG1GC</td>
<td>使用 G1 (Garbage First) 垃圾收集器</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis=n</td>
<td>设置最大GC停顿时间(GC pause time)指标(target). 这是一个软性指标(soft goal), JVM 会尽量去达成这个目标.</td>
</tr>
<tr>
<td>-XX:InitiatingHeapOccupancyPercent=n</td>
<td>启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示”一直执行GC循环”. 默认值为 45.</td>
</tr>
<tr>
<td>-XX:NewRatio=n</td>
<td>新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2.</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=n</td>
<td>eden/survivor 空间大小的比例(Ratio). 默认值为 8.</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold=n</td>
<td>提升年老代的最大临界值(tenuring threshold). 默认值为 15.</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads=n</td>
<td>设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同.</td>
</tr>
<tr>
<td>-XX:ConcGCThreads=n</td>
<td>并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而不同.</td>
</tr>
<tr>
<td>-XX:G1ReservePercent=n</td>
<td>设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认值是 10.</td>
</tr>
<tr>
<td>-XX:G1HeapRegionSize=n</td>
<td>使用G1时Java堆会被分为大小统一的的区(region)。此参数可以指定每个heap区的大小. 默认值将根据 heap size 算出最优解. 最小值为 1Mb, 最大值为 32Mb.</td>
</tr>
</tbody>
</table>
<h2 id="记录G1的GC日志">记录G1的GC日志</h2><h3 id="记录G1的GC日志-1">记录G1的GC日志</h3><p>我们要介绍的最后一个主题是使用日志信息来分享G1收集器的性能. 本节简要介绍垃圾收集的相关参数,以及日志中打印的相关信息.</p>
<h3 id="设置日志细节(Log_Detail)">设置日志细节(Log Detail)</h3><p>可以设置3种不同的日志级别.</p>
<p><strong>(1) -verbosegc (等价于 -XX:+PrintGC)</strong> 设置日志级别为 <strong>好</strong> <em>fine</em>.</p>
<p><strong>日志输出示例</strong></p>
<pre><code><span class="list">[<span class="keyword">GC</span> pause <span class="list">(<span class="keyword">G1</span> Humongous Allocation)</span> <span class="list">(<span class="keyword">young</span>)</span> <span class="list">(<span class="keyword">initial-mark</span>)</span> <span class="number">24</span>M- &gt;21M<span class="list">(<span class="keyword">64M</span>)</span>, <span class="number">0.2349730</span> secs]
<span class="list">[<span class="keyword">GC</span> pause <span class="list">(<span class="keyword">G1</span> Evacuation Pause)</span> <span class="list">(<span class="keyword">mixed</span>)</span> <span class="number">66</span>M-&gt;21M<span class="list">(<span class="keyword">236M</span>)</span>, <span class="number">0.1625268</span> secs]  </span></span>
</code></pre><p><strong>(2) -XX:+PrintGCDetails</strong> 设置日志级别为 <strong>更好</strong> <em>finer</em>. 使用此选项会显示以下信息:</p>
<ul>
<li>每个阶段的 Average, Min, 以及 Max 时间.</li>
<li>根扫描(Root Scan), RSet 更新(同时处理缓冲区信息), RSet扫描(Scan), 对象拷贝(Object Copy), 终止(Termination, 包括尝试次数).</li>
<li>还显示 “other” 执行时间, 比如选择 CSet, 引用处理(reference processing), 引用排队(reference enqueuing) 以及释放(freeing) CSet等.</li>
<li>显示 Eden, Survivors 以及总的 Heap 占用信息(occupancies).</li>
</ul>
<p><strong>日志输出示例</strong></p>
<pre><code><span class="list">[<span class="keyword">Ext</span> Root Scanning <span class="list">(<span class="keyword">ms</span>)</span>: Avg: <span class="number">1.7</span> Min: <span class="number">0.0</span> Max: <span class="number">3.7</span> Diff: <span class="number">3.7</span>]
<span class="list">[<span class="keyword">Eden:</span> <span class="number">818</span>M<span class="list">(<span class="keyword">818M</span>)</span>-&gt;0B<span class="list">(<span class="keyword">714M</span>)</span> Survivors: <span class="number">0</span>B-&gt;104M Heap: <span class="number">836</span>M<span class="list">(<span class="keyword">4096M</span>)</span>-&gt;409M<span class="list">(<span class="keyword">4096M</span>)</span>]</span></span>
</code></pre><p><strong>(3) -XX:+UnlockExperimentalVMOptions -XX:G1LogLevel=finest</strong> 设置日志级别为 <strong>最好</strong> <em>finest</em>. 和 finer 级别类似, 包含每个 worker 线程信息.</p>
<pre><code>[Ext Root Scanning (ms): <span class="number">2.1</span> <span class="number">2.4</span> <span class="number">2.0</span> <span class="number">0.0</span>
<span class="label">       Avg:</span> <span class="number">1.6</span> <span class="string">Min:</span> <span class="number">0.0</span> <span class="string">Max:</span> <span class="number">2.4</span> <span class="string">Diff:</span> <span class="number">2.3</span>]
   [Update RS (ms):  <span class="number">0.4</span>  <span class="number">0.2</span>  <span class="number">0.4</span>  <span class="number">0.0</span>
<span class="label">       Avg:</span> <span class="number">0.2</span> <span class="string">Min:</span> <span class="number">0.0</span> <span class="string">Max:</span> <span class="number">0.4</span> <span class="string">Diff:</span> <span class="number">0.4</span>]
       [Processed <span class="string">Buffers :</span> <span class="number">5</span> <span class="number">1</span> <span class="number">10</span> <span class="number">0</span>
<span class="label">       Sum:</span> <span class="number">16</span>, <span class="string">Avg:</span> <span class="number">4</span>, <span class="string">Min:</span> <span class="number">0</span>, <span class="string">Max:</span> <span class="number">10</span>, <span class="string">Diff:</span> <span class="number">10</span>]
</code></pre><h3 id="Determining_Time">Determining Time</h3><p>有两个参数决定了GC日志中打印的时间显示形式.</p>
<p><strong>(1) -XX:+PrintGCTimeStamps</strong> - 显示从JVM启动时算起的运行时间.</p>
<p><strong>日志输出示例</strong></p>
<pre><code>1<span class="class">.729</span>: <span class="attr_selector">[GC pause (young) 46M-&gt;35M(1332M), 0.0310029 secs]</span>
</code></pre><p><strong>(2) -XX:+PrintGCDateStamps</strong> - 在每条记录前加上日期时间.</p>
<p><strong>日志输出示例</strong></p>
<pre><code>2012<span class="tag">-05-02T11</span><span class="pseudo">:16</span><span class="pseudo">:32</span><span class="class">.057</span>+0200: <span class="attr_selector">[GC pause (young) 46M-&gt;35M(1332M), 0.0317225 secs]</span>
</code></pre><h3 id="理解_G1_日志">理解 G1 日志</h3><p>为了使你更好地理解GC日志, 本节通过实际的日志输出，定义了许多专业术语. 下面的例子显示了GC日志的内容,并加上日志中出现的术语和值的解释说明.</p>
<p><strong>Note:</strong> 更多信息请参考 <a href="https://blogs.oracle.com/poonam/entry/understanding_g1_gc_logs" target="_blank" rel="external">Poonam Bajaj的博客： G1垃圾回收日志</a>.</p>
<h3 id="G1_日志相关术语">G1 日志相关术语</h3><ul>
<li>Clear CT</li>
<li>CSet</li>
<li>External Root Scanning</li>
<li>Free CSet</li>
<li>GC Worker End</li>
<li>GC Worker Other</li>
<li>Object Copy</li>
<li>Other</li>
<li>Parallel Time</li>
<li>Ref Eng</li>
<li>Ref Proc</li>
<li>Scanning Remembered Sets</li>
<li>Termination Time</li>
<li>Update Remembered Set</li>
<li>Worker Start</li>
</ul>
<h4 id="Parallel_Time(并行阶段耗时)">Parallel Time(并行阶段耗时)</h4><pre><code><span class="number">414.557</span>: [GC pause (young), <span class="number">0.03039600</span> secs] [Parallel Time: 22.9 ms]
[GC Worker Start (ms): <span class="number">7096.0 70</span><span class="number">96.0 7096</span>.<span class="number">1 7096.1</span> <span class="number">706.1 70</span><span class="number">96.1 7096</span>.<span class="number">1 7096.1</span> <span class="number">7096.2 70</span><span class="number">96.2 7096</span>.<span class="number">2 7096.2</span>
   Avg: 7096.1, Min: 7096.0, Max: 7096.2, Diff: 0.2]
</code></pre><p><code>Parallel Time</code> – 主要并行部分运行停顿的整体时间</p>
<p><code>Worker Start</code>– 各个工作线程(workers)启动时的时间戳(Timestamp)</p>
<p><strong>Note: </strong>日志是根据 thread id 排序,并且每条记录都是一致的.</p>
<h4 id="External_Root_Scanning(外部根扫描)">External Root Scanning(外部根扫描)</h4><pre><code>[Ext Root Scanning (ms): <span class="number">3.1 3.4</span> <span class="number">3.4 3.0</span> <span class="number">4.2 2.0</span> <span class="number">3.6 3.2</span> <span class="number">3.4 7.7</span> <span class="number">3.7 4.4</span>
 Avg: 3.8, Min: 2.0, Max: 7.7, Diff: 5.7]
</code></pre><p><code>External root scanning</code> - 扫描外部根花费的时间(如指向堆内存的系统词典(system dictionary)等部分)</p>
<h4 id="Update_Remembered_Set(更新_RSet)">Update Remembered Set(更新 RSet)</h4><pre><code>[Update RS (ms): <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> Avg: <span class="number">0.0</span>, Min: <span class="number">0.0</span>, Max: <span class="number">0.1</span>, Diff: <span class="number">0.1</span>]
[Processed Buffers : <span class="number">26</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>
Sum: <span class="number">26</span>, Avg: <span class="number">2</span>, Min: <span class="number">0</span>, Max: <span class="number">26</span>, Diff: <span class="number">26</span>]
</code></pre><p><code>Update Remembered Set</code> - 必须更新在pause之前已经完成但尚未处理的缓冲. 花费的时间取决于cards的密度。cards越多,耗费的时间就越长。</p>
<h4 id="Scanning_Remembered_Sets(扫描_RSets)">Scanning Remembered Sets(扫描 RSets)</h4><pre><code>[Scan RS (ms): <span class="number">0.4 0.2</span> <span class="number">0.1 0.3</span> <span class="number">0.0 0.0</span> <span class="number">0.1 0.2</span> <span class="number">0.0 0.1</span> <span class="number">0.0 0.0</span> Avg: 0.1, Min: 0.0, Max: 0.4, Diff: 0.3]F
</code></pre><p><code>Scanning Remembered Sets</code> - 查找指向 Collection Set 的指针(pointers)</p>
<h4 id="Object_Copy(对象拷贝)">Object Copy(对象拷贝)</h4><pre><code>[Object Copy (ms): <span class="number">16.7 16.7</span> <span class="number">16.7 16.9</span> <span class="number">16.0 18.1</span> <span class="number">16.5 16.8</span> <span class="number">16.7 12.3</span> <span class="number">16.4 15.7</span> Avg: 16.3, Min: 12.3, Max:  18.1, Diff: 5.8]
</code></pre><p><code>Object copy</code> – 每个独立的线程在拷贝和转移对象时所消耗的时间.</p>
<h4 id="Termination_Time(结束时间)">Termination Time(结束时间)</h4><pre><code>[Termination (ms): <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span>
<span class="number">0.0</span> Avg: <span class="number">0.0</span>, Min: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>] [Termination Attempts : <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> Sum: <span class="number">12</span>, Avg: <span class="number">1</span>, Min: <span class="number">1</span>, Max: <span class="number">1</span>, Diff: <span class="number">0</span>]
</code></pre><p><code>Termination time</code> - 当worker线程完成了自己那部分对象的复制和扫描,就进入终止协议(termination protocol)。它查找未完成的工作(looks for work to steal), 一旦它完成就会再进入终止协议。 终止尝试记录(Termination attempt counts)所有查找工作的尝试次数(attempts to steal work).</p>
<h4 id="GC_Worker_End">GC Worker End</h4><pre><code>[GC Worker End (ms): <span class="number">7116.4 71</span><span class="number">16.3 7116</span>.<span class="number">4 7116.3</span> <span class="number">7116.4 71</span><span class="number">16.3 7116</span>.<span class="number">4 7116.4</span> <span class="number">7116.4 71</span><span class="number">16.4 7116</span>.<span class="number">3 7116.3</span>
Avg: 7116.4, Min: 7116.3, Max: 7116.4, Diff:   0.1]
[GC Worker (ms): <span class="number">20.4 20.3</span> <span class="number">20.3 20.2</span> <span class="number">20.3 20.2</span> <span class="number">20.2 20.2</span> <span class="number">20.3 20.2</span> <span class="number">20.1 20.1</span>
 Avg: 20.2, Min: 20.1, Max: 20.4, Diff: 0.3]
</code></pre><p><code>GC worker end time</code> – 独立的 GC worker 停止时的时间戳.</p>
<p><code>GC worker time</code> – 每个独立的 GC worker 线程消耗的时间.</p>
<h4 id="GC_Worker_Other">GC Worker Other</h4><pre><code>[GC Worker Other (ms): <span class="number">2.6 2.6</span> <span class="number">2.7 2.7</span> <span class="number">2.7 2.7</span> <span class="number">2.7 2.8</span> <span class="number">2.8 2.8</span> <span class="number">2.8 2.8</span>
Avg: 2.7, Min: 2.6, Max: 2.8, Diff: 0.2]
</code></pre><p><code>GC worker other</code> – 每个GC线程中不能归属到之前列出的worker阶段的其他时间. 这个值应该很低. 过去我们见过很高的值,是由于JVM的其他部分的瓶颈引起的(例如在分层[Tiered]代码缓存[Code Cache]占有率的增加)。</p>
<h4 id="Clear_CT">Clear CT</h4><pre><code>[Clear CT: <span class="number">0.6</span> ms]
</code></pre><p>清除 RSet 扫描元数据(scanning meta-data)的 card table 消耗的时间.</p>
<h4 id="Other">Other</h4><pre><code>[Other: <span class="number">6.8</span> ms]
</code></pre><p>其他各种GC暂停的连续阶段花费的时间.</p>
<h4 id="CSet">CSet</h4><pre><code>[Choose CSet: <span class="number">0.1</span> ms]
</code></pre><p>敲定要进行垃圾回收的region集合时消耗的时间. 通常很小,在必须选择 old 区时会稍微长一点点.</p>
<h4 id="Ref_Proc">Ref Proc</h4><pre><code>[Ref Proc: <span class="number">4.4</span> ms]
</code></pre><p>处理 soft, weak, 等引用所花费的时间,不同于前面的GC阶段</p>
<h4 id="Ref_Enq">Ref Enq</h4><pre><code>[Ref Enq: <span class="number">0.1</span> ms]
</code></pre><p>将 soft, weak, 等引用放置到待处理列表(pending list)花费的时间.</p>
<h4 id="Free_CSet">Free CSet</h4><pre><code>[Free CSet: <span class="number">2.0</span> ms]
</code></pre><p>释放刚被垃圾收集的 heap区所消耗的时间,包括对应的remembered sets。</p>
<h2 id="总结">总结</h2><p>在此OBE中, 您对Java JVM 中的G1垃圾收集器有了个大致的了解。首先你学到了为何堆和垃圾收集器是所有Java JVM的关键部分。接下来讲述了使用CMS和G1收集器进行垃圾回收的工作方式. 接下来,您了解了G1的命令行参数/开关以及和使用它们的最佳实践。最后,您了解了日志对象以及GC日志中的数据。</p>
<p>在本教程中,你学到了这些知识:</p>
<ul>
<li>Java JVM 的组成部分</li>
<li>对 G1 的概述</li>
<li>概述 CMS 垃圾收集器</li>
<li>概述 G1 垃圾收集器</li>
<li>命令行参数与最佳实践</li>
<li>G1 的日志信息</li>
</ul>
<h2 id="相关资源">相关资源</h2><p>更多相关信息请参考以下网站链接.</p>
<p><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="external">HotSpot 虚拟机参数</a><br><a href="http://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html" target="_blank" rel="external">G1(垃圾优先)收集器</a><br><a href="https://blogs.oracle.com/poonam/entry/understanding_g1_gc_logs" target="_blank" rel="external">Poonam Bajaj的博客： G1垃圾回收日志</a><br><a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=609&amp;p_org_id=1001&amp;lang=US&amp;get_params=dc:D67232GC10,p_preview:N" target="_blank" rel="external">Java SE 7: 开发富客户端应用程序</a><br><a href="http://www.amazon.cn/gp/product/B00IOB0K1Q" target="_blank" rel="external">Java性能优化权威指南 - 中文版</a><br><a href="http://www.oracle.com/oll" target="_blank" rel="external">Oracle 学习资料库</a>  </p>
<h2 id="作者信息">作者信息</h2><ul>
<li>课程开发人员: Michael J Williams</li>
<li>质量保证: Krishnanjani Chitta</li>
<li>翻译人员: <a href="http://blog.csdn.net/renfufei" target="_blank" rel="external">铁锚 http://blog.csdn.net/renfufei</a></li>
<li>参考: <a href="http://www.infoq.com/cn/news/2008/05/g1" target="_blank" rel="external">JavaOne: Garbage First</a></li>
<li>这里有一群纯技术Java程序员: <a href="http://jq.qq.com/?_wv=1027&amp;k=cXLDjh" target="_blank" rel="external">欢迎大牛和爱好者加入【Java高级交流群: 329019348】
</a></li>
<li>原文链接: <a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="external">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html</a></li>
</ul>
<hr>
<p>转帖地址:<a href="http://blog.csdn.net/renfufei/article/details/41897113" target="_blank" rel="external">http://blog.csdn.net/renfufei/article/details/41897113</a></p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章非常详细的介绍了G1垃圾收集器的相关知识]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="JVM" scheme="http://sunxiang0918.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MongoDB在Linux下的集群安装与配置]]></title>
    <link href="http://sunxiang0918.github.io/2015/06/29/MongoDB%E5%9C%A8Linux%E4%B8%8B%E7%9A%84%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://sunxiang0918.github.io/2015/06/29/MongoDB在Linux下的集群安装与配置/</id>
    <published>2015-06-29T13:24:24.000Z</published>
    <updated>2015-08-01T13:54:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MongoDB在Linux下的集群安装与配置">MongoDB在Linux下的集群安装与配置</h1><h2 id="一-MongoDB集群方式">一.MongoDB集群方式</h2><p><strong>Mongodb</strong>是时下流行的NoSql数据库.它拥有三种集群的搭建方式:<code>Replica Set</code> / <code>Sharding</code> / <code>Master-Slaver</code>.   分别为 副本集方式集群, 分片集群, 主从集群.<br>三种集群搭建方式首选<code>Replica Set</code>，只有真的是大数据，Sharding才能显现威力，毕竟备节点同步数据是需要时间的。Sharding可以将多片数据集中到路由节点上进行一些对比，然后将数据返回给客户端，但是效率还是比较低的说。  </p>
<p>这里用最常用的 Replica的方式集群来做介绍</p>
<h2 id="二-Replica_Set">二.Replica Set</h2><p><code>Replica Set</code>集群当中包含了多份数据，保证主节点挂掉了，备节点能继续提供数据服务，提供的前提就是数据需要和主节点一致。如下图：<br><img src="/img/2015/06/29/1.png" alt=""></p>
<p><code>Mongodb(M)</code>表示主节点，<code>Mongodb(S)</code>表示备节点，<code>Mongodb(A)</code>表示仲裁节点。主备节点存储数据，仲裁节点不存储数据。客户端同时连接主节点与备节点，不连接仲裁节点。</p>
<p>使用的时候 可以通过配置 让M负责写,S负责读.从而达到读写分离的效果</p>
<p>仲裁节点是一种特殊的节点，它本身并<code>不存储数据</code>，主要的作用是决定哪一个备节点在主节点挂掉之后提升为主节点，所以客户端不需要连接此节点。这里虽然只有一个备节点，但是仍然需要一个仲裁节点来提升备节点级别。</p>
<a id="more"></a>
<h2 id="三-集群搭建">三.集群搭建</h2><p>我们在这里使用了两台机器来安装.<br><img src="/img/2015/06/29/2.png" alt=""></p>
<p>147和148两个作为两个Replica节点,负责数据的存储.同时这两个机器又同时作为仲裁节点负责节点的提升</p>
<ul>
<li><p>下载mongodb<br>在官网上直接下载:<a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1204-3.0.4.tgz" target="_blank" rel="external">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1204-3.0.4.tgz</a></p>
</li>
<li><p>上传到两台机器上去:  </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /Users/SUN/Downloads/mongodb-linux-x86_64-ubuntu1204-<span class="number">3.0</span>.<span class="number">4</span>.tgz root@<span class="number">172.16</span>.<span class="number">128.147</span>:~/</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压到目的地:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf mongodb-linux-x86_64-ubuntu1204-<span class="number">3.0</span>.<span class="number">4</span>.tgz -C /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改目录的名字:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv mongodb-linux-x86_64-ubuntu1204-<span class="number">3.0</span>.<span class="number">4</span>/ mongo</span><br><span class="line">cp -r mongo/ mongo2</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立数据文件夹:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">mkdir data/db</span><br><span class="line">mkdir <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>建立mongodb的配置文件:</p>
</li>
<li><p>Replica Node1:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#master.conf</span></span><br><span class="line">dbpath=/mongo/data/db</span><br><span class="line">logpath=/mongo/<span class="built_in">log</span>/db.log</span><br><span class="line">pidfilepath=/mongo/db.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">replSet=testrs</span><br><span class="line"><span class="built_in">bind</span>_ip=<span class="number">172.16</span>.<span class="number">128.147</span></span><br><span class="line">port=<span class="number">27017</span></span><br><span class="line">oplogSize=<span class="number">1000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">noprealloc=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Replica Node2:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#master.conf</span></span><br><span class="line">dbpath=/mongo/data/db</span><br><span class="line">logpath=/mongo/<span class="built_in">log</span>/db.log</span><br><span class="line">pidfilepath=/mongo/db.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">replSet=testrs</span><br><span class="line"><span class="built_in">bind</span>_ip=<span class="number">172.16</span>.<span class="number">128.148</span></span><br><span class="line">port=<span class="number">27017</span></span><br><span class="line">oplogSize=<span class="number">1000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">noprealloc=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Replica arbiterNode1:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#arbiter.conf </span></span><br><span class="line">dbpath=/mongo2/data/db</span><br><span class="line">logpath=/mongo2/<span class="built_in">log</span>/db.log</span><br><span class="line">pidfilepath=/mongo2/db.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">replSet=testrs</span><br><span class="line"><span class="built_in">bind</span>_ip=<span class="number">172.16</span>.<span class="number">128.147</span></span><br><span class="line">port=<span class="number">27018</span></span><br><span class="line">oplogSize=<span class="number">1000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">noprealloc=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Replica arbiterNode2:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#arbiter.conf </span></span><br><span class="line">dbpath=/mongo2/data/db</span><br><span class="line">logpath=/mongo2/<span class="built_in">log</span>/db.log</span><br><span class="line">pidfilepath=/mongo2/db.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">replSet=testrs</span><br><span class="line"><span class="built_in">bind</span>_ip=<span class="number">172.16</span>.<span class="number">128.148</span></span><br><span class="line">port=<span class="number">27018</span></span><br><span class="line">oplogSize=<span class="number">1000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">noprealloc=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>参数解释：</strong><br><code>dbpath</code>：数据存放目录<br><code>logpath</code>：日志存放路径<br><code>pidfilepath</code>：进程文件，方便停止mongodb<br><code>directoryperdb</code>：为每一个数据库按照数据库名建立文件夹存放<br><code>logappend</code>：以追加的方式记录日志<br><code>replSet</code>：replica set的名字<br><code>bind_ip</code>：mongodb所绑定的ip地址<br><code>port</code>：mongodb进程所使用的端口号，默认为27017<br><code>oplogSize</code>：mongodb操作日志文件的最大大小。单位为Mb，默认为硬盘剩余空间的5%<br><code>fork</code>：以后台方式运行进程<br><code>noprealloc</code>：不预先分配存储</p>
<ul>
<li><p>设置全局的Local环境变量:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/default/locale</span><br></pre></td></tr></table></figure>
<p>  在locale文件中 加入:  <code>LC_ALL=&quot;zh_CN&quot;</code><br>  然后再执行:  </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LC_ALL=zh_CN</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>启动mongodb:<br>  分别在三台机器上执行:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mongod <span class="operator">-f</span> ../dbconfig.conf</span><br></pre></td></tr></table></figure>
<p>  <img src="/img/2015/06/29/3.png" alt=""></p>
</li>
<li><p>完成启动:<br>  这个时候可以输入:<code>pgrep mongo -l</code>  来判断mongo服务是否启动</p>
</li>
<li><p>配置Replica Set:</p>
<p>  随便登陆任意一个mongodb:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mongo <span class="number">172.16</span>.<span class="number">128.147</span>:<span class="number">27017</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	&gt;use admin</span><br><span class="line"></span><br><span class="line">	&gt;cfg=&#123; _id:<span class="string">"testrs"</span>, members:[ &#123;_id:<span class="number">0</span>,host:<span class="string">'172.16.128.147:27017'</span>,priority:<span class="number">2</span>&#125;, &#123;_id:<span class="number">1</span>,host:<span class="string">'172.16.128.148:27017'</span>,priority:<span class="number">1</span>&#125;,   </span><br><span class="line">&#123;_id:<span class="number">2</span>,host:<span class="string">'172.16.128.147:27018'</span>,arbiterOnly:<span class="literal">true</span>&#125;,&#123;_id:<span class="number">3</span>,host:<span class="string">'172.16.128.148:27018'</span>,arbiterOnly:<span class="literal">true</span>&#125;] &#125;;</span><br><span class="line"></span><br><span class="line">	&gt;rs.initiate(cfg)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>到此,就给mongodb 指定了 <code>replica</code>模式的 集群了.</p>
<p>这个时候可以通过: <code>&gt;rs.status()</code> 命令来查看集群的状态</p>
<ul>
<li><p>配置成为ubuntu的服务:<br>  在<code>/etc/init.d/</code>目录下新建脚本文件mongodb</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span><br><span class="line"></span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:     mongodb</span></span><br><span class="line"><span class="comment"># Required-Start:</span></span><br><span class="line"><span class="comment"># Required-Stop:</span></span><br><span class="line"><span class="comment"># Default-Start:        2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:         0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: mongodb</span></span><br><span class="line"><span class="comment"># Description: mongo db server</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line">PROGRAM=/usr/<span class="built_in">local</span>/mongo/bin/mongod</span><br><span class="line">MONGOPID=`ps -ef | grep <span class="string">'mongod'</span> | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$PROGRAM</span> || <span class="built_in">exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">  start)</span><br><span class="line">     <span class="built_in">ulimit</span> -n <span class="number">3000</span></span><br><span class="line">     <span class="built_in">log</span>_begin_msg <span class="string">"Starting MongoDB server”</span><br><span class="line">     export LC_ALL=zh_CN</span><br><span class="line">     <span class="variable">$PROGRAM</span> -f /usr/local/mongo/dbconfig.conf</span><br><span class="line">     log_end_msg 0</span><br><span class="line">     ;;</span><br><span class="line">  stop)</span><br><span class="line">     log_begin_msg "</span>Stopping MongoDB server”</span><br><span class="line">     <span class="built_in">export</span> LC_ALL=zh_CN</span><br><span class="line">     <span class="variable">$PROGRAM</span> --dbpath /usr/<span class="built_in">local</span>/mongo/data/db --shutdown</span><br><span class="line">     <span class="built_in">log</span>_end_msg <span class="number">0</span></span><br><span class="line">     ;;</span><br><span class="line">  status)</span><br><span class="line">     ;;</span><br><span class="line">  *)</span><br><span class="line">     <span class="built_in">log</span>_success_msg <span class="string">"Usage: /etc/init.d/mongodb &#123;start|stop|status&#125;"</span></span><br><span class="line">     <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后给这个文件 增加运行权限 <code>chmod +x /etc/init.d/mongodb</code></p>
<p>这样就可以使用:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongodb stop</span><br><span class="line">sudo service mongodb start</span><br></pre></td></tr></table></figure>
<p>启动或停止服务了</p>
<p>如果再加一句: <code>update-rc.d mongodb defaults</code><br>那么就会 开机自启动</p>
<h2 id="四-集群测试">四.集群测试</h2><p>正常运行的时候 应该是有 两个数据节点 和两个决策节点. 其中147为主  148为辅</p>
<p>使用工具连接到mongo中去.这时显示的是:<br><img src="/img/2015/06/29/4.png" alt=""></p>
<p>然后直接kill mongo 进程:   sudo kill 1004</p>
<p>然后再连接数据库,这个时候会发现 连接变了.<br><img src="/img/2015/06/29/5.png" alt=""></p>
<p>这个时候继续正常的操作.  插入新的数据等等.<br>而后,重新启动147节点. 会发现 一切数据恢复正常. </p>
<p>集群成功</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MongoDB在Linux下的集群安装与配置">MongoDB在Linux下的集群安装与配置</h1><h2 id="一-MongoDB集群方式">一.MongoDB集群方式</h2><p><strong>Mongodb</strong>是时下流行的NoSql数据库.它拥有三种集群的搭建方式:<code>Replica Set</code> / <code>Sharding</code> / <code>Master-Slaver</code>.   分别为 副本集方式集群, 分片集群, 主从集群.<br>三种集群搭建方式首选<code>Replica Set</code>，只有真的是大数据，Sharding才能显现威力，毕竟备节点同步数据是需要时间的。Sharding可以将多片数据集中到路由节点上进行一些对比，然后将数据返回给客户端，但是效率还是比较低的说。  </p>
<p>这里用最常用的 Replica的方式集群来做介绍</p>
<h2 id="二-Replica_Set">二.Replica Set</h2><p><code>Replica Set</code>集群当中包含了多份数据，保证主节点挂掉了，备节点能继续提供数据服务，提供的前提就是数据需要和主节点一致。如下图：<br><img src="/img/2015/06/29/1.png" alt=""></p>
<p><code>Mongodb(M)</code>表示主节点，<code>Mongodb(S)</code>表示备节点，<code>Mongodb(A)</code>表示仲裁节点。主备节点存储数据，仲裁节点不存储数据。客户端同时连接主节点与备节点，不连接仲裁节点。</p>
<p>使用的时候 可以通过配置 让M负责写,S负责读.从而达到读写分离的效果</p>
<p>仲裁节点是一种特殊的节点，它本身并<code>不存储数据</code>，主要的作用是决定哪一个备节点在主节点挂掉之后提升为主节点，所以客户端不需要连接此节点。这里虽然只有一个备节点，但是仍然需要一个仲裁节点来提升备节点级别。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://sunxiang0918.github.io/tags/Linux/"/>
    
      <category term="MongoDB" scheme="http://sunxiang0918.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>如何在Git中撤销一切]]></title>
    <link href="http://sunxiang0918.github.io/2015/06/24/%E5%A6%82%E4%BD%95%E5%9C%A8Git%E4%B8%AD%E6%92%A4%E9%94%80%E4%B8%80%E5%88%87/"/>
    <id>http://sunxiang0918.github.io/2015/06/24/如何在Git中撤销一切/</id>
    <published>2015-06-24T12:23:29.000Z</published>
    <updated>2015-07-28T01:52:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何在Git中撤销一切">如何在Git中撤销一切</h1><p>翻译：李伟<br>审校：张帆<br>译自：<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">Github</a></p>
<p><img src="https://jf-bucket-public.oss-cn-qingdao.aliyuncs.com/jfperiodical/attached/image/20150612/2016242594.png" alt=""></p>
<p>任何一个版本控制系统中，最有用的特性之一莫过于 “撤销（undo）”操作。在Git中，“撤销”有很多种含义。<br>当你完成了一次新的提交（commit），Git会及时存储当前时刻仓库（repository）的快照（snapshot）；你能够使用Git将项目回退到任何之前的版本。<br>下文中，我将列举几个常见的、需要“撤销”的场景，并且展示如何使用Git来完成这些操作。</p>
<h3 id="一、撤销一个公共修改_Undo_a_“public”_change">一、撤销一个公共修改 Undo a “public” change</h3><p><strong>场景：</strong>你刚刚用git push将本地修改推送到了GitHub，这时你意识到在提交中有一个错误。你想撤销这次提交。</p>
<p><strong>使用撤销命令：</strong><code>git revert</code></p>
<p><strong>发生了什么：</strong>git revert将根据给定SHA的相反值，创建一个新的提交。如果旧提交是“matter”，那么新的提交就是“anti-matter”——旧提交中所有已移除的东西将会被添加进到新提交中，旧提交中增加的东西将在新提交中移除。</p>
<p>这是Git最安全、也是最简单的“撤销”场景，因为这样不会修改历史记录——你现在可以git push下刚刚revert之后的提交来纠正错误了。</p>
<a id="more"></a>
<h3 id="二、修改最近一次的提交信息_Fix_the_last_commit_message">二、修改最近一次的提交信息 Fix the last commit message</h3><p><strong>场景：</strong>你只是在最后的提交信息中敲错了字，比如你敲了git commit -m “Fxies bug #42”，而在执行git push之前你已经意识到你应该敲”Fixes bug #42”。</p>
<p><strong>使用撤销命令：</strong><code>git commit –amend或git commit --amend -m &quot;Fixes bug #42&quot;</code></p>
<p><strong>发生了什么：</strong>git commit –amend将使用一个包含了刚刚错误提交所有变更的新提交，来更新并替换这个错误提交。由于没有staged的提交，所以实际上这个提交只是重写了先前的提交信息。</p>
<h3 id="三、撤销本地更改_Undo_“local”_changes">三、撤销本地更改 Undo “local” changes</h3><p><strong>场景：</strong>当你的猫爬过键盘时，你正在编辑的文件恰好被保存了，你的编辑器也恰在此时崩溃了。此时你并没有提交过代码。你期望撤销这个文件中的所有修改——将这个文件回退到上次提交的状态。</p>
<p><strong>使用撤销命令：</strong><code>git checkout --</code></p>
<p><strong>发生了什么：</strong>git checkout将工作目录（working directory）里的文件修改成先前Git已知的状态。你可以提供一个期待回退分支的名字或者一个确切的SHA码，Git也会默认检出HEAD——即：当前分支的上一次提交。</p>
<p><strong>注意：</strong>用这种方法“撤销”的修改都将真正的消失。它们永远不会被提交。因此Git不能恢复它们。此时，一定要明确自己在做什么！（或许可以用git diff来确定）</p>
<h3 id="四、重置本地修改_Reset_“local”_changes">四、重置本地修改 Reset “local” changes</h3><p><strong>场景：</strong>你已经在本地做了一些提交（还没push），但所有的东西都糟糕透了，你想撤销最近的三次提交——就像它们从没发生过一样。<br><strong>使用撤销命令：</strong><code>git reset或git reset --hard</code><br><strong>发生了什么：</strong>git reset将你的仓库纪录一直回退到指定的最后一个SHA代表的提交，那些提交就像从未发生过一样。默认情况下，git reset会保留工作目录（working directory）。这些提交虽然消失了，但是内容还在磁盘上。这是最安全的做法，但通常情况是：你想使用一个命令来“撤销”所有提交和本地修改——那么请使用—hard参数吧。</p>
<h3 id="五、撤销本地后重做_Redo_after_undo_“local”">五、撤销本地后重做 Redo after undo “local”</h3><p><strong>场景：</strong>你已经提交了一些内容，并使用git reset –hard撤销了这些更改（见上面），突然意识到：你想还原这些修改！<br><strong>使用撤销命令：</strong><code>git reflog和git reset, 或者git checkout</code><br><strong>发生了什么：</strong>git reflog是一个用来恢复项目历史记录的好办法。你可以通过git reflog恢复几乎任何已提交的内容。<br>你或许对git log命令比较熟悉，它能显示提交列表。git reflog与之类似，只不过git reflog显示的是HEAD变更次数的列表。</p>
<h3 id="一些说明：">一些说明：</h3><ol>
<li>只有HEAD会改变。当你切换分支时，用git commit提交变更时，或是用git reset撤销提交时，HEAD都会改变。但当你用git checkout —时， HEAD不会发生改变。（就像上文提到的情形，那些更改根本就没有提交，因此reflog就不能帮助我们进行恢复了）</li>
<li>git reflog不会永远存在。Git将会定期清理那些“不可达（unreachable）”的对象。不要期望能够在reflog里找到数月前的提交记录。</li>
<li>reflog只是你个人的。你不能用你的reflog来恢复其他开发者未push的提交。  </li>
</ol>
<p><img src="/img/2015/06/24/1.png" alt="">  </p>
<p>因此，怎样合理使用reflog来找回之前“未完成”的提交呢？这要看你究竟要做什么：  </p>
<ol>
<li>如果你想恢复项目历史到某次提交，那请使用git reset —hard</li>
<li>如果你想在工作目录（working direcotry）中恢复某次提交中的一个或多个文件，并且不改变提交历史，那请使用git checkout—</li>
<li>如果你想确切的回滚到某次提交，那么请使用git cherry-pick。</li>
</ol>
<h3 id="六、与分支有关的那些事_Once_more,_with_branching">六、与分支有关的那些事 Once more, with branching</h3><p><strong>场景：</strong>你提交了一些变更，然后你意识到你正在master分支上，但你期望的是在feature分支上执行这些提交。<br><strong>使用撤销命令：</strong><code>git branch feature, git reset --hard origin/master, 和 git checkout feature</code><br><strong>发生了什么：</strong>你可能用的是git checkout -b来建立新的分支，这是创建和检出分支的便捷方法——但实际你并不想立刻切换分支。git branch feature会建立一个叫feature的分支，这个分支指向你最近的提交，但是你还停留在master分支上。<br>git reset —hard将master回退至origin/master，并忽略所有新提交。别担心，那些提交都还保留在feature上。<br>最后，git checkout将分支切换到feature，这个分支原封不动的保留了你最近的所有工作。</p>
<h3 id="七、事半功倍处理分支_Branch_in_time_saves_nine">七、事半功倍处理分支 Branch in time saves nine</h3><p><strong>场景：</strong>你基于master新建了一个feature分支，但是master分支远远落后与origin/master。现在master分支与origin/master同步了，你期望此刻能在feature下立刻commit代码，并且不是在远远落后master的情况下。<br><strong>使用撤销命令：</strong><code>git checkout feature和git rebase master</code><br><strong>发生了什么：</strong>你也许已经敲了命令：git reset（但是没用—hard,有意在磁盘上保存这些提交内容），然后敲了git checkout -b，之后重新提交更改，但是那样的话，你将失去本地的提交记录。不过，一个更好的方法：</p>
<p><strong>使用git rebase master可以做到一些事情：</strong></p>
<ol>
<li>首先，它定位你当前检出分支和master之间的共同祖先节点（common ancestor）。</li>
<li>然后，它将当前检出的分支重置到祖先节点（ancestor），并将后来所有的提交都暂存起来。</li>
<li>最后，它将当前检出分支推进至master末尾，同时在master最后一次提交之后，再次提交那些在暂存区的变更。</li>
</ol>
<h3 id="八、批量撤销/找回_Mass_undo/redo">八、批量撤销/找回 Mass undo/redo</h3><p><strong>场景：</strong>你开始朝一个既定目标开发功能，但是中途你感觉用另一个方法更好。你已经有十几个提交，但是你只想要其中的某几个，其他的都可以删除不要。<br><strong>使用撤销命令：</strong><code>git rebase -i</code><br><strong>发生了什么：</strong>-i将rebases设置为“交互模式（interactive mode）”。rebase开始执行的操作就像上文讨论的一样，但是在重新执行某个提交时，它会暂停下来，让你修改每一次提交。<br>rebase –i将会打开你的默认文本编辑器，然后列出正在执行的提交，就像这样：<br><img src="/img/2015/06/24/2.png" alt=""><br>前两列最关键：第一列是选择命令，它会根据第二列中的SHA码选择相应的提交。默认情况下，rebase –i会认为每个更改都正通过pick命令被提交。<br>要撤销一个提交，直接在编辑器删除对应的行就可以了。如果在你的项目不再需要这些错误的提交，你可以直接删除上图中的第1行和3-4行。<br>如果你想保留提交但修改提交信息，你可以使用reword命令。即，将命令关键字pick换成reword（或者r）。你现在可能想立刻修改提交消息，但这么做不会生效——rebase –i将忽略SHA列后的所有东西。现有的提交信息会帮助我们记住0835fe2代表什么。当你敲完rebase –i命令后，Git才开始提示你重写那些新提交消息。<br>如果你需要将2个提交合并，你可以用squash或者fixup命令，如下图：<br><img src="/img/2015/06/24/3.png" alt=""><br>squash和fixup都是“向上”结合的——那些用了这些合并命令（编者按：指squash、fixup）的提交，将会和它之前的提交合并：上图中，0835fe2和6943e85将会合并成一个提交，而38f5e4e和af67f82将会合并成另一个提交。<br>当你用squash时，Git将会提示是否填写新的提交消息；fixup则会给出列表中第一个提交的提交信息。在上图中，af67f82是一个“Ooops”信息，因为这个提交信息已经同38f5e4e一样了。但是你可以为0835fe2和6943e85合并的新提交编写提交信息。<br>当你保存并退出编辑器时，Git将会按照从上到下的顺序执行你的提交。你可以在保存这些提交之前，修改提交的执行顺序。如果有需要，你可以将af67f82和0835fe2合并，并且可以这样排序：<br><img src="/img/2015/06/24/4.png" alt="">  </p>
<h3 id="九、修复早先的提交_Fix_an_earlier_commit">九、修复早先的提交 Fix an earlier commit</h3><p><strong>场景：</strong>之前的提交里落下了一个文件，如果先前的提交能有你留下的东西就好了。你还没有push，并且这个提交也不是最近的提交，因此你不能用commit –amend。<br><strong>使用撤销命令：</strong><code>git commit --squash和git rebase --autosquash -i</code><br><strong>发生了什么：</strong>git commit –squash将会创建一个新的提交，该提交信息可能像这样“squash! Earlier commit”。（你也可以手写这些提交信息，commit –squash只是省得让你打字了）。<br>如果你不想为合并的提交编写信息，也可以考虑使用命令git commit —fixup。这种情况下，你可能会使用commit —fixup，因为你仅希望在rebase中使用之前的提交信息。<br>rebase —autosquash –i将会启动rebase交互编辑器，编辑器会列出任何已完成的squash!和fixup!提交，如下图：<br><img src="/img/2015/06/24/5.png" alt=""><br>当使用—squash和–fixup时，你或许记不清你想修复的某个提交的SHA码——只知道它可能在一个或五个提交之前。你或许可以使用Git的^和~操作符手动找回。HEAD^表示HEAD的前一次提交。HEAD~4表示HEAD前的4次提交，加起来总共是前5次提交。</p>
<h3 id="十、停止跟踪一个已被跟踪的文件_Stop_tracking_a_tracked_file">十、停止跟踪一个已被跟踪的文件 Stop tracking a tracked file</h3><p><strong>场景：</strong>你意外将application.log添加到仓库中，现在你每次运行程序，Git都提示application.log中有unstaged的提交。你在.gitignore中写上”<em>.log”，但仍旧没用——怎样告诉Git“撤销”跟踪这个文件的变化呢？<br><strong>使用撤销命令：</strong> git rm —cached application.log<br><em>*发生了什么：</em></em>尽管.gitignore阻止Git跟踪文件的变化，甚至是之前没被跟踪的文件是否存在，但是，一旦文件被add或者commit，Git会开始持续跟踪这个文件的变化。类似的，如果你用git add –f来“强制”add，或者覆盖.gitignore，Git还是会继续监视变化。所以以后最好不要使用–f来add .gitignore文件。<br>如果你希望移除那些应当被忽略的文件，git rm –cached可以帮助你，并将这些文件保留在磁盘上。因为这个文件现在被忽略了，你将不会在git status中看到它，也不会再把这个文件commit了。<br>以上就是如何在Git上撤销的方法。如果你想学习更多Git命令用法，可以移步下面相关的文档：<br>· <a href="http://git-scm.com/docs/git-checkout" target="_blank" rel="external">checkout</a><br>· <a href="http://git-scm.com/docs/git-commit" target="_blank" rel="external">commit</a><br>· <a href="http://git-scm.com/docs/git-rebase" target="_blank" rel="external">rebase</a><br>· <a href="http://git-scm.com/docs/git-reflog" target="_blank" rel="external">reflog</a><br>· <a href="http://git-scm.com/docs/git-reset" target="_blank" rel="external">reset</a><br>· <a href="http://git-scm.com/docs/git-revert" target="_blank" rel="external">revert</a><br>· <a href="http://git-scm.com/docs/git-rm" target="_blank" rel="external">rm</a></p>
<p>原文地址：<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">Github</a><br>译文地址：<a href="http://www.jointforce.com/jfperiodical/article/show/796?m=d03" target="_blank" rel="external">http://www.jointforce.com/jfperiodical/article/show/796?m=d03</a></p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章非常详细的介绍了GIT中撤销提交的相关知识]]>
    
    </summary>
    
      <category term="GIT" scheme="http://sunxiang0918.github.io/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>Swift扩展的三个微妙细节]]></title>
    <link href="http://sunxiang0918.github.io/2015/05/18/Swift%E6%89%A9%E5%B1%95%E7%9A%84%E4%B8%89%E4%B8%AA%E5%BE%AE%E5%A6%99%E7%BB%86%E8%8A%82/"/>
    <id>http://sunxiang0918.github.io/2015/05/18/Swift扩展的三个微妙细节/</id>
    <published>2015-05-18T13:55:14.000Z</published>
    <updated>2015-07-31T14:08:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift扩展的三个微妙细节">Swift扩展的三个微妙细节</h1><p>每当我初次翻看某文档时，我都走马观花似的快速阅过，还一边点着头一边喃喃自语说：“好！懂了，就这么回事！”，可是过后当我真正要运用到这些我以为已经理解了的知识点时，却发现实际情况和我想的往往不一样，每当这时我就懵了，心想：“哇哦…怎么回事？这和我想的完全不一样啊！文档里有说这事吗？”。</p>
<p>最近的几次讨论促使我扪心自问是否真正的理解了Swift中的扩展。我阅读过关于扩展的文档，并且我“认为”我自己对这块内容已经是理解的相当透彻了。可是这几次讨论，加上自己私下通过敲代码的验证，让我发现了我原先不曾注意到几个微妙的细节。</p>
<p>更新：这篇文章刚一发表，Swift社区就出手襄助并帮助我弄明白了我最根本的纠结点在哪。为此，我写了另一篇文章“<a href="http://www.andrewcbancroft.com/2015/04/24/clarifying-swift-access-control-hint-swift-isnt-c-sharp/" target="_blank" rel="external">阐明Swift访问控制</a>”进一步说明我之前的误解。为了避免犯我曾今犯过的错误，我建议大家去读一读。</p>
<h2 id="三个关于扩展的微妙细节">三个关于扩展的微妙细节</h2><p>对下面列出的三个细节的思考严重挑战了我之前对Swift扩展的理解：</p>
<ol>
<li>Swift扩展对它所扩展类型的<strong>visibility</strong>。比如，扩展能访问被<code>private</code>所修饰的内容吗?</li>
<li>定义扩展的位置是否对扩展的<strong>visibility</strong>有影响。比如我这有一个类型我想写个扩展，把扩展写在同一个源文件里和把扩展写在另一个文件里有什么区别吗？</li>
<li>扩展里“成员”的默认访问修饰符以及是否给他们添加修饰对这个扩展作为一个类型的公共接口的影响。</li>
</ol>
<a id="more"></a>
<p>在我开始之前，假设我有一个公共结构体<code>Person</code>。这个结构体有一些私有属性，<code>name</code>，<code>gender</code>，和<code>age</code>。用一个枚举把<code>Gender</code>封装了一下。这个结构体看起来如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    private <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    private <span class="keyword">var</span> gender: <span class="type">Gender</span></span><br><span class="line">    private <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"> </span><br><span class="line">    public <span class="keyword">init</span>(name: <span class="type">String</span>, gender: <span class="type">Gender</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.gender = gender</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">howOldArdYou</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formattedAge()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 私有方法，用于下面分析扩展的`visibility`...</span></span><br><span class="line">    private <span class="func"><span class="keyword">func</span> <span class="title">formattedAge</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span>.gender &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Male</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"I'm <span class="subst">\(<span class="keyword">self</span>.age)</span>."</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">Female</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Not telling."</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Male</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Female</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，就让我们给<code>Person</code>写个扩展，通过实践来弄清楚刚刚提到的三个小细节…</p>
<h2 id="扩展对类型的访问能力">扩展对类型的访问能力</h2><p>当我提出第一个细节时，关于扩展对被扩展类型的访问能力时，我问了一个问题：“扩展能访问到被<code>private</code>修饰的内容吗?”。答案一开始出乎我的预料：能…扩展能访问到。</p>
<p>然而，这里就要考虑到第二个细节所涉及的问题，那就是：在哪里定义这个扩展是绝对有影响的。</p>
<h3 id="定义在同一个文件里">定义在同一个文件里</h3><p>如果扩展和类型是在写同一个源文件里，则扩展能访问到在类型中被<code>priavte</code>所修饰的内容。</p>
<p>举个栗子，在Person.swift里定义一个<code>Person</code>的扩展就会允许这个扩展访问被<code>private</code>修饰的变量和方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getAge</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age <span class="comment">// 尽管age是 --private--， 但编译成功</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getFormattedAge</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formattedAge() <span class="comment">// 尽管 formattedAge是 --private--，但编译成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“这谁知道？！什么？？为啥？”，我当时就没想明白…</p>
<p>至于为什么把扩展写在同一个源文件里头会这样，我自己的推理是其实可以在写类型的时候，就把扩展的implementation当作类型的一部分给写了，这样的最终效果是一样的。</p>
<p>我在我要“扩展”的类型的源文件里，所以无论是我把要新添加的功能当作这个类型的扩展写下来，或是就在这个类型里面定义我原本打算写在扩展里的功能是没有区别的，都是一样的效果。</p>
<p>所以，站在编译器的角度来看，编译器可能会说：“好吧，我看到这里写了一个扩展，但是真没这个必要，因为扩展和类型都在同一个源文件里…，所以开发者完全可以把扩展里的这些代码直接写在类型里面…，所以他／她能够访问到被<code>private</code>修饰的代码段。”</p>
<p>更新:我上面的写的推理恰恰说明了我压根就没搞明白Swift访问控制机制。所以我建议大家读一读我后来写的“<a href="http://www.andrewcbancroft.com/2015/04/24/clarifying-swift-access-control-hint-swift-isnt-c-sharp/" target="_blank" rel="external">阐明Swfit控制机制</a>”这篇文章，里面有更多的细节。</p>
<h3 id="定义在不同文件里">定义在不同文件里</h3><p>把扩展写在另一个文件里，则扩展无法访问类型中那些被<code>private</code>修饰的内容了。</p>
<p>按照上文我自己推理的逻辑来反过来想，定义在不同文件中就访问不了私有属性对我来说也是说的通的。</p>
<p>大多数情况下，你都会给那些你没有源代码的类型扩展，在这种情况下，扩展就只能访问那些被<code>public</code>修饰的内容了。<br><img src="/img/2015/05/18/1.png" alt=""></p>
<h2 id="默认情况下的扩展访问控制">默认情况下的扩展访问控制</h2><p>对最后一个细节的验证也让我更深的体会。<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID25" target="_blank" rel="external">苹果官方文档</a>说了，但是直到我动手验证了一番，我才算领会到了默认访问控制修饰符给扩展所造成的微妙的影响。</p>
<h3 id="没有明确声明访问修饰赋时的默认访问">没有明确声明访问修饰赋时的默认访问</h3><p>简单的说，当你声明一个扩展但没有特别明确指明访问修饰符时（默认情况下），这个扩展的默认访问等级取决于被扩展的那个类型的访问等级。</p>
<ul>
<li>如果类型是<code>public</code>或者是<code>internal</code>，那么扩展的implementation的“成员”就默认为<code>internal</code>。这里让我没想到是，除非你特别声明，那么给<code>public</code>类型的扩展的成员变量在默认情况下也是<code>internal</code>。</li>
<li>如果类型是<code>private</code>，那么默认情况下扩展的implementation中的“成员”也是<code>private</code></li>
</ul>
<p>下面就是在我们不明确的声明添加什么访问修饰的前提下，来看扩展会是一个什么反应（为了能访问私有属性变量和方法，我在Person.swift里定义了这个扩展）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getAge</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">getFormattedAge</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> formattedAge()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这段代码用默认的访问修饰符时就会允许在同一个模块中的实例访问扩展里的API。但是，如果被扩展的类型的实例是在另一个模块（比如在测试模块）,则无法访问扩展中任何新增的公共API。</p>
<p>同一模块</p>
<p><img src="/img/2015/05/18/2.png" alt=""></p>
<p>不同模块（测试）</p>
<p><img src="/img/2015/05/18/3.png" alt=""><br>因为某些原因，我一直都以为如果给一个是<code>public</code>的类型添加扩展，那么扩展里的成员也理应是<code>public</code>。我不知道为什么我会这么想，但是幸好我的验证把这点捋清楚了。</p>
<h3 id="正常声明扩展，但给扩展的implementation添加public修饰">正常声明扩展，但给扩展的implementation添加public修饰</h3><p>给扩展的implementation的成员添加了<code>public</code>访问控制修饰，那么不管是在同一模块还是不同模块（test target）都能访问这些成员。</p>
<p>只要成员被<code>public</code>修饰，那么在同一个源文件里声明扩展还是在另一个文件里声明扩展已经无所谓了…但是，正如前文所讲，只有在同一个源文件中声明的扩展才能够访问那些被<code>private</code>修饰的类型成员变量。</p>
<p>在不同（左）和同一个（右）源文件中声明的扩展</p>
<p><img src="/img/2015/05/18/4.png" alt=""></p>
<p>在不同模块中也能访问公共的扩展成员变量</p>
<p><img src="/img/2015/05/18/5.png" alt=""><br>这里请注意，在我写<code>extension Person {...}</code>时，我没有给这个扩展添加任何的修饰，我只是给这个扩展的成员添加了<code>public</code>。即便如此，新添加的方法仍然可以在不同的模块中被访问到。</p>
<p>也就是说，没有必要写<code>public extension Person {...}</code>。因为<code>Person</code>已经是<code>public</code>了，所以基于<code>Person</code>的扩展也就很自然的延用了类型本身的访问等级。</p>
<p>总结<br>对我来说，这篇文章所提到的三个关于Swift扩展的细节已足以让我敲敲代码去验证一番了。我希望这里所作的分析能够为那些尝试理解Swfit扩展的朋友扫清一些障碍。</p>
<hr>
<p>原文链接:<a href="http://www.devtf.cn/?p=460" target="_blank" rel="external">http://www.devtf.cn/?p=460</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift扩展的三个微妙细节">Swift扩展的三个微妙细节</h1><p>每当我初次翻看某文档时，我都走马观花似的快速阅过，还一边点着头一边喃喃自语说：“好！懂了，就这么回事！”，可是过后当我真正要运用到这些我以为已经理解了的知识点时，却发现实际情况和我想的往往不一样，每当这时我就懵了，心想：“哇哦…怎么回事？这和我想的完全不一样啊！文档里有说这事吗？”。</p>
<p>最近的几次讨论促使我扪心自问是否真正的理解了Swift中的扩展。我阅读过关于扩展的文档，并且我“认为”我自己对这块内容已经是理解的相当透彻了。可是这几次讨论，加上自己私下通过敲代码的验证，让我发现了我原先不曾注意到几个微妙的细节。</p>
<p>更新：这篇文章刚一发表，Swift社区就出手襄助并帮助我弄明白了我最根本的纠结点在哪。为此，我写了另一篇文章“<a href="http://www.andrewcbancroft.com/2015/04/24/clarifying-swift-access-control-hint-swift-isnt-c-sharp/">阐明Swift访问控制</a>”进一步说明我之前的误解。为了避免犯我曾今犯过的错误，我建议大家去读一读。</p>
<h2 id="三个关于扩展的微妙细节">三个关于扩展的微妙细节</h2><p>对下面列出的三个细节的思考严重挑战了我之前对Swift扩展的理解：</p>
<ol>
<li>Swift扩展对它所扩展类型的<strong>visibility</strong>。比如，扩展能访问被<code>private</code>所修饰的内容吗?</li>
<li>定义扩展的位置是否对扩展的<strong>visibility</strong>有影响。比如我这有一个类型我想写个扩展，把扩展写在同一个源文件里和把扩展写在另一个文件里有什么区别吗？</li>
<li>扩展里“成员”的默认访问修饰符以及是否给他们添加修饰对这个扩展作为一个类型的公共接口的影响。</li>
</ol>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>74个Swift标准库函数]]></title>
    <link href="http://sunxiang0918.github.io/2015/03/25/74%E4%B8%AASwift%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://sunxiang0918.github.io/2015/03/25/74个Swift标准库函数/</id>
    <published>2015-03-25T14:33:03.000Z</published>
    <updated>2015-07-31T14:48:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="74个Swift标准库函数">74个Swift标准库函数</h1><blockquote>
<p>本文译自 <a href="http://practicalswift.com/2014/06/14/the-swift-standard-library-list-of-built-in-functions/" target="_blank" rel="external">Swift Standard Library: Documented and undocumented built-in functions in the Swift standard library – the complete list with all 74 functions</a>。我不是原作者，我只是勤劳的翻译工：）文中作者没有提及他是如何发现这么多未在文档中体现的内置函数的，估计是反编译的结果。我测试了好多个都能用，而且Xcode还会给出语法提示：）</p>
</blockquote>
<p>Swift包含了74个内置函数，但在<code>The Swift Programming Langage</code>一书中只介绍了其中的7个，其它的都没有在文档中体现。</p>
<p>这篇文章列举出了所有的内置Swift函数。文中所谓的<code>内置函数</code>是指无需引入任何模块（比如说Fundation等）即可以直接使用的函数。</p>
<a id="more"></a>
<h2 id="下面先来看看7个在文档中提到的内置函数：">下面先来看看7个在文档中提到的内置函数：</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//断言，参数如果为`true`则继续，否则抛出异常</span></span><br><span class="line"><span class="comment">// assert mentioned on page 55</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算序列的元素个数</span></span><br><span class="line"><span class="comment">// countElements mentioned on page 79</span></span><br><span class="line"><span class="built_in">countElements</span>(<span class="string">"foo"</span>) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个新的序列，其中每个元素是一个元组，第一个值为原来元素所在的位置`index`，第二个为原来序列中的元素</span></span><br><span class="line"><span class="comment">// enumerate mentioned on page 94</span></span><br><span class="line"><span class="keyword">for</span> (i, j) <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">"A"</span>, <span class="string">"B"</span>]) &#123;</span><br><span class="line">    <span class="comment">// "0:A", "1:B" will be printed</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"<span class="subst">\(i)</span>:<span class="subst">\(j)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回所有参数中的最小值</span></span><br><span class="line"><span class="comment">// min mentioned on page 246</span></span><br><span class="line"><span class="built_in">min</span>(<span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="comment">// print mentioned on page 85</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印（带换行）</span></span><br><span class="line"><span class="comment">// println mentioned on page 4</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"World"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="comment">// sort mentioned on page 14</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sort</span>([<span class="string">"B"</span>, <span class="string">"A"</span>]) &#123;</span><br><span class="line">    <span class="comment">// "A", "B" will be printed</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="下面列出一些很实用，但未在文档中体现的内置函数：">下面列出一些很实用，但未在文档中体现的内置函数：</h2><ul>
<li><strong>abs(signedNumber)：</strong>返回数字的绝对值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">abs</span>(-<span class="number">1</span>) == <span class="number">1</span></span><br><span class="line"><span class="built_in">abs</span>(-<span class="number">42</span>) == <span class="number">42</span></span><br><span class="line"><span class="built_in">abs</span>(<span class="number">42</span>) == <span class="number">42</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>contains(sequence, element)：</strong>如果某个序列<code>sequence</code>（比如说一个数组）包含指定的元素element，则返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="built_in">contains</span>(languages, <span class="string">"Swift"</span>) == <span class="literal">true</span></span><br><span class="line"><span class="built_in">contains</span>(languages, <span class="string">"Java"</span>) == <span class="literal">false</span></span><br><span class="line"><span class="built_in">contains</span>([<span class="number">29</span>, <span class="number">85</span>, <span class="number">42</span>, <span class="number">96</span>, <span class="number">75</span>], <span class="number">42</span>) == <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>dropFirst(sequence)：</strong>返回一个去掉了首个元素的、新的序列（比如一个新数组）。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="keyword">var</span> oldLanguages = <span class="built_in">dropFirst</span>(languages)</span><br><span class="line"><span class="built_in">equal</span>(oldLanguages, [<span class="string">"Objective-C"</span>]) == <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>dropLast(sequence)：</strong>返回一个去掉了最后一个元素的、新的序列（比如一个新数组）。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="keyword">var</span> newLanguages = <span class="built_in">dropLast</span>(languages)</span><br><span class="line"><span class="built_in">equal</span>(newLanguages, [<span class="string">"Swift"</span>]) == <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>dump(object)：</strong>打印出某个对象<code>object</code>的所有信息</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="built_in">dump</span>(languages)</span><br><span class="line"><span class="comment">// Prints:</span></span><br><span class="line"><span class="comment">// ▿ 2 elements</span></span><br><span class="line"><span class="comment">//   - [0]: Swift</span></span><br><span class="line"><span class="comment">//   - [1]: Objective-C</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>equal(sequence1, sequence2)：</strong>判断两个序列是否相等</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="built_in">equal</span>(languages, [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]) == <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> oldLanguages = <span class="built_in">dropFirst</span>(languages)</span><br><span class="line"><span class="built_in">equal</span>(oldLanguages, [<span class="string">"Objective-C"</span>]) == <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>filter(sequence, includeElementClosure)：</strong>对序列<code>sequence</code>中每个元素都执行includeElementClosure闭包，并将所有闭包结果为<code>true</code>的元素合成一个新序列<code>sequence</code>并返回。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="number">1</span>...<span class="number">100</span>, &#123; $<span class="number">0</span> % <span class="number">10</span> == <span class="number">0</span> &#125;) &#123;</span><br><span class="line">    <span class="comment">// 10, 20, 30, ...</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">contains</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>], i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>find(sequence, element)：</strong>返回序列<code>sequence</code>中某元素<code>element</code>的位置<code>index</code>。如果序列中不存在此元素，则返回<code>nil</code>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="built_in">find</span>(languages, <span class="string">"Objective-C"</span>) == <span class="number">1</span></span><br><span class="line"><span class="built_in">find</span>(languages, <span class="string">"Java"</span>) == <span class="literal">nil</span></span><br><span class="line"><span class="built_in">find</span>([<span class="number">29</span>, <span class="number">85</span>, <span class="number">42</span>, <span class="number">96</span>, <span class="number">75</span>], <span class="number">42</span>) == <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>indices(sequence)：</strong>返回序列<code>sequence</code>中所有元素的位置（<code>indices</code>是<code>index</code>的复数）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">equal</span>(<span class="built_in">indices</span>([<span class="number">29</span>, <span class="number">85</span>, <span class="number">42</span>]), [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">indices</span>([<span class="number">29</span>, <span class="number">85</span>, <span class="number">42</span>]) &#123;</span><br><span class="line">    <span class="comment">// 0, 1, 2</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>join(separator, sequence)：</strong>将序列<code>sequence</code>通过分隔符<code>separator</code>连成一个字符串，并返回此字符串。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">join</span>(<span class="string">":"</span>, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>]) == <span class="string">"A:B:C"</span></span><br><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="built_in">join</span>(<span class="string">"/"</span>, languages) == <span class="string">"Swift/Objective-C"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>map(sequence, transformClosure)：</strong>对序列<code>sequence</code>中每个元素都执行<code>includeElementClosure</code>闭包，并将所有闭包的结果合成一个新序列<code>sequence</code>并返回。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">equal</span>(<span class="built_in">map</span>(<span class="number">1</span>...<span class="number">3</span>, &#123; $<span class="number">0</span> * <span class="number">5</span> &#125;), [<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">map</span>(<span class="number">1</span>...<span class="number">10</span>, &#123; $<span class="number">0</span> * <span class="number">10</span> &#125;) &#123;</span><br><span class="line">    <span class="comment">// 10, 20, 30, ...</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">contains</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>], i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>max(comparable1, comparable2, etc.)：</strong>返回参数中的最大值。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span></span><br><span class="line"><span class="built_in">max</span>(<span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>) == <span class="number">8</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>maxElement(sequence)：</strong>返回序列sequence中的最大值。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">maxElement</span>(<span class="number">1</span>...<span class="number">10</span>) == <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="built_in">maxElement</span>(languages) == <span class="string">"Swift"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>minElements(sequence)：</strong>返回序列sequence中的最小值。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">minElement</span>(<span class="number">1</span>...<span class="number">10</span>) == <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="built_in">minElement</span>(languages) == <span class="string">"Objective-C"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>reduce(sequence, initial, combineClosure)：</strong>给定一个序列<code>sequence</code>，以及一个初始值<code>initial</code>，然后将<code>initial</code>和序列里的第1个元素作为参数传入<code>combineClosure</code>中进行运算，得到的结果保存到<code>initial</code>；然后再将<code>initial</code>和第2个元素传入<code>combineClosure</code>中计算，结果保存到<code>initial</code>；重复计算直到所有<code>sequence</code>中的元素都计算完毕，并返回最终的<code>initial</code>值。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="built_in">reduce</span>(languages, <span class="string">""</span>, &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;) == <span class="string">"SwiftObjective-C"</span></span><br><span class="line"><span class="built_in">reduce</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>], <span class="number">1</span>, &#123; $<span class="number">0</span> * $<span class="number">1</span> &#125;) == <span class="number">1000</span></span><br><span class="line"><span class="built_in">reverse</span>(sequence)：返回逆序的序列sequence。</span><br><span class="line"><span class="built_in">equal</span>(<span class="built_in">reverse</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]), [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reverse</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="comment">// 3, 2, 1</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>startsWith(sequence1, sequence2)：</strong>如果序列<code>sequence1</code>中开头的元素跟序列<code>sequence2</code>中的所有元素都相等，则返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">startsWith</span>(<span class="string">"foobar"</span>, <span class="string">"foo"</span>) == <span class="literal">true</span></span><br><span class="line"><span class="built_in">startsWith</span>(<span class="number">10</span>..<span class="number">100</span>, <span class="number">10</span>..<span class="number">15</span>) == <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> languages = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>]</span><br><span class="line"><span class="built_in">startsWith</span>(languages, [<span class="string">"Swift"</span>]) == <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面提到的函数是我认为在Swift编程中会经常用到的函数。下面将列出完整的74个函数列表。</p>
<h2 id="完整74个内置函数：">完整74个内置函数：</h2><p>abs(…)<br>advance(…)<br>alignof(…)<br>alignofValue(…)<br>assert(…)<br>bridgeFromObjectiveC(…)<br>bridgeFromObjectiveCUnconditional(…)<br>bridgeToObjectiveC(…)<br>bridgeToObjectiveCUnconditional(…)<br>c_malloc_size(…)<br>c_memcpy(…)<br>c_putchar(…)<br>contains(…)<br>count(…)<br>countElements(…)<br>countLeadingZeros(…)<br>debugPrint(…)<br>debugPrintln(…)<br>distance(…)<br>dropFirst(…)<br>dropLast(…)<br>dump(…)<br>encodeBitsAsWords(…)<br>enumerate(…)<br>equal(…)<br>filter(…)<br>find(…)<br>getBridgedObjectiveCType(…)<br>getVaList(…)<br>indices(…)<br>insertionSort(…)<br>isBridgedToObjectiveC(…)<br>isBridgedVerbatimToObjectiveC(…)<br>isUniquelyReferenced(…)<br>join(…)<br>lexicographicalCompare(…)<br>map(…)<br>max(…)<br>maxElement(…)<br>min(…)<br>minElement(…)<br>numericCast(…)<br>partition(…)<br>posix_read(…)<br>posix_write(…)<br>print(…)<br>println(…)<br>quickSort(…)<br>reduce(…)<br>reflect(…)<br>reinterpretCast(…)<br>reverse(…)<br>roundUpToAlignment(…)<br>sizeof(…)<br>sizeofValue(…)<br>sort(…)<br>split(…)<br>startsWith(…)<br>strideof(…)<br>strideofValue(…)<br>swap(…)<br>swift_MagicMirrorData_summaryImpl(…)<br>swift_bufferAllocate(…)<br>swift_keepAlive(…)<br>toString(…)<br>transcode(…)<br>underestimateCount(…)<br>unsafeReflect(…)<br>withExtendedLifetime(…)<br>withObjectAtPlusZero(…)<br>withUnsafePointer(…)<br>withUnsafePointerToObject(…)<br>withUnsafePointers(…)<br>withVaList(…)</p>
<hr>
<p><strong>原文链接:</strong><a href="http://swiftist.org/topics/126" target="_blank" rel="external">http://swiftist.org/topics/126</a></p>
<p><strong>update:</strong>这篇原文写于14年6月.当时的Swift版本还是1.0. 现在已经是swift2.0了.因此可能有些变化.<br>我会找时间把里面的内置函数都过一遍.看是否有什么变化</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="74个Swift标准库函数">74个Swift标准库函数</h1><blockquote>
<p>本文译自 <a href="http://practicalswift.com/2014/06/14/the-swift-standard-library-list-of-built-in-functions/">Swift Standard Library: Documented and undocumented built-in functions in the Swift standard library – the complete list with all 74 functions</a>。我不是原作者，我只是勤劳的翻译工：）文中作者没有提及他是如何发现这么多未在文档中体现的内置函数的，估计是反编译的结果。我测试了好多个都能用，而且Xcode还会给出语法提示：）</p>
</blockquote>
<p>Swift包含了74个内置函数，但在<code>The Swift Programming Langage</code>一书中只介绍了其中的7个，其它的都没有在文档中体现。</p>
<p>这篇文章列举出了所有的内置Swift函数。文中所谓的<code>内置函数</code>是指无需引入任何模块（比如说Fundation等）即可以直接使用的函数。</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT 两个仓库的合并]]></title>
    <link href="http://sunxiang0918.github.io/2015/01/13/GIT-%E4%B8%A4%E4%B8%AA%E4%BB%93%E5%BA%93%E7%9A%84%E5%90%88%E5%B9%B6/"/>
    <id>http://sunxiang0918.github.io/2015/01/13/GIT-两个仓库的合并/</id>
    <published>2015-01-13T05:47:18.000Z</published>
    <updated>2015-08-01T06:04:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="GIT_两个仓库的合并">GIT 两个仓库的合并</h1><p>情况是这样的,以前我们的全文检索引擎是按照模块提交到不同的Git仓库上的. 现在做新的检索引擎准备按照springframe那样,按照模块还是提交到一个Git仓库中,便于版本的维护.<br>这就牵涉到,需要把以前的一些模块仓库,合并到一起来.因为我们还是想保留以前的提交记录等等.而不是直接新建一个仓库,然后把代码都拷贝到一起.这样就会丢失以前的提交记录.</p>
<h2 id="操作过程是这样的:">操作过程是这样的:</h2><ol>
<li><p>先在<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">sourcetree</a>中 <code>clone</code>新的仓库.比如:<a href="http://127.0.0.1/a.git" target="_blank" rel="external">http://127.0.0.1/a.git</a></p>
 <a id="more"></a>
</li>
<li><p>然后在<code>sourcetree</code>中 增加新的远程仓库. 地址是旧的仓库地址:<br> <img src="/img/2015/01/13/1.png" alt=""><br> <img src="/img/2015/01/13/2.png" alt="">  </p>
<p> 这时界面是这样的:<br> <img src="/img/2015/01/13/3.png" alt="">  </p>
</li>
<li><p>右键选中temp远程仓库:</p>
<p> <img src="/img/2015/01/13/4.png" alt="">  </p>
</li>
<li><p>选择 <code>Fetch from temp</code> 抓取远程分支数据到本地仓库:</p>
<p> <img src="/img/2015/01/13/5.png" alt="">  </p>
</li>
<li><p>然后选择master分支,<code>check out</code></p>
<p> <img src="/img/2015/01/13/6.png" alt="">  </p>
<p> <img src="/img/2015/01/13/7.png" alt="">  </p>
</li>
<li><p>切换回本地的<code>master</code>分支</p>
<p> <img src="/img/2015/01/13/8.png" alt="">  </p>
</li>
<li><p>然后选择合并<code>master</code>和<code>temp</code>分支</p>
<p> <img src="/img/2015/01/13/9.png" alt="">  </p>
<p> 合并结果:</p>
<p> <img src="/img/2015/01/13/10.png" alt="">  </p>
</li>
<li><p>最后提交到新仓库的<code>master</code>分支上,就OK了.</p>
<p> <img src="/img/2015/01/13/11.png" alt="">  </p>
</li>
<li><p>最后再删除本地和远程的<code>temp</code>分支即可</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="GIT_两个仓库的合并">GIT 两个仓库的合并</h1><p>情况是这样的,以前我们的全文检索引擎是按照模块提交到不同的Git仓库上的. 现在做新的检索引擎准备按照springframe那样,按照模块还是提交到一个Git仓库中,便于版本的维护.<br>这就牵涉到,需要把以前的一些模块仓库,合并到一起来.因为我们还是想保留以前的提交记录等等.而不是直接新建一个仓库,然后把代码都拷贝到一起.这样就会丢失以前的提交记录.</p>
<h2 id="操作过程是这样的:">操作过程是这样的:</h2><ol>
<li><p>先在<a href="https://www.sourcetreeapp.com/">sourcetree</a>中 <code>clone</code>新的仓库.比如:<a href="http://127.0.0.1/a.git">http://127.0.0.1/a.git</a></p>]]>
    
    </summary>
    
      <category term="GIT" scheme="http://sunxiang0918.github.io/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<翻译>象印NPVD-10电饭煲使用说明]]></title>
    <link href="http://sunxiang0918.github.io/2014/12/29/%E8%B1%A1%E5%8D%B0VD-10%E7%94%B5%E9%A5%AD%E7%85%B2%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://sunxiang0918.github.io/2014/12/29/象印VD-10电饭煲使用说明/</id>
    <published>2014-12-29T04:52:45.000Z</published>
    <updated>2015-07-31T15:13:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="象印NPVD-10电饭煲使用说明">象印NPVD-10电饭煲使用说明</h1><p>最近日淘非常的流行,特别是<code>电饭煲``马桶盖</code>这些玩意儿.<br>结果我一朋友跑日本去耍,带回来一个象印的电饭煲,据说还是特别热门的型号.<br>但是他买回来才发现看不懂.于是这个时候想起了我这个自学过一年日语的半吊子帮忙…<br>于是乎,凭着隐约还记得一点的日语,挑重点帮他翻译了一下说明书.<br>我想既然是热门型号.那我就把这个东西放上来,有需要的就自取吧.</p>
<a id="more"></a>
<p><img src="/img/2014/12/29/1.png" alt=""><br><a href="/img/2014/12/29/1.png">查看原图</a></p>
<p><img src="/img/2014/12/29/2.png" alt=""><br><a href="/img/2014/12/29/2.png">查看原图</a></p>
<p><img src="/img/2014/12/29/3.png" alt=""><br><a href="/img/2014/12/29/3.png">查看原图</a></p>
<p><img src="/img/2014/12/29/4.png" alt=""><br><a href="/img/2014/12/29/4.png">查看原图</a></p>
<p><img src="/img/2014/12/29/5.png" alt=""><br><a href="/img/2014/12/29/5.png">查看原图</a></p>
<p><img src="/img/2014/12/29/6.png" alt=""><br><a href="/img/2014/12/29/6.png">查看原图</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="象印NPVD-10电饭煲使用说明">象印NPVD-10电饭煲使用说明</h1><p>最近日淘非常的流行,特别是<code>电饭煲``马桶盖</code>这些玩意儿.<br>结果我一朋友跑日本去耍,带回来一个象印的电饭煲,据说还是特别热门的型号.<br>但是他买回来才发现看不懂.于是这个时候想起了我这个自学过一年日语的半吊子帮忙…<br>于是乎,凭着隐约还记得一点的日语,挑重点帮他翻译了一下说明书.<br>我想既然是热门型号.那我就把这个东西放上来,有需要的就自取吧.</p>]]>
    
    </summary>
    
      <category term="其他" scheme="http://sunxiang0918.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
      <category term="生活" scheme="http://sunxiang0918.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JDK新特性思维导图]]></title>
    <link href="http://sunxiang0918.github.io/2014/12/06/JDK%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://sunxiang0918.github.io/2014/12/06/JDK新特性思维导图/</id>
    <published>2014-12-06T13:37:44.000Z</published>
    <updated>2015-07-30T13:44:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JDK新特性思维导图">JDK新特性思维导图</h1><p>这篇文章是我重温JDK1.5开始的新特性的时候整理的思维导图,可以当做大纲来查看.有时搞忘的时候可以拿来再看看.</p>
<p><img src="/img/2014/12/06/1.png" alt=""></p>
<p><a href="/img/2014/12/06/1.png">查看原图</a></p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章是我在重温JDK1.5开始的新特性的时候整理的思维导图,可以当做大纲来查看]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[zookeeper 集群部署]]></title>
    <link href="http://sunxiang0918.github.io/2014/09/20/zookeeper-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2014/09/20/zookeeper-集群部署/</id>
    <published>2014-09-20T11:55:15.000Z</published>
    <updated>2015-07-31T01:54:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="zookeeper_集群部署">zookeeper 集群部署</h1><p>在现在的软件系统中,通常都会搭建集群或者分布式环境了.而在这种情况下,通常都需要一个分布式程序协调者的服务.这最常用的就是zookeeper了.<br>在我们的系统中,会使用zookeeper来做<code>统一的配置管理</code>,集群<code>节点状态管理</code>,以及<code>分布式锁</code>的功能.<br>为了保证zookeeper本身的高可用性,那么这就需要对ZK进行集群.</p>
<h2 id="安装环境">安装环境</h2><p>操作系统:Ubuntu 12.04 64位<br>JDK:1.7.0_55 64位<br>机器: <code>192.168.1.100</code> <code>192.168.1.101</code>  <code>192.168.1.101</code></p>
<h2 id="安装步骤">安装步骤</h2><a id="more"></a>
<h3 id="1-_下载Zookeeper">1. 下载Zookeeper</h3><p>直接到他的官网上下载最新的zookeeper软件: <a href="http://zookeeper.apache.org/releases.html#download" target="_blank" rel="external">http://zookeeper.apache.org/releases.html#download</a></p>
<p><img src="/img/2014/09/20/1.png" alt=""></p>
<h3 id="2-_上传Zookeeper安装包到服务器">2. 上传Zookeeper安装包到服务器</h3><p>这个随便使用什么东西上传都可以, <code>sft</code> <code>scp</code> 等等</p>
<h3 id="3-_为Zookeeper创建目录-">3. 为Zookeeper创建目录.</h3><p>在bash中创建文件夹. 我把目录建到 /usr/local/下的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /usr/<span class="built_in">local</span>/zookeeper</span><br></pre></td></tr></table></figure>
<h3 id="4-_解压安装包到zk的目录">4. 解压安装包到zk的目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar –xzvf zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz /usr/<span class="built_in">local</span>/zookeeper</span><br></pre></td></tr></table></figure>
<h3 id="5-_再创建几个ZK必要的文件夹">5. 再创建几个ZK必要的文件夹</h3><p>ZK还需要创建几个运行时必要的文件夹: 一个用来存放数据<code>data</code>,一个用来存放数据日志的<code>datalog</code>,以及一个存放ZK运行时日志的目录<code>logs</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /usr/<span class="built_in">local</span>/zookeeper/data</span><br><span class="line">$ mkdir /usr/<span class="built_in">local</span>/zookeeper/datalog</span><br><span class="line">$ mkdir /usr/<span class="built_in">local</span>/zookeeper/logs</span><br></pre></td></tr></table></figure>
<h3 id="6-_在data目录中创建一个myid文件">6. 在data目录中创建一个myid文件</h3><p>这个文件主要是用于标示自己是哪一个服务器的.文件的内容很简单,里面就是一个数字.<br>比如自己的server1,那么里面就写一个<code>1</code>.如果是server2,那么里面就写一个<code>2</code>.</p>
<h3 id="7-_配置ZK的配置文件zoo-cfg">7. 配置ZK的配置文件zoo.cfg</h3><p>接下来进入zk的conf目录.这个目录中应该有一个<code>zoo_sample.cfg</code>的文件.拷贝这个文件,并重命名为<code>zoo.cfg</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<h3 id="8-_修改zoo-cfg文件的内容">8. 修改zoo.cfg文件的内容</h3><p>配置的内容如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line">initLimit=<span class="number">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=<span class="number">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/zookeeper/data</span><br><span class="line">dataLogDir=/usr/<span class="built_in">local</span>/zookeeper/datalog</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"></span><br><span class="line">minSessionTimeout=<span class="number">1000</span></span><br><span class="line">maxSessionTimeout=<span class="number">1500</span></span><br><span class="line"></span><br><span class="line">server.<span class="number">1</span>=<span class="number">192.168</span>.<span class="number">1.100</span>:<span class="number">2888</span>:<span class="number">3888</span>  </span><br><span class="line">server.<span class="number">2</span>=<span class="number">192.168</span>.<span class="number">1.101</span>:<span class="number">2888</span>:<span class="number">3888</span>  </span><br><span class="line">server.<span class="number">3</span>=<span class="number">192.168</span>.<span class="number">1.102</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure>
<p><strong>参数说明:</strong><br><code>tickTime</code>：zookeeper中使用的基本时间单位, 毫秒值.</p>
<p><code>initLimit</code>: zookeeper集群中的包含多台server, 其中一台为leader, 集群中其余的server为follower。 initLimit参数配置初始化连接时, follower和leader之间的最长心跳时间. 此时该参数设置为5, 说明时间限制为5倍tickTime, 即5*2000=10000ms=10s.</p>
<p><code>syncLimit</code>: 该参数配置leader和follower之间发送消息, 请求和应答的最大时间长度. 此时该参数设置为2, 说明时间限制为2倍tickTime, 即4000ms.</p>
<p><code>dataDir</code>: 数据存放目录. 可以是任意目录.但是我喜欢这么干</p>
<p><code>dataLogDir</code>: log目录, 同样可以是任意目录. 如果没有设置该参数, 将使用和dataDir相同的设置</p>
<p><code>clientPort</code>: 监听client连接的端口号.</p>
<p><code>server.X=A:B:C</code>: 其中X是一个数字, 表示这是第几号server. A是该server所在的IP地址. B配置该server和集群中的leader交换消息所使用的端口. C配置选举leader时所使用的端口.</p>
<p><code>minSessionTimeout</code>: 最小的会话超时时间,这两个参数可以适当的调低一点,否则如果一个临时状态节点挂掉以后,会有很长时间才会在ZK中体现出来.</p>
<p><code>maxSessionTimeout</code>: 最大的会话超时时间</p>
<h3 id="9-_启动Zookeeper">9. 启动Zookeeper</h3><p>配置到这里就完了.其实ZK的集群配置非常的简单.<br>启动也非常的简单.直接在命令行中调用:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./zkServer.sh start</span><br></pre></td></tr></table></figure>
<p>第一台机器启动的时候可能会报异常,这是正常的.他启动后会尝试连接其他的两台机器.但是由于其他两台还没启动起来,所以会报错. 启动了就好了.</p>
<p>PS: 需要注意的是,ZK集群提供了过半存活的能力.也就是说2n+1台机器环境下的ZK集群.最多允许n个节点挂掉.超过了就无法选举出leader了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="zookeeper_集群部署">zookeeper 集群部署</h1><p>在现在的软件系统中,通常都会搭建集群或者分布式环境了.而在这种情况下,通常都需要一个分布式程序协调者的服务.这最常用的就是zookeeper了.<br>在我们的系统中,会使用zookeeper来做<code>统一的配置管理</code>,集群<code>节点状态管理</code>,以及<code>分布式锁</code>的功能.<br>为了保证zookeeper本身的高可用性,那么这就需要对ZK进行集群.</p>
<h2 id="安装环境">安装环境</h2><p>操作系统:Ubuntu 12.04 64位<br>JDK:1.7.0_55 64位<br>机器: <code>192.168.1.100</code> <code>192.168.1.101</code>  <code>192.168.1.101</code></p>
<h2 id="安装步骤">安装步骤</h2>]]>
    
    </summary>
    
      <category term="Zookeeper" scheme="http://sunxiang0918.github.io/tags/Zookeeper/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在MAC下使用beyondcompare比较JAVA Class文件]]></title>
    <link href="http://sunxiang0918.github.io/2014/09/20/%E5%9C%A8MAC%E4%B8%8B%E4%BD%BF%E7%94%A8beyondcompare%E6%AF%94%E8%BE%83JAVA-Class%E6%96%87%E4%BB%B6/"/>
    <id>http://sunxiang0918.github.io/2014/09/20/在MAC下使用beyondcompare比较JAVA-Class文件/</id>
    <published>2014-09-20T02:33:29.000Z</published>
    <updated>2015-08-01T06:52:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在MAC下使用beyondcompare比较JAVA_Class文件">在MAC下使用beyondcompare比较JAVA Class文件</h1><p>2014年9月1日.beyondCompare终于推出了Mac版了.真的是大快人心的大好事,大了又大.<br>以前用过很多MAC上的比较工具,像什么<code>Araxis Merge</code> <code>DiffFork</code> <code>DiffMerge</code> <code>Kaleidoscope</code>等等. 都没有很好用. 对比Windows平台上的BeyondCompare,差的不是一点半点.</p>
<p>使用beyondcompare对比.class文件的时候,默认是直接对比的二进制文件.这基本上就看不懂.因此,需要在对比的时候自动的反编译为源代码.然后再进行对比.</p>
<a id="more"></a>
<ol>
<li>打开beyondcompare. </li>
<li>选择 <code>BeyondCompare—&gt;File Formats</code></li>
<li>然后新建一个文本的 解析格式:  class<br> <img src="/img/2014/09/20/2.png" alt=""></li>
<li>在<code>general</code> 里面 过滤格式 输入  <code>*.class</code></li>
<li><code>Conversion</code>里面  选择  <code>External Program</code>.</li>
<li><code>Loading</code> 里面输入   <code>had -p %s &gt;%t</code></li>
<li>选择上 <code>Disable editing</code></li>
<li>在<a href="http://varaneckas.com/jad/" target="_blank" rel="external">http://varaneckas.com/jad/</a>上面下载适用于MAC使用的JAD软件.并解压到第三步配置的地方.</li>
</ol>
<p>这样就OK了.使用beyondCompare直接比较JAVA Class文件</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在MAC下使用beyondcompare比较JAVA_Class文件">在MAC下使用beyondcompare比较JAVA Class文件</h1><p>2014年9月1日.beyondCompare终于推出了Mac版了.真的是大快人心的大好事,大了又大.<br>以前用过很多MAC上的比较工具,像什么<code>Araxis Merge</code> <code>DiffFork</code> <code>DiffMerge</code> <code>Kaleidoscope</code>等等. 都没有很好用. 对比Windows平台上的BeyondCompare,差的不是一点半点.</p>
<p>使用beyondcompare对比.class文件的时候,默认是直接对比的二进制文件.这基本上就看不懂.因此,需要在对比的时候自动的反编译为源代码.然后再进行对比.</p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="Mac" scheme="http://sunxiang0918.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析]]></title>
    <link href="http://sunxiang0918.github.io/2014/07/28/DB2%E4%B8%8B%E4%BD%BF%E7%94%A8Hibernate%E8%87%AA%E5%8A%A8%E9%87%8D%E5%BB%BA%E8%A1%A8%E5%AF%BC%E8%87%B4%E6%95%B4%E4%B8%AADB2%E5%8D%A1%E4%BD%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://sunxiang0918.github.io/2014/07/28/DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析/</id>
    <published>2014-07-28T01:51:28.000Z</published>
    <updated>2015-07-28T02:29:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析">DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析</h1><h2 id="问题现象:">问题现象:</h2><p>今天在做高级检索的时候,当用户在界面配置了高级检索的字段后,需要程序自动的把AI3_ADVANCEDSEARCH表删除后,重建.本来这个功能在XDA和xSpace上是能正常工作的.<br>这两个系统所使用的数据库是 MYSQL和ORACLE.一切正常.  现在TVBS使用的是DB2. 在做测试的时候发现.<strong>每当重建表的时候,整个重建的线程都卡住了</strong>.同时,<strong>使用DB2的SQL管理工具,对任意的表进行修改/删除/新建,都会卡住</strong>.这肯定是有问题的.</p>
<h2 id="原因分析过程:">原因分析过程:</h2><ol>
<li>最开始就怀疑是hibernate和DB2的配合的问题,于是打断点.一路跟踪到它卡住的地方.<br><img src="/img/2014/07/28/1.png" alt=""><br>就是这里,调用JDBC的statement.executeUpdate就会卡住. 这句是标准的JDBC的代码.其中statement的实例是DB2的驱动中的对象,于是<span style="background:yellow">怀疑是DB2的驱动问题</span>.于是从网上重新找驱动.<a id="more"></a></li>
<li><p>DB2的驱动是个锤子,官网上根本下不到.需要验证码,验证码IBM又不发给我们.于是只能大海捞针的到处找.终于找到了DB2 9.5的驱动.<span style="background:red">于是换上新的驱动,继续测试. 结果依旧.</span>问题没有解决.看来不是驱动的问题.</p>
</li>
<li><p>换一种思路.写了一段小的JDBC程序来执行创建表的操作:<br><img src="/img/2014/07/28/2.png" alt=""><br>这样操作又能成功. 于是对比分析两次执行的差别.<span style="background:yellow">发现  statement对象的类型不同</span>.<br> 简单的JDBC使用的是 db2驱动中的类<code>com.ibm.db2.jcc.am.tm.</code>而MAMSpace中使用的是JBOSS封装过的类<code>org.jboss.resource.adapter.jdbc.WrappedStatement</code><br> 于是<span style="background:yellow">怀疑是JBOSS的JNDI数据库连接池的问题.</span></p>
</li>
<li><p>马上<span style="background:yellow">更换我们dcmp使用的连接池.</span>不是用JBOSS的JNDI数据库连接池.然后再次进行测试.<br> <span style="background:red">结果……问题依旧…..</span></p>
</li>
<li><p>重启DB2….再次把小程序和MAMSpace都断点到同一位置.然后<span style="background:yellow">开始怀疑是否是事务等问题.</span>于是分析两个statment对象中属性的不同. 但是….一个驱动.居然混淆了的.<br><img src="/img/2014/07/28/3.png" alt=""><br>它所有的字段,属性全部都是 a b c d 的命名.<span style="background:red">大致对比了一下.还是没发现问题.</span></p>
</li>
<li><p>无耐.只有重新再来.经过五六次的不断断点,不断重启DB2. <strong>发现一个很怪异的现象</strong>.<br> 就是 每次卡住以后,只有重启DB2才能恢复 DB2对数据表的DDL功能.<br>并且,<span style="background:yellow">重启后,会发现其实这个时候DB2已经把 AI3_ADVANCEDSEARCH表建出来了. 但是缺少一个字段.</span><br> 建表语句:</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"AI3_ADVANCESEARCH"</span> (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),rEvtl <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID))</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>卡住重启后,建出来的表:   
![](/img/2014/07/28/4.png)  
注意,与建表语句相比,差了 rEvtl字段.  于是<span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"background:yellow"</span>&gt;</span>开始怀疑是否是这个字段有问题.<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><p>7.再一次重启DB2和DCMP,并断点到执行建表语句的位置. 这次直接把内存中的SQL语句给更改了.改成:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"AI3_ADVANCESEARCH"</span> (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID))</span></span><br></pre></td></tr></table></figure>
<p>也就是去掉rEvtl字段,只建4个基本字段.<br><span style="background:green">果然这次程序没有被卡住.</span><br>于是,马上回跳程序.<span style="background:yellow">在不重启服务器和DB2的情况下</span>,执行有rEvtl字段的建表语句.也就是会被卡住的DDL. <span style="background:green">结果执行成功.并没有被卡住…..</span>  无语了.只能<span style="background:yellow">怀疑是DB2的内部处理中有甚么特殊的地方.</span></p>
<ol>
<li>再一次重启DB2和DCMP.这次直接把内存中SQL语句给更改成:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"AI3_ADVANCESEARCH"</span> (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),NHNXL <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID))</span></span><br></pre></td></tr></table></figure>
<p>也就是第5个字段改成大写.<span style="background:red">测试结果还是失败</span>…看来<span style="background:yellow">不是字段大小写的问题.</span></p>
<ol>
<li>再一次重启DB2和DCMP.这次直接把内存中SQL语句中第五个字段的字段类型改成bigint.:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"AI3_ADVANCESEARCH"</span> (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),OSEBi <span class="built_in">bigint</span>,<span class="keyword">primary</span> <span class="keyword">key</span> (ID))</span></span><br></pre></td></tr></table></figure>
<p><span style="background:red">测试结果再次失败</span>….看来<span style="background:yellow">不是字段类型的问题.</span></p>
<ol>
<li>再一次重启DB2和DCMP.这次直接把内存中SQL语句改成:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> AI3_ADVANCESEARCH (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),ENldl <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID)) <span class="keyword">IN</span> TBL_SMAM <span class="keyword">INDEX</span> <span class="keyword">IN</span> IDX_SMAM</span></span><br></pre></td></tr></table></figure>
<p>也就是把表名的双引号去掉.增加上表空间. <span style="background:red">测试结果依然失败</span>…..看来<span style="background:yellow">不是表名和表空间的问题.</span></p>
<ol>
<li>再一次重启DB2和DCMP.这次直接把内存中SQL语句改成:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> AI3_ADVANCESEARCH (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,QMwQH <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID)) <span class="keyword">IN</span> TBL_SMAM <span class="keyword">INDEX</span> <span class="keyword">IN</span> IDX_SMAM</span></span><br></pre></td></tr></table></figure>
<p>也就是把ENTITYTYPE这个字段删掉,<span style="background:red">测试结果还是不行</span>….</p>
<ol>
<li><p>转变一下思路, 先在SQL管理器中把表删除了. 然后再在程序里面创建表.<span style="background:green">就OK了.</span><br>转变一下,由此可见,<span style="background:yellow">问题并不在于Create表的地方.应该是drop表出的问题.</span></p>
</li>
<li><p>既然出在drop表的地方.那么我在这个地方是不是可以不调用drop表喃?于是写了一段存储过程.</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">"MAMDBA"</span>.<span class="string">"DROPADVANCESEARCH"</span>()</span><br><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line">SPECIFIC DROPADAVANCESEARCH</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">IF</span> <span class="keyword">EXISTS</span> (<span class="keyword">select</span> * <span class="keyword">from</span> sysibm.systables <span class="keyword">where</span> TID &lt;&gt; <span class="number">0</span> <span class="keyword">and</span> name = <span class="string">'AI3_ADVANCESEARCH'</span> ) <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">drop</span> <span class="keyword">table</span> AI3_ADVANCESEARCH;</span></span><br><span class="line">	<span class="operator"><span class="keyword">END</span> <span class="keyword">IF</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">END</span></span></span><br></pre></td></tr></table></figure>
<p>然后在调用删除的地方直接调用存储过程来进行删除: “call dropadvancesearch()”.    <span style="background:red">测试结果还是不得行.</span></p>
<ol>
<li>再一次的对比了一下成功的情况. 发现<span style="background:yellow">如果drop表的语句是通过hibernate执行的,那么,虽然在SQL管理器中看到表确实是删除了,日志中事务确实是提交了.但是再次建表的时候如果新建的表结构与被删除的表表结构不同,DB2就会被卡住.</span> 重启DB2后,被删除的表又冒出来了.<span style="background:yellow">这可能和DB2的某个执行有关.但是网上DB2的资料太少了.找不出问题的原因</span>.因此,<span style="background:blue">最后.只能在删除表的地方判断下是否是DB2,如果是,那么就直接使用JDBC来删除表而不使用hibernate来执行删除</span>. 重启后,<span style="background:green">问题解决.</span><br><img src="/img/2014/07/28/5.png" alt=""> </li>
</ol>
<hr>
<h2 id="总结:">总结:</h2><p>这个问题相当的奇怪,到最后都没找出真正的问题原因.在MYSQL和Oracle中不存在这个问题.因此可以确定应该是DB2中的某些处理相当奇怪,造成了在Hibernate管理事务的情况下.会造成DB2删除表在DB2内部发生死锁.于是乎,导致整个DB2停止响应.当重启后,真正的表并没有删除,因此,如果又建立一张和以前被删除的表的名字一样的表的话,是有问题的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析">DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析</h1><h2 id="问题现象:">问题现象:</h2><p>今天在做高级检索的时候,当用户在界面配置了高级检索的字段后,需要程序自动的把AI3_ADVANCEDSEARCH表删除后,重建.本来这个功能在XDA和xSpace上是能正常工作的.<br>这两个系统所使用的数据库是 MYSQL和ORACLE.一切正常.  现在TVBS使用的是DB2. 在做测试的时候发现.<strong>每当重建表的时候,整个重建的线程都卡住了</strong>.同时,<strong>使用DB2的SQL管理工具,对任意的表进行修改/删除/新建,都会卡住</strong>.这肯定是有问题的.</p>
<h2 id="原因分析过程:">原因分析过程:</h2><ol>
<li>最开始就怀疑是hibernate和DB2的配合的问题,于是打断点.一路跟踪到它卡住的地方.<br><img src="/img/2014/07/28/1.png" alt=""><br>就是这里,调用JDBC的statement.executeUpdate就会卡住. 这句是标准的JDBC的代码.其中statement的实例是DB2的驱动中的对象,于是<span style="background:yellow">怀疑是DB2的驱动问题</span>.于是从网上重新找驱动.]]>
    
    </summary>
    
      <category term="DB2" scheme="http://sunxiang0918.github.io/tags/DB2/"/>
    
      <category term="Hibernate" scheme="http://sunxiang0918.github.io/tags/Hibernate/"/>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Lucene进行索引部分更新缓慢原因分析]]></title>
    <link href="http://sunxiang0918.github.io/2014/07/25/%E4%BD%BF%E7%94%A8Lucene%E8%BF%9B%E8%A1%8C%E7%B4%A2%E5%BC%95%E9%83%A8%E5%88%86%E6%9B%B4%E6%96%B0%E7%BC%93%E6%85%A2%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    <id>http://sunxiang0918.github.io/2014/07/25/使用Lucene进行索引部分更新缓慢原因分析/</id>
    <published>2014-07-25T10:23:55.000Z</published>
    <updated>2015-07-27T11:05:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用Lucene进行索引部分更新缓慢原因分析">使用Lucene进行索引部分更新缓慢原因分析</h1><h2 id="问题的引出">问题的引出</h2><p>在我们的系统中,使用了<code>Lucene</code>作为全文检索引擎用作NRT近实时检索.这就牵涉到一个更新的问题.<br>在Lucene当中,其实是<strong>不存在部分更新</strong>的说法的,它仅仅支持全更新.因此,为了应用端的调用方便.在我们的FTEngine全文检索引擎中是提供了部分更新的功能的,其逻辑大体上来说,就是根据传入的<code>uniqueID</code>,在索引中找到对应的<code>Document</code>.然后再恢复它的<code>Term</code>.而后再<strong>构造全更新的Document</strong>,交由Lucene进行全更新.<br>但是,在北京台项目中,突然发现全文检索更新的很慢,往往页面都对素材修改了2个小时了,索引都还没有更新. 从而引出了这个问题.</p>
<h2 id="解决思路">解决思路</h2><p>经过最初步的分析, 发现发生这种现象多集中于有大量的归档与回迁的操作.这两个操作对索引的影响就是会一次性的大量的进行索引的部分更新. 因此就把原因怀疑到了部分更新上.</p>
<a id="more"></a>
<h2 id="分析过程">分析过程</h2><ol>
<li>修改FTEngine的源代码.在项目中,加入大量的日志,全部显示使用时间.<br><img src="/img/2014/07/25/1.png" alt=""><br><img src="/img/2014/07/25/2.png" alt="">  </li>
<li><p>发现程序在恢复<strong>没有Store</strong>的字段的Term的时候非常的慢.经过分析以及网上找问题,发现是由于我们对于Index的字段没有使用Lucene提供的<strong>TermVector</strong>功能,也就是Term的位置向量.它是以空间来换取时间,当使用了位置向量后,就相当于为每一个Term都编了号,记录了位置.这样在恢复的时候大大的提高了查询Term的性能.这样就能很快的恢复Document了.</p>
</li>
<li><p>经过修改后,再进行测试,发现有些Document的恢复还是很慢. 对比恢复的快的与慢得Document.发现他们的区别在于恢复字段的时候,如果每一个字段都是有值的,那么由于有termVector那么会非常的快.但是如果这个字段是没有值的,那么恢复Term就相当的慢.<br><img src="/img/2014/07/25/3.png" alt=""><br><img src="/img/2014/07/25/4.png" alt=""> </p>
</li>
<li><p>进一步分析,没有<strong>digitalbarcode</strong>字段,那么他恢复这个的时候是如何处理的呢?<br>代码先去找这条记录的这个字段是否有<strong>Vector</strong>向量.<br><img src="/img/2014/07/25/5.png" alt=""><br>因为该条Documnet根本就没有这个字段,所以肯定没有这个向量.所以他走到<code>else</code>中去了.<br><img src="/img/2014/07/25/6.png" alt=""><br>else中的处理是先读到该字段的所有<code>term</code>. digitalTapeBarcode大概有2万个term.然后把这些term都取出来.遍历所有的term.然后判断这个term是否是属于这个document的.<br><img src="/img/2014/07/25/7.png" alt="">  </p>
</li>
<li><p>程序的结果也符合预期:<br><img src="/img/2014/07/25/8.png" alt="">  </p>
</li>
<li><p>找到问题原因后,就着手进行修改. 由于Lucene本身没有提供根据document来查询这条记录是否有这个字段.所以我们才会进行遍历.这也是无法修改的.</p>
</li>
<li><p>但是,在这我使用了一个取巧的办法.<br><img src="/img/2014/07/25/9.png" alt=""><br>也就是认为如果在使用TermVector的情况下(现在的索引,在北京台之后的都是使用了TermVector的).<br><strong>如果在TermVector中没有找到,就认为该Document中没有这个字段,不需要恢复.</strong>也就没必要去遍历这几万次.<br><img src="/img/2014/07/25/10.png" alt=""><br><img src="/img/2014/07/25/11.png" alt="">  </p>
</li>
</ol>
<p>相同的90条记录,进行部分更新.   修改前用时 <strong>38778</strong>毫秒 ,修改后  <strong>4475</strong>毫秒. 基本认为问题解决.<br>在不修改底层到<code>Lucene</code>的情况下,只能这样了</p>
<ol>
<li>做1W条记录的批量部分更新测试:</li>
</ol>
<p>修改前: 开始时间: 2014-07-25 11:57:35,666      结束时间:2014-07-25 13:12:39,811 共用时:<strong>4504</strong>秒<br><img src="/img/2014/07/25/12.png" alt="">    </p>
<p>修改后:开始时间:2014-07-25 17:20:23,382      结束时间:2014-07-25 17:25:57,946 共用时:<strong>334</strong>秒<br><img src="/img/2014/07/25/13.png" alt=""> </p>
<ol>
<li>到此,问题基本解决</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章是记录了在我们系统中使用Lucene作为全文检索的时候,进行大量的部分更新时非常缓慢的原因分析排查过程.]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="Lucene" scheme="http://sunxiang0918.github.io/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义hibernate方言 支持正则表达式查询]]></title>
    <link href="http://sunxiang0918.github.io/2014/07/21/%E8%87%AA%E5%AE%9A%E4%B9%89hibernate%E6%96%B9%E8%A8%80-%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2/"/>
    <id>http://sunxiang0918.github.io/2014/07/21/自定义hibernate方言-支持正则表达式查询/</id>
    <published>2014-07-21T12:00:18.000Z</published>
    <updated>2015-07-30T13:18:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="自定义hibernate方言_支持正则表达式查询">自定义hibernate方言 支持正则表达式查询</h1><h2 id="问题的引出">问题的引出</h2><p>最近收到一个新的需求,在基于数据库查询中,需要支持更高级的正则表达式的查询.但是这个在Hibernate的HQL中是不支持的.那么就需要想办法支持这个功能.</p>
<h2 id="解决过程">解决过程</h2><ul>
<li>首先需要明确的是查询数据库是否支持正则表达式的查询. 经过网上的查询.发现我们系统支持的<code>Mysql5.5</code>以及<code>Oracle10g</code>都是支持正则表达式查询的,但是两个的语法稍微有点不一样.</li>
</ul>
<p><strong>通用正则表达式语法</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">表示匹配任意一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[ ]</code></td>
<td style="text-align:center">匹配任何单一字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[0-9]</code></td>
<td style="text-align:center">表示一个字符的范围</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">否定一个字符集合，将匹配除指定字符外的任何东西</td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">匹配特殊字符转义</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">0个或多个匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">1个或多个匹配（等于 {1, }）</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">0个或1个匹配（等于 {0, 1}）</td>
</tr>
<tr>
<td style="text-align:center"><code>{n}</code></td>
<td style="text-align:center">指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>{n, }</code></td>
<td style="text-align:center">不少于指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>{n ,m}</code></td>
<td style="text-align:center">匹配数目的范围</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p><strong>标准类别:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[:alnum:]</td>
<td style="text-align:center">文字数字字符</td>
</tr>
<tr>
<td style="text-align:center">[:alpha:]</td>
<td style="text-align:center">文字字符</td>
</tr>
<tr>
<td style="text-align:center">[:blank:]</td>
<td style="text-align:center">空白字符</td>
</tr>
<tr>
<td style="text-align:center">[:cntrl:]</td>
<td style="text-align:center">控制字符</td>
</tr>
<tr>
<td style="text-align:center">[:digit:]</td>
<td style="text-align:center">数字字符</td>
</tr>
<tr>
<td style="text-align:center">[:graph:]</td>
<td style="text-align:center">图形字符</td>
</tr>
<tr>
<td style="text-align:center">[:lower:]</td>
<td style="text-align:center">小写文字字符</td>
</tr>
<tr>
<td style="text-align:center">[:print:]</td>
<td style="text-align:center">图形或空格字符</td>
</tr>
<tr>
<td style="text-align:center">[:punct:]</td>
<td style="text-align:center">标点字符</td>
</tr>
<tr>
<td style="text-align:center">[:space:]</td>
<td style="text-align:center">空格、制表符、新行、和回车</td>
</tr>
<tr>
<td style="text-align:center">[:upper:]</td>
<td style="text-align:center">大写文字字符</td>
</tr>
<tr>
<td style="text-align:center">[:xdigit:]</td>
<td style="text-align:center">十六进制数字字符</td>
</tr>
</tbody>
</table>
<p><strong>Mysql</strong>: mysql的正则表达式查询是以关键字<code>REGEXP</code>和<code>NOT REGEXP</code>做标识的.后面的语法和一般的正则表达式是一样的.</p>
<p>它们的用法是:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'Monty!'</span> <span class="keyword">REGEXP</span> <span class="string">'.*'</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'new*\n*line'</span> <span class="keyword">REGEXP</span> <span class="string">'new\\*.\\*line'</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'a'</span> <span class="keyword">REGEXP</span> <span class="string">'^[a-d]'</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'justalnums'</span> <span class="keyword">REGEXP</span> <span class="string">'[[:alnum:]]+'</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'!!'</span> <span class="keyword">REGEXP</span> <span class="string">'[[:alnum:]]+'</span>;</span></span><br></pre></td></tr></table></figure>
<p>具体更多信息可以参见:<a href="https://dev.mysql.com/doc/refman/5.1/en/regexp.html" target="_blank" rel="external">Regular Expressions</a></p>
<p><strong>Oracle</strong>:oracle的正则表达式查询是以关键字<code>REGEXP_LIKE</code>和<code>NOT REGEXP_LIKE</code>做标识的.</p>
<p>它们的用法是:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> TestTable <span class="keyword">where</span> REGEXP_LIKE ( name, <span class="string">'^\(\d&#123;3&#125;\) \d&#123;3&#125;-\d&#123;4&#125;$'</span> )</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TestTable <span class="keyword">where</span> REGEXP_LIKE ( name, <span class="string">'new\\*.\\*line'</span> )</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TestTable <span class="keyword">where</span> REGEXP_LIKE ( name, <span class="string">'[[:alnum:]]+'</span> )</span></span><br></pre></td></tr></table></figure>
<p>具体更多信息可以参见:<a href="http://docs.oracle.com/cd/B19306_01/appdev.102/b14251/adfns_regexp.htm" target="_blank" rel="external">Using Regular Expressions in Oracle Database</a></p>
<ul>
<li>分析Hibernate解析HQL的地方.通过断点可以发现,HQL转换成SQL的时候,Hibernate的Dialect方言是起了关键的作用的.它注册了HQL的各种<code>字段类型``内置函数</code>以及它们转换成对应数据库SQL的方法.</li>
<li><code>org.hibernate.dialect.Dialect</code> 这个类主要有 <code>register*</code>开头的几个方法.用于注册各种<code>字段类型``内置函数``关键字</code>等等.</li>
<li>我们需要的就是继承某一数据库的Dialect.然后在构造函数中加上我们需要的自定义的<code>字段类型``内置函数``关键字</code></li>
<li>比如在<strong>Mysql</strong>中增加正者表达式,就需要继承<code>MySQL5Dialect</code>.然后在构造函数中进行注册:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomMySQL5Dialect</span> <span class="keyword">extends</span> <span class="title">MySQL5Dialect</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomMySQL5Dialect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">/*通过自定义MYSQL的方言. 增加函数的支持</span><br><span class="line">        * 这个的意思就是 当遇到 regexp(name,'rain')的时候,自动的转换成  name REGEXP 'rain'  这句SQL</span><br><span class="line">         * 再比如  regexp(name,'[[:alnum:]]+rain[[:alnum:]]+|[[:alnum:]]+rain|rain[[:alnum:]]+').就转换成</span><br><span class="line">         *  name REGEXP '[[:alnum:]]+rain[[:alnum:]]+|[[:alnum:]]+rain|rain[[:alnum:]]+' 这句SQL.然后返回是一个布尔值</span><br><span class="line">         *  又因为hibernate不支持自定义的检索函数无返回值. 所以 写的时候 必须 写成 where regexp(name,'rain')=true</span><br><span class="line">         *  否则解析会报错</span><br><span class="line">         *  */</span></span><br><span class="line">        registerFunction(<span class="string">"regexp"</span>, <span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN, <span class="string">"?1 REGEXP '?2'"</span>));</span><br><span class="line"></span><br><span class="line">        registerFunction(<span class="string">"noregexp"</span>, <span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN, <span class="string">"?1 NOT REGEXP '?2'"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*这个地方替换成了自定义的SQLFunction.详见@see com.sobey.database.hibernate.CustomExactSearchSQLFunction*/</span></span><br><span class="line">        <span class="comment">/*精确查询*/</span></span><br><span class="line">        registerFunction(<span class="string">"exactsearch"</span>,<span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN,<span class="string">"( ?1 REGEXP '?2' AND ?1 NOT REGEXP '[[:alnum:][:punct:]]+?2[[:alnum:][:punct:]]+|[[:alnum:][:punct:]]+?2|?2[[:alnum:][:punct:]]+' )"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在<strong>Oracle</strong>中增加正则表达式,需要继承<code>Oracle10gDialect</code>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomOracleDialect</span>  <span class="keyword">extends</span> <span class="title">Oracle10gDialect</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomOracleDialect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*2014-10-20 14:54:28 由于默认情况下 hibernate会把 text映射成为Oracle中的 long型.而不是text类型.</span><br><span class="line">         * 而long是oracle废弃了的,一个表只能有一个long字段.因此,就造成了表表不起的问题.因此就需要我们手动的映射到clob上 */</span></span><br><span class="line">        registerColumnType(-<span class="number">1</span>, <span class="string">"clob"</span>);         <span class="comment">//Types.LONGVARCHAR</span></span><br><span class="line">        registerColumnType(-<span class="number">16</span>, <span class="string">"clob"</span>);        <span class="comment">//Types.LONGNVARCHAR</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*通过自定义Oracle的方言. 增加函数的支持</span><br><span class="line">        * 这个的意思就是 当遇到 regexp(name,'rain')的时候,自动的转换成   REGEXP_LIKE (name,'rain')  这句SQL</span><br><span class="line">         * 再比如  regexp(name,'[[:alnum:]]+rain[[:alnum:]]+|[[:alnum:]]+rain|rain[[:alnum:]]+').就转换成</span><br><span class="line">         *  name REGEXP '[[:alnum:]]+rain[[:alnum:]]+|[[:alnum:]]+rain|rain[[:alnum:]]+' 这句SQL.然后返回是一个布尔值</span><br><span class="line">         *  又因为hibernate不支持自定义的检索函数无返回值. 所以 写的时候 必须 写成 where regexp(name,'rain')=true</span><br><span class="line">         *  否则解析会报错</span><br><span class="line">         *  */</span></span><br><span class="line">        registerFunction(<span class="string">"regexp"</span>, <span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN, <span class="string">"REGEXP_LIKE(?1,'?2')"</span>));</span><br><span class="line"></span><br><span class="line">        registerFunction(<span class="string">"noregexp"</span>, <span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN, <span class="string">"NOT REGEXP_LIKE(?1,'?2')"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*精确查询*/</span></span><br><span class="line">        registerFunction(<span class="string">"exactsearch"</span>,<span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN,<span class="string">"(REGEXP_LIKE(?1,'?2') AND NOT REGEXP_LIKE(?1,'[[:alnum:][:punct:]]+?2[[:alnum:][:punct:]]+|[[:alnum:][:punct:]]+?2|?2[[:alnum:][:punct:]]+'))"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在上述的表达式中 <code>?1</code> <code>?2</code> 分别表示的是 第一个入参和第二个入参.因为我们定义了<strong>REGEXP</strong>操作是一个<strong>二元操作符</strong>.需要传入字段名以及正则表达式规则.</p>
</li>
<li><p>这样自定义后.在配置Hibernate的时候直接指定方言为我们自定义的Dialect:</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 引入dataSource --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernateProperties"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">props</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.dialect"</span>&gt;</span>xxx.CustomOracleDialect<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.format_sql"</span>&gt;</span>false<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">				...</span><br><span class="line">			<span class="tag">&lt;/<span class="title">props</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这样就可以在HQL中使用我们新定义的函数了.比如:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from Test where exactsearch(name,'new\\*.\\*line')=true;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>这里调用自定义函数由于是<code>StandardBasicTypes.BOOLEAN</code>.因此返回值需要和一个布尔值进行对比.这样才不会解析报错.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="自定义hibernate方言_支持正则表达式查询">自定义hibernate方言 支持正则表达式查询</h1><h2 id="问题的引出">问题的引出</h2><p>最近收到一个新的需求,在基于数据库查询中,需要支持更高级的正则表达式的查询.但是这个在Hibernate的HQL中是不支持的.那么就需要想办法支持这个功能.</p>
<h2 id="解决过程">解决过程</h2><ul>
<li>首先需要明确的是查询数据库是否支持正则表达式的查询. 经过网上的查询.发现我们系统支持的<code>Mysql5.5</code>以及<code>Oracle10g</code>都是支持正则表达式查询的,但是两个的语法稍微有点不一样.</li>
</ul>
<p><strong>通用正则表达式语法</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">表示匹配任意一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[ ]</code></td>
<td style="text-align:center">匹配任何单一字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[0-9]</code></td>
<td style="text-align:center">表示一个字符的范围</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">否定一个字符集合，将匹配除指定字符外的任何东西</td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">匹配特殊字符转义</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">0个或多个匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">1个或多个匹配（等于 {1, }）</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">0个或1个匹配（等于 {0, 1}）</td>
</tr>
<tr>
<td style="text-align:center"><code>{n}</code></td>
<td style="text-align:center">指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>{n, }</code></td>
<td style="text-align:center">不少于指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>{n ,m}</code></td>
<td style="text-align:center">匹配数目的范围</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="Hibernate" scheme="http://sunxiang0918.github.io/tags/Hibernate/"/>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记一次JVM优化过程]]></title>
    <link href="http://sunxiang0918.github.io/2014/06/27/%E8%AE%B0%E4%B8%80%E6%AC%A1JVM%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>http://sunxiang0918.github.io/2014/06/27/记一次JVM优化过程/</id>
    <published>2014-06-27T02:29:56.000Z</published>
    <updated>2015-07-27T10:12:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="记一次JVM优化过程">记一次JVM优化过程</h1><h2 id="问题的引出">问题的引出</h2><p>在多个系统环境中都出现了我们的DCMP在运行过程中突然停止响应,并且时间长达几分钟至几十分钟之久.期间DCMP任何功能都无法运行.严重的影响了系统的运行.因此需要分析排查问题的原因</p>
<h2 id="解决思路">解决思路</h2><p>经过最初步的分析,发现是DCMP在运行一段时间后,会执行<code>FullGC</code>. 在FullGC的过程中整个系统会停止一切响应.因此,解决该问题的思路,就是分析出DCMP平凡进行<code>FullGC</code>的原因.然后进行优化</p>
<h2 id="分析过程">分析过程</h2><ol>
<li><p>在DCMP运行的过程中,通过windows任务管理器找到进程的<code>PID</code>.然后调用JDK自带的命令: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat –gcutil PID 重复次数 间隔时间</span><br></pre></td></tr></table></figure>
<p> 获取当前JVM的内存信息:<br> <img src="/img/2014/06/27/1.png" alt=""><br> 他上面标识了JVM中每一个区的说占用百分比.</p>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>通过一段时间的观察,发现DCMP每一次<code>FullGC</code>都是由于<code>Perm</code>区内存空间占满造成的,而不是<code>Old</code>区.  在JVM定义中Perm区是<strong>持久区</strong>.用于<strong>存放ClassLoader和Class的类信息以及常量</strong>的.理论上是不会大量的增长的.因此在分段式的GC中是不会被GC的.只有在FullGC中会被GC.而我们的系统中,1G的<code>perm</code>区,仅仅需要10分钟就会被填满.这肯定是有问题的.</p>
</li>
<li><p>经过系统最小化的测试原则.也就是把能去掉的模块都去掉,仅仅保留DCMP运行的最少模块.发现<code>Perm</code>区的增长和<code>CDPLB</code><em>(我们系统中的一个组件与任务调度的服务)</em>的轮询时间高度一直.有理由相信和<code>CDPLB</code>有关.于是排查代码.发现对于一个<code>CDPLB</code>的任务,他在每一次轮询的时候都要调用ITaskRedirector的实现类进行分析获取该任务需要交由哪个执行器来处理.于是修改CDPLB的逻辑,让每一个任务在添加的时候就调用一次ITaskRedirector去获取执行器的名字.上线后,再次调用<code>jstat</code>命令发现<code>perm</code>区的增长后明显的好转.但是对于一般的情况,增速还是过快.特别是进行保存元数据的时候,会进行明显的增长.</p>
</li>
<li><p>再次分析<code>ITaskRedirector</code>实现类与保存元数据的逻辑的共性.发现都有<strong>xml</strong>转换对象的步骤.初步猜测与这个有关.于是编写测试类:<br> <img src="/img/2014/06/27/2.png" alt=""><br> 该断代码的逻辑在于读取一个临时实体的XML字符串. 然后不断的循环,一次采用<code>XStream</code>来反序列化生成临时实体对象,一次采用<code>Dom4j</code>来生成临时实体对象.两种方式交替执行.每次执行停顿<em>5000</em>毫秒.该代码执行后,通过<code>jstat</code>分析得出,每当使用<code>XStream</code>生成临时实体的时候<code>Perm</code>区都会增长<strong>0.5%</strong>左右.而使用<code>Dom4j</code>不会(<em>如果使用Dom4j的XPATH功能,会增长0.1左右</em>).由此可以断定应该是<code>Xstream</code>在反序列化XML生成对象的过程中产生了<strong>动态的代理Class</strong>.造成了<code>perm</code>区的增加.</p>
</li>
<li><p>根据网上查到的说法,<code>Xstream</code>是线程安全的,因此修改代码.把以前每调用一次序列化/反序列化 就要注册一次<code>Xstream</code>改为了<strong>缓存常量</strong>.经过这次修改,<code>Perm</code>区增长的问题基本解决.每一次的<code>FullGC</code>都不是由于<code>Perm</code>区满了引起的了.</p>
</li>
<li><p>继续使用<code>jstat</code>分析,发现系统虽然<code>FullGC</code>的<strong>频率降低</strong>了,但是每一次<code>FullGC</code>的<strong>持续时间还是很久</strong>.经过进一步的查资料,我们现在使用的是<code>Parallel GC</code>,也就是<strong>并行GC</strong>.该GC的特点是<strong>并行</strong>处理<code>Minor GC</code>.系统吞吐量优先,也就是说,它会尽量减少GC的次数,等到内存满后再进行一次FullGC.所以FullGC的时间相当的长.因此,<strong>更换GC方式为CMS GC</strong>.</p>
</li>
<li><p><code>CMS GC</code>全称<code>Concurrent Mark-Sweep GC</code>.它是一种并行的<strong>标记GC</strong>.当有部分内存需要被GC的时候,它会标记这部分内存.然后系统就不再使用这部分内存.同一时间,它开始并行的开始释放被标记的这部分内存.从而达到高响应的.它是一种高响应式的GC,它为了能减少GC的时间,通过不断的标记和交换内存来达到目的.因此对于系统的吞吐量是有一定的影响的.</p>
</li>
<li><p>决定选用CMS GC方式后,还需要决定的就是整个系统的堆大小以及每一个区的大小.<br> <img src="/img/2014/06/27/3.png" alt="">  </p>
</li>
<li><p>判断JVM是否调优有三个标准:<strong>吞吐量</strong>,<strong>延迟及响应性</strong>,<strong>内存占用</strong>.</p>
<ul>
<li><code>吞吐量</code>是对<strong>单位时间内处理工作量的度量</strong>,设计吞吐量需求时,一般不考虑它对延迟或响应时间的影响.通常情况下,增加吞吐量的代价是延迟的增加或内存使用的增加.吞吐量性能的需求的一个典型例子是:应用程序每秒需要完成2500次事务.</li>
<li><code>延迟及响应性</code>是<strong>对引用程序收到指令开始工作直到完成该工作所消耗时间的度量</strong>.通常情况下,提高响应性的代价是更低的吞吐量,或者更多的内存消耗.延迟需求的一个典型例子是应用程序应该在60ms内完成请求的处理工作</li>
<li><code>内存占用</code>是指在<strong>同等程度的吞吐量,延迟,可用性等前提下,运行应用程序所需要的内存大小</strong>.内存占用通常以运行应用程序需要的JAVA堆大小或运行应用程序所需要的总大小来表述.一般情况下可以通过增大JAVA堆的方式增加内存能够提高吞吐量,降低延迟.</li>
</ul>
</li>
<li><p>我们的DCMP系统目前暂时没有一个硬性的吞吐量或响应的要求,但是要求尽量在等量内存下达到最大吞吐量或最低响应时间.要达到这个要求有三个原则:</p>
<ol>
<li>每一次MinorGC都尽可能多的收集垃圾对象.遵守这一原则可以减少应用程序发生FullGC的频率.FullGC的持续时间总是最长的.是应用程序无法达到其延迟或吞吐量要求的罪魁祸首.</li>
<li>处理吞吐量和延迟问题时,垃圾处理器能使用的内存越大,即JAVA堆空间越大,垃圾收集效果越好.</li>
<li>在这三个性能指标(吞吐量,延迟,内存占用)中任意选择两个进行JVM调优.</li>
</ol>
</li>
<li><p>开始优化内存之前,需要理解JVM中堆的布局非常重要,它直接可以从理论上帮助我们确定应用程序使用JAVA堆的大小,微调影响垃圾收集器性能的空间大小.<br><img src="/img/2014/06/27/4.png" alt=""><br>JVM主要有三个空间,分别是:<strong>新生代</strong>,<strong>老年代</strong>以及<strong>永久区</strong>.<br>JAVA应用程序分类JAVA对象的时候,首先在新生代空间(<code>Eden</code>)中分配对象.经过一次<code>MinorGC</code>后,存活下来的对象会放入<code>S0</code>区.然后<code>S0</code>和<code>S1</code>交换.当再一次<code>MinorGC</code>后,把存活下来的对象再放入当前的<code>S0</code>区.经过几次<code>MinorGC</code>之后还保持活跃的对象会被晋升到老年代中.永久代中空间存放的是VM和JAVA类的元数据已经驻留的Strings和类静态变量.</p>
<ul>
<li>整个JVM堆大小可以使用 <code>–Xmx</code>和<code>-Xms</code>指定</li>
<li>新生代可以使用<code>-XX:NewSize</code>  <code>-XX:MaxNewSize</code>  或者 <code>–Xmn</code>指定</li>
<li>老年代空间大小会根据新生代的大小隐式的指定.即 <strong>老年代=堆大小-新生代</strong></li>
<li>持久代空间大小通过: <code>-XX:PermSize</code>   <code>-XX:MaxPerSize</code> 来指定<br>新生代,老年代,永久代这三个空间中的任何一个不能满足内存分配请求时,就会发生垃圾回收,理解这一点非常重要.</li>
</ul>
</li>
<li><p>有了理论的知识后,接下来就是根据我们系统具体的进行分析了.首选需要的就是选择JVM运行模式.毫无疑问,我们系统肯定是使用的<code>Server</code>模式.Server模式提供了更复杂的生成码优化功能,这个功能对于服务器的应用而言尤其重要</p>
</li>
<li><p>接下来就是确定内存占用.程序的内存并不是越多越好,这需要考虑成本等问题.初始堆大小通常应该是老年代活跃数据的<strong>3-4</strong>倍.永久代大小应该比永久代活跃数据大<strong>1.5-2</strong>倍.新生代大小通常应该是老年代活跃数据的<strong>1-1.5</strong>倍.</p>
</li>
<li><p>所谓的活跃数据,即<strong>应用程序运行于稳定态时,长期存活的对象在JAVA堆中占用的空间大小</strong>.换句话说,活跃数据大小是引用程序运行于稳定后,FullGC之后JAVA堆中老年代和永久代占用的空间大小.</p>
</li>
<li><p>经过在107机器上大规模的跑hotfolder入库(<em>文件分析-保存元数据</em>).我们老年代的活跃数据大概为<strong>1个G</strong>.因此调整初始化堆大小为<strong>4G</strong>,永久代<strong>346m</strong>,新生代<strong>1.5G</strong><br><img src="/img/2014/06/27/5.png" alt="">  </p>
</li>
<li><p>接下来微调新生代的大小.<br>通常情况下,<strong>新生代空间越小,MinorGC持续时间越短</strong>,不考虑这对于MinorGC持续时间的影响,减少新生代空间又会增加MinorGC的频率.因此需要取<strong>它们的中间点</strong>.分析GC数据的时候,如果发现MinorGC的间隔时间过长,修正的方法是减少新生代空间.如果Minor频率太高,修正的方法是增加新生代空间.经过GC日志的分析,新生代1.5G的空间比较合适我们的系统,每次MinorGC的平均时间为0.04秒左右.<br><img src="/img/2014/06/27/6.png" alt="">   </p>
</li>
<li><p>微调老年代的大小.<br>这一步的目标是评估FullGC引入的<code>最差停滞时间</code>以及<code>FullGC的频率</code>.<br>同年轻代一样,老年代的优化也需要采集垃圾手机的统计数据.我们关注的是FullGC的持续时间和频率.经过采样,发现了一个问题.在当前的配置情况下,当系统运行了一段时间后,会进行大量的FullGC.而不进行MinorGC. FullGC占到了所有GC的90%以上.虽然每一次FullGC的持续时间都不长,但这是不正常的,经过GC日志的分析.发现,当系统进行大量的FullGC的时候,老年区与持久区并没有被占满,也就是说FullGC不是这两个区被占满造成的.每次出发FullGC的时机都是年轻代占满,进行GC的时候.报concurrent mode failure<br><img src="/img/2014/06/27/7.png" alt=""><br>经过oracle等论坛的查询和源码的分析,发现出现这种现象有一种情况就是当<code>年轻代GC</code>的时候,他需要向<strong>老年代晋升对象</strong>,而老年代的空间如果不够年轻代晋升的对象时(<strong>这里有一个误区,也是让我疑惑了很久的地方,就是明明老年代的空间大于年轻代,为什么还会不够.原因在于CMS方式的GC是不会整理内存的,内存空间是一个一个的片段.当老年区的最大连续内存片段小于年轻代晋升的对象大小时,JVM就会认为空间不足</strong>),就会发生MinorGC失败,从而JVM尝试进行FullGC.因此,可以得出一个结论就是年轻代和老年代空间大小比过小了.在不增加堆空间大小的情况下,就只能减少年轻代的空间.因此,重新修改年轻代大小为1G.</p>
</li>
<li><p>Survivor空间调优<br><code>Survivor</code>空间也就是图上的 <code>S0</code> <code>S1</code>空间. 两个空间的大小虽然很小,但是作用很大.整个Survivor空间分成了两个部分,即<strong>S0</strong>和<strong>S1</strong>,也叫<strong>From</strong>区和<strong>To</strong>区.它相当于是一个缓存区,能提高年轻代晋升到老年代的对象的命中率.一旦完成MinorGC,Eden空间会被清空,From空间也会被清空.而To空间中保留了还是活跃的对象,之后Survivor空间交换标记为下一次MinorGC作准备.现在被清空的From区被标记成了To区,而To区被标记成From区.因此MinorGC结束时,Eden空间和一块Survivor空间被清空,另一块Survivor空间中保留经历了上一次MinorGC存货下来的活跃对象.如果MinorGC时.To区空间不足以容纳所有从Eden区和From区中复制过来的活跃对象,超出的部分就会直接晋升至老年区.这会加速FullGC的频率.调整Survivor空间的大小,让其有足够的空间容纳存活对象足够长的时间,直到几个周期之后对象老化.就能避免Survivor空间的溢出.<br>调整Survivor空间大小可以通过: <code>-XX:SurvivorRation=&lt;ratio&gt;</code> 进行调整.<br>计算公式为: <code>Survivor空间大小=-Xmn/(+XX:SurvivorRation=&lt;ration&gt;+2)</code><br>要调优Survivor空间,需要监控晋升阀值.晋升阀值决定了对象在新生代Survivor空间中保留的次数.通过在GC日志中增加<code>-XX:+PrintTenuringDistribution</code>.来监控晋升阀值.<br>增加该参数后,每一个MinorGC都会打印Survivor区中的对象大小以及保留次数:<br>比如:  </p>
<blockquote>
<p>age 1: 6115072bytes, 6115072 total<br>age 2:  286672bytes, 6401774 total<br>age 3:  115704 bytes, 6517448 total<br>age 4:   95932 bytes,  6613380 total<br>age 5:   89465 bytes,  6702845 total<br>age 6:   88322 bytes,  6791167 total<br>age 7    88201bytes,  6879368 total  </p>
</blockquote>
<p>从上表来看,年龄为<code>1</code> <code>2</code> <code>3</code>的对象非常的多,而年龄<code>4</code>开始就很少了.也就是说系统的Survivor的晋升阀值就是3.即<code>-XX:MaxTenuringThreshold=3</code>.整个年龄为3的对象为65兆.所以就配置Survivor区大小为<strong>130m</strong>.即<strong>-XX:SurvivorRatio=6</strong></p>
</li>
<li><p>CMS收集周期调优<br>确定完JVM堆以及每一个区的大小后,还需要的就是根据CMS收集策略来调整一些参数.比如:  </p>
<ul>
<li>Perm区满后是采用FullGC还是直接抛异常终止系统运行的<code>-XX:+CMSPermGenSweepingEnabled</code>参数.  </li>
<li>CMS老年代开始标记的进入周期,如果CMS周期开的太晚,就会发生失速.如果它无法以足够快的速度回收对象,就无法避免老年化空间用尽.但是如果CMS周期开始得过早,又会引起无用的消耗,影响应用程序的吞吐量.经过GC日志的分析,当老年代占用大于1.6G的时候,就会发生concurrent mode failure.因此决定CMS进入时机为老年代的60%,即: <code>-XX:CMSInitiatingOccupancyFraction=60</code></li>
<li>CMS回收不会整理内存,这就会造成老年区的内存碎片越来越多,影响效率.因此就需要指定进行几次FullGC后,整理老年区的内存.这会增加一个FullGC的时间,但是可以整体的增加系统的吞吐量.经过分析我们的系统很久才会触发一次FullGC,于是配置每一个FullGC前都进行内存整理: <code>-XX:CMSFullGCsBeforeCompaction=1</code></li>
</ul>
</li>
<li><p>到此,GC的配置已完成,然后就是进行大量的测试.现在的配置如下:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_OPTS=%JAVA_OPTS% -Xms4096m -Xmx4096m -XX:PermSize=<span class="number">346</span>m -XX:MaxPermSize=<span class="number">346</span>m -Xmn1024m  -Xss128k -server -XX:MaxTenuringThreshold=<span class="number">5</span></span><br><span class="line"><span class="built_in">set</span> JAVA_OPTS=%JAVA_OPTS% -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSPermGenSweepingEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+CMSClassUnloadingEnabled -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:SurvivorRatio=<span class="number">6</span> -XX:CMSFullGCsBeforeCompaction=<span class="number">1</span> -XX:CMSInitiatingOccupancyFraction=<span class="number">60</span> -XX:ParallelGCThreads=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> JAVA_OPTS=%JAVA_OPTS% -XX:+DisableExplicitGC</span><br></pre></td></tr></table></figure>
<p>经过3台AT导入同时导入的压力测试:<br><img src="/img/2014/06/27/8.png" alt="">  </p>
<p>系统运行<strong>52937</strong>秒,整个GC暂停时间<strong>231.71</strong>秒. 系统可用时间 <strong>99.56%</strong>.平均GC时间<strong>0.039</strong>秒,最大停顿时间<strong>2.7</strong>秒.达到系统要求.</p>
<ol>
<li><p>把同样的配置发到旺旺现场,发现系统还是响应很慢,收集GC日志后发现.他们的元数据太大.造成新生代被占满的速度太快.平凡的进行MinorGC. 平均每<strong>0.2秒</strong>就进行一个MinorGC,系统停顿<strong>0.04秒</strong>. 整个系统的可用时间只有<strong>75%</strong>.没达到吞吐量的需求.日志显示<strong>0.2秒</strong>新生代的<strong>900M</strong>空间就会被占满.但是不会平凡的进行FullGC.证明<strong>整体的GC策略是正确的</strong>,但是确实由于量的原因,<strong>4G空间不能满足要求了</strong>.所以一方面增加现场的内存配置到8G.另一方面,分析流程,发现由于AT导入速度大于我们保存元数据的速度.所以保存元数据的流程越来越多,而保存元数据没有使用CDPLB调度,所有的任务都驻留在内存中,造成了新生代增速过快.因此,修改程序让CDPLB也来调度保存元数据,同一时间只有300个任务驻留在内存中.再次观察日志.问题解决.</p>
</li>
<li><p>至此,整个DCMP的内存调优结束.</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章是记录了一次在我们的项目中遇到CG时间过长的问题排查过程.]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="JVM" scheme="http://sunxiang0918.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Jboss4控制台加锁]]></title>
    <link href="http://sunxiang0918.github.io/2014/05/18/Jboss4%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%8A%A0%E9%94%81/"/>
    <id>http://sunxiang0918.github.io/2014/05/18/Jboss4控制台加锁/</id>
    <published>2014-05-18T06:10:01.000Z</published>
    <updated>2015-08-01T06:28:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Jboss4控制台加锁">Jboss4控制台加锁</h1><p>由于Jboss服务器默认的情况下,可以通过远程的方式登陆控制台,然后关闭卸载服务.这对于真正的线上服务来说是非常危险的操作,哪怕是在电视台内部的局域网也是如此.因此,需要给JBOSS控制台加上密码.</p>
<h2 id="隐藏访问目录">隐藏访问目录</h2><p>这一步主要是隐藏控制台的访问目录.<br>具体是修改:<code>jboss_home/server/default/deploy/jbossweb-tomcat55.sar/conf/web.xml</code>文件:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="设置JMX-Console控制台密码">设置JMX-Console控制台密码</h2><p>因为即使用防火墙将8080端口屏蔽，别有用心的用户也可以通过<a href="http://your_domain/JMX-Console进行访问，修改如下" target="_blank" rel="external">http://your_domain/JMX-Console进行访问，修改如下</a>:</p>
<ol>
<li>修改<code>JBOSS_HOME/server/default/deploy/jmx-console.war/WEB-INF/web.xml</code>,取消<code>&lt;security-constraint&gt;</code>这段注释</li>
<li>修改同目录下<code>jboss-web.xml</code>,取消<code>&lt;security-domain&gt;</code>这段注释</li>
<li>修改<code>JBOSS_HOME/server/default/conf/props/jmx-console-users.properties</code>,增加用户<code>修改 admin=admin   设置用户名=设置密码</code></li>
<li>修改同目录下<code>jmx-console-roles.properties</code>     修改 admin 改为   上面设置的用户名</li>
</ol>
<h2 id="设置Web-Console控制台密码">设置Web-Console控制台密码</h2><ol>
<li>修改<code>JBOSS_HOME/server/default/deploy/management/console-mgr.sar/web-console.war/WEB-INF/web.xml</code> 取消<code>&lt;security-constraint&gt;</code>这段注释</li>
<li>修改同目录下的<code>jboss-web.xml</code> 取消<code>&lt;security-domain&gt;</code> 这段注释</li>
<li>修改<code>JBOSS_HOME/server/default/conf/props/web-console-roles.properties</code> 增加<code>admin=JBossAdmin,HttpInvoker</code></li>
<li>修改<code>JBOSS_HOME/server/default/conf/login-config.xml</code>.改为下面这样:</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application-policy</span> <span class="attribute">name</span>=<span class="value">"web-console"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">authentication</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">login-module</span> <span class="attribute">code</span>=<span class="value">"org.jboss.security.auth.spi.UsersRolesLoginModule"</span> <span class="attribute">flag</span>=<span class="value">"required"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">module-option</span> <span class="attribute">name</span>=<span class="value">"usersProperties"</span>&gt;</span>props/web-console-users.properties<span class="tag">&lt;/<span class="title">module-option</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">module-option</span> <span class="attribute">name</span>=<span class="value">"rolesProperties"</span>&gt;</span>props/web-console-roles.properties<span class="tag">&lt;/<span class="title">module-option</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">login-module</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">authentication</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">application-policy</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>修改<code>jboss_home/server/default/conf/jboss-service.xml</code>.将:</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A flag to disable the scans --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">attribute</span> <span class="attribute">name</span>=<span class="value">"ScanEnabled"</span>&gt;</span>false<span class="tag">&lt;/<span class="title">attribute</span>&gt;</span> <span class="comment">&lt;!--将true改为false--&gt;</span></span><br></pre></td></tr></table></figure>
<p>到这里,就完成了JBoss控制台密码的设置了. 重启JBOSS就OK了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Jboss4控制台加锁">Jboss4控制台加锁</h1><p>由于Jboss服务器默认的情况下,可以通过远程的方式登陆控制台,然后关闭卸载服务.这对于真正的线上服务来说是非常危险的操作,哪怕是在电视台内部的局域网也是如此.因此,需要给JBOSS控制台加上密码.</p>
<h2 id="隐藏访问目录">隐藏访问目录</h2><p>这一步主要是隐藏控制台的访问目录.<br>具体是修改:<code>jboss_home/server/default/deploy/jbossweb-tomcat55.sar/conf/web.xml</code>文件:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="JBOSS" scheme="http://sunxiang0918.github.io/tags/JBOSS/"/>
    
  </entry>
  
</feed>