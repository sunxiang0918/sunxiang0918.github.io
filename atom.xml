<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[翔妖除魔的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://sunxiang0918.github.io//"/>
  <updated>2015-12-27T13:11:22.000Z</updated>
  <id>http://sunxiang0918.github.io//</id>
  
  <author>
    <name><![CDATA[翔妖除魔]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[在Swift中使用随机数]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/27/%E5%9C%A8Swift%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>http://sunxiang0918.github.io/2015/12/27/在Swift中使用随机数/</id>
    <published>2015-12-27T12:27:49.000Z</published>
    <updated>2015-12-27T13:11:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Swift中使用随机数">在Swift中使用随机数</h1><p>在我们的开发过程中,有时需要产生一些随机数.而Swift中并没有像JAVA中一样提供一个专门的<code>Random</code>类来集中的生成随机数.<br>在Swift中,提供了几个全局的函数来生成随机数.一个是<code>random()</code>,还有一个是<code>arc4random()</code>,以及专门生成浮点的<code>srand48(Int)</code>和<code>drand48()</code>.<br>这些方法并没有进行封装,其实并不符合面向对象的思想.并且如果想要限制生成的随机数的最大最小值也不得行.因此,我们有必要对他们进行一个封装.</p>
<a id="more"></a>
<h2 id="arc4random()">arc4random()</h2><p>arc4random 是一个非常优秀的随机数算法,它会返回给我们一个任意的整数,如果我们想要在某一个范围里的话,做一次取模运算取余数就可以了.但是由于<code>arc4random()</code>函数返回的值无论上什么平台上都是返回一个<code>UInt32</code>(无符号32位整数)的值.因此,在32位的平台上进行<code>Int(arc4random())</code>转换的话,就有一半的几率出现转换越界,这就会造成程序的崩溃.</p>
<p>因此,在这种情况下,我们可以使用<code>arc4random_uniform</code>这个改良的<code>arc4random</code>函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">arc4random_uniform</span><span class="params">(<span class="number">_</span>: UInt32)</span></span> -&gt; <span class="type">UInt32</span></span><br></pre></td></tr></table></figure>
<p>这个函数接收一个UInt32的数字n作为输入,返回一个0到n-1之间的随机数.那么,只要我们传入的n不超过Int的范围,就可以避免像上面一样的转换越界的问题了.</p>
<p>因此,我们Int的随机数生成函数可以写成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Int = <span class="number">0</span>, <span class="number">_</span> upper: Int = Int.<span class="built_in">max</span>)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lower + <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(upper - lower + <span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(range: Range&lt;Int&gt;)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random(range.startIndex, range.endIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码使用了<code>扩展</code>,对Int类型增加了一个扩展,并实现了<code>random(lower: Int = 0, _ upper: Int = Int.max) -&gt; Int</code>和<code>random(range: Range&lt;Int&gt;) -&gt; Int</code>两个方法.这样,如果我们需要一个整数的随机数的话,就可以这样调用了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span>.random()</span><br><span class="line"><span class="type">Int</span>.random(<span class="number">0</span>, <span class="number">50</span>)</span><br><span class="line"><span class="type">Int</span>.random(<span class="number">20</span>...<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p>这里不得不夸一下<code>扩展</code>机制,真心方便.它可以不修改原有类的源码的情况下,给这个类增加新的功能.这就大大的增加了编写代码的方便.毕竟很多时候最开始时是考虑不周全的,我们并不能给某个类增加所有的方法,到后面进行修改的时候,就必然牵涉到修改源码.如果源码是自己写的还好,如果源码不是自己写的或者根本就没有源码了.那么给这个类增加方法就非常的不方便了.JAVA中有大量的<code>XXXXUtils</code>类,其实干的就是这个事情,比如<code>StringUtils</code>,由于JAVA中的<code>String</code>类是不能继承和修改的,因此就只有定义了一个工具类,里面就是对String做了一堆的扩展.调用的时候更不符合面向对象的思想.全是<code>StringUtils.xxxx(sourceStr,destStr)</code>这样的.</p>
<h2 id="其他类型的随机数">其他类型的随机数</h2><p>除了整数的随机数以外,浮点的随机数也是很常用的.因此我们同样可以对浮点数进行扩展.这里就有两种思路,第一种是继续使用<code>arc4random()</code>函数,把生成的随机整数转换成为浮点数.还有一种就是调用<code>srand48(Int)</code>和<code>drand48()</code>直接生成随机浮点数.这两个方案都是差不多的,不过由于每次调用<code>drand48()</code>前都需要调用<code>srand48(Int)</code>设置随机初始化的种子,因此我个人更倾向于使用<code>arc4random()</code>.于是就有以下的方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>.random(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Double = <span class="number">0</span>, <span class="number">_</span> upper: Double = <span class="number">100</span>)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">Double</span>(arc4random()) / <span class="number">0xFFFFFFFF</span>) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Float</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Float = <span class="number">0</span>, <span class="number">_</span> upper: Float = <span class="number">100</span>)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">Float</span>(arc4random()) / <span class="number">0xFFFFFFFF</span>) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">CGFloat</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: CGFloat = <span class="number">0</span>, <span class="number">_</span> upper: CGFloat = <span class="number">1</span>)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(<span class="type">Float</span>(arc4random()) / <span class="type">Float</span>(<span class="type">UINT32_MAX</span>)) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样集中常用数据类型的随机数的生成就都有了,并且使用起来也非常的方便.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bool</span>.random()</span><br><span class="line"><span class="type">Double</span>.random(<span class="number">1.5</span>,<span class="number">10.8</span>)</span><br><span class="line"><span class="type">Float</span>.random()</span><br><span class="line"><span class="type">CGFloat</span>.random()</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在Swift中使用随机数">在Swift中使用随机数</h1><p>在我们的开发过程中,有时需要产生一些随机数.而Swift中并没有像JAVA中一样提供一个专门的<code>Random</code>类来集中的生成随机数.<br>在Swift中,提供了几个全局的函数来生成随机数.一个是<code>random()</code>,还有一个是<code>arc4random()</code>,以及专门生成浮点的<code>srand48(Int)</code>和<code>drand48()</code>.<br>这些方法并没有进行封装,其实并不符合面向对象的思想.并且如果想要限制生成的随机数的最大最小值也不得行.因此,我们有必要对他们进行一个封装.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ELK初实践]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/21/ELK%E5%88%9D%E5%AE%9E%E8%B7%B5/"/>
    <id>http://sunxiang0918.github.io/2015/12/21/ELK初实践/</id>
    <published>2015-12-21T12:07:47.000Z</published>
    <updated>2015-12-22T03:00:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ELK(ElasticSearch+Logstash+Kiabana)初实践">ELK(ElasticSearch+Logstash+Kiabana)初实践</h1><p>ELK是由<a href="https://www.elastic.co" target="_blank" rel="external">elastic</a>公司维护的开源的实时日志采集与分析三剑客.它能够在分布式的架构下,使用<a href="https://www.elastic.co/products/logstash" target="_blank" rel="external">Logstash</a>实时的采集各种不同来源的日志,并通过清洗/ETL转换,形成有意义的数据,存入到<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="external">ElasticSearch</a>全文检索引擎中,再通过<a href="https://www.elastic.co/products/kibana" target="_blank" rel="external">Kiabana</a>呈现出来.<br>我们可以通过这套开源系统实时的了解服务器的软硬件信息,业务负载,错误异常等等.同时也能统一收集日志并做归档处理.当管理的机器非常多的时候这就非常的有意义了.</p>
<p><img src="/img/2015/12/21/1.png" alt=""></p>
<a id="more"></a>
<h2 id="ElasticSearch">ElasticSearch</h2><p>Elasticsearch是一个基于<a href="https://lucene.apache.org/core/" target="_blank" rel="external">Apache Lucene(TM)</a>的开源搜索引擎.与Solr类似,它隐藏了Lucene的复杂性.并提供大量分布式的功能.使用者能够很简单的就构建起一个全文检索引擎,并提供出<code>Restful</code>的API.而不需要编写任何的代码.</p>
<h3 id="安装">安装</h3><p>Elasticsearch的安装非常的简单,它只依赖JAVA的运行环境.最简的运行方式就是直接下载它编译好了的压缩包.然后解压即可用.<br>(默认JAVA运行环境已经配置完成)</p>
<ol>
<li>从<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="external">https://www.elastic.co/downloads/elasticsearch</a>下载最新的运行包.</li>
<li>使用<code>tar -xvf elasticsearch-2.1.0.tar.gz</code>解压</li>
<li>在<code>elasticsearch-2.1.0</code>文件夹下执行<code>./bin/elasticsearch</code></li>
<li><p>在浏览器中访问<a href="http://127.0.0.1:9200" target="_blank" rel="external">http://127.0.0.1:9200</a>.如果得到一个JSON的结果,就表明ES启动成功</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> "<span class="attribute">name</span>" : <span class="value"><span class="string">"Hood"</span></span>,</span><br><span class="line"> "<span class="attribute">cluster_name</span>" : <span class="value"><span class="string">"elasticsearch"</span></span>,</span><br><span class="line"> "<span class="attribute">version</span>" : <span class="value">&#123;</span><br><span class="line">   "<span class="attribute">number</span>" : <span class="value"><span class="string">"2.1.0"</span></span>,</span><br><span class="line">   "<span class="attribute">build_hash</span>" : <span class="value"><span class="string">"72cd1f1a3eee09505e036106146dc1949dc5dc87"</span></span>,</span><br><span class="line">   "<span class="attribute">build_timestamp</span>" : <span class="value"><span class="string">"2015-11-18T22:40:03Z"</span></span>,</span><br><span class="line">   "<span class="attribute">build_snapshot</span>" : <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">   "<span class="attribute">lucene_version</span>" : <span class="value"><span class="string">"5.3.1"</span></span><br><span class="line"> </span>&#125;</span>,</span><br><span class="line"> "<span class="attribute">tagline</span>" : <span class="value"><span class="string">"You Know, for Search"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想要一个监控界面来控制和了解ES的话,可以下载<a href="https://www.elastic.co/products/marvel" target="_blank" rel="external">marvel</a>.<code>Marvel</code>是Elasticsearch的管理和监控工具，在开发环境下免费使用.它包含了一个叫做Sense的交互式控制台，使用户方便的通过浏览器直接与Elasticsearch进行交互.不过这个东西不能进行商用.另外一个可视化的插件是<a href="https://github.com/mobz/elasticsearch-head.git" target="_blank" rel="external">Header</a>,同样是一个ES的管理和监控的工具,不过它的功能稍微要少一些.</p>
</li>
<li>安装<code>Header</code>的话非常简单,直接在es的<code>bin</code>目录中执行<code>sudo ./plugin install mobz/elasticsearch-head</code>即可,它会自动的下载并解压安装包到<code>plugins</code>目录.</li>
<li><p>安装完成后,在浏览器中浏览<a href="http://localhost:9200/_plugin/head/" target="_blank" rel="external">http://localhost:9200/_plugin/head/</a></p>
<p> <img src="/img/2015/12/21/2.png" alt="Header主界面"></p>
</li>
<li><p>安装<code>Marvel</code>稍微要麻烦一点,最新的<code>Marvel2.X</code>需要依赖<code>Kiabana</code>了.首先需要安装<code>License</code>模块:<code>./plugin install license</code>,然后在ES中安装<code>marvel-agent</code>:<code>./plugin install marvel-agent</code>,最后需要在<code>Kiabana</code>中安装<code>marvel</code>:<code>./kibana plugin --install elasticsearch/marvel/latest</code></p>
</li>
<li><p>安装完成后,启动<code>Elasticsearch</code>和<code>Kiabana</code>.然后在浏览器中浏览<a href="http://localhost:5601/app/marvel" target="_blank" rel="external">http://localhost:5601/app/marvel</a>即可.</p>
<p> <img src="/img/2015/12/21/3.png" alt="Marvel主界面"></p>
</li>
</ol>
<p>剩下的<code>Elasticsearch</code>的其他使用,我会另开博文来讲述,这里主要是讲ELK的整合使用~</p>
<h2 id="Kiabana">Kiabana</h2><p>Kibana是一个基于浏览器页面的<code>Elasticsearch</code>前端展示工具,提供了非常牛逼的图表和表现能力。Kibana全部使用HTML语言和Javascript编写的.因此可以部署到任意的Web容器中去.当然,官网上下载的安装包中已经内置了一个Web容器,直接运行即可.</p>
<h3 id="安装-1">安装</h3><ol>
<li>从<a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="external">https://www.elastic.co/downloads/kibana</a>下载最新的运行包.</li>
<li>使用<code>tar -xvf kibana-4.3.0-darwin-x64.tar.gz</code>解压</li>
<li><p>修改<code>/config/kibana.yml</code>文件,指定<code>Elasticsearch</code>的访问地址:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The Elasticsearch instance to use for all your queries.</span></span><br><span class="line">elasticsearch.url: <span class="string">"http://localhost:9200"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kibana-4.3.0-darwin-x64</code>文件夹下执行<code>./kibana</code>即可. 他会自动的在ES中创建它自己所需的索引文件.</p>
</li>
<li><p>在浏览器中打开<a href="http://127.0.0.1:5601/app/kibana" target="_blank" rel="external">http://127.0.0.1:5601/app/kibana</a>即可.这个时候就可以在界面的<code>Discover</code>中进行索引的查询了.</p>
<p> <img src="/img/2015/12/21/4.png" alt=""></p>
</li>
<li><p>同时,也可以使用<code>Visualize</code>功能,建立不同的报表.我们对日志的处理也主要就是通过记录的不同维度,建立不同的图表.然后订阅到<code>Dashboard</code>中.这样就能对日志进行实时的监控和分析.</p>
<p> <img src="/img/2015/12/21/5.png" alt=""></p>
</li>
</ol>
<h2 id="Logstash">Logstash</h2><p>Logstash是一个应用程序日志、事件的传输、处理、管理和搜索的平台.你可以用它来统一对应用程序日志进行收集管理.这点上它的功能其实和<code>Flume</code>是有点类似的.<br><img src="/img/2015/12/21/6.png" alt=""></p>
<h3 id="安装-2">安装</h3><p>Logstash是使用JRuby写的,因此需要依赖JAVA的运行环境.</p>
<ol>
<li>从<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">https://www.elastic.co/downloads/logstash</a>下载最新的运行包.</li>
<li>使用<code>tar -xvf logstash-2.1.0.tar.gz</code>解压</li>
<li>在<code>logstash-2.1.0</code>文件夹下执行<code>./bin/logstash agent -f logstash.conf</code>即可.</li>
</ol>
<p>这里主要是使用了<code>agent</code>模式运行,采集日志的配置记录到<code>logstash.conf</code>文件中. 接下来就介绍一下<code>logstash.conf</code>这个文件.</p>
<h3 id="配置">配置</h3><p>Logstash的日志采集过程主要有三个部分,分别是<code>Input</code> <code>Filter</code>和<code>Output</code>.对应了日志的收集,日志的整理和日志的输出,同时在Filter的前后允许配置<code>Codec</code>也就是编解码.每一个过程都提供了非常多的插件来辅助处理.具体有哪些插件可以访问<a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html" target="_blank" rel="external">Input</a>,<a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" target="_blank" rel="external">Filter</a>,<a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html" target="_blank" rel="external">Output</a>以及<a href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html" target="_blank" rel="external">Codec</a>.</p>
<p>比如最简单的一个conf文件为:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input &#123; stdin &#123; &#125; &#125;</span><br><span class="line">output &#123;</span><br><span class="line">   stdout &#123; codec=&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它指定了日志采集的输入源为命令行输入,不经过任何的处理,输出源为控制台输出,输出的时候编码为ruby的debug格式</p>
<p>执行这个采集的效果就是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/local/logstash-2.1.0/bin/logstash agent -f logstash-simple.conf</span></span><br><span class="line">Logstash startup completed</span><br><span class="line">hello World </span><br><span class="line">&#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"helloWorld"</span>,</span><br><span class="line">     <span class="string">"@version"</span> =&gt; <span class="string">"1"</span>,</span><br><span class="line">   <span class="string">"@timestamp"</span> =&gt; <span class="string">"2015-12-14T12:08:28.688Z"</span>,</span><br><span class="line">         <span class="string">"host"</span> =&gt; <span class="string">"localhost"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来看一个复杂点的例子,这个是我们测试环境抓取业务日志的conf配置:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">    	type =&gt; <span class="string">"my_app"</span></span><br><span class="line">        path =&gt; <span class="string">"/Applications/tomcat7/logs/fpLog/ALL/fpServer.log"</span></span><br><span class="line">        tags =&gt; [ <span class="string">"my_app"</span>, <span class="string">"logback"</span> ]</span><br><span class="line">        sincedb_path =&gt; <span class="string">"./sincedb"</span>	<span class="comment"># sincedb会记录日志文件的inode信息及当前读了多少bytes,以确保logstash停掉重启后可接着之前的位置继续收集日志</span></span><br><span class="line">		sincedb_write_interval =&gt; <span class="number">10</span>	<span class="comment"># 写sincedb的频率,logstash停止时会自动将当前收集位置记录到sincedb</span></span><br><span class="line">		<span class="comment">#start_position =&gt; "beginning"	# 注意,一定要设为beginning,默认是end.因为如果在logstash停掉期间,日志被rotate了两次,意味着有一整个日志文件是完全没有sincedb记录,logstash重启后就直接从start_position开始读,所以一定要设置为beginning.对于有sincedb记录的,logstash会接着停掉时的sincedb记录的位置继续收集日志</span></span><br><span class="line">		discover_interval =&gt; <span class="number">10</span></span><br><span class="line">		stat_interval =&gt; <span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> [message] =~ <span class="string">"^\[.+?\]"</span> &#123;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		drop&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	grok &#123;</span><br><span class="line">		match =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"\[(?&lt;log_id&gt;.*?)\] (?&lt;log_level&gt;\w+)  %&#123;TIMESTAMP_ISO8601:log_time&#125; (?&lt;system&gt;\w+) \[(?&lt;thread_name&gt;.+?)\] (?&lt;class_name&gt;.+)\- (?&lt;content&gt;.*)"</span> &#125;</span><br><span class="line">		remove_field =&gt; [ <span class="string">"message"</span> ]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	date &#123;</span><br><span class="line">    	match =&gt; [ <span class="string">"log_time"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>, <span class="string">"ISO8601"</span> ]</span><br><span class="line">    	timezone =&gt; <span class="string">"Asia/Shanghai"</span></span><br><span class="line">    	target =&gt; <span class="string">"@timestamp"</span></span><br><span class="line">    	remove_field =&gt; [ <span class="string">"log_time"</span> ]</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> [content] =~ <span class="string">"^\&#123;.*?\&#125;$"</span> &#123;</span><br><span class="line">  	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  		drop&#123;&#125;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">	json &#123;</span><br><span class="line">        source =&gt; <span class="string">"content"</span></span><br><span class="line">        target =&gt; <span class="string">"jsoncontent"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">	stdout &#123;&#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">  		hosts =&gt; <span class="string">"localhost:9200"</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先来看看Input{}. 他使用了<code>file</code>插件,从文件读取读取日志,并且给日志增加了一个Type属性用于区别来源.同时,1秒一次的监控日志的变化,把已扫描了的日志偏移量记录到<code>./sincedb</code>中去.</li>
<li>接下来就是filter{}了.<ul>
<li>一来,使用if语句,正则匹配<code>[]</code>开头的日志行,这个符合这个正则的日志才予以保留,其他的日志直接删除掉.</li>
<li>而后使用了grok插件,这个插件最重要的功能就是进行ETL转换,把非结构化的日志,转换成结构化的对象. 它使用正则表达式,以及<code>&lt;xxxx&gt;</code>的形式用来匹配和挖取有用的变量.</li>
<li>比如这个例子中的:<code>\[(?&lt;log_id&gt;.*?)\] (?&lt;log_level&gt;\w+)  %{TIMESTAMP_ISO8601:log_time} (?&lt;system&gt;\w+) \[(?&lt;thread_name&gt;.+?)\] (?&lt;class_name&gt;.+)\- (?&lt;content&gt;.*)</code>就是用来匹配<code>[1450580425858_394] INFO  2015-12-20 11:00:25.873 XXXXXX [myScheduler-4] c.s.j.s.c.c.AbstractTaskDispatcher- {&quot;site&quot;:&quot;unknown_site&quot;,&quot;tags&quot;:[&quot;unknown_tag&quot;],&quot;throwable&quot;:&quot;&quot;,&quot;detail&quot;:&quot;扫描模式,fileanalysis组件调度器,开始恢复上次待分配的任务.isChangePriority=false&quot;,&quot;time&quot;:&quot;2015-12-20 11:00:25.873&quot;,&quot;system&quot;:&quot;XXXXXX&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;source&quot;:&quot;unknown_source&quot;,&quot;extends&quot;:{},&quot;tool&quot;:&quot;unknown_tool&quot;,&quot;user&quot;:&quot;unknown_user&quot;,&quot;client_ip&quot;:&quot;unknown_ip&quot;,&quot;ip&quot;:&quot;172.16.129.7&quot;}</code>日志的.</li>
<li>通过grok插件的处理,这个时候日志事件就变为一个结构化的数据了.针对这个数据我们就可以进行很多其他的处理.</li>
<li>下面使用了<code>date</code>插件来处理日期.它定义了日期的标准格式,以及时区.然后把解析出来的时间赋值给模型上的某个字段.</li>
<li>接下来,再次使用<code>if</code>语句,对模型中的<code>content</code>字段再次进行清洗,对于不是JSON格式的日志,直接删除.</li>
<li>最后,使用<code>json</code>插件,把<code>content</code>字段JSON化.<br>最后使用output{}把转换好的日志输出到两个地方,一个是控制台,另外一个就是前文所说的<code>elasticsearch</code>了.</li>
</ul>
</li>
</ul>
<p>当我们执行这个日志采集Agent后,他就会不断的监控日志文件.一旦日志文件有变化,他就会采集到,并做处理,然后发送到es中. 最后我们就可以使用kibana来进行查看了.</p>
<h2 id="总结">总结</h2><p>本文主要介绍了ELK的作用,以及安装. 以一个简单的配置例子,介绍了ELK整合的常用方式以及效果.<br>通过ELK,可以把以前很麻烦的分布式日志的收集和整理简单化了.<br>更高级的功能,随着我使用的深入,会继续更新博文.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ELK(ElasticSearch+Logstash+Kiabana)初实践">ELK(ElasticSearch+Logstash+Kiabana)初实践</h1><p>ELK是由<a href="https://www.elastic.co">elastic</a>公司维护的开源的实时日志采集与分析三剑客.它能够在分布式的架构下,使用<a href="https://www.elastic.co/products/logstash">Logstash</a>实时的采集各种不同来源的日志,并通过清洗/ETL转换,形成有意义的数据,存入到<a href="https://www.elastic.co/products/elasticsearch">ElasticSearch</a>全文检索引擎中,再通过<a href="https://www.elastic.co/products/kibana">Kiabana</a>呈现出来.<br>我们可以通过这套开源系统实时的了解服务器的软硬件信息,业务负载,错误异常等等.同时也能统一收集日志并做归档处理.当管理的机器非常多的时候这就非常的有意义了.</p>
<p><img src="/img/2015/12/21/1.png" alt=""></p>]]>
    
    </summary>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="日志挖掘" scheme="http://sunxiang0918.github.io/tags/%E6%97%A5%E5%BF%97%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>如何关闭OSX 10.11 SIP]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/10/%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%ADOSX-10-11-SIP/"/>
    <id>http://sunxiang0918.github.io/2015/12/10/如何关闭OSX-10-11-SIP/</id>
    <published>2015-12-10T14:27:09.000Z</published>
    <updated>2015-12-10T14:35:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何关闭OSX_10-11_SIP_(System_Integrity_Protection)">如何关闭OSX 10.11 SIP (System Integrity Protection)</h1><p>2015.10.8 01:50更新：实在忍不住，看完池老师的公众号，就升级了。问题果然是有的，池老师你还我睡眠时间，又整到凌晨……</p>
<ol>
<li>关于Homebrew的安装参考链接</li>
<li>Cocoapods使用这个命令安装sudo gem install -n /usr/local/bin cocoapods原因是原来使用的/usr/bin这个目录被rootless保护了，那个-n参数作用是把二进制文件安装到指定目录，参考stackoverflow解决Cocoapods无法安装 注意stackoverflow中提到的使用这个参数「rootless=0」就不要用了，该方法apple官方已经封了，要停用rootless就用我下述的方法（也是官方推荐方法）</li>
<li>……暂时就这些，有问题在更新，或者留言给我你的问题，我看看能不能解决</li>
</ol>
<p>注意：SIP功能是Apple在OSX上推出的系统完整性保护功能，对于普通MAC用户来说是一项安全保护功能，如果不了解他的作用请不要随意关闭，对于开发者来说，因为会使用到很多的第三方辅助工具（例如：Cocoapods、Homebrew），而这些工具可能会修改系统目录，在这些工具未推出适应OSX 10.11的版本时，有必要临时关闭SIP以确保开发工具的使用。</p>
<p>建议：普通用户随意，开发者目前请谨慎升级，如果你已经升级，相信你可能需要恶心一阵了，因为有些工具没有更新不能正常使用或部分功能失效，甚至在关闭SIP后也有点问题，当然你只要耐心等待软件更新和网友的智慧或是自己动手丰衣足食，很多问题还是可以解决的。</p>
<a id="more"></a>
<ol>
<li><p><strong>进入RecoveryHD</strong><br>开机按住<code>Option</code>键在出现的启动选择菜单中选择<code>RecoveryHD</code>进入恢复模式</p>
</li>
<li><p><strong>使用csrutil命令</strong><br>打开终端Terminal，键入<code>csrutil</code>可以显示该命令的使用方法</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">usage: csrutil &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">Modify the System Integrity Protection configuration. All configuration changes apply to the entire machine.</span><br><span class="line">Available commands:</span><br><span class="line"></span><br><span class="line">    clear</span><br><span class="line">        Clear the existing configuration. Only available <span class="keyword">in</span> Recovery OS.</span><br><span class="line">    <span class="built_in">disable</span></span><br><span class="line">        Disable the protection on the machine. Only available <span class="keyword">in</span> Recovery OS.</span><br><span class="line">    <span class="built_in">enable</span></span><br><span class="line">        Enable the protection on the machine. Only available <span class="keyword">in</span> Recovery OS.</span><br><span class="line">    status</span><br><span class="line">        Display the current configuration.</span><br><span class="line"></span><br><span class="line">    netboot</span><br><span class="line">        add &lt;address&gt;</span><br><span class="line">            Insert a new IPv4 address <span class="keyword">in</span> the list of allowed NetBoot sources.</span><br><span class="line">        list</span><br><span class="line">            Print the list of allowed NetBoot sources.</span><br><span class="line">        remove &lt;address&gt;</span><br><span class="line">            Remove an IPv4 address from the list of allowed NetBoot sources.</span><br></pre></td></tr></table></figure>
<p> 可以看到在正常系统模式下中仅可以用status命令查询SIP状态</p>
</li>
<li><p><strong>常用参数</strong></p>
<ul>
<li>clear：清除配置设置，等同于完全开启SIP(<code>仅在恢复模式下有效</code>)</li>
<li>disable：关闭SIP(<code>仅在恢复模式下有效</code>)</li>
<li>enable：开启SIP(<code>仅在恢复模式下有效</code>)</li>
<li>status：查询SIP状态</li>
</ul>
</li>
<li><p><strong>常用参数进阶</strong><br>除了可以完全关闭/打开，还可以进行单项和多项组合关闭相关功能，用法如下</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil <span class="built_in">enable</span> [--without kext|fs|debug|dtrace|nvram] [--no-internal]</span><br></pre></td></tr></table></figure>
<p> 单项使用：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo csrutil <span class="built_in">enable</span> –without fs：Filesystem Protections <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without kext：Kext Signing <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without debug：Debugging Restrictions <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without nvram：NVRAM Protections <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without dtrace：DTrace Restrictions <span class="built_in">disable</span></span><br></pre></td></tr></table></figure>
<p> 组合使用：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo csrutil <span class="built_in">enable</span> –without kext –without fs：Filesystem Protections and Kext Signing are disabled</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更多详情请参考：<br><a href="http://cms.35g.tw/coding/關閉-osx-10-11-sip-system-integrity-protection-功能/zh-hans/" target="_blank" rel="external">可丁丹尼@一路往前走2.0</a><br><a href="https://pikeralpha.wordpress.com/2015/08/19/csrutil-updated/" target="_blank" rel="external">csrutil updated in DP7</a><br><a href="http://www.idelta.info/archives/sip-rootless-internal-in-el-capitan/" target="_blank" rel="external">SIP/Rootless Internal in El Capitan</a></p>
<hr>
<p>原文链接:<a href="http://www.jianshu.com/p/0572336a0771" target="_blank" rel="external">http://www.jianshu.com/p/0572336a0771</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="如何关闭OSX_10-11_SIP_(System_Integrity_Protection)">如何关闭OSX 10.11 SIP (System Integrity Protection)</h1><p>2015.10.8 01:50更新：实在忍不住，看完池老师的公众号，就升级了。问题果然是有的，池老师你还我睡眠时间，又整到凌晨……</p>
<ol>
<li>关于Homebrew的安装参考链接</li>
<li>Cocoapods使用这个命令安装sudo gem install -n /usr/local/bin cocoapods原因是原来使用的/usr/bin这个目录被rootless保护了，那个-n参数作用是把二进制文件安装到指定目录，参考stackoverflow解决Cocoapods无法安装 注意stackoverflow中提到的使用这个参数「rootless=0」就不要用了，该方法apple官方已经封了，要停用rootless就用我下述的方法（也是官方推荐方法）</li>
<li>……暂时就这些，有问题在更新，或者留言给我你的问题，我看看能不能解决</li>
</ol>
<p>注意：SIP功能是Apple在OSX上推出的系统完整性保护功能，对于普通MAC用户来说是一项安全保护功能，如果不了解他的作用请不要随意关闭，对于开发者来说，因为会使用到很多的第三方辅助工具（例如：Cocoapods、Homebrew），而这些工具可能会修改系统目录，在这些工具未推出适应OSX 10.11的版本时，有必要临时关闭SIP以确保开发工具的使用。</p>
<p>建议：普通用户随意，开发者目前请谨慎升级，如果你已经升级，相信你可能需要恶心一阵了，因为有些工具没有更新不能正常使用或部分功能失效，甚至在关闭SIP后也有点问题，当然你只要耐心等待软件更新和网友的智慧或是自己动手丰衣足食，很多问题还是可以解决的。</p>]]>
    
    </summary>
    
      <category term="MAC" scheme="http://sunxiang0918.github.io/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nutch2.3 安装与部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/08/Nutch2-3-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/12/08/Nutch2-3-安装与部署/</id>
    <published>2015-12-08T14:15:32.000Z</published>
    <updated>2015-12-08T15:26:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Nutch2-3_安装与部署">Nutch2.3 安装与部署</h1><p><a href="http://nutch.apache.org" target="_blank" rel="external">Nutch</a>是由JAVA开发的开源的全文检索引擎.不过更多的被用来当成Web爬虫来使用.现在Nutch分为了1.x和2.x两个版本在维护.而这两个版本的最主要的区别在于底层存储的抽象.1.x版本是基于Hadoop架构的,底层存储只能使用HDFS.而2.x版本通过<a href="http://gora.apache.org" target="_blank" rel="external">Apache Gora</a>对底层存储做了抽象,能访问HBase,MYSQL,MongoDB,Solr,AvroStore等等.</p>
<p>但是从2.X开始,官方就只提供源码的下载了,不再提供编译后的发布版本,因此就需要我们自己去进行编译.</p>
<a id="more"></a>
<h2 id="编译">编译</h2><p>为了简便起见,我们准备底层的存储使用mongoDB. 因此,这个演示是基于 Nutch+MongoDB的.</p>
<ol>
<li><p>下载源码<br> 从官网上下载<a href="http://www.apache.org/dyn/closer.lua/nutch/2.3/apache-nutch-2.3-src.tar.gz" target="_blank" rel="external">http://www.apache.org/dyn/closer.lua/nutch/2.3/apache-nutch-2.3-src.tar.gz</a>.然后执行命令 <code>tar -xvf apache-nutch-2.3-src.tar.gz</code>进行解压.</p>
</li>
<li><p>修改<code>$NUTCH_HOME/conf/nutch-site.xml</code>,增加以下内容:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>storage.data.store.class<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>org.apache.gora.mongodb.store.MongoStore<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">description</span>&gt;</span>Default class for storing data<span class="tag">&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>http.agent.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>My Nutch Spider<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>$NUTCH_HOME/conf/gora.properties</code>,在最下面找到<code># MongoDBStore properties  #</code>,然后打开注释:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################</span></span><br><span class="line"><span class="comment"># MongoDBStore properties  #</span></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line">gora.datastore.default=org.apache.gora.mongodb.store.MongoStore</span><br><span class="line">gora.mongodb.override_hadoop_configuration=<span class="literal">false</span></span><br><span class="line">gora.mongodb.mapping.file=/gora-mongodb-mapping.xml</span><br><span class="line">gora.mongodb.servers=localhost:<span class="number">27017</span></span><br><span class="line">gora.mongodb.db=mytestdatabase</span><br><span class="line"><span class="comment">#gora.mongodb.login=login</span></span><br><span class="line"><span class="comment">#gora.mongodb.secret=secret</span></span><br></pre></td></tr></table></figure>
<p> 注意,如果你的mongo数据库没有auth,最后两行需要注释掉.</p>
</li>
<li><p>修改<code>$NUTCH_HOME/ivy/ivy.xml</code>.去掉下面的注释,使用gora-hbase:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Uncomment this to use MongoDB as Gora backend. --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">dependency</span> <span class="attribute">org</span>=<span class="value">"org.apache.gora"</span> <span class="attribute">name</span>=<span class="value">"gora-mongodb"</span> <span class="attribute">rev</span>=<span class="value">"0.5"</span> <span class="attribute">conf</span>=<span class="value">"*-&gt;default"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> 这个地方需要特别注意一下,这里虽然使用了<code>gora-mongodb-0.5</code>,但是这个版本其实是有问题的,会在后面抓取记录保存到MongoDB的时候报:<code>java.lang.IllegalArgumentException: can&#39;t serialize class
org.apache.avro.util.Utf8</code>的异常,开始折腾了我很久.最后发现了这个是<code>gora-mongodb-0.5</code>自身的一个<a href="https://issues.apache.org/jira/browse/GORA-388" target="_blank" rel="external">Bug</a>,在0.6中是被修复了的.因此,我最开始想把整个gora升级成为0.6,结果Nutch不能执行.因此,目前阶段如果你底层想要使用MongoDB进行存储的话,需要单个把<code>gora-mongodb</code>升级到<code>0.6</code>版本,而其他的不动.</p>
</li>
<li><p>接下来就是编译了,直接在<code>$NUTCH_HOME</code>根目录上执行<code>ant runtime</code>即可.<br> 但是这个速度不得不吐槽.非常的坑爹,基本上下了我3个多小时.不知道是什么原因,我平时使用JAVA的Maven环境的时候下载其实是非常的快的.但是IVY的依赖下载就非常非常非常的慢.理论上他们是同一个网络地址啊. 为了能加速那么一丢丢.可以把<code>$NUTCH_HOME/ivy/ivysettings.xml</code>中的<code>repo.maven.org</code>给替换成国内的镜像.比如:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"repo.maven.org"</span></span><br><span class="line">   <span class="attribute">value</span>=<span class="value">"http://maven.oschina.net/content/groups/public/"</span></span><br><span class="line">   <span class="attribute">override</span>=<span class="value">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 其他的两个不能替换,我换了以后会找不到包的.</p>
<p> 如果你的编译长时间的停在<code>[ivy:resolve] :: loading settings :: file = $NUTCH_HOME/ivy/ivysettings.xml</code>.那么你可以把进程杀了重新执行一次<code>ant runtime</code>.可能执行个十来次就能编译成功了.</p>
<p> 最终,会显示:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">job:</span><br><span class="line">     [jar] Building jar: <span class="variable">$NUTCH_HOME</span>/build/apache-nutch-<span class="number">2.3</span>.job</span><br><span class="line">runtime:</span><br><span class="line">    [copy] Copying <span class="number">1</span> file to <span class="variable">$NUTCH_HOME</span>/nutch/runtime/deploy</span><br><span class="line">    [copy] Copying <span class="number">2</span> files to <span class="variable">$NUTCH_HOME</span>/nutch/runtime/<span class="built_in">local</span>/lib</span><br><span class="line">BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure>
<p> 然后会在你的<code>$NUTCH_HOME</code>目录下,创建<code>runtime</code>和<code>build</code>目录. 其中的<code>runtime</code>目录即为你编译好了的<code>Nutch2.3</code>.</p>
<p> 如果在编译过程中出现<code>Could not load definitions from resource org/sonar/ant/antlib.xml.It could not be found.</code>的警告的话,不要着急,这个错误不影响你最后的编译是否成功.如果你有强迫症,见不得有警告的话.那么可以到<a href="http://search.maven.org" target="_blank" rel="external">Maven</a>中下载<code>sonar-ant-task-2.2.jar</code>包,然后放入<code>$NUTCH_HOME/lib</code>,然后修改<code>$NTUCH_HOME/build.xml</code>即可:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Define the Sonar task if this hasn't been done in a common script --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">taskdef</span> <span class="attribute">uri</span>=<span class="value">"antlib:org.sonar.ant"</span> <span class="attribute">resource</span>=<span class="value">"org/sonar/ant/antlib.xml"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classpath</span> <span class="attribute">path</span>=<span class="value">"$&#123;ant.library.dir&#125;"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classpath</span> <span class="attribute">path</span>=<span class="value">"$&#123;mysql.library.dir&#125;"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classpath</span>&gt;</span><span class="tag">&lt;<span class="title">fileset</span> <span class="attribute">dir</span>=<span class="value">"lib/"</span> <span class="attribute">includes</span>=<span class="value">"sonar*.jar"</span> /&gt;</span><span class="tag">&lt;/<span class="title">classpath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">taskdef</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="部署">部署</h2><p>其实编译完成后的<code>runtime</code>文件夹就已经是一个完整的可以运行的环境了.<br>我们在这里做一个简单的测试:使用Nutch爬取<a href="http://www.cnbeta.com" target="_blank" rel="external">cnbeta</a>中的新闻文章.</p>
<ol>
<li><p>在<code>$NUTCH_HOME/runtime/local</code>下创建一个文件<code>seed.txt</code>. 里面就是需要爬取的网站,一行一个.我们在这里只写一行:<code>www.cnbeta.com</code></p>
</li>
<li><p>修改<code>$NUTCH_HOME/runtime/cong/automaton-urlfilter.txt</code>文件,这个文件就是URL的过滤.避免爬取到不需要的网站.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># accept anything else</span></span><br><span class="line">+^http://www.cnbeta.com/$</span><br><span class="line">+^http://www.cnbeta.com/articles/\d\.htm$</span><br><span class="line"><span class="comment"># skip everything else</span></span><br><span class="line">-.</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在命令行中执行<code>$NUTCH_HOME/runtime/bin/crawl seed.txt test 2</code>.<br> 这个时候就会开始爬取目标网站了.你会看到很多的日志信息:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	fetching http://www.cnbeta.com/topics/<span class="number">8</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">71</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">28</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">464</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">72</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">27</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">455</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">73</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">68</span> <span class="number">102</span> kb/s, <span class="number">26</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">83</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">49</span>/<span class="number">50</span> spinwaiting/active, <span class="number">73</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">0</span> kb/s, <span class="number">25</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">74</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">25</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">444</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">75</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">68</span> <span class="number">102</span> kb/s, <span class="number">24</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/commentrss.php (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">76</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">0</span> kb/s, <span class="number">23</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">197</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">77</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">22</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br></pre></td></tr></table></figure>
<p> 等一段时间后,爬取就完成了.然后打开Mongo数据库,就会看到有一个<code>mytestdatabase</code>的库.里面有一个<code>test_webpage</code>的表,其中的东西就是爬虫爬取的内容了.随便抓取一个举例:</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">	&#123;</span><br><span class="line">  "_id": "com.cnbeta.www:http/articles/447355.htm",</span><br><span class="line">  "status": 2,</span><br><span class="line">  "fetchTime": NumberLong(1449587050404),</span><br><span class="line">  "fetchInterval": 2592000,</span><br><span class="line">  "retriesSinceFetch": 0,</span><br><span class="line">  "score": 0.0,</span><br><span class="line">  "inlinks": &#123;</span><br><span class="line">    "http://www·cnbeta·com/": ""</span><br><span class="line">  &#125;,</span><br><span class="line">  "markers": &#123;</span><br><span class="line">    "_gnmrk_": "1449586889-28161",</span><br><span class="line">    "_ftcmrk_": "1449586889-28161",</span><br><span class="line">    "dist": "1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "metadata": &#123;</span><br><span class="line">    "_rs_": BinData(0, "AAABzw==")</span><br><span class="line">  &#125;,</span><br><span class="line">  "batchId": "1449586889-28161",</span><br><span class="line">  "baseUrl": "http://www.cnbeta.com/articles/447355.htm",</span><br><span class="line">  "prevFetchTime": NumberLong(1449586888595),</span><br><span class="line">  "protocolStatus": &#123;</span><br><span class="line">    "code": 1,</span><br><span class="line">    "args": [</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">    "lastModified": NumberLong(0)</span><br><span class="line">  &#125;,</span><br><span class="line">  "content": BinData(0, "XXXXXX网页的内容,太长了,就省略了"),</span><br><span class="line">  "contentType": "application/xhtml+xml",</span><br><span class="line">  "headers": &#123;</span><br><span class="line">    "Vary": "Accept-Encoding",</span><br><span class="line">    "Date": "Tue, 08 Dec 2015 15:04:10 GMT",</span><br><span class="line">    "Last-Modified": "Sun, 06 Dec 2015 02:11:14 GMT",</span><br><span class="line">    "Content-Encoding": "gzip",</span><br><span class="line">    "Content-Type": "text/html",</span><br><span class="line">    "Accept-Ranges": "bytes",</span><br><span class="line">    "Connection": "close",</span><br><span class="line">    "Server": "grid-cache/1.4.4",</span><br><span class="line">    "X-CDNZZ-FCACHE": "EXPIRED"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这就是爬取下来的内容.就可以通过我们进一步处理了.<br> 而这个字段的定义是在<code>$NUTCH_HOME/runtime/local/conf/gora-mongodb-mapping.xml</code>中定义的.</p>
</li>
</ol>
<h2 id="结束语">结束语</h2><p>这样,一个最简单的Nutch的运行环境就搭建成功了.更多的更高级的功能,我们后面再慢慢来试验.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Nutch2-3_安装与部署">Nutch2.3 安装与部署</h1><p><a href="http://nutch.apache.org">Nutch</a>是由JAVA开发的开源的全文检索引擎.不过更多的被用来当成Web爬虫来使用.现在Nutch分为了1.x和2.x两个版本在维护.而这两个版本的最主要的区别在于底层存储的抽象.1.x版本是基于Hadoop架构的,底层存储只能使用HDFS.而2.x版本通过<a href="http://gora.apache.org">Apache Gora</a>对底层存储做了抽象,能访问HBase,MYSQL,MongoDB,Solr,AvroStore等等.</p>
<p>但是从2.X开始,官方就只提供源码的下载了,不再提供编译后的发布版本,因此就需要我们自己去进行编译.</p>]]>
    
    </summary>
    
      <category term="Nutch" scheme="http://sunxiang0918.github.io/tags/Nutch/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="爬虫" scheme="http://sunxiang0918.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Linux上运行Swift]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/05/%E5%9C%A8Linux%E4%B8%8A%E8%BF%90%E8%A1%8CSwift/"/>
    <id>http://sunxiang0918.github.io/2015/12/05/在Linux上运行Swift/</id>
    <published>2015-12-05T15:26:26.000Z</published>
    <updated>2015-12-05T16:29:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Linux上运行Swift">在Linux上运行Swift</h1><p>盼星星盼月亮,等了半年,终于在12月的头几天,苹果开源了<code>Swift</code>语言.并建立了一个<a href="http://swift.org" target="_blank" rel="external">Swift.org</a>社区以及<a href="http://github.com/apple" target="_blank" rel="external">Github</a>来维护.开源以后,最大的好处当然是有更多的人来参与Swift语言的发展,让Swift语言增加更多的新的特性,更多的开源框架,工作在更多的平台上面.这对于一个开发语言来说无疑是一个很好的消息.而对于我来说,除了在编写代码的时候能更了解Swift某些函数的参数意义和工作的原理(作为一个JAVA Coder,平时如果遇到搞不定的问题或者是不明白的地方,习惯了直接翻它的源码来了解原委的)外,让我基本上抛弃了<code>Python</code>脚本,平时有什么小东西小程序需要写一下的话,现在可以直接写一个Swift文件,然后在命令行直接调用<code>swift xxx.swift</code>或者<code>swiftc -O xxxx.swift</code>即可.</p>
<h2 id="在Linux上安装Swift">在Linux上安装Swift</h2><p>前面废话说了这么多.现在就来看看如何在Linux上安装Swift的运行环境.MACOS上的就不用说了,直接安装一个Xcode就可以了.</p>
<a id="more"></a>
<h3 id="环境">环境</h3><p>目前Swift提供了<code>Ubuntu</code>上编译好了的安装包. 因此需要Ubuntu14.04以上的操作系统.<br>同时,Swift的编译环境还需要<code>clang</code>.这个也是需要安装的.</p>
<ol>
<li><p>由于<code>clang</code>目前才出来,比较的新.因此在<code>cn.archive.ubuntu.com</code>上还没有,需要切换到官方源上去.</p>
<ol>
<li>备份原来的源列表 <code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></li>
<li><p>使用编辑器打开<code>sources.list</code>文件,修改里面的内容为:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-security main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-updates main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-proposed main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-backports main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-security main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-updates main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-proposed main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后更新一下源 <code>sudo apt-get update</code></p>
</li>
<li><p>安装<code>clang</code></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install clang libicu-dev</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>下载,并安装<code>Swift</code></p>
<ol>
<li>在<a href="https://swift.org/download/" target="_blank" rel="external">官方网站</a>上下载与你操作系统对应的安装包.比如我用的<code>Ubuntu 14.10</code>操作系统,那么就下载<a href="https://swift.org/builds/ubuntu1404/swift-2.2-SNAPSHOT-2015-12-01-b/swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu14.04.tar.gz" target="_blank" rel="external">swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu14.04.tar.gz</a></li>
<li><p>下载后,解压到本地目录.由于它都是安排好了目录的.都是<code>/usr</code>下面.因此.只需要拷贝到/usr下面即可.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -R /swift/usr/ /</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样,Swift的运行环境就算是安装完成了.我们可以输入<code>swift --version</code>来做验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Parallels-Virtual-Platform:~$ swift --versionSwift version <span class="number">2.2</span>-dev (LLVM <span class="number">46</span>be9ff861, Clang <span class="number">4</span>deb154edc, Swift <span class="number">778</span>f82939c)Target: x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="在命令行中执行一个简单程序">在命令行中执行一个简单程序</h2><p>既然安装完成了运行环境,那么接下来我们就试着编写一个最简单的程序.然后执行.</p>
<ol>
<li>创建一个<code>test.swift</code>文件.</li>
<li>在其中写上</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Hello Swift!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<ol>
<li>保存文件后,在命令行中执行 <code>swift test.swift</code>.即可得到程序执行的结果.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Parallels-Virtual-Platform:~$ swift test.swift</span><br><span class="line">Hello Swift!</span><br></pre></td></tr></table></figure>
<ol>
<li>我们也可以把这个文件直接编译成可执行的程序:<code>swift -O test.swift</code>.执行了这个命令后,会在当前目录生成一个<code>test</code>可执行文件. 直接在命令行中执行<code>./test</code>也是可以得到结果的.</li>
</ol>
<p>Swift的命令行程序与其他的语言不同,它不需要一个特殊约定的<code>main</code>函数. 只要你执行的命令的作用于是全局的,那么在就会在执行的时候按顺序的先执行这些全局作用于的语句.相当于它的全局作用域就是一个大的<code>main</code>函数.<br>又由于一个Swift文件中可以写很多的类或方法,不想<code>JAVA</code>一样,一个<code>java</code>文件只能有一个公开的类.因此,对于一个简单的小程序来说,我们完全可以把所有的代码都写在一个<code>swift</code>文件中,然后进行执行,不用考虑什么包依赖等等,非常的方便.</p>
<h2 id="在命令行中执行一个多文件编译的程序">在命令行中执行一个多文件编译的程序</h2><p>当然,除了最最简单的只有1个文件的程序外,更多的程序都是有代码结构的,都是由多个<code>swift</code>文件组成的.<br>在这种情况下,就需要使用<code>swift build</code>命令来 多文件协同编译了.</p>
<ol>
<li><p>这种情况下的swift程序源码需要按照一定的约定来创建.</p>
<ol>
<li>项目的名称即为目录的名称. 比如我现在有个<code>TestProgram</code>的项目,那么就需要创建一个<code>TestProgram</code>的目录.</li>
<li>在这个目录下创建一个<code>Package.swift</code>文件,这个文件是必须的,它用于提供给包管理器进行包依赖的信息.这就类似于JAVA中的<code>package-info.java</code></li>
<li>创建一个<code>Sources</code>文件夹,所有的源码都应该放在这里</li>
<li>在<code>Sources</code>文件夹下,创建一个<code>main.swift</code>文件,这个就是应用的入口文件.</li>
<li><p>最终,项目的结构就是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/TestProgram</span><br><span class="line">/TestProgram/Package.swift</span><br><span class="line">/TestProgram/Sources/main.swift</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>为了体现多文件协同编译,现在再在<code>Sources</code>目录下新增加一个文件<code>Hello.swif</code></p>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(a:<span class="params">(name:String)</span></span></span>-&gt;<span class="type">Void</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> args = <span class="type">Process</span>.arguments</span><br><span class="line">		<span class="keyword">if</span> args.<span class="built_in">count</span> &gt;= <span class="number">2</span>&#123;</span><br><span class="line">			a(name:args[<span class="number">1</span>])</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"Hello Swift!"</span>)</span><br><span class="line">		&#125;       &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>然后在<code>main.swift</code>中编写:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello(&#123;name <span class="keyword">in</span> <span class="built_in">print</span>(<span class="string">"Hello <span class="subst">\(name)</span> on Linux!"</span>)&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到项目的根目录<code>/TestProgram</code>.执行<code>swift build</code>编译即可.正确的话它会输出以下信息</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Parallels-Virtual-Platform:~/TestProject$ swift buildCompiling Swift Module <span class="string">'TestProject'</span> (<span class="number">2</span> sources)Linking Executable:  .build/debug/TestProjectroot@Parallels-Virtual-Platform:~/TestProject$ .build/debug/TestProject</span><br></pre></td></tr></table></figure>
<p> 需要注意的是,<code>swift build</code>会在工程目录下生成一个<code>.build</code>文件夹,里面就是编译后的可执行的文件,默认是使用的<code>debug target</code>. 并且<code>Linux</code>下编译的可执行文件是不能直接在<code>OSX</code>上使用的,反之亦然.</p>
</li>
<li><p>直接调用<code>.build/debug/TestProject</code> 便可执行程序.</p>
</li>
<li><p>第二步的代码中有一句<code>let args = Process.arguments</code>.我们可以通过此函数获取命令行的输入,它肯定是一个大于等于1的数组,第一个元素就是程序自己的名字.后面是用户在命令行中输入的参数,并且不仅仅限于<code>main.swift</code>才能获取,任何的Swift文件中都可以取得这个值.因此,我们刚才的程序也可以这样输入:<code>.build/debug/TestProject SUN</code>.那么程序的<code>args[1]</code>即为<code>SUN</code>.</p>
</li>
<li>由于Swift不需要像<code>JAVA</code>或者<code>OC</code>一样,如果源码在两个源文件中就需要编写一堆无用的<code>import</code>语句,只要在同一个项目中,<code>Swift</code>的不同源文件定义的类或函数都可以直接的调用,只有在跨工程或<code>Framework</code>的时候,才需要<code>import Package</code>.这大大的方便了我们编写项目.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在Linux上运行Swift">在Linux上运行Swift</h1><p>盼星星盼月亮,等了半年,终于在12月的头几天,苹果开源了<code>Swift</code>语言.并建立了一个<a href="http://swift.org">Swift.org</a>社区以及<a href="http://github.com/apple">Github</a>来维护.开源以后,最大的好处当然是有更多的人来参与Swift语言的发展,让Swift语言增加更多的新的特性,更多的开源框架,工作在更多的平台上面.这对于一个开发语言来说无疑是一个很好的消息.而对于我来说,除了在编写代码的时候能更了解Swift某些函数的参数意义和工作的原理(作为一个JAVA Coder,平时如果遇到搞不定的问题或者是不明白的地方,习惯了直接翻它的源码来了解原委的)外,让我基本上抛弃了<code>Python</code>脚本,平时有什么小东西小程序需要写一下的话,现在可以直接写一个Swift文件,然后在命令行直接调用<code>swift xxx.swift</code>或者<code>swiftc -O xxxx.swift</code>即可.</p>
<h2 id="在Linux上安装Swift">在Linux上安装Swift</h2><p>前面废话说了这么多.现在就来看看如何在Linux上安装Swift的运行环境.MACOS上的就不用说了,直接安装一个Xcode就可以了.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MYSQL支持utf8mb4]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/02/MYSQL%E6%94%AF%E6%8C%81utf8mb4/"/>
    <id>http://sunxiang0918.github.io/2015/12/02/MYSQL支持utf8mb4/</id>
    <published>2015-12-02T14:41:52.000Z</published>
    <updated>2015-12-02T14:59:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MYSQL支持utf8mb4">MYSQL支持utf8mb4</h1><p>MYSQL默认的utf8字符集采用了3个字节来进行保存.这就存在了一个问题,那就是有部分的UTF8的字符其实是保存不进MYSQL的,比如现在流行的emoji表情,这和以前的认知是不同的.为了避免以后出现问题,找了这方面的信息.推荐如果有保存扩展字符的用户,提前就把MYSQL的字符集给修改了.具体MYSQL的默认utf8支持哪些字符编码,可以参见这个:<a href="http://witmax.cn/unicode-list.html" target="_blank" rel="external">Unicode编码表</a>,前126行就是它支持的,后面的就是不支持的.</p>
<p>发现这个问题其实相当的偶然,在知乎上看到了一个问题<a href="http://www.zhihu.com/question/35901422/answer/64960598" target="_blank" rel="external">为什么知乎不支持non-BMP的汉字？</a>.突然发现了这个问题,一验证果然如此.<br>具体来说就是MYSQL的utf8字符集只使用了3个字节来保存字符.因此UTF8扩展区的字符就无法保存.这个在MYSQL5.5后引入了<code>utf8mb4</code>的字符集来解决这个问题,它使用了4个字节来存储字符,扩展了存储的数量.因此,如果各位是使用的MYSQL5.5以上的版本,推荐在可能存入扩展字符的字段上设置字符集为utf8mb4.虽然这样可能会造成空间的浪费,但是比以后在上线的系统上升级数据库的风险要小的多.</p>
<a id="more"></a>
<h2 id="修改方法">修改方法</h2><h3 id="MYSQL服务器端">MYSQL服务器端</h3><p>只需要修改数据库的配置文件 <code>/etc/my.cnf</code>,增加或修改以下两行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">character-set-server=utf8mb4 </span><br><span class="line">collation_server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>
<p>然后重启数据库即可.<br>对于已有的表,执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span></span><br></pre></td></tr></table></figure>
<p>即可.</p>
<h3 id="客户端">客户端</h3><p>由于JDBC的MYSQL驱动现在不支持显示的设置<code>utf8mb4</code>字符集,所以不能在url连接上增加<code>characterEncoding=utf8mb4</code>.<br>那么就只能采取以下的三种方法了(都需要高版本的JDBC驱动):</p>
<ol>
<li>在服务器上设置了<code>character-set-server=utf8mb4</code>后,在客户端url上不显示的设置字符集,它会自动继承服务器的设置</li>
<li>在执行SQL之前,运行<code>set names utf8mb4</code>.例如:<code>connection.prepareStatement(&quot;set names utf8mb4&quot;).executeQuery();</code></li>
<li>设置MYSQL的 init_connect参数,设置<code>set names utf8mb4</code>.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MYSQL支持utf8mb4">MYSQL支持utf8mb4</h1><p>MYSQL默认的utf8字符集采用了3个字节来进行保存.这就存在了一个问题,那就是有部分的UTF8的字符其实是保存不进MYSQL的,比如现在流行的emoji表情,这和以前的认知是不同的.为了避免以后出现问题,找了这方面的信息.推荐如果有保存扩展字符的用户,提前就把MYSQL的字符集给修改了.具体MYSQL的默认utf8支持哪些字符编码,可以参见这个:<a href="http://witmax.cn/unicode-list.html">Unicode编码表</a>,前126行就是它支持的,后面的就是不支持的.</p>
<p>发现这个问题其实相当的偶然,在知乎上看到了一个问题<a href="http://www.zhihu.com/question/35901422/answer/64960598">为什么知乎不支持non-BMP的汉字？</a>.突然发现了这个问题,一验证果然如此.<br>具体来说就是MYSQL的utf8字符集只使用了3个字节来保存字符.因此UTF8扩展区的字符就无法保存.这个在MYSQL5.5后引入了<code>utf8mb4</code>的字符集来解决这个问题,它使用了4个字节来存储字符,扩展了存储的数量.因此,如果各位是使用的MYSQL5.5以上的版本,推荐在可能存入扩展字符的字段上设置字符集为utf8mb4.虽然这样可能会造成空间的浪费,但是比以后在上线的系统上升级数据库的风险要小的多.</p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="Mysql" scheme="http://sunxiang0918.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在自己的App中嵌入onePassword密码管理]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/30/%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84App%E4%B8%AD%E5%B5%8C%E5%85%A5onePassword%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    <id>http://sunxiang0918.github.io/2015/11/30/在自己的App中嵌入onePassword密码管理/</id>
    <published>2015-11-30T11:36:31.000Z</published>
    <updated>2015-12-02T15:19:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在自己的App中嵌入onePassword密码管理">在自己的App中嵌入onePassword密码管理</h1><p><a href="https://agilebits.com/onepassword/" target="_blank" rel="external">1Password</a>是一个密码管理软件,它可以方便和安全的管理你的密码.它提供反钓鱼保护功能和卓越的密码管理,并具有自动生成强密码功能.所有的机密资料,包括密码,身份卡和信用卡,都是保存在一个安全的地方.在OSX和IOS系统上非常的流行.在我的博文<a href="/2015/09/21/MacOS下JAVA开发使用经验(一">MacOS下JAVA开发使用经验(一)</a> )也有介绍.<br>自从我的账号被CSDN泄露的干干净净以后的一段时间里,我的其他账号是不是的就会收到更改密码的邮件.于是,一下狠心购买了<code>1Password</code>,并且把我所有的差不多200多个账号的密码通过<code>1Password</code>都给改成了14位的随机字符,以后就不用担心一个密码丢失导致其他的账号也丢失了(1Password自己本身在它的网上没有所谓的用户名密码,密码是通过加密文件整体在WIFI或iCloud中同步的.).但是这就带来了一个麻烦,就是我的密码都变成了类似于这样的<code>RxCa9vdBUB3fCU</code>的字符串.当使用safari这些的时候还好,它有浏览器的插件可以自动填充.遇到一些App,就只能手动的输入了(类似于光大银行和QQ不允许粘贴密码).这相当的麻烦,又容易出错.因此,自己开发APP的时候,就特别的注意了在输入密码的地方要与<code>1Password</code>的整合,这点网易系的APP就做的比较好,<code>网易云音乐</code>和<code>考拉海淘</code>就是支持了<code>1Password</code>的.<br>要在自己的App中引入<code>1Password</code>其实也不麻烦,可以说是相当的简单.<code>1Password</code>在<code>GitHub</code>上开源了App与它的软件交互的扩展<a href="https://github.com/AgileBits/onepassword-app-extension" target="_blank" rel="external">1PasswordExtension</a>.我们通过这个扩展就可以在自己的App中嵌入<code>1Password</code>的密码管理了.</p>
<a id="more"></a>
<h2 id="导入1PasswordExtension扩展">导入1PasswordExtension扩展</h2><p>这个可以使用<code>cocoaPods</code>. 在项目的<code>Pods</code>文件中增加<code>pod &#39;1PasswordExtension&#39;</code>,然后执行<code>pod install</code>即可.由于它已经兼容了<code>swift</code>了,所以不需要特别的再链接OC的头文件了.</p>
<h2 id="使用1Password进行登陆框的填充">使用1Password进行登陆框的填充</h2><p>这个过程也非常的简单.</p>
<ol>
<li>在登录的页面上增加一个按钮,<code>1PasswordExtension</code>内置好了它的图片,你可以直接使用.</li>
<li>给这个按钮增加点击的事件.</li>
<li><p>在Controller类中增加事件的实现,调用<code>public func findLoginForURLString(URLString: String, forViewController viewController: UIViewController, sender: AnyObject?, completion: (([NSObject : AnyObject]?, NSError?) -&gt; Void)?)</code>方法:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OnePasswordExtension</span>.sharedExtension().findLoginForURLString(<span class="string">""</span>, forViewController: <span class="keyword">self</span>, sender: sender) &#123; (_loginDictionary, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">			   <span class="comment">//loginDictionary中即用调用1Password后,用户选择的用户名和密码</span></span><br><span class="line">               guard <span class="keyword">let</span> loginDictionary = _loginDictionary <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> loginDictionary.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">               		<span class="comment">//如果用户点的是取消,这里就是0</span></span><br><span class="line">                   <span class="keyword">if</span> error!.code != <span class="type">Int</span>(<span class="type">AppExtensionErrorCodeCancelledByUser</span>) &#123;</span><br><span class="line">                       <span class="comment">//<span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//把用户名和密码赋值给输入框即可.更进一步的可以直接激活登录操作</span></span><br><span class="line">               view?.userNameField.text = loginDictionary[<span class="type">AppExtensionUsernameKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">               view?.passwordField.text = loginDictionary[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">               </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p> 效果如图:</p>
<p> <img src="/img/2015/11/30/1.PNG" alt=""><br> <img src="/img/2015/11/30/2.PNG" alt=""></p>
</li>
<li><p>如果更想进一步,只有当判断到安装了<code>1Password</code>程序,按钮才出现的话.可以调用<code>view?.onePasswordButton.hidden = !OnePasswordExtension.sharedExtension().isAppExtensionAvailable()</code>.这个方法会判断系统中是否有应用程序能处理<code>org-appextension-feature-password-management</code>这个特性.如果有程序可以执行,那么就返回<code>true</code>. 需要注意的是:在IOS9中你需要给<code>Info.plist</code>文件中增加一行记录:<br> <img src="/img/2015/11/30/3.png" alt=""><br> 更多的信息可以参见<a href="https://developer.apple.com/videos/wwdc/2015/?id=703" target="_blank" rel="external">Privacy and Your Apps session</a></p>
</li>
</ol>
<h2 id="使用1Password进行新用户的注册">使用1Password进行新用户的注册</h2><p>同使用1Password进行用户登陆差不多,新用户的注册也是很简单的.</p>
<ol>
<li>在登录的页面上增加一个按钮,<code>1PasswordExtension</code>内置好了它的图片,你可以直接使用.</li>
<li>给这个按钮增加点击的事件.</li>
<li><p>在Controller类中增加事件的实现,调用<code>public func storeLoginForURLString(URLString: String, loginDetails loginDetailsDictionary: [NSObject : AnyObject]?, passwordGenerationOptions: [NSObject : AnyObject]?, forViewController viewController: UIViewController, sender: AnyObject?, completion: (([NSObject : AnyObject]?, NSError?) -&gt; Void)?)</code>方法</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造1Password新注册用户页面的一些信息</span></span><br><span class="line"><span class="keyword">let</span> newLoginDetails:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="type">AppExtensionTitleKey</span>: <span class="string">"ACME"</span>,</span><br><span class="line">		<span class="type">AppExtensionUsernameKey</span>: <span class="keyword">self</span>.usernameTextField.text!,</span><br><span class="line">		<span class="type">AppExtensionPasswordKey</span>: <span class="keyword">self</span>.passwordTextField.text!,</span><br><span class="line">		<span class="type">AppExtensionNotesKey</span>: <span class="string">"Saved with the ACME app"</span>,</span><br><span class="line">		<span class="type">AppExtensionSectionTitleKey</span>: <span class="string">"ACME Browser"</span>,</span><br><span class="line">		<span class="type">AppExtensionFieldsKey</span>: [</span><br><span class="line">			<span class="string">"firstname"</span> : <span class="keyword">self</span>.firstnameTextField.text!,</span><br><span class="line">			<span class="string">"lastname"</span> : <span class="keyword">self</span>.lastnameTextField.text!</span><br><span class="line">			<span class="comment">// Add as many string fields as you please.</span></span><br><span class="line">		]</span><br><span class="line">	]</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置密码生成规则</span></span><br><span class="line">	<span class="keyword">let</span> passwordGenerationOptions:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="comment">// 密码最小长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMinLengthKey</span>: (<span class="number">8</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 最大密码长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMaxLengthKey</span>: (<span class="number">30</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 是否必须包含数字</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireDigitsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 字符必须包含符号</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireSymbolsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Here are all the symbols available in the the 1Password Password Generator:</span></span><br><span class="line">		<span class="comment">// !@#$%^&amp;*()_-+=|[]&#123;&#125;'\";.,&gt;?/~`</span></span><br><span class="line">		<span class="comment">// The string for AppExtensionGeneratedPasswordForbiddenCharactersKey should contain the symbols and characters that you wish 1Password to exclude from the generated password.</span></span><br><span class="line">		<span class="comment">//生成密码的时候排除的字符</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordForbiddenCharactersKey</span>: <span class="string">"!@#$%/0lIO"</span></span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用1Password,打开它的页面输入用户注册信息</span></span><br><span class="line">	<span class="type">OnePasswordExtension</span>.sharedExtension().storeLoginForURLString(<span class="string">"https://www.acme.com"</span>, loginDetails: newLoginDetails, passwordGenerationOptions: passwordGenerationOptions, forViewController: <span class="keyword">self</span>, sender: sender) &#123; (loginDictionary, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">		<span class="keyword">if</span> loginDictionary == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> error!.code != <span class="type">Int</span>(<span class="type">AppExtensionErrorCodeCancelledByUser</span>) &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"Error invoking 1Password App Extension for find login: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把用户输入的注册信息返回给界面组件</span></span><br><span class="line">		<span class="keyword">self</span>.usernameTextField.text = loginDictionary?[<span class="type">AppExtensionUsernameKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.passwordTextField.text = loginDictionary?[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.firstnameTextField.text = loginDictionary?[<span class="type">AppExtensionReturnedFieldsKey</span>]?[<span class="string">"firstname"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.lastnameTextField.text = loginDictionary?[<span class="type">AppExtensionReturnedFieldsKey</span>]?[<span class="string">"lastname"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p> 效果如图:</p>
<p> <img src="/img/2015/11/30/4.PNG" alt=""><br> <img src="/img/2015/11/30/5.PNG" alt=""></p>
</li>
</ol>
<h2 id="使用1Password进行密码的修改">使用1Password进行密码的修改</h2><p>既然有新用户的注册以及登陆,那么密码管理中还有一个就是密码的修改.</p>
<ol>
<li>在登录的页面上增加一个按钮,<code>1PasswordExtension</code>内置好了它的图片,你可以直接使用.</li>
<li>给这个按钮增加点击的事件.</li>
<li><p>在Controller类中增加事件的实现,调用<code>public func changePasswordForLoginForURLString(URLString: String, loginDetails loginDetailsDictionary: [NSObject : AnyObject]?, passwordGenerationOptions: [NSObject : AnyObject]?, forViewController viewController: UIViewController, sender: AnyObject?, completion: (([NSObject : AnyObject]?, NSError?) -&gt; Void)?)</code></p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造1Password修改密码页面的一些信息</span></span><br><span class="line"><span class="keyword">let</span> newLoginDetails:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="type">AppExtensionTitleKey</span>: <span class="string">"ACME"</span>, <span class="comment">// Optional, used for the third schenario only</span></span><br><span class="line">		<span class="type">AppExtensionUsernameKey</span>: <span class="string">"aUsername"</span>, <span class="comment">// Optional, used for the third schenario only</span></span><br><span class="line">		<span class="type">AppExtensionPasswordKey</span>: changedPassword,</span><br><span class="line">		<span class="type">AppExtensionOldPasswordKey</span>: oldPassword,</span><br><span class="line">		<span class="type">AppExtensionNotesKey</span>: <span class="string">"Saved with the ACME app"</span>, <span class="comment">// Optional, used for the third schenario only</span></span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置密码生成规则</span></span><br><span class="line">	<span class="keyword">let</span> passwordGenerationOptions:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="comment">// 密码最小长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMinLengthKey</span>: (<span class="number">8</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 最大密码长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMaxLengthKey</span>: (<span class="number">30</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 是否必须包含数字</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireDigitsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 字符必须包含符号</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireSymbolsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Here are all the symbols available in the the 1Password Password Generator:</span></span><br><span class="line">		<span class="comment">// !@#$%^&amp;*()_-+=|[]&#123;&#125;'\";.,&gt;?/~`</span></span><br><span class="line">		<span class="comment">// The string for AppExtensionGeneratedPasswordForbiddenCharactersKey should contain the symbols and characters that you wish 1Password to exclude from the generated password.</span></span><br><span class="line">		<span class="comment">//生成密码的时候排除的字符</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordForbiddenCharactersKey</span>: <span class="string">"!@#$%/0lIO"</span></span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用1Password,打开它的页面输入密码修改信息OnePasswordExtension.sharedExtension().changePasswordForLoginForURLString("https://www.acme.com", loginDetails: newLoginDetails, passwordGenerationOptions: passwordGenerationOptions, forViewController: self, sender: sender) &#123; (loginDictionary, error) -&gt; Void in</span></span><br><span class="line">		<span class="keyword">if</span> loginDictionary == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> error!.code != <span class="type">Int</span>(<span class="type">AppExtensionErrorCodeCancelledByUser</span>) &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"Error invoking 1Password App Extension for find login: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//把用户的修改返还给界面</span></span><br><span class="line">		<span class="keyword">self</span>.oldPasswordTextField.text = loginDictionary?[<span class="type">AppExtensionOldPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.freshPasswordTextField.text = loginDictionary?[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.confirmPasswordTextField.text = loginDictionary?[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p> 效果如图:</p>
<p> <img src="/img/2015/11/30/6.PNG" alt=""><br> <img src="/img/2015/11/30/7.PNG" alt=""></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在自己的App中嵌入onePassword密码管理">在自己的App中嵌入onePassword密码管理</h1><p><a href="https://agilebits.com/onepassword/">1Password</a>是一个密码管理软件,它可以方便和安全的管理你的密码.它提供反钓鱼保护功能和卓越的密码管理,并具有自动生成强密码功能.所有的机密资料,包括密码,身份卡和信用卡,都是保存在一个安全的地方.在OSX和IOS系统上非常的流行.在我的博文<a href="/2015/09/21/MacOS下JAVA开发使用经验(一">MacOS下JAVA开发使用经验(一)</a> )也有介绍.<br>自从我的账号被CSDN泄露的干干净净以后的一段时间里,我的其他账号是不是的就会收到更改密码的邮件.于是,一下狠心购买了<code>1Password</code>,并且把我所有的差不多200多个账号的密码通过<code>1Password</code>都给改成了14位的随机字符,以后就不用担心一个密码丢失导致其他的账号也丢失了(1Password自己本身在它的网上没有所谓的用户名密码,密码是通过加密文件整体在WIFI或iCloud中同步的.).但是这就带来了一个麻烦,就是我的密码都变成了类似于这样的<code>RxCa9vdBUB3fCU</code>的字符串.当使用safari这些的时候还好,它有浏览器的插件可以自动填充.遇到一些App,就只能手动的输入了(类似于光大银行和QQ不允许粘贴密码).这相当的麻烦,又容易出错.因此,自己开发APP的时候,就特别的注意了在输入密码的地方要与<code>1Password</code>的整合,这点网易系的APP就做的比较好,<code>网易云音乐</code>和<code>考拉海淘</code>就是支持了<code>1Password</code>的.<br>要在自己的App中引入<code>1Password</code>其实也不麻烦,可以说是相当的简单.<code>1Password</code>在<code>GitHub</code>上开源了App与它的软件交互的扩展<a href="https://github.com/AgileBits/onepassword-app-extension">1PasswordExtension</a>.我们通过这个扩展就可以在自己的App中嵌入<code>1Password</code>的密码管理了.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为自己的APP增加OpenIn功能]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/27/%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84APP%E5%A2%9E%E5%8A%A0OpenIn%E5%8A%9F%E8%83%BD/"/>
    <id>http://sunxiang0918.github.io/2015/11/27/为自己的APP增加OpenIn功能/</id>
    <published>2015-11-27T01:55:25.000Z</published>
    <updated>2015-11-30T09:56:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为自己的APP增加OpenIn功能">为自己的APP增加OpenIn功能</h1><p>在做App的时候,可能会遇到你的程序可以打开某种类型的文档.比如用户在safari中下载了一个torrent类型的文件,然后需要直接使用你写的App打开.那么这个时候就需要在编写App的时候进行文档类型的注册了.</p>
<p><img src="/img/2015/11/27/1.png" alt=""></p>
<a id="more"></a>
<h2 id="1-在Info-plist中注册文档类型">1.在Info.plist中注册文档类型</h2><p>首先要做的就是在Info.plist中增加文档类型的注册,表示这个程序能处理哪些文档.</p>
<p>这里有两种方式,一种是通过项目的Info栏直接增加<code>Document Types</code>和<code>Exported UTIs</code>.<br>就像这样:</p>
<p><img src="/img/2015/11/27/3.png" alt=""></p>
<p>还有一种就是直接修改info.plist文件:</p>
<p><img src="/img/2015/11/27/2.png" alt=""></p>
<p>其xml为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleDocumentTypes<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>LSItemContentTypes<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>cn.sunxiang0918.transmission.torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleTypeRole<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>Viewer<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleTypeName<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>torrent file<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>LSHandlerRank<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>Owner<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTExportedTypeDeclarations<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTTypeConformsTo<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>public.data<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTTypeIdentifier<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>cn.sunxiang0918.transmission.torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTTypeTagSpecification<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">key</span>&gt;</span>public.mime-type<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>application/torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">key</span>&gt;</span>public.filename-extension<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里稍作解释.</p>
<ul>
<li><strong>CFBundleDocumentTypes</strong>:为注册文档类型以及角色</li>
<li><strong>UTExportedTypeDeclarations</strong>:为注册处理类型与方式</li>
<li><strong>LSItemContentTypes</strong>:自己定义的一种文档的唯一串</li>
<li><strong>CFBundleTypeName</strong>:文档的类型名字</li>
<li><strong>UTTypeTagSpecification</strong>:指定文档的类型以及后缀名</li>
</ul>
<p>通过这个的指定,现在程序就能关联到某种文档文件了.</p>
<h2 id="处理文档的打开操作">处理文档的打开操作</h2><p>有了与文档的关联后,还需要进行的操作就是当用户指定APP打开文档后需要执行的操作了.</p>
<p><del>在<code>AppDelegate</code>这个程序的入口类中,有一个方法:<code>func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject) -&gt; Bool</code>.<br>我们只要重载这个方法就可以了.<br>这个方法中最总要的两个入参就是<code>openURL url: NSURL</code>以及<code>sourceApplication: String?</code><br>它说明了是哪一个其他程序传过来的文档,以及文档目前的路径是什么.<br>当有了这个参数后,我们就可以直接读取文档的内容了.</del><code>IOS9废弃</code></p>
<p>在<code>AppDelegate</code>这个程序的入口类中,有一个方法:<code>func application(application: UIApplication, openURL url: NSURL, options: [String : AnyObject]) -&gt; Bool</code>.<br>我们只要重载这个方法就可以了.<br>这个方法中最重要的两个入参就是<code>openURL url: NSURL</code>以及<code>options: [String : AnyObject]</code><br>它说明了是哪一个其他程序传过来的文档,以及文档目前的路径是什么.<br>当有了这个参数后,我们就可以直接读取文档的内容了.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, openURL url: NSURL,options: [String : AnyObject])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> encrypteddata = <span class="type">NSData</span>(contentsOfURL: url)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> base64 = encrypteddata!.base64EncodedStringWithOptions(<span class="type">NSDataBase64EncodingOptions</span>(rawValue: <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//尝试删除文件</span></span><br><span class="line">            try <span class="type">NSFileManager</span>.defaultManager().removeItemAtURL(url)</span><br><span class="line">        &#125; catch <span class="keyword">let</span> e &#123;</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>NSData(contentsOfURL: url)</code>可以读取文档的二进制的内容.<br>文档读取后可以通过<code>NSFileManager.defaultManager().removeItemAtURL(url)</code>删除磁盘上的文档.<br>最后返回一个true,表示是这个程序是能处理这个文档的.</p>
<p>到此,我们的自己的程序就能打开任意的文档并进行相应的处理了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为自己的APP增加OpenIn功能">为自己的APP增加OpenIn功能</h1><p>在做App的时候,可能会遇到你的程序可以打开某种类型的文档.比如用户在safari中下载了一个torrent类型的文件,然后需要直接使用你写的App打开.那么这个时候就需要在编写App的时候进行文档类型的注册了.</p>
<p><img src="/img/2015/11/27/1.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift中使用NSUserDefaults保存自定义对象]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/24/Swift%E4%B8%AD%E4%BD%BF%E7%94%A8NSUserDefaults%E4%BF%9D%E5%AD%98%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sunxiang0918.github.io/2015/11/24/Swift中使用NSUserDefaults保存自定义对象/</id>
    <published>2015-11-24T03:32:07.000Z</published>
    <updated>2015-11-24T04:08:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift中使用NSUserDefaults保存自定义对象">Swift中使用NSUserDefaults保存自定义对象</h1><p>NSUserDefaults适合存储轻量级的本地客户端数据,比如保存一些系统的基本配置等东西,使用NSUserDefaults是首选,它非常的简单,不依赖其他的什么东西,屏蔽了Plist文件的读写等等.</p>
<p>但是NSUserDefaults支持的数据格式比较有限,只支持了<code>Int</code>、<code>Float</code>、<code>Double</code>，<code>String</code>，<code>NSDate</code>，<code>NSArray</code>，<code>NSDictionary</code>，<code>Bool</code>.不支持自定义对象的存取.</p>
<p>这个特性对于简单的数值来说还算比较容易.只需要简单的操作(一个Value 一个Key ),例如，想要保存一个NSString的对象，代码实现为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().setInteger(<span class="number">10</span>, forKey: <span class="string">"aaa"</span>)</span><br><span class="line"><span class="comment">//取</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().integerForKey(<span class="string">"aaaa"</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是涉及到复杂的对象的时候,就需要我们进行特殊的处理了.</p>
<p>其实这个特殊处理也很简单,既然<code>NSUserDefaults</code>支持<code>NSDate</code>类型的数据.那么我们在存取自定义对象的时候,就可以预先把我们的自定义对象转换成为<code>NSData</code>类型的即可.</p>
<p>在Swift中如果要把一个自定义对象能转换成为<code>NSData</code>.需要在自定义对象上实现<code>NSObject</code>和<code>NSCoding</code>协议,并且实现<code>func encodeWithCoder(aCoder: NSCoder)</code>和<code>init?(coder aDecoder: NSCoder)</code>方法,比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Foundation</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SiteInfoVO</span> : <span class="title">NSObject</span>,<span class="title">NSCoding</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> url:<span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> userName:<span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> password:<span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(url:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@objc</span> internal <span class="func"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(aCoder: NSCoder)</span></span> &#123;</span><br><span class="line">        aCoder.encodeObject(url, forKey: <span class="string">"url"</span>)</span><br><span class="line">        aCoder.encodeObject(userName, forKey: <span class="string">"userName"</span>)</span><br><span class="line">        aCoder.encodeObject(password, forKey: <span class="string">"password"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@objc</span> internal required <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        url = aDecoder.decodeObjectForKey(<span class="string">"url"</span>) <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">        </span><br><span class="line">        userName = aDecoder.decodeObjectForKey(<span class="string">"userName"</span>) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        password = aDecoder.decodeObjectForKey(<span class="string">"password"</span>) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用<code>NSKeyedUnarchiver</code>类来进行转换了.</p>
<p>那么保存一个自定义对象到<code>NSUserDefaults</code>就变为了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _value = <span class="type">SiteInfoVO</span>(url:<span class="string">"123"</span>)</span><br><span class="line"><span class="keyword">let</span> modelData:<span class="type">NSData</span> = <span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject(_value)</span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().setObject(modelData, forKey: <span class="string">"defaultName"</span>)</span><br></pre></td></tr></table></figure>
<p>而读取一个自定义对象就成为了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">NSUserDefaults</span>.standardUserDefaults().objectForKey(<span class="string">"defaultName"</span>) <span class="keyword">as</span>? <span class="type">NSData</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> _data = data &#123;</span><br><span class="line">   <span class="keyword">let</span> model = <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(_data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们可以给<code>NSUserDefaults</code>增加一个扩展,把编解码自定义对象进行一次封装:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Foundation</span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">NSUserDefaults</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">modelForKey</span><span class="params">(defaultName: String)</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> obj = <span class="keyword">self</span>.objectForKey(defaultName) <span class="keyword">as</span>? <span class="type">NSData</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> tmp = obj &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">arrayModelForKey</span><span class="params">(defaultName: String)</span></span> -&gt; [<span class="type">AnyObject</span>]? &#123;</span><br><span class="line">        <span class="keyword">let</span> obj = <span class="keyword">self</span>.objectForKey(defaultName) <span class="keyword">as</span>? [<span class="type">NSData</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> result:[<span class="type">AnyObject</span>]?</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> _obj = obj &#123;</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> tmp <span class="keyword">in</span> _obj &#123;</span><br><span class="line">                <span class="keyword">let</span> myModel = <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(tmp)</span><br><span class="line">                result?.append(myModel!)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">setModel</span><span class="params">(value: AnyObject?, forKey defaultName: String)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        guard <span class="keyword">let</span> _value = value <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.setObject(<span class="literal">nil</span>, forKey: defaultName)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> modelData:<span class="type">NSData</span> = <span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject(_value)</span><br><span class="line">        <span class="keyword">self</span>.setObject(modelData, forKey: defaultName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">setArrayModels</span><span class="params">(value: [AnyObject]?, forKey defaultName: String)</span></span> &#123;</span><br><span class="line">        guard <span class="keyword">let</span> _value = value <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.setObject(<span class="literal">nil</span>, forKey: defaultName)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> data:[<span class="type">NSData</span>] = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> _value &#123;</span><br><span class="line">            data.append(<span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject(v))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.setObject(data, forKey: defaultName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:按照这个思路,其实把自定义对象转换成JSON字符串等都是可以的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift中使用NSUserDefaults保存自定义对象">Swift中使用NSUserDefaults保存自定义对象</h1><p>NSUserDefaults适合存储轻量级的本地客户端数据,比如保存一些系统的基本配置等东西,使用NSUserDefaults是首选,它非常的简单,不依赖其他的什么东西,屏蔽了Plist文件的读写等等.</p>
<p>但是NSUserDefaults支持的数据格式比较有限,只支持了<code>Int</code>、<code>Float</code>、<code>Double</code>，<code>String</code>，<code>NSDate</code>，<code>NSArray</code>，<code>NSDictionary</code>，<code>Bool</code>.不支持自定义对象的存取.</p>
<p>这个特性对于简单的数值来说还算比较容易.只需要简单的操作(一个Value 一个Key ),例如，想要保存一个NSString的对象，代码实现为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().setInteger(<span class="number">10</span>, forKey: <span class="string">"aaa"</span>)</span><br><span class="line"><span class="comment">//取</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().integerForKey(<span class="string">"aaaa"</span>)</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker1.9新特性-跨物理机的多容器网络连接]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/09/Docker1-9%E6%96%B0%E7%89%B9%E6%80%A7-%E8%B7%A8%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84%E5%A4%9A%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    <id>http://sunxiang0918.github.io/2015/11/09/Docker1-9新特性-跨物理机的多容器网络连接/</id>
    <published>2015-11-09T13:47:08.000Z</published>
    <updated>2015-12-28T14:02:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Docker1-9新特性-跨物理机的多容器网络连接">Docker1.9新特性-跨物理机的多容器网络连接</h1><p>近日，Docker公司正式发布Docker 1.9版本。他带来了很多新的特性,其中最重要的新特性无疑就是多宿主机互联功能.</p>
<p>在今年6月份的DockerCon上，互联曾经作为测试版本的特性被提出。目前，该特性正式集成在了Docker引擎的稳定版中，并将在产品中使用。其主要功能是为跨宿主机创建Docker引擎中的虚拟网络提供支持。用户可以把其所属的容器挂载到网络中，并控制网络拓扑和通信方式。此外，系统还允许用户在不修改应用的情况下直接与任何网络进行集成。</p>
<p>那么,我们现在就来试一试如何简单的实现多宿主机互联功能.</p>
<h2 id="原理">原理</h2><p>Docker新的网络拓扑是采用的<code>overlay network</code>模式的网络.<br>它需要一个分布式的<code>Key-Value Storage</code>作为辅助的存储.当前Docker支持<code>Consul</code>,<code>Etcd</code>和<code>ZooKeeper</code>.当创建网络之前,你首先是需要安装并运行<code>KVS</code>.然后在启动Docker的时候加上一定的参数,这样Docker就会把网络拓扑信息保存在<code>KVS</code>上,形成全局唯一的网络.</p>
<p><img src="/img/2015/11/09/1.png" alt=""></p>
<a id="more"></a>
<h2 id="安装Docker1-9前的准备">安装Docker1.9前的准备</h2><p>由于Docker1.9多宿主机联网的功能设计为可插拔式，毫无保留兼容<code>VXLAN</code>或者IPVLAN等技术。使用ovs（Open vSwitch）和VXLAN隧道进行实现。因此,需要操作系统支持<code>VXLAN</code>.而在<code>Kernel3.16</code>以下支持这个是有问题的.这个可以参见<a href="https://github.com/docker/docker/issues/14145" target="_blank" rel="external">Issues14145</a>.因此我们首先就是需要把操作系统的内核升级.具体的升级方法可以参考我之前的博文<a href="http://sunxiang0918.cn/2015/11/08/升级CentOS7的Linux内核/" target="_blank" rel="external">升级CentOS7的Linux内核</a>.</p>
<p>然后还需要关闭Selinux. 直接编辑<code>/etc/selinux/config</code>文件中设置<code>SELINUX=disabled</code> ，然后重启服务器。</p>
<p>还需要做的就是关闭防火墙:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br></pre></td></tr></table></figure>
<h2 id="安装Docker1-9">安装Docker1.9</h2><p>接下来就是安装最新的Docker1.9了. 在安装最新版之前,需要把旧的版本删除了.<br>然后在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>
<p>等他执行完成后,最新版就安装完成了.</p>
<h2 id="启动Zookeeper">启动Zookeeper</h2><p>这里我使用<code>Zookeeper</code>来做试验,官网上的是使用<code>Consul</code>做的演示,如果想使用<code>Consul</code>可以看<a href="http://docs.docker.com/engine/userguide/networking/get-started-overlay/" target="_blank" rel="external">这里</a>.</p>
<p>安装<code>Zookeeper</code>集群就不在这里细说了,可以参考之前的博文<a href="http://sunxiang0918.cn/2014/09/20/zookeeper-集群部署/" target="_blank" rel="external">zookeeper 集群部署</a>.</p>
<p>安装完后启动<code>zookeeper</code>.  这里假设 我的ZK的地址为:<code>10.211.55.2:2181</code></p>
<h2 id="启动Docker服务">启动Docker服务</h2><p>接下来就是需要启动Docker服务了.<br>以前的启动方式是:<code>service docker start</code>.<br>但是这样就不会增加<code>KVS</code>的参数,因此我们需要手动的启动Docker服务:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker daemon --cluster-store=zk://<span class="number">10.211</span>.<span class="number">55.2</span>:<span class="number">2181</span> --cluster-advertise=eth0:<span class="number">2376</span></span><br></pre></td></tr></table></figure>
<p>这里主要有两个参数:</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">—cluster-store=PROVIDER://URL</td>
<td style="text-align:center">这个指的就是KVS的存储位置,比如zookeeper的就是:zk://xxxx,Consul的就是 consul://xxxxx</td>
</tr>
<tr>
<td style="text-align:center">—cluster-advertise=HOST_IP</td>
<td style="text-align:center">这个就是本机Docker服务需要对外公布的集群地址,可以直接写网卡地址</td>
</tr>
</tbody>
</table>
<p>使用上面的参数启动后,Docker会在Zookeeper上建立一个目录.里面存放的就是网络的配置信息.</p>
<p><img src="/img/2015/11/09/2.png" alt=""></p>
<p>直接把所有宿主机上的Docker都像这样的方式启动.</p>
<p>如果你想直接使用<code>service docker start</code>方式启动的话,需要修改<code>/usr/lib/systemd/system/docker.service</code>这个文件.在<code>ExecStart=/usr/bin/docker daemon</code>后面加上<code>--cluster-store=zk://10.211.55.2:2181 --cluster-advertise=eth0:2376</code>.然后执行<code>systemctl daemon-reload</code>,重新加载<code>docker.service</code>即可. 以后就可以在命令行中直接输入<code>service docker start</code>启动带1.9跨网的Docker服务了.注意,一定要先启动Zookeeper哦!</p>
<h2 id="创建网络">创建网络</h2><p>Docker1.9新增加了一个命令<code>network</code>,用于配置网络.在Docker1.9中,它把网络也当成了一种类似于容器的东西.可以创建,查询,删除网络.</p>
<p>比如在单机下 可以输入<code>docker network create my-single-net</code>创建一个网络.<br>然后在启动容器的时候使用:<code>docker run -itd --net=my-single-net --name web nginx</code>来使一个容器使用指定的网络来通信. 只要是在<strong>同一个网络</strong>下的容器,他们之间都可以通过<strong>容器的名字</strong>进行互联.而不需要像以前一样,写一堆的<code>-Link</code>了.<br>而对于不同的网络之间也可以使用<code>docker network connect</code>命令来使两个网络之间进行互联.<br>比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create app</span><br><span class="line">docker run -itd --name myapp --net=app myapp</span><br><span class="line">docker network connect app web</span><br></pre></td></tr></table></figure>
<p>这样,就可以在容器中使用<code>myapp.app</code>来访问其他的容器.</p>
<p>铺垫了这么多,现在我们就来创建<code>overlay</code>类型的网络.<br>直接在终端中输入:<code>docker network create --driver overlay my-net</code><br>这个命令就可以创建一个<code>overlay</code>类型的网络,Docker接收到命令后会自动的在ZK上创建相应的节点.<br>那么这个时候,在其他机器上通过输入<code>docker network ls</code>就应该能看到这个网络了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7_with_kernel4 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER</span><br><span class="line"><span class="number">65</span>a73f31fd82        my-net              overlay</span><br><span class="line"><span class="number">8</span>dc2d1533977        docker_gwbridge     bridge</span><br><span class="line"><span class="number">4</span>e4dcdfbe708        none                null</span><br><span class="line"><span class="number">53509</span>e0d8617        host                host</span><br><span class="line">a1dd3a2d90ce        bridge              bridge</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7_with_kernel4_2 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER</span><br><span class="line"><span class="number">65</span>a73f31fd82        my-net              overlay</span><br><span class="line"><span class="number">1</span>fac52653a98        host                host</span><br><span class="line"><span class="number">8</span>dc2d1533977        docker_gwbridge     bridge</span><br><span class="line">cc8810e5a932        bridge              bridge</span><br><span class="line"><span class="number">59</span>ae81d5b75f        none                null</span><br></pre></td></tr></table></figure>
<p>正如上面所显示的.两台不同的宿主机上 现在都有一个ID为<code>65a73f31fd82</code>的<code>overlay</code>类型的网络了.</p>
<p>这个时候如果是调用<code>ifconfig</code>命令来查看宿主机的网络配置,会发现他现在是有<code>docker0</code>,<code>docker_gwbridge</code>,<code>eth0</code>等几个网卡的.其中<code>docker_gwbridge</code>其实就是一个桥接网卡,它就负责了多个宿主机间的通信.</p>
<p><img src="/img/2015/11/09/3.png" alt=""></p>
<h2 id="启动容器">启动容器</h2><p>既然网络已经配置好了,那么接下来要做的就是 启动容器了.这里我们已启动<code>jplock/zookeeper</code>容器为例,在跨宿主机的Docker中创建一个<code>Zookeeper</code>的集群.</p>
<p>一号宿主机(10.211.55.13):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jplock/zookeeper</span><br><span class="line">docker run --name zookeeper1 --privileged=<span class="literal">true</span> -p <span class="number">2181</span>:<span class="number">2181</span> -p <span class="number">2888</span>:<span class="number">2888</span> -p <span class="number">3888</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br><span class="line">docker run --name zookeeper3 --privileged=<span class="literal">true</span> -p <span class="number">2182</span>:<span class="number">2181</span> -p <span class="number">2882</span>:<span class="number">2888</span> -p <span class="number">3882</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br></pre></td></tr></table></figure></p>
<p>二号宿主机(10.211.55.16):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jplock/zookeeper</span><br><span class="line">docker run --name zookeeper2 --privileged=<span class="literal">true</span> -p <span class="number">2181</span>:<span class="number">2181</span> -p <span class="number">2888</span>:<span class="number">2888</span> -p <span class="number">3888</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br><span class="line">docker run --name zookeeper4 --privileged=<span class="literal">true</span> -p <span class="number">2182</span>:<span class="number">2181</span> -p <span class="number">2882</span>:<span class="number">2888</span> -p <span class="number">3882</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br></pre></td></tr></table></figure></p>
<p>这样就在每一个宿主机上启动了两个<code>Zookeeper</code>的容器,并且都使用了相同的<code>my-net</code>网络.</p>
<p>这个时候使用<code>docker exec -ti zookeeper1 /bin/bash</code>进入到容器当中.使用<code>ip address show</code>命令查看容器的IP的话,会显示为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">3</span>cfba8da9b6f:/opt/zookeeper<span class="comment"># ip address show</span></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> qdisc noqueue state UNKNOWN group default</span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127.0</span>.<span class="number">0.1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::<span class="number">1</span>/<span class="number">128</span> scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">6</span>: eth0@<span class="keyword">if</span>7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1450</span> qdisc noqueue state UP group default</span><br><span class="line">    link/ether <span class="number">02</span>:<span class="number">42</span>:<span class="number">0</span>a:<span class="number">00</span>:<span class="number">00</span>:<span class="number">03</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">10.0</span>.<span class="number">0.3</span>/<span class="number">24</span> scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::<span class="number">42</span>:aff:fe00:<span class="number">3</span>/<span class="number">64</span> scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">8</span>: eth1@<span class="keyword">if</span>9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc noqueue state UP group default</span><br><span class="line">    link/ether <span class="number">02</span>:<span class="number">42</span>:ac:<span class="number">12</span>:<span class="number">00</span>:<span class="number">02</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">172.18</span>.<span class="number">0.2</span>/<span class="number">16</span> scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::<span class="number">42</span>:acff:fe12:<span class="number">2</span>/<span class="number">64</span> scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>其中的<code>eth0</code>就是容器全局唯一的一个<code>IP地址</code>.</p>
<p>这个时候再调用<code>cat /etc/hosts</code>来查看容器的<code>hosts</code>配置,会发现:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">3</span>cfba8da9b6f:/opt/zookeeper<span class="comment"># cat /etc/hosts</span></span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.3</span>	<span class="number">3</span>cfba8da9b6f</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>	localhost</span><br><span class="line">::<span class="number">1</span>	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::<span class="number">0</span>	ip6-localnet</span><br><span class="line">ff00::<span class="number">0</span>	ip6-mcastprefix</span><br><span class="line">ff02::<span class="number">1</span>	ip6-allnodes</span><br><span class="line">ff02::<span class="number">2</span>	ip6-allrouters</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.2</span>	zookeeper1</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.2</span>	zookeeper1.my-net</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.4</span>	zookeeper3</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.4</span>	zookeeper3.my-net</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.5</span>	zookeeper4</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.5</span>	zookeeper4.my-net</span><br></pre></td></tr></table></figure>
<p>Docker每启动一个容器,就会在相同网络下的其他容器的Hosts中加入hosts.因此,这个时候其实4个ZooKeeper的网络都是通的了,并且通过<code>容器名</code>.<code>网络名</code>是可以直接访问的.</p>
<p>这个时候在宿主机上使用<code>docker network inspect my-net</code>命令就可以查看<code>my-net</code>网络当前的状况,有什么容器在使用这个网络等等信息.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my-net"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"65a73f31fd820732ebbf665072311c36e2938105a3b42b26597340fc217ff47c"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"global"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"overlay"</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"0d790e0dafd8af213fa81e98c5833539f000dfd5c2c35065e9dbc07d1b40dc7b"</span>: &#123;</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"6434fc9a7a477779e73874d2ec508b4c139d3cb5cd56c7e0ded8d3d5b0bf6457"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:00:00:04"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"10.0.0.4/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"20a8b20914b11c52b6285ebe4414cf492d1bc71001919c62a5a1e7bc5018fa0c"</span>: &#123;</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"14cf4810b09849ae0b197fabd52d155bcaee5debd68a3d982027c5856ba84afe"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:00:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"10.0.0.2/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样,Docker很简单的就实现了多宿主机的网络互通,每一个容器只需要通过全局唯一的<code>容器名</code>就可以访问任意一个在<strong>相同网络</strong>中的容器了.</p>
<p><img src="/img/2015/11/09/4.png" alt=""></p>
<h2 id="注意">注意</h2><p>目前还有一个问题,就是采用这种模式的情况下,其实容器的IP地址还是会改变的.因为它其实是在容器启动的时候,在ZK中去询问一个可用的IP地址,然后创建一个临时节点保存容器名和IP地址的映射. 当容器关闭后,这个IP地址就被释放了出来.下一次再申请可用的IP地址的时候,IP地址可能就变化了.这点需要我们在开发的时候注意,如果程序是依赖于IP地址的话,可能每次重启就会出现问题.尽量的使用Hosts来代替IP地址.</p>
<p>如果确实有固定IP的需求,这个还需要再进一步的研究.</p>
<p><img src="/img/2015/11/09/5.png" alt=""></p>
<hr>
<p>参考文章:<br><a href="http://blog.docker.com/2015/11/docker-multi-host-networking-ga/" target="_blank" rel="external">http://blog.docker.com/2015/11/docker-multi-host-networking-ga/</a><br><a href="https://github.com/docker/libnetwork/issues/" target="_blank" rel="external">https://github.com/docker/libnetwork/issues/</a></p>
<p><a href="http://qiita.com/simota/items/06ad3400224e98d43fc5" target="_blank" rel="external">http://qiita.com/simota/items/06ad3400224e98d43fc5</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Docker1-9新特性-跨物理机的多容器网络连接">Docker1.9新特性-跨物理机的多容器网络连接</h1><p>近日，Docker公司正式发布Docker 1.9版本。他带来了很多新的特性,其中最重要的新特性无疑就是多宿主机互联功能.</p>
<p>在今年6月份的DockerCon上，互联曾经作为测试版本的特性被提出。目前，该特性正式集成在了Docker引擎的稳定版中，并将在产品中使用。其主要功能是为跨宿主机创建Docker引擎中的虚拟网络提供支持。用户可以把其所属的容器挂载到网络中，并控制网络拓扑和通信方式。此外，系统还允许用户在不修改应用的情况下直接与任何网络进行集成。</p>
<p>那么,我们现在就来试一试如何简单的实现多宿主机互联功能.</p>
<h2 id="原理">原理</h2><p>Docker新的网络拓扑是采用的<code>overlay network</code>模式的网络.<br>它需要一个分布式的<code>Key-Value Storage</code>作为辅助的存储.当前Docker支持<code>Consul</code>,<code>Etcd</code>和<code>ZooKeeper</code>.当创建网络之前,你首先是需要安装并运行<code>KVS</code>.然后在启动Docker的时候加上一定的参数,这样Docker就会把网络拓扑信息保存在<code>KVS</code>上,形成全局唯一的网络.</p>
<p><img src="/img/2015/11/09/1.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://sunxiang0918.github.io/tags/Docker/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[升级CentOS7的Linux内核]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/08/%E5%8D%87%E7%BA%A7CentOS7%E7%9A%84Linux%E5%86%85%E6%A0%B8/"/>
    <id>http://sunxiang0918.github.io/2015/11/08/升级CentOS7的Linux内核/</id>
    <published>2015-11-08T07:56:29.000Z</published>
    <updated>2015-11-09T11:05:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="升级CentOS7的Linux内核">升级CentOS7的Linux内核</h1><p>默认刚安装的CentOS7的内核是3.10的.</p>
<p>这个可以在 终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="number">3.10</span>.<span class="number">0</span>-<span class="number">229</span>.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>来确认.</p>
<p>由于我需要试验docker1.9中的新功能.而它的新功能需要<code>vxlan</code>的相关功能.而这个在3.16以上版本才正确.因此,就需要给CentOS7升级内核.</p>
<a id="more"></a>
<h2 id="步骤">步骤</h2><ol>
<li><p>首先在命令行中输入:<code>uname -r</code> 来确定你现在的版本是什么</p>
</li>
<li><p>而后输入:<code>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</code> 导入Key</p>
</li>
<li><p>输入:<code>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</code>来安装elrepo的yum源</p>
</li>
<li><p>在这个源中,保留了内核的最新两个版本.应用名字叫:<code>kernel-ml</code>.因此 我们输入:<code>yum --enablerepo=elrepo-kernel install kernel-ml -y</code>.就可以安装最新的内核了.</p>
</li>
<li><p>而后输入<code>awk -F\&#39; &#39;$1==&quot;menuentry &quot; {print $2}&#39; /etc/grub2.cfg</code> 可以查看启动CentOS的顺序.</p>
</li>
<li><p>如果想自动的进入第一个内核就是最新的话,可以输入:<code>grub2-set-default 0</code></p>
</li>
<li><p>这样,重启的话.系统就会是最新的内核了.</p>
</li>
</ol>
<p>PS: 如果不想安装最新的内核版本.而是想选一个早先的版本的话.可以访问这个地址:<a href="dfw.mirror.rackspace.com">dfw.mirror.rackspace.com</a>.他里面有很多版本的镜像.找到你想要的版本的rpm.直接下载下来.然后上传到Centos中.然后执行<code>yum localinstall xxxx.rpm -y</code> 就可以本地安装内核了. 剩下的操作和在线的是一样的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="升级CentOS7的Linux内核">升级CentOS7的Linux内核</h1><p>默认刚安装的CentOS7的内核是3.10的.</p>
<p>这个可以在 终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="number">3.10</span>.<span class="number">0</span>-<span class="number">229</span>.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>来确认.</p>
<p>由于我需要试验docker1.9中的新功能.而它的新功能需要<code>vxlan</code>的相关功能.而这个在3.16以上版本才正确.因此,就需要给CentOS7升级内核.</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://sunxiang0918.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive1.2的部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/04/Hive1-2%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/11/04/Hive1-2的部署/</id>
    <published>2015-11-04T14:55:26.000Z</published>
    <updated>2015-11-04T15:14:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Hive1-2的部署">Hive1.2的部署</h1><h2 id="简介">简介</h2><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
<p>听起来HBase与Hive有些类似，概念也有点模糊，那我们先了解下他们之间有什么区别：</p>
<p>HBase是一种分布式、面向列的NoSQL数据库，基于HDFS存储，以表的形式存储数据，表由行和列组成，列划分到列族中。HBase不提供类SQL查询语言，要想像SQL这样查询数据，可以使用Phonix，让SQL查询转换成hbase的扫描和对应的操作，也可以使用现在说讲Hive仓库工具，让HBase作为Hive存储。</p>
<p>Hive是运行在Hadoop之上的数据仓库，将结构化的数据文件映射为一张数据库表，提供简单类SQL查询语言，称为HQL，并将SQL语句转换成MapReduce任务运算。有利于利用SQL语言查询、分析数据，适于处理不频繁变动的数据。Hive底层可以是HBase或者HDFS存储的文件。</p>
<p>两者都是基于Hadoop上不同的技术，相互结合使用，可处理企业中不同类型的业务，利用Hive处理非结构化离线分析统计，利用HBase处理在线查询。</p>
<p>由于HDFS不能存储元数据,因此Hive需要一个辅助的关系数据库来保存它的元数据信息.<br>可以使用它本地的derby数据库,也可以使用本地或远程的MYSQL数据库来存储.通常我们都是存放在MYSQL中的.</p>
<a id="more"></a>
<h2 id="部署">部署</h2><p>由于Hive是运行在Hadoop之上的数据仓库.它的所有数据都是存放在Hadoop兼容的存储上的.因此它本身的集群其实就是启动N多个相同的Hive节点就可以了.也就是说,我们可以完全安装修改一台的Hive.然后直接把整个Hive文件夹拷贝到其他机器上即可.</p>
<ol>
<li>在MYSQL中创建一个独立的database.命名为<code>hive</code></li>
<li>解压<code>apache-hive-1.2.1-bin.tar.gz</code>到/home/hadoop/下 然后改名为<code>hive</code></li>
<li><p>修改环境变量  </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/hadoop/hadoop  </span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/home/hadoop/hive  </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HIVE_HOME</span>/bin  </span><br><span class="line"><span class="built_in">export</span> CLASS_PATH=<span class="variable">$CALSSPATH</span>:<span class="variable">$HIVE_HOME</span>/lib</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>hive/conf</code>下 拷贝 <code>hive_env.sh.template</code> 改名成 <code>hive_env.sh</code></p>
</li>
<li><p>修改这个文件里面的HADOOP_HOME和HIVE_CONF_DIR</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Set HADOOP_HOME to point to a specific hadoop install directory</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/hadoop/hadoop-<span class="number">2.6</span>.<span class="number">0</span></span><br><span class="line">	<span class="comment">#Hive Configuration Directory can be controlled by:</span></span><br><span class="line"><span class="built_in">export</span> HIVE_CONF_DIR=/home/hadoop/apache-hive-<span class="number">1.2</span>.<span class="number">0</span>-bin/conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>在hive/conf下 拷贝 hive-default.xml.template 改名成 hive-site.xml</p>
</li>
<li><p>修改里面的所有内容为:(因为会先自动的加载hive-default.xml里面的所有内容,所以hive-site里面的内容就是自定义的配置)</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>jdbc:mysql://10.211.55.2:3306/hive<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>驱动名<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>root<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>用户名<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>admin<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>密码<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/hive/warehouse<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>数据路径（相对hdfs）<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>放入mysql的驱动到 hive/lib中 比如: <code>mysql-connector-java-5.1.31-bin.jar</code></p>
</li>
<li>找到一个叫<code>jline-2.12.jar</code>的文件，复制他，去hadoop主目录将<code>hadoop/yarn/lib</code>下的<code>jline0.9.94.jar</code>替换成刚刚复制的,否则会出现包冲突.</li>
<li>切换到hive/bin,输入 <code>bin/hive --service metastore</code><br>当显示<code>Starting Hive Metastore Server</code>就表示启动成功了.</li>
</ol>
<h2 id="验证">验证</h2><p>启动以后,在终端中输入<code>JPS</code>.可以 看到一个 <code>RunJar</code>的服务,这就表示启动成功了.</p>
<p>然后再输入<code>./hive</code>可以进入hive的命令行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HMaster0 ~]<span class="comment"># hive</span></span><br><span class="line">Logging initialized usingconfiguration <span class="keyword">in</span> file:/opt/apache-hive-<span class="number">1.2</span>.<span class="number">0</span>-bin/conf/hive-log4j.properties</span><br><span class="line">hive&gt; show databases;</span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">Time taken: <span class="number">0.986</span> seconds,Fetched: <span class="number">1</span> row(s)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建一个测试库</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create database <span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个hive_test的表,并指定字段分隔符为tab建</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table hive_<span class="built_in">test</span>(id int,name string) row format delimited fields terminated by <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从本地文件中导入数据到Hive表中</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; load data <span class="built_in">local</span> inpath <span class="string">'/home/hadoop/hive/examples/files/kv1.txt'</span> overwrite into table hive_<span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行最简单的查询</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * from hive_<span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到此,Hive的最简单的安装就结束了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hive1-2的部署">Hive1.2的部署</h1><h2 id="简介">简介</h2><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
<p>听起来HBase与Hive有些类似，概念也有点模糊，那我们先了解下他们之间有什么区别：</p>
<p>HBase是一种分布式、面向列的NoSQL数据库，基于HDFS存储，以表的形式存储数据，表由行和列组成，列划分到列族中。HBase不提供类SQL查询语言，要想像SQL这样查询数据，可以使用Phonix，让SQL查询转换成hbase的扫描和对应的操作，也可以使用现在说讲Hive仓库工具，让HBase作为Hive存储。</p>
<p>Hive是运行在Hadoop之上的数据仓库，将结构化的数据文件映射为一张数据库表，提供简单类SQL查询语言，称为HQL，并将SQL语句转换成MapReduce任务运算。有利于利用SQL语言查询、分析数据，适于处理不频繁变动的数据。Hive底层可以是HBase或者HDFS存储的文件。</p>
<p>两者都是基于Hadoop上不同的技术，相互结合使用，可处理企业中不同类型的业务，利用Hive处理非结构化离线分析统计，利用HBase处理在线查询。</p>
<p>由于HDFS不能存储元数据,因此Hive需要一个辅助的关系数据库来保存它的元数据信息.<br>可以使用它本地的derby数据库,也可以使用本地或远程的MYSQL数据库来存储.通常我们都是存放在MYSQL中的.</p>]]>
    
    </summary>
    
      <category term="Hive" scheme="http://sunxiang0918.github.io/tags/Hive/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hbase分布式部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/03/Hbase%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/11/03/Hbase分布式部署/</id>
    <published>2015-11-03T15:12:39.000Z</published>
    <updated>2015-11-03T15:30:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Hbase分布式部署">Hbase分布式部署</h1><p>HBase的安装首先是有两个先决条件的,第一个就是需要zookeeper的支持,另外一个就是需要HDFS的支持了.<br>因此,安装Hbase的头两部就是安装<code>zookeeper</code>和<code>hadoop</code></p>
<p>这两个东西的安装可以参考我以前的博文:<a href="http://sunxiang0918.cn/2015/11/03/Hadoop全分布式部署/" target="_blank" rel="external">Hadoop全分布式部署</a>以及<a href="http://sunxiang0918.cn/2014/09/20/zookeeper-集群部署/" target="_blank" rel="external">zookeeper 集群部署</a>.这里就不再复述了.</p>
<h2 id="环境">环境</h2><p>环境: centos7 + hadoop2.6.2 + hbase1.1.2</p>
<p>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h2 id="安装步骤">安装步骤</h2><ol>
<li>首先还是需要把<code>hbase-1.1.2-bin.tar.gz</code>拷贝到几台机器上.然后使用<code>tar -xvf</code>命令解压,并重命名为hbase.  当前路径也就是 <code>/home/hadoop/hbase</code></li>
</ol>
<a id="more"></a>
<ol>
<li><p>配置<code>conf/hbase-site.xml</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="pi">&lt;?xml version="1.0"?&gt;</span>  </span><br><span class="line">	<span class="pi">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://master:9000/hbase<span class="tag">&lt;/<span class="title">value</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>区域服务器使用存储HBase数据库数据的目录,服务器名称不能填IP，不然会报错<span class="tag">&lt;/<span class="title">description</span>&gt;</span>          </span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>              </span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span>                </span><br><span class="line">     <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="title">name</span>&gt;</span>                 </span><br><span class="line">     <span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span>                     </span><br><span class="line">     <span class="tag">&lt;<span class="title">description</span>&gt;</span>指定HBase运行的模式： false: 单机模式或者为分布式模式   true: 全分布模式 <span class="tag">&lt;/<span class="title">description</span>&gt;</span>             </span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>                                                   </span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span>                                                     </span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="title">name</span>&gt;</span>                                                       </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span> master,slave01, slave02 <span class="tag">&lt;/<span class="title">value</span>&gt;</span>                                                           </span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>ZooKeeper集群服务器的位置<span class="tag">&lt;/<span class="title">description</span>&gt;</span>                                                                 </span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>                                                                  </span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 完整的配置可以看<a href="http://hbase.apache.org/book.html#config.files" target="_blank" rel="external">此处</a></p>
</li>
<li><p>配置数据服务器的地址<br> 也就是修改<code>/conf/regionservers</code>,把三台机器的host都写进去</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">slave01</span><br><span class="line">slave02</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置HBase的JDK<br> 修改<code>/conf/hbase-env.sh</code>文件.<br> 打开注释 <code>export JAVA_HOME=xxxxxxx</code> 这里指向JDK的目录,要求是JDK1.7+</p>
</li>
<li><p>配置ZK的使用方式.默认情况下是使用的hbase内置的ZK,这个在集群下是不行的.因此我们需要给他改成使用外部的集群的ZK.<br> 修改<code>/conf/hbase-env.sh</code>文件最后面.<br> 打开注释 <code>export HBASE_MANAGES_ZK=false</code> 这里的false指的就是使用外部的Zookeeper</p>
</li>
<li><p>所有其他的机器都这样配置</p>
</li>
<li><p>在主节点上 启动,验证<br> 配置好上面的这些东西后,就可以在主节点上启动hbase了.<br> 直接在<code>bin</code>中 输入 <code>./start-hbase.sh</code> 即可启动.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	starting master, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-master-master.out</span><br><span class="line">slave01: starting regionserver, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-regionserver-slave01.out</span><br><span class="line">slave02: starting regionserver, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-regionserver-slave02.out</span><br><span class="line">master: starting regionserver, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-regionserver-master.out</span><br></pre></td></tr></table></figure>
<p> 出现上面的东西 就说明是启动完成了.<br> 这个时候使用<code>jps</code>命令 应该可以看到有一个 <code>HMaster</code> 和 <code>HRegionServer</code> 服务.<br> 而在其他的从节点上 应该看得到<code>HRegionServer</code>服务.</p>
<p> 这个时候随便在某一台机器上输入 <code>./hbase shell</code> 进入hbase的终端,并输入<code>status</code>的话,应该可以看到集群的状态:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	[hadoop@master bin]$ ./hbase shell</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">03</span> <span class="number">23</span>:<span class="number">02</span>:<span class="number">05</span>,<span class="number">690</span> WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library <span class="keyword">for</span> your platform... using <span class="built_in">builtin</span>-java classes <span class="built_in">where</span> applicable</span><br><span class="line">HBase Shell; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list of supported commands.</span><br><span class="line">Type <span class="string">"exit&lt;RETURN&gt;"</span> to leave the HBase Shell</span><br><span class="line">Version <span class="number">1.1</span>.<span class="number">2</span>, rcc2b70cf03e3378800661ec5cab11eb43fafe0<span class="built_in">fc</span>, Wed Aug <span class="number">26</span> <span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> PDT <span class="number">2015</span></span><br><span class="line">hbase(main):<span class="number">001</span>:<span class="number">0</span>&gt; status</span><br><span class="line"><span class="number">3</span> servers, <span class="number">0</span> dead, <span class="number">0.6667</span> average load</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code><span class="label">同时也可以通过在浏览器中输入: `http://master:</span><span class="number">16010</span><span class="escape">` </span>打开<span class="escape">`H</span>Base<span class="escape">`的</span>管理页面.也是可以的
</code></pre><p>到此,最简单的HBASE集群就搭建成功了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hbase分布式部署">Hbase分布式部署</h1><p>HBase的安装首先是有两个先决条件的,第一个就是需要zookeeper的支持,另外一个就是需要HDFS的支持了.<br>因此,安装Hbase的头两部就是安装<code>zookeeper</code>和<code>hadoop</code></p>
<p>这两个东西的安装可以参考我以前的博文:<a href="http://sunxiang0918.cn/2015/11/03/Hadoop全分布式部署/">Hadoop全分布式部署</a>以及<a href="http://sunxiang0918.cn/2014/09/20/zookeeper-集群部署/">zookeeper 集群部署</a>.这里就不再复述了.</p>
<h2 id="环境">环境</h2><p>环境: centos7 + hadoop2.6.2 + hbase1.1.2</p>
<p>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h2 id="安装步骤">安装步骤</h2><ol>
<li>首先还是需要把<code>hbase-1.1.2-bin.tar.gz</code>拷贝到几台机器上.然后使用<code>tar -xvf</code>命令解压,并重命名为hbase.  当前路径也就是 <code>/home/hadoop/hbase</code></li>
</ol>]]>
    
    </summary>
    
      <category term="Hbase" scheme="http://sunxiang0918.github.io/tags/Hbase/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hadoop全分布式部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/03/Hadoop%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/11/03/Hadoop全分布式部署/</id>
    <published>2015-11-03T09:23:25.000Z</published>
    <updated>2015-11-03T11:59:38.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Hadoop全分布式部署步骤">Hadoop全分布式部署步骤</h1><h2 id="环境">环境</h2><p>环境: centos7 +hadoop2.6.2<br>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h1 id="安装步骤:">安装步骤:</h1><h2 id="安装虚拟机,_保证机器能上网">安装虚拟机, 保证机器能上网</h2><ol>
<li>修改hosts文件,把机器都加上</li>
<li>修改机器的hostname文件: <code>sudo nano /etc/hostname</code>,需要注意的是这个文件是必须要改的,否则默认安装出来的centos都叫localhost. 这个在组建集群后,是会有问题的.</li>
</ol>
<h2 id="在机器上安装JDK-">在机器上安装JDK.</h2><ol>
<li>如果已经安装了openJDK,不想要的话,可以先删除:<ol>
<li><code>rpm -qa | grep java</code>  查看有哪些java相关的包</li>
<li><code>yum -y remove java</code>  删除openJDK</li>
<li><code>rpm -e —nodeps xxxxxxx</code>  再手动删除一些第一部显示的还与openJDK相关的包</li>
</ol>
</li>
<li><p>下载oracle的 jdk. 解压到一个目录</p>
<ol>
<li><p>然后修改/etc/profile. 在最后面增加:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.<span class="number">7.0</span>_51`</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行 <code>source /etc/profile</code> 刷新新的环境变量</p>
</li>
</ol>
</li>
</ol>
<a id="more"></a>
<h2 id="在虚拟机系统中增加hadoop用户">在虚拟机系统中增加hadoop用户</h2><ol>
<li><code>user add hadoop</code></li>
<li><code>passwd hadoop</code>  </li>
<li>为了方便,把hadoop用户加入 root用户组<br>用root登陆,然后输入:  <code>usermod -g  root hadoop</code><br>然后使用 <code>id hadoop</code> 验证一下.如果是:<code>uid=502(hadoop) gid=0(root) 组=0(root)</code>  就是对的</li>
</ol>
<h2 id="配置ssh免密码登陆">配置ssh免密码登陆</h2><p>hadoop工作的时候,各节点需要相互通讯,正常情况下需要输入用户名密码,这个需要人工参与.不方便. 为了让节点能自动通过安全认证,需要配置ssh免密码登陆</p>
<ol>
<li>先在master上，生成公钥、私钥对<br>以hadoop身份登录到系统<br><code>cd</code> (进入个人主目录，默认为/home/hadoop)<br><code>ssh-keygen -t rsa -P &#39;&#39;</code> (注：最后是二个单引号)   即：以rsa算法，生成公钥、私钥对，-P ‘’表示空密码。该命令运行完后，会在个人主目录下生成.ssh目录，里面会有二个文件id_rsa（私钥） ,id_rsa.pub(公钥)  </li>
<li>导入公钥      <code>cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys</code><br>执行完以后，可以在本机上测试下，用ssh连接自己，即：<code>ssh localhost</code> (或ssh master)，如果不幸还是提示要输入密码，说明还没起作用，还有一个关键的操作 <code>chmod 600 .ssh/authorized_keys</code> (修改文件权限，否则不起作用)<br>然后再测试下 ssh localhost ，如果不需要输入密码，就连接成功，表示ok，一台机器已经搞定了。</li>
<li>在其它机器上生成公钥、密钥，并将公钥文件复制到master<ol>
<li>以hadoop身份登录其它二台机器 slave01、slave02，执行 <code>ssh-keygen -t rsa -P &#39;&#39;</code> 生成公钥、密钥</li>
<li>然后用scp命令，把公钥文件发放给master（即：刚才已经搞定的那台机器）<br>slave01上：   <code>scp .ssh/id_rsa.pub hadoop@master:/home/hadoop/id_rsa_01.pub</code><br>slave02上：   <code>scp .ssh/id_rsa.pub hadoop@master:/home/hadoop/id_rsa_02.pub</code><br>这二行执行完后，回到master中，查看下/home/hadoop目录，应该有二个新文件id_rsa_01.pub、id_rsa_02.pub，<br>然后在master上，导入这二个公钥<br><code>cat id_rsa_01.pub &gt;&gt; .ssh/authorized_keys</code><br><code>cat id_rsa_02.pub &gt;&gt; .ssh/authorized_keys</code><br>这样，master这台机器上，就有所有3台机器的公钥了。</li>
</ol>
</li>
<li>将master上的“最全”公钥，复制到其它机器<ol>
<li>继续保持在master上，<br> <code>scp .ssh/authorized_keys hadoop@slave01:/home/hadoop/.ssh/authorized_keys</code><br> <code>scp .ssh/authorized_keys hadoop@slave02:/home/hadoop/.ssh/authorized_keys</code></li>
<li>修改其它机器上authorized_keys文件的权限<br>slave01以及slave02机器上，均执行命令    <code>chmod 600 .ssh/authorized_keys</code></li>
</ol>
</li>
<li>验证<br>在每个虚拟机上，均用 ssh 其它机器的hostname 验证下，如果能正常无密码连接成功，表示ok</li>
</ol>
<h2 id="上传并解压hadoop2-6-2">上传并解压hadoop2.6.2</h2><p>上传hadoop到 <code>/home/hadoop</code><br>执行 <code>tar -xvf hadoop-2.6.2.tar.gz</code><br>然后改名字为 hadoop   <code>mv hadoop2.6.2/ hadoop</code></p>
<h2 id="修改配置">修改配置</h2><p>一共7个文件需要修改:<br>$HADOOP_HOME/etc/hadoop/hadoop-env.sh</p>
<p>$HADOOP_HOME/etc/hadoop/yarn-env.sh</p>
<p>$HADOOP_HOME/etc/hadoop/core-site.xml</p>
<p>$HADOOP_HOME/etc/hadoop/hdfs-site.xml</p>
<p>$HADOOP_HOME/etc/hadoop/mapred-site.xml</p>
<p>$HADOOP_HOME/etc/hadoop/yarn-site.xml</p>
<p>$HADOOP_HOME/etc/hadoop/slaves</p>
<h3 id="hadoop-env-sh_、yarn-env-sh">hadoop-env.sh 、yarn-env.sh</h3><p>这二个文件主要是修改JAVA_HOME后的目录，改成实际本机jdk所在目录位置<br>nano etc/hadoop/hadoop-env.sh<br>找到下面这行的位置，改成（jdk目录位置，大家根据实际情况修改）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/home/hadoop/jdk</span><br></pre></td></tr></table></figure>
<p>在 hadoop-env.sh中 , 加上这句:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_PREFIX=/home/hadoop/hadoop</span><br></pre></td></tr></table></figure>
<h3 id="core-site-xml">core-site.xml</h3><p>修改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="pi">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/tmp<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>core-site.xml的完整参数请参考<br><a href="http://hadoop.apache.org/docs/r2.6.2/hadoop-project-dist/hadoop-common/core-default.xml" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.6.2/hadoop-project-dist/hadoop-common/core-default.xml</a></p>
<h3 id="hdfs-site-xml">hdfs-site.xml</h3><p>修改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="pi">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.datanode.ipc.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>0.0.0.0:50020<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.datanode.http.address<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>0.0.0.0:50075<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>2<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dfs.replication表示数据副本数，一般不大于datanode的节点数。<br>hdfs-site.xml的完整参数请参考<br><a href="http://hadoop.apache.org/docs/r2.6.2/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.6.2/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml</a></p>
<h3 id="mapred-site-xml">mapred-site.xml</h3><p>修改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="pi">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mapred-site.xml的完整参数请参考<br><a href="http://hadoop.apache.org/docs/r2.6.2/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.6.2/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml</a></p>
<h3 id="yarn-site-xml">yarn-site.xml</h3><p>修改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>yarn-site.xml的完整参数请参考<br><a href="http://hadoop.apache.org/docs/r2.6.2/hadoop-yarn/hadoop-yarn-common/yarn-default.xml" target="_blank" rel="external">http://hadoop.apache.org/docs/r2.6.2/hadoop-yarn/hadoop-yarn-common/yarn-default.xml</a></p>
<h3 id="slaves文件修改">slaves文件修改</h3><p>slaves文件暂时不管（可以先用mv slaves slaves.bak 将它改名）</p>
<h3 id="启动master节点">启动master节点</h3><ol>
<li>第一次启动先初始化namenod:<br><code>$HADOOP_HOME/bin/hdfs namenode –format</code><br>当等到:出现 <code>INFO common.Storage: Storage directory /home/hadoop/tmp/dfs/name has been successfully formatted.</code> 就表示格式化成功.</li>
<li>启动dfs:<br>执行<code>$HADOOP_HOME/sbin/start-dfs.sh</code><br>启动完成后,输入 <code>jps</code>查看进程.如果看到有<code>SecondaryNameNode</code>和<code>NameNode</code> 就表示master节点OK了.</li>
<li>启动yarn:<br>执行<code>$HADOOP_HOME/sbin/start-yarn.sh</code><br>启动完成后,输入<code>jps</code>查看进程.如果看到有<code>ResourceManager</code> 就表示OK了</li>
</ol>
<h3 id="修改slaves节点">修改slaves节点</h3><ol>
<li>恢复刚才备份的slaves文件. </li>
<li>修改这个文件,加入其他slaves节点的ip或host</li>
<li>运行<code>HADOOP_HOME/sbin/stop-dfs.sh</code>和<code>HADOOP_HOME/sbin/stop-yarn.sh</code> 停止服务</li>
<li>拷贝master上的hadoop目录到slave01和slave02上:</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp -r hadoop hadoop@slave01:/home/hadoop/</span><br><span class="line">scp -r hadoop hadoop@slave02:/home/hadoop/</span><br></pre></td></tr></table></figure>
<h3 id="启动整个集群-">启动整个集群.</h3><p>在master节点上,启动:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP_HOME</span>/sbin/start-dfs.sh</span><br><span class="line"><span class="variable">$HADOOP_HOME</span>/sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>如果正常的话, 会有<code>SecondaryNameNode</code>,<code>NameNode</code>,<code>ResourceManager</code> 三个进程.<br>而slave01的机器上会有<code>DataNode</code>,<code>NodeManager</code> 两个节点.</p>
<p>这个时候 主节点的 50070和 8088 也可以用浏览器访问了: <code>http://master:50070/</code>   <code>http://master:8088/</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hadoop全分布式部署步骤">Hadoop全分布式部署步骤</h1><h2 id="环境">环境</h2><p>环境: centos7 +hadoop2.6.2<br>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h1 id="安装步骤:">安装步骤:</h1><h2 id="安装虚拟机,_保证机器能上网">安装虚拟机, 保证机器能上网</h2><ol>
<li>修改hosts文件,把机器都加上</li>
<li>修改机器的hostname文件: <code>sudo nano /etc/hostname</code>,需要注意的是这个文件是必须要改的,否则默认安装出来的centos都叫localhost. 这个在组建集群后,是会有问题的.</li>
</ol>
<h2 id="在机器上安装JDK-">在机器上安装JDK.</h2><ol>
<li>如果已经安装了openJDK,不想要的话,可以先删除:<ol>
<li><code>rpm -qa | grep java</code>  查看有哪些java相关的包</li>
<li><code>yum -y remove java</code>  删除openJDK</li>
<li><code>rpm -e —nodeps xxxxxxx</code>  再手动删除一些第一部显示的还与openJDK相关的包</li>
</ol>
</li>
<li><p>下载oracle的 jdk. 解压到一个目录</p>
<ol>
<li><p>然后修改/etc/profile. 在最后面增加:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.<span class="number">7.0</span>_51`</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行 <code>source /etc/profile</code> 刷新新的环境变量</p>
</li>
</ol>
</li>
</ol>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://sunxiang0918.github.io/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转> 为 Key-Value 数据库实现MVCC 事务]]></title>
    <link href="http://sunxiang0918.github.io/2015/10/23/%E4%B8%BA-Key-Value-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0MVCC-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://sunxiang0918.github.io/2015/10/23/为-Key-Value-数据库实现MVCC-事务/</id>
    <published>2015-10-23T03:12:50.000Z</published>
    <updated>2015-10-23T03:21:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为_Key-Value_数据库实现MVCC_事务">为 Key-Value 数据库实现MVCC 事务</h1><p>ACID 是软件领域使用最广泛的技术之一，它是关系数据库的基石，是企业级中间件不可或缺的部分，但通常通过黑盒的方式提供。但是在许多情况下，这种古老的事务方式已经不能够适应现代大规模系统和NoSQL数据库的需要了，现代系统要求更高的性能要求，更大的数据量，更高的可用性。在这种情况下，传统的事务模型被定制的事务或者半事务模型所取代，而在这些模型中事务性并不像以往那样被看重。</p>
<p>在本文中我们会讨论一下key-value数据库的无锁事务操作，这种技术可以广泛应用于任何一种数据库系统。在GridDynamics中，我们就用这种技术在Oracle Coherence上实现了一个轻量级的非标准的事务机制。在第一部分我们会通过几个重要的用例来了解两种简单的方法，在第二部分我们会研究更多更通用的方法，比如说PostgreSQL的MVCC实现。</p>
<h2 id="原子性缓存切换，读提交隔离">原子性缓存切换，读提交隔离</h2><p>让我们从一个简单易于实现的方法开始，这个方法适用于读远多于写的系统。比如说电子商务系统中每天要进行的数据更新，一些管理性操作例如无效货品的修复以及缓存更新。</p>
<p>最简单的例子是把所有数据都加载进缓存里，然后通过一个代理接口来执行诸如 get() 和 put() 这样的操作。这个接口会与两个缓存打交道，A和B，按照以下逻辑运行（图 1）：</p>
<ul>
<li>任何时候只能有一个缓存处于可用状态，代理接口会把所有的请求路由给它（图1.1）。</li>
<li>更新数据的时候把新数据加载到目前不可用的缓存中（图1.2）。</li>
<li>更新进程切换标志哪个缓存可用的标记（图1.3），代理接口开始把新的读请求分发到新标记为可用的缓存。</li>
<li>缓存切换阶段的事务可以依据不用的持久性和隔离性要求来分别处理。如果允许“不可重复读” ，那么切换很简单，老数据会被立刻清理掉。否则，代理接口会维护一个仍未结束的事务列表，并把属于这个列表中的每一个请求都路由到原来的缓存中。只有当列表中的所有事物都提交或者放弃之后老数据才会被清空。<a id="more"></a>
</li>
</ul>
<p><img src="/img/2015/10/23/1.png" alt=""><br>Fig.1 Cache Switch</p>
<p>相同的技术也可用于部分更新。依据存储方式的不同也有多种实现方法，我们来看一个有三个缓存简单例子。这个例子中的框架遇上一个类似，但是代理接口按照以下逻辑运行（图 2）：</p>
<ul>
<li>用户请求被路由到主缓存（”PRIMARY”缓存）（图 2.1）</li>
<li>新增数据和更新数据加载进2号缓存（“NEW”缓存），删除项的key放入3号缓存（”DELETE”缓存）（图2.2）</li>
<li>提交进程（特指写事务）切换全局标示，这个标示会告诉代理接口先去”NEW”和”DELETE”缓存去查找所请求的数据，如果在这两个区域中没有发现再去”PRIMARY”缓存查找（图2.3）。换句话说，在这一步所有的请求都被改派到了更新过的数据中查找。</li>
<li>提交进程将 NEW 和 DELETE 区域的变化传递给PRIMARY。也即在PRIMARY缓存区以非原子的方式更新、增加、删除数据项（图2.4）。</li>
<li>最后，所有的提交进程把全局标识切换回来，所有的请求仍然路由到 PRIMARY 缓存区域（图2.5）。</li>
<li>在第4步，可以把老数据拷贝到另一个缓存区，这样就可以支持回滚操作。即使是全量更新也可以用这种方法。</li>
</ul>
<p><img src="/img/2015/10/23/2.png" alt=""><br>Fig.2 Partial Cache Switch</p>
<p>从上面的两个例子我们可以看出，专用于读的数据快照避免了数据更新的干扰，大大降低了复杂性。在一个写密集型的环境中就不容易做到这一点了。在下一节我们会讨论一种非常好的方法可以完美的解决这个问题。</p>
<p>MVCC 事务，可重复读隔离</p>
<p>事物间的隔离可以通过给数据项加上版本号来实现。有许多方法能做到这一点，下面我们会介绍一种与PostgreSQL  的事务处理方法非常相似的办法。</p>
<p>正如前面所说，每个事务可以对应于一个部分数据快照。在同一时间，每一个数据项都有他自己的生命周期 - 从加入缓存到移出缓存或者被更新（被新版本所取代）。所以可以通过给每条数据打两个时间戳来实现隔离，每个事物通过开始时间（两个时间戳之一，译者注）来找出在事务开始时处于可见状态的数据。但在实践中常用一个单调递增的计数来代替时间戳：</p>
<ul>
<li>当新事务开始的时候：<ul>
<li>它会获得一个全局唯一且单调递增的事务ID ，也叫 XID。</li>
<li>进程里保存着所有事务的XID.</li>
</ul>
</li>
<li>缓存里的每个数据项有两个额外标记，xmin 和 xmax。按照以下规则赋值：<ul>
<li>当数据项被某个事务建立的时候， xmin 设置为该事务的XID ，xmax 无值。</li>
<li>当数据被某个事务移除的时候，xmin 不变，xmax 设置为该事务的XID。数据并没有真的从缓存中清除，只是被标记为已删除。</li>
<li>当数据被某个事务更新的时候，老数据仍然保存在缓存里，xmax 被赋值为事务的XID，同时增加一条新的数据，新数据的 xmin 也赋值为XID 并且xmax 为空。换句话说更新操作等于一次删除加一次增加。</li>
</ul>
</li>
<li>如果以下两个条件成立，那么数据对于某次事务是可见的：<ul>
<li>xmin 有值并且小于或等于当前事务ID。</li>
<li>xmax 为空，或者等于未提交事务（放弃的或者还未完成的）的XID ，或者大于当前事务ID。</li>
</ul>
</li>
<li>xmin 和 xmax 可以存储两个位标记，表明事务是否放弃或者提交，这样才能进行上面的检查（xmax 是否等于未提交事务的ID）。<br>逻辑如下图所示：</li>
</ul>
<p><img src="/img/2015/10/23/3.png" alt=""><br>Fig.3 PostgeSQL-like MVCC</p>
<p>这种方法的缺点是废弃数据的移除有些繁琐。因为不同事务看到的数据版本不同，决定何时将数据标为不可见或者移除是比较复杂的。不过也有两种以上的方法能够做到，第一种是PostgreSQL中使用的，第二种是Oracle使用的：</p>
<ul>
<li>所有的版本都存储在同一个key-value空间中，对版本数量没有限制（也即可以储存任意多的版本，译者注）。由一个后台进程来回收老版本数据，这个回收可以按计划调度执行也可以再读或者写的时候触发。</li>
<li>主key-value 空间只储存最新的版本，之前的版本储存在另外的地方，且储存老版本的空间大小是固定的。 最新的版本会指向之前的版本，但是却不能够由此上溯到之前的任意版本， 因为存储老版本数据的区域大小是固定的， 太早的版本会被移除。如果某个事务不能够找到指定版本的数据就会失败。 </li>
</ul>
<hr>
<p><strong>原文链接:</strong><a href="http://my.oschina.net/juliashine/blog/111624" target="_blank" rel="external">http://my.oschina.net/juliashine/blog/111624</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为_Key-Value_数据库实现MVCC_事务">为 Key-Value 数据库实现MVCC 事务</h1><p>ACID 是软件领域使用最广泛的技术之一，它是关系数据库的基石，是企业级中间件不可或缺的部分，但通常通过黑盒的方式提供。但是在许多情况下，这种古老的事务方式已经不能够适应现代大规模系统和NoSQL数据库的需要了，现代系统要求更高的性能要求，更大的数据量，更高的可用性。在这种情况下，传统的事务模型被定制的事务或者半事务模型所取代，而在这些模型中事务性并不像以往那样被看重。</p>
<p>在本文中我们会讨论一下key-value数据库的无锁事务操作，这种技术可以广泛应用于任何一种数据库系统。在GridDynamics中，我们就用这种技术在Oracle Coherence上实现了一个轻量级的非标准的事务机制。在第一部分我们会通过几个重要的用例来了解两种简单的方法，在第二部分我们会研究更多更通用的方法，比如说PostgreSQL的MVCC实现。</p>
<h2 id="原子性缓存切换，读提交隔离">原子性缓存切换，读提交隔离</h2><p>让我们从一个简单易于实现的方法开始，这个方法适用于读远多于写的系统。比如说电子商务系统中每天要进行的数据更新，一些管理性操作例如无效货品的修复以及缓存更新。</p>
<p>最简单的例子是把所有数据都加载进缓存里，然后通过一个代理接口来执行诸如 get() 和 put() 这样的操作。这个接口会与两个缓存打交道，A和B，按照以下逻辑运行（图 1）：</p>
<ul>
<li>任何时候只能有一个缓存处于可用状态，代理接口会把所有的请求路由给它（图1.1）。</li>
<li>更新数据的时候把新数据加载到目前不可用的缓存中（图1.2）。</li>
<li>更新进程切换标志哪个缓存可用的标记（图1.3），代理接口开始把新的读请求分发到新标记为可用的缓存。</li>
<li>缓存切换阶段的事务可以依据不用的持久性和隔离性要求来分别处理。如果允许“不可重复读” ，那么切换很简单，老数据会被立刻清理掉。否则，代理接口会维护一个仍未结束的事务列表，并把属于这个列表中的每一个请求都路由到原来的缓存中。只有当列表中的所有事物都提交或者放弃之后老数据才会被清空。]]>
    
    </summary>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[3DTouch尝鲜]]></title>
    <link href="http://sunxiang0918.github.io/2015/10/18/3DTouch%E5%B0%9D%E9%B2%9C/"/>
    <id>http://sunxiang0918.github.io/2015/10/18/3DTouch尝鲜/</id>
    <published>2015-10-18T07:50:40.000Z</published>
    <updated>2015-10-18T09:03:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="3DTouch尝鲜">3DTouch尝鲜</h1><p>随着IOS9和iphone6S的推出,苹果新提供了3D Touch功能,让以往平面的操作,扩展到了3维.<br>让我们对应用的操作增加了新的方式.<br>目前最常用的3DTouch方式就是快捷菜单已经内容浏览了.于是我也把我练手的一个<code>知乎日报</code>的<a href="http://git.oschina.net/xycm/ZhiHuDaily-Swift" target="_blank" rel="external">DEMO</a>程序增加上了3DTouch.</p>
<p>由于在xcode的模拟器上是没有办法模拟出3DTouch的操作,因此如果想在模拟器上开发这个功能的话,需要参考github上的一位大神的<a href="https://github.com/DeskConnect/SBShortcutMenuSimulator" target="_blank" rel="external">解决方案</a>,当然这种方案只能模拟快捷菜单,其他的3DTouch的操作是没法模拟的,最好的方式还是去买一个iphone6S.</p>
<h2 id="快捷菜单">快捷菜单</h2><p>所谓的快捷菜单就是 在应用的图标上重按,然后会出现几个快捷项.直接点击这些菜单项就可以执行某些操作.</p>
<p><img src="/img/2015/10/18/1.gif" alt=""></p>
<a id="more"></a>
<h3 id="UI设置">UI设置</h3><p>要实现这些个快捷菜单就需要在程序启动或配置info.plist程序的时候给程序增加上<code>UIMutableApplicationShortcutItem</code>.<br>这个其实就是<code>UIApplicationShortcutItem</code>的一个子类.<code>UIApplicationShortcutItem</code>就是IOS用来表示快捷菜单的类,并且一个程序最多只能有4个快捷菜单项.<br>他有几个重要的属性:</p>
<ul>
<li>UIApplicationShortcutItemType,事件的唯一标识,用来表示你到底点击了哪个操作</li>
<li>UIApplicationShortcutItemTitle,标题,在没有子标题的情况下可以自动换行</li>
<li>UIApplicationShortcutItemSubtitle,子标题,在标题下方较小字体显示</li>
<li>UIApplicationShortcutItemIconType,枚举选取系统中的一个图标</li>
<li>UIApplicationShortcutItemIconFile,自定义一个图标文件,以单色35*35的大小展示</li>
<li>UIApplicationShortcutItemUserInfo,自定义字典,可以放入自定义的属性.</li>
</ul>
<p>因此,要给我的程序增加<code>最新日报</code> <code>每日瞎扯</code>的话,就需要这样操作:</p>
<ol>
<li>info.plist配置方式:</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>UIApplicationShortcutItems<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">key</span>&gt;</span>UIApplicationShortcutItemType<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">string</span>&gt;</span>newNews<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">key</span>&gt;</span>UIApplicationShortcutItemTitle<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">string</span>&gt;</span>最新日报<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">key</span>&gt;</span>UIApplicationShortcutItemIconType<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">string</span>&gt;</span>Share<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">key</span>&gt;</span>UIApplicationShortcutItemType<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">string</span>&gt;</span>xiaCheNews<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">key</span>&gt;</span>UIApplicationShortcutItemTitle<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">string</span>&gt;</span>每日瞎扯<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">key</span>&gt;</span>UIApplicationShortcutItemIconType<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">string</span>&gt;</span>Compose<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>编程方式:</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 增加Icon 3DTouch的功能</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加icon 3d Touch</span></span><br><span class="line">        <span class="comment">//先建立图标</span></span><br><span class="line">        <span class="keyword">let</span> firstItemIcon:<span class="type">UIApplicationShortcutIcon</span> = <span class="type">UIApplicationShortcutIcon</span>(type: .<span class="type">Share</span>)</span><br><span class="line">        <span class="comment">//然后创建按钮项,通过Type可以确定是哪一个按钮,</span></span><br><span class="line">        <span class="keyword">let</span> firstItem = <span class="type">UIMutableApplicationShortcutItem</span>(type: <span class="string">"1"</span>, localizedTitle: <span class="string">"最新日报"</span>, localizedSubtitle: <span class="literal">nil</span>, icon: firstItemIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> secondItemIcon:<span class="type">UIApplicationShortcutIcon</span> = <span class="type">UIApplicationShortcutIcon</span>(type: .<span class="type">Compose</span>)</span><br><span class="line">        <span class="keyword">let</span> secondItem = <span class="type">UIMutableApplicationShortcutItem</span>(type: <span class="string">"2"</span>, localizedTitle: <span class="string">"每日瞎扯"</span>, localizedSubtitle: <span class="literal">nil</span>, icon: secondItemIcon, userInfo: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        application.shortcutItems = [firstItem,secondItem]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件处理">事件处理</h3><p>UI解决了后,接下来需要做的就是处理快捷菜单的事件了.<br>在<code>IOS9</code>中<code>UIApplication</code>增加了一个回调方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Void</span>)</span><br></pre></td></tr></table></figure>
<p>当接收到快捷菜单的点击后,会调用这个方法.因此我们的事件处理就可以放到这里面:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - 3D Touch的操作</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: <span class="params">(Bool)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="comment">//这个方法就是激活了3DTouch时触发的操作.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> handledShortCutItem = handleShortCutItem(shortcutItem)</span><br><span class="line">        completionHandler(handledShortCutItem)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    这个方法用处处理3DTouch的操作</span><br><span class="line">    </span><br><span class="line">    - parameter shortcutItem: 3DTouch的按钮</span><br><span class="line">    </span><br><span class="line">    - returns: 是否执行成功</span><br><span class="line">    */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">handleShortCutItem</span><span class="params">(shortcutItem: UIApplicationShortcutItem)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> handled = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到根视图</span></span><br><span class="line">        <span class="keyword">let</span> launchImageViewController = window!.rootViewController <span class="keyword">as</span>? <span class="type">LaunchImageViewController</span></span><br><span class="line">        <span class="comment">//打开根视图</span></span><br><span class="line">        <span class="keyword">let</span> rootNavigationViewController = launchImageViewController!.viewController <span class="keyword">as</span>? <span class="type">UINavigationController</span></span><br><span class="line">        <span class="keyword">let</span> pkRevealController = rootNavigationViewController?.viewControllers.first <span class="keyword">as</span>? <span class="type">PKRevealController</span></span><br><span class="line">        <span class="keyword">let</span> rootViewController = pkRevealController?.frontViewController</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> shortcutItem.type == <span class="string">"1"</span> &#123; <span class="comment">//最新日报</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//然后打开最新的日报</span></span><br><span class="line">            rootViewController?.performSegueWithIdentifier(<span class="string">"pushSegue"</span>, sender: <span class="string">"newNews"</span>)</span><br><span class="line">            </span><br><span class="line">            handled = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> shortcutItem.type == <span class="string">"2"</span> &#123; <span class="comment">//每日瞎扯</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//然后打开每日瞎扯</span></span><br><span class="line">            rootViewController?.performSegueWithIdentifier(<span class="string">"pushSegue"</span>, sender: <span class="string">"xiacheNews"</span>)</span><br><span class="line">            </span><br><span class="line">            handled = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是<code>completionHandler</code><br>在API中说明如果我们的应用程序不在后台而是重新启动的时候,应该设置为false,并且这时的回调是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>因此我们还需要再在<code>didFinishLaunchingWithOptions</code>中增加相应的逻辑:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"><span class="comment">// 增加3DTouch启动程序时的处理</span></span><br><span class="line">        <span class="comment">// 从启动项中获取是否是从3DTouch中启动的</span></span><br><span class="line">        <span class="keyword">let</span> launchShortcutItem:<span class="type">UIApplicationShortcutItem</span>? = launchOptions?[<span class="type">UIApplicationLaunchOptionsShortcutItemKey</span> <span class="keyword">as</span> <span class="type">NSObject</span>] <span class="keyword">as</span>? <span class="type">UIApplicationShortcutItem</span></span><br><span class="line">        <span class="keyword">if</span>  launchShortcutItem != <span class="literal">nil</span>&#123;</span><br><span class="line">            <span class="comment">//说明是使用3DTouch启动的,那么当页面启动的时候就需要直接跳转到新闻详细中</span></span><br><span class="line">            <span class="comment">//这里的逻辑是这样的,在启动的时候设置一个标志,是否需要跳转,然后在LaunchImageViewController中会判断是否有这个标志.如果有</span></span><br><span class="line">            <span class="comment">//就进行界面的跳转</span></span><br><span class="line">            <span class="type">LaunchImageViewController</span>.jumpTo = launchShortcutItem?.type == <span class="string">"1"</span> ? <span class="string">"newNews"</span> : <span class="string">"xiacheNews"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是我们可以从启动的<code>launchOptions</code>获取<code>key</code>为<code>UIApplicationLaunchOptionsShortcutItemKey</code>的项,如果没有就说明不是3DTouch启动的,否则就是点击某一个<code>快捷菜单</code>启动的.</p>
<p>当这两个地方都处理了后, 3DTouch的快捷菜单功能就算是完成了.</p>
<h2 id="内容预览">内容预览</h2><p>3DTouch在应用中还有一个常用的功能,就是内容预览.通过轻按(peek)和重按(pop)来进行一系列的操作.</p>
<p><img src="/img/2015/10/18/2.PNG" alt=""></p>
<p><img src="/img/2015/10/18/3.PNG" alt=""></p>
<p>首先需要的是判断3DTouch是否在这个Controller上开启,决定这个的是<code>UIForceTouchCapability</code>:</p>
<ul>
<li>UIForceTouchCapabilityUnknown        //3D Touch检测失败</li>
<li>UIForceTouchCapabilityUnavailable        //3D Touch不可用</li>
<li>UIForceTouchCapabilityAvailable        //3D Touch可用</li>
</ul>
<p>所以在程序中我们可以这样写:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    检测页面是否处于3DTouch</span><br><span class="line">    */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">check3DTouch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.traitCollection.forceTouchCapability == <span class="type">UIForceTouchCapability</span>.<span class="type">Available</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.registerForPreviewingWithDelegate(<span class="keyword">self</span>, sourceView: <span class="keyword">self</span>.view)</span><br><span class="line">            <span class="comment">//长按停止</span></span><br><span class="line">            <span class="keyword">self</span>.longPress.enabled = <span class="literal">false</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.longPress.enabled = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当我们想给某一个controller增加内容预览功能的时候,就需要给这个controller实现<code>UIViewControllerPreviewingDelegate</code>协议.</p>
<p>这个协议有两个方法,分别是<code>peek</code>操作时触发以及<code>pop</code>操作触发:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轻按</span></span><br><span class="line">public <span class="func"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint)</span></span> -&gt; <span class="type">UIViewController</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">//重按</span></span><br><span class="line">public <span class="func"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)</span></span></span><br></pre></td></tr></table></figure>
<p>那么轻按预览的逻辑就很好处理了.<br>在<code>public func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController?</code>这个方法中,根据<code>location</code>找到轻按的内容项是哪一个,然后在程序中找到对应的详细内容.然后构造一个UIViewController进行返回.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    轻按进入浮动页面</span><br><span class="line">    </span><br><span class="line">    - parameter previewingContext:</span><br><span class="line">    - parameter location:</span><br><span class="line">    </span><br><span class="line">    - returns:</span><br><span class="line">    */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint)</span></span> -&gt; <span class="type">UIViewController</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cellPosition = mainTableView.convertPoint(location, fromView: view)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> touchedIndexPath = mainTableView.indexPathForRowAtPoint(cellPosition) &#123;</span><br><span class="line">            </span><br><span class="line">            mainTableView.deselectRowAtIndexPath(touchedIndexPath, animated: <span class="literal">true</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> aStoryboard = <span class="type">UIStoryboard</span>(name: <span class="string">"Main"</span>, bundle:<span class="type">NSBundle</span>.mainBundle())</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newsDetailViewController = aStoryboard.instantiateViewControllerWithIdentifier(<span class="string">"newsDetailViewController"</span>) <span class="keyword">as</span>? <span class="type">NewsDetailViewController</span>  &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>  newsDetailViewController.newsListControl == <span class="literal">nil</span> &#123;</span><br><span class="line">                    newsDetailViewController.newsListControl = <span class="keyword">self</span>.newsListControl</span><br><span class="line">                    newsDetailViewController.mainViewController = <span class="keyword">self</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                newsDetailViewController.newsLocation = (touchedIndexPath.section,touchedIndexPath.row)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> cellFrame = mainTableView.cellForRowAtIndexPath(touchedIndexPath)!.frame</span><br><span class="line">                previewingContext.sourceRect = view.convertRect(cellFrame, fromView: mainTableView)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> newsDetailViewController</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIViewController</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在我的程序中就是找到轻按的新闻列表行.然后找到具体是哪一篇新闻,然后从<code>storyBoard</code>中获取出新闻详细的ViewController.然后传入新闻详细的参数,最后返回. 这样就完成了轻按显示详细的目的.</p>
<p>而重案的话就更好处理了,在方法<code>public func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)</code>中的<code>viewControllerToCommit</code>表示的就是你轻按激活的预览View.如果你想直接放大显示这个View的话,就直接调用<code>self.showViewController(viewControllerToCommit, sender: self)</code>即可.比如我程序中的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    重按进入文章详情页</span><br><span class="line">    </span><br><span class="line">    - parameter previewingContext:</span><br><span class="line">    - parameter viewControllerToCommit:</span><br><span class="line">    */</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">previewingContext</span><span class="params">(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.showViewController(viewControllerToCommit, sender: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当然,你还可以增加些其他的操作.</p>
<p>更高级的操作比如内容预览上的Action等,等我后面增加到我的程序中后再来补充.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="3DTouch尝鲜">3DTouch尝鲜</h1><p>随着IOS9和iphone6S的推出,苹果新提供了3D Touch功能,让以往平面的操作,扩展到了3维.<br>让我们对应用的操作增加了新的方式.<br>目前最常用的3DTouch方式就是快捷菜单已经内容浏览了.于是我也把我练手的一个<code>知乎日报</code>的<a href="http://git.oschina.net/xycm/ZhiHuDaily-Swift">DEMO</a>程序增加上了3DTouch.</p>
<p>由于在xcode的模拟器上是没有办法模拟出3DTouch的操作,因此如果想在模拟器上开发这个功能的话,需要参考github上的一位大神的<a href="https://github.com/DeskConnect/SBShortcutMenuSimulator">解决方案</a>,当然这种方案只能模拟快捷菜单,其他的3DTouch的操作是没法模拟的,最好的方式还是去买一个iphone6S.</p>
<h2 id="快捷菜单">快捷菜单</h2><p>所谓的快捷菜单就是 在应用的图标上重按,然后会出现几个快捷项.直接点击这些菜单项就可以执行某些操作.</p>
<p><img src="/img/2015/10/18/1.gif" alt=""></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOS下JAVA开发使用经验(二)]]></title>
    <link href="http://sunxiang0918.github.io/2015/10/11/MacOS%E4%B8%8BJAVA%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C-%E4%BA%8C/"/>
    <id>http://sunxiang0918.github.io/2015/10/11/MacOS下JAVA开发使用经验-二/</id>
    <published>2015-10-11T13:39:59.000Z</published>
    <updated>2015-10-11T15:55:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MacOS下JAVA开发使用经验(二)">MacOS下JAVA开发使用经验(二)</h1><p><a href="http://sunxiang0918.cn/2015/09/21/MacOS下JAVA开发使用经验(一" target="_blank" rel="external">上一篇文章</a>)写了最常用的一些工具,接下来再介绍一下提高开发生产力的工具.</p>
<h2 id="软件">软件</h2><h3 id="BetterZip">BetterZip</h3><p>这个是MAC下很常用的压缩/解压的软件.它对于Windows下的中文支持的比较好.<br>基本上没有遇到在Windows下压缩的中文字符,到Mac下就无法打开的问题了.<br>同时他也支持rar格式. 对于我们JAVA的各种<code>ear</code>,<code>war</code>,<code>jar</code>等 都是可以直接打开,然后编辑的.当双击某个jar中的xml文件后会自动打开关联的文件编辑器,然后保存文本编辑器也会自动的更新jar包.</p>
<p><img src="/img/2015/10/11/1.png" alt=""></p>
<h3 id="Beyond_Compare">Beyond Compare</h3><p>这个是我们搞IT的大杀器.以前只有在Windows上有,当时为了这一个软件,我不得不装上了虚拟机.<br>不得不说,用过这么多文件比较工具,这个始终是神话般的存在.什么<code>DiffMerge</code> <code>FileMerge</code> <code>Araxis Merge</code> <code>Kaleidoscope</code> 都弱爆了.<br>这个工具可以配合你的<code>sourceTree</code>等代码管理工具使用,直接清晰地对比和合并代码.同时也可以和<code>JD</code>反编译工具配合直接对比<code>class</code>文件的差异(这个可以参考我的<a href="http://sunxiang0918.cn/2014/09/20/在MAC下使用beyondcompare比较JAVA-Class文件/" target="_blank" rel="external">另一篇文章</a>).</p>
<p><img src="/img/2015/10/11/2.png" alt=""></p>
<a id="more"></a>
<h3 id="Dash">Dash</h3><p>这个又是<code>Mac Only</code>的一个福利,是一款功能单一却精准的API文档浏览器,以及代码片段管理工具.它采用了单窗口的模式,最方便的提供了API查询的需求.我们平时写东西的时候,最常用的就是查看源码和API了,IDE提供了源码的查看,而<code>Dash</code>则提供了<code>API查询</code>的功能. 它可以和绝大多数的IDE合作,包括我们JAVA最常用的<code>Intellij</code> <code>eclipse</code>.只需要在需要查看API的代码上按住<code>Command+Shift+左键</code>(这个可以自己设置),那么就会自动的跳转到它的界面上并显示这段代码的API.不需要我们到处去翻了.<br>它基本上集成了绝大多数的API文档,包括<code>JDK</code> <code>Spring</code> <code>Hibernate</code>等等,同时也支持三方的推送,只要是符合标准的url地址,都可以添加到它里面进行管理.</p>
<p><img src="/img/2015/10/11/3.png" alt=""></p>
<h3 id="JD-GUI">JD-GUI</h3><p>这个是Mac下的可视化的<code>Java</code>反编译工具.使用很简单,直接双击打开界面后,把<code>class</code>文件或者文件夹直接拖入他的窗口就可以了.然后就会自动的反编译好,如果是一个文件夹的话,他还支持代码间的跳转.这对有些时候来说有奇效.</p>
<p><img src="/img/2015/10/11/4.png" alt=""></p>
<h3 id="MongoHub">MongoHub</h3><p>这个是在Mac下非常好用的<code>Mongo</code>可视化客户端.它基本上提供了<code>Mongo</code>的所有操作,并且支持Mongo的集群连接,同时,它是免费<a href="https://github.com/jeromelebel/MongoHub-Mac" target="_blank" rel="external">开源的</a>.如果在开发中需要使用<code>Mongo</code>数据库.那么这个基本上是不二的选择.</p>
<p><img src="/img/2015/10/11/5.png" alt=""></p>
<h3 id="Navicat_Premium">Navicat Premium</h3><p>这个是多平台下的多数据库管理工具,能支持<code>Oracle</code>,<code>Mysql</code>,<code>Sqlite</code>,<code>PostgreSQL</code>.不过我主要是拿它来管理<code>Oracle</code>和<code>Sqlite</code>.它也提供了很全面的数据库管理功能.比如导入导出,执行函数,事件,任务等等.但是这个工具使用起来有点慢,而且容易崩溃(我也不知道为什么,已经遇到很多次了),所以不怎么常用.不过用来临时操作下<code>Oracle</code>或<code>Sqlite</code>还是推荐.</p>
<p><img src="/img/2015/10/11/6.png" alt=""></p>
<h3 id="OmniDiskSweeper">OmniDiskSweeper</h3><p>这个工具也是平时使用Mac必不可少的,主要是用来查看磁盘空间被什么文件使用的.通过这个软件可以很容易的看到你的磁盘到底是被什么占用了这么多.自从又一次无意间发现企鹅聊天占用了我系统盘10个G空间存放莫名其妙的东西后,我就养成了定时执行一次这个软件的习惯,谁叫我们是屌丝只买得起256G的SSD喃..空间还是要节约到用..</p>
<p><img src="/img/2015/10/11/7.png" alt=""></p>
<h3 id="OmniGraffle&amp;OmniPlan">OmniGraffle&amp;OmniPlan</h3><p>这两个工具是用来画UML和项目甘特图的,也是在Mac上算是比较好用的了.它们对应了Windows上的<code>Visio</code>和<code>Project</code>.如果你们是一个传统点的软件开发公司,相信采用瀑布开发模型的肯定是需要这两个软件的.</p>
<p><img src="/img/2015/10/11/8.png" alt=""></p>
<p><img src="/img/2015/10/11/9.png" alt=""></p>
<h3 id="Sequel_Pro">Sequel Pro</h3><p>这个是在Mac环境下的Mysql的管理软件.完全免费的,并且是原生的Mac软件,使用速度比<code>Navicat</code>快.功能也和<code>Navicat</code>是一样的.因此,我平时更倾向于使用这个工具来管理<code>Mysql</code>.<br>它的开源地址是:<a href="https://github.com/sequelpro/sequelpro" target="_blank" rel="external">https://github.com/sequelpro/sequelpro</a></p>
<p><img src="/img/2015/10/11/10.jpg" alt=""></p>
<h3 id="Microsoft_Remote_Desktop">Microsoft Remote Desktop</h3><p>这个工具也是在工作中基本上跑不掉的.它是用来远程Windows系统的,相当于Windows上的远程桌面.没有办法,我们的环境中还是有一半的Windows机器作为媒体处理的执行器.平时需要远程上去调试些东西.不过还算微软厚道,这个工具还是比较好用的,能支持同时打开几个文件.并且能直接粘贴复制远程桌面的东西到本地.</p>
<p><img src="/img/2015/10/11/11.png" alt=""></p>
<h3 id="Transmit">Transmit</h3><p>非常好用的sftp工具,他提供了<code>FTP</code> <code>SFTP</code> <code>S3</code> 的文件访问.并且支持标签组的操作,以及直接双击打开关联的工具修改文件并自动上传.还支持各种姿势的拖拽操作.总之非常方便,强烈地推荐.</p>
<p><img src="/img/2015/10/11/12.png" alt=""></p>
<h3 id="Brew">Brew</h3><p>brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 只需要一个命令， 非常方便.类似于Ubuntu上的<code>apt-get</code>.他能方便的管理我们的各种软件的依赖,这些工具通常都是些比较专业的命令行工具,安装不是需要编译一大堆就是需要下载各种依赖包,总之不简单.用了这个之后,一句话而已,就搞定了.<br>要安装Brew也很简单,在终端中输入 <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>即可.<br>安装后 就可以在终端中输入<code>brew</code> 来进行各种操作了.<br>比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">brew install wget</span><br><span class="line">brew search /*get/</span><br><span class="line">brew list</span><br><span class="line">brew update</span><br></pre></td></tr></table></figure>
<h3 id="zsh">zsh</h3><p>Linux/Unix提供了很多种Shell,除了大家最常用的bash以外,<code>Macos</code>还预装了一个<code>zsh</code>.这个可是一个大杀器,被称为终极Shell,但是由于配置过于复杂,用的人始终不多.直到有一天,有个外国友人搞了一个<code>oh my zsh</code>的项目,可以让你很容易的使用上<code>zsh</code>.</p>
<ol>
<li>切换到zsh<br> 直接在终端中输入 <code>chsh -s /bin/zsh</code> 即可.</li>
<li>安装oh my zsh<br> 这个也直接在终端中输入 <code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code> 即可.它会自动的下载源码并编译然后安装配置一条龙搞完.安装完成后重新打开一个终端窗口,你就可以看到一个彩色的提示了<br><img src="/img/2015/10/11/13.png" alt=""></li>
<li><p>修改 ~/.zshrc配置<br> 这个配置文件里面就是zsh的自定义配置项了,可以在这里配置zsh的主题,插件,命令行别名等等.<br> 比如以下就是我常用的别名:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">		<span class="built_in">alias</span> hexog=<span class="string">'hexo generate'</span></span><br><span class="line"><span class="built_in">alias</span> hexod=<span class="string">'hexo deploy'</span></span><br><span class="line"><span class="built_in">alias</span> hexon=<span class="string">'hexo new'</span></span><br><span class="line"><span class="built_in">alias</span> cls=<span class="string">'clear'</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l'</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ls -a'</span></span><br><span class="line"><span class="built_in">alias</span> vi=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> javac=<span class="string">"javac -J-Dfile.encoding=utf8"</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">"grep --color=auto"</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> html=st   <span class="comment"># 在命令行直接输入后缀为 html 的文件名，会在 sublimeText 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> rb=st     <span class="comment"># 在命令行直接输入 ruby 文件，会在 sublimeText 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> py=st       <span class="comment"># 在命令行直接输入 python 文件，会用 sublimeText 中打开，以下类似</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> js=st</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> c=st</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> java=st</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> txt=st</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> gz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> tgz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> zip=<span class="string">'unzip'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> bz2=<span class="string">'tar -xjvf'</span></span><br></pre></td></tr></table></figure>
<p> 主题的话,推荐使用<code>agnoster</code>,颜色比较好看,并且能以标签的形式展示Git的分支等等,就像上面的截图一样.不过这个主题需要安装<code>Menlo-Powerline.otf</code>字体.并且使用<code>d6a36b1</code>提交上的<code>agnoster</code>主题文件,否则是会有乱码的.</p>
</li>
<li><p>使用zsh</p>
<ul>
<li>zsh完全兼容bash,原来怎么使用bash的就可以怎么使用zsh,命令完全一样.</li>
<li>提供了强大的历史记录功能,上下箭头可以翻阅所有你执行过的命令,并且还可以加限制条件,比如先输入一个<code>cd</code>,然后上下箭头显示的就是 你所有执行过的<code>cd</code> 命令.</li>
<li>各种补全功能,它的Tab补全功能不像bash是严格区分大小写的,他可以自动识别大小写,这样就再也不用不停的大小写切换了.路径补全如果遇到相同开头的路径了,多按几次tab键是可以直接选择的,而不像以前只能再不断的输入字母直到路径唯一.命令补全功能也很强大,它可以理解大多数的命令参数.比如你想杀掉java的进程,以前需要先输入<code>ps</code>命令找到<code>java</code>进程的<code>PID</code>.然后执行<code>kill PID</code>来杀掉进程.使用zsh可以直接输入<code>kill java</code>+tab键,他会列出现在所有的java进程,一个回车,zsh会自动的替换为进程的pid.</li>
<li>目录浏览和跳转,在命令行中输入d会列出你再这个会话里面访问过的目录列表,并且前面还有序号.接下来你只需要输入序号,就可以直接跳转到当前目录了.这样就可以直达很多地方,非常的方便.以前需要一步一步的<code>cd</code>.</li>
<li>支持直接输入<code>..</code>或<code>...</code>,或者直接输入当前目录的名字,基本上再也不需要cd命令了.以前经常不小心在<code>cd ..</code>中间没有加上空格.命令不起作用.这个就再也不会出现这种情况了.</li>
<li>智能跳转,在安装了autojump之后,配合zsh,会自动记录你访问过的目录.然后它自动的构建一个遍历树结构.以后你直接通过 j+目录名 就可以直接进行目录的跳转了.大多数情况下还是比较靠谱的.比如你访问过<code>/Application/tomcat/bin</code>.  那么你直接输入<code>j tbin</code>它就能自动的跳转到那去,非常的方便.</li>
<li><code>ctrl+r</code>可以搜索你以前输入过的命令,并重新执行. 比如你以前输入过<code>nano ~/.zshrc</code>.那么现在你只要点击<code>ctrl+r</code>后,输入<code>zsh</code> 就可以直接显示出<code>nano ~/.zshrc</code>,一个回车就重复执行了.</li>
</ul>
</li>
</ol>
<h2 id="总结">总结</h2><p>其实基于Unix的<code>MacOs</code> 真的非常适合我们程序猿的使用(dotNet的除外).它不光提供了方便好用的GUI环境,还提供了强大的类<code>Unix</code>的命令行操作.很多Linux上的操作或命令或经验,基本上可以直接在Macos上使用.对于我们Java开发来说,什么<code>activemq</code> <code>elasticsearch</code> <code>flume</code> <code>hadoop</code> <code>JBOSS</code> <code>kafka</code> <code>mongodb</code> <code>neo4j</code> <code>redis</code> <code>tomcat</code> <code>zookeeper</code>些,基本上都可以直接下载下来然后运行<code>sh</code>就可以了.像<code>redis</code>这些需要编译的,在你安装过<code>xcode</code>的情况下,基本上一个<code>make</code>命令就搞定了.<br>如果没有试过,建议大家可以先装一个黑苹果试一试.我相信用过一段时间后,会喜欢上在Mac上做开发的.<br>MacOS绝不不仅仅是一个装逼的花瓶!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MacOS下JAVA开发使用经验(二)">MacOS下JAVA开发使用经验(二)</h1><p><a href="http://sunxiang0918.cn/2015/09/21/MacOS下JAVA开发使用经验(一">上一篇文章</a>)写了最常用的一些工具,接下来再介绍一下提高开发生产力的工具.</p>
<h2 id="软件">软件</h2><h3 id="BetterZip">BetterZip</h3><p>这个是MAC下很常用的压缩/解压的软件.它对于Windows下的中文支持的比较好.<br>基本上没有遇到在Windows下压缩的中文字符,到Mac下就无法打开的问题了.<br>同时他也支持rar格式. 对于我们JAVA的各种<code>ear</code>,<code>war</code>,<code>jar</code>等 都是可以直接打开,然后编辑的.当双击某个jar中的xml文件后会自动打开关联的文件编辑器,然后保存文本编辑器也会自动的更新jar包.</p>
<p><img src="/img/2015/10/11/1.png" alt=""></p>
<h3 id="Beyond_Compare">Beyond Compare</h3><p>这个是我们搞IT的大杀器.以前只有在Windows上有,当时为了这一个软件,我不得不装上了虚拟机.<br>不得不说,用过这么多文件比较工具,这个始终是神话般的存在.什么<code>DiffMerge</code> <code>FileMerge</code> <code>Araxis Merge</code> <code>Kaleidoscope</code> 都弱爆了.<br>这个工具可以配合你的<code>sourceTree</code>等代码管理工具使用,直接清晰地对比和合并代码.同时也可以和<code>JD</code>反编译工具配合直接对比<code>class</code>文件的差异(这个可以参考我的<a href="http://sunxiang0918.cn/2014/09/20/在MAC下使用beyondcompare比较JAVA-Class文件/">另一篇文章</a>).</p>
<p><img src="/img/2015/10/11/2.png" alt=""></p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="MAC" scheme="http://sunxiang0918.github.io/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis集群部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/10/03/Redis%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/10/03/Redis集群部署/</id>
    <published>2015-10-03T06:24:35.000Z</published>
    <updated>2015-10-13T09:12:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Redis集群部署">Redis集群部署</h1><p>Redis作为目前最常用的内存NOSQL数据库,使用的场景非常的广泛.但是在3.0以前官方一直都是没有集群的方案的.相当于是一个单机内存数据库.为了其高可用,集群的部署是非常有必要的.因此,各种第三方厂商都推出了自己的集群方案.使用的最多的就是<code>豌豆荚</code>开源的<code>Codis</code>,<code>Twitter</code>开源的<code>Twemproxy</code>,<code>Netflix</code>的<code>Dynamo</code>.</p>
<p>目前Redis是<code>3.0.4</code>版本,其中已经自带了<code>Redis Cluster</code>.但是官方的方案有一些架构上的问题.</p>
<ul>
<li>首先,官方方案是完全的去中心化的,依靠自己Server的网络通信来进行同步.那么,在节点比较多的情况下,性能上是有影响的.</li>
<li>其二,一个redis进程既负责读写数据又负责集群交互，虽然设计者已经尽可能简化了代码和逻辑，但还是让redis从一个内存NoSQL变成了一个分布式NoSQL.</li>
<li>其三,官方方案没有采用一致性哈希,而是预分配slot的形式来进行分片.新节点的加入不是自动的,依赖于外部的ruby脚本.</li>
<li>其四,集群版本和单机版本数据不兼容,客户端不兼容.它的集群分发依赖于客户端的驱动. 目前只有JAVA的<code>Jedis Driver</code>支持了<code>Redis Cluster</code>的连接.而<code>spring-data-redis</code>目前也还没有支持官方方案.因此我们不能直接调用.</li>
<li>其五,集群至少要分三片,加上主从备份.也就是说至少需要6个节点才能组建<code>Redis</code>集群.</li>
</ul>
<p>从上面可以看出,目前官方的方案.并不适合我们.它现在还不稳定,开源社区的支持也比较少.<br>从其他三方的方案中进行对比,最后选择<code>Codis</code>作为我们<code>Redis</code>集群部署的方案.</p>
<a id="more"></a>
<h2 id="官方集群方案的部署">官方集群方案的部署</h2><p>虽然目前我们不会使用官方的方案,但是不排除以后会使用.毕竟是官方的东西,应该要靠谱些.</p>
<ol>
<li><p>下载 并编译最新的Redis. 由于Redis是C写的.并且网上只有源码.因此,最好是直接下载源码到<code>类unix</code>机器上,然后调用 <code>sudo make</code> 命令自动的编译出可运行的版本.</p>
</li>
<li><p>最少集群6个节点,因此在我的磁盘上建立一个<code>redis-test</code>文件夹.然后建立6个子文件夹,作为6个节点.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis-test</span><br><span class="line"><span class="built_in">cd</span> redis-test</span><br><span class="line">mkdir <span class="number">7000</span> <span class="number">7001</span> <span class="number">7002</span> <span class="number">7003</span> <span class="number">7004</span> <span class="number">7005</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后拷贝6分编译好的redis到各个目录中去.</p>
</li>
<li><p>修改redis.conf文件.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port <span class="number">7005</span> </span><br><span class="line">pidfile /Volumes/EXCHANGE/redis-test/<span class="number">7000</span>/redis.pid </span><br><span class="line">cluster-enabled yes  </span><br><span class="line"><span class="comment"># 和端口对应  </span></span><br><span class="line">cluster-config-file nodes.conf  </span><br><span class="line">cluster-node-timeout <span class="number">5000</span>  </span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改好后,进入每一个的src文件夹,执行<code>./redis-server ../redis.conf</code> 启动6个服务.</p>
</li>
<li><p>随便找一个节点的src目录,找到<code>redis-trib.rb</code>文件.然后执行:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas <span class="number">1</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span></span><br></pre></td></tr></table></figure>
<p> 其中的<code>--replicas 1</code>指的是从服务的数量.</p>
<p> 执行了这句后,会显示出集群的分布情况.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span>: OK</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on <span class="number">6</span> nodes...</span><br><span class="line">Using <span class="number">3</span> masters:</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span></span><br><span class="line">Adding replica <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span> to <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span></span><br><span class="line">Adding replica <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span> to <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span></span><br><span class="line">Adding replica <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span> to <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span></span><br><span class="line">M: d450eaf8b29ccc57c5ab851868a0e23b41d0f50c <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span></span><br><span class="line">   slots:<span class="number">0</span>-<span class="number">5460</span> (<span class="number">5461</span> slots) master</span><br><span class="line">M: b4f505a8bfbc58dcd65c0a106f284ae1fe3efe1b <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span></span><br><span class="line">   slots:<span class="number">5461</span>-<span class="number">10922</span> (<span class="number">5462</span> slots) master</span><br><span class="line">M: e81eea0243d2976daca5b349ec0bc2d109ac81d0 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span></span><br><span class="line">   slots:<span class="number">10923</span>-<span class="number">16383</span> (<span class="number">5461</span> slots) master</span><br><span class="line">S: <span class="number">52</span>a634c534ca5db005dbc31494676e08454ebfa4 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span></span><br><span class="line">   replicates d450eaf8b29ccc57c5ab851868a0e23b41d0f50c</span><br><span class="line">S: <span class="number">270</span>c10d1f3b85438b74b8fd5c9d91a3e0ce8a0da <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span></span><br><span class="line">   replicates b4f505a8bfbc58dcd65c0a106f284ae1fe3efe1b</span><br><span class="line">S: e6eae15e4883<span class="built_in">cd</span>408fe889e85565a38f6e030de7 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span></span><br><span class="line">   replicates e81eea0243d2976daca5b349ec0bc2d109ac81d0</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span>)</span><br><span class="line">M: d450eaf8b29ccc57c5ab851868a0e23b41d0f50c <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span></span><br><span class="line">   slots:<span class="number">0</span>-<span class="number">5460</span> (<span class="number">5461</span> slots) master</span><br><span class="line">M: b4f505a8bfbc58dcd65c0a106f284ae1fe3efe1b <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span></span><br><span class="line">   slots:<span class="number">5461</span>-<span class="number">10922</span> (<span class="number">5462</span> slots) master</span><br><span class="line">M: e81eea0243d2976daca5b349ec0bc2d109ac81d0 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span></span><br><span class="line">   slots:<span class="number">10923</span>-<span class="number">16383</span> (<span class="number">5461</span> slots) master</span><br><span class="line">M: <span class="number">52</span>a634c534ca5db005dbc31494676e08454ebfa4 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span></span><br><span class="line">   slots: (<span class="number">0</span> slots) master</span><br><span class="line">   replicates d450eaf8b29ccc57c5ab851868a0e23b41d0f50c</span><br><span class="line">M: <span class="number">270</span>c10d1f3b85438b74b8fd5c9d91a3e0ce8a0da <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span></span><br><span class="line">   slots: (<span class="number">0</span> slots) master</span><br><span class="line">   replicates b4f505a8bfbc58dcd65c0a106f284ae1fe3efe1b</span><br><span class="line">M: e6eae15e4883<span class="built_in">cd</span>408fe889e85565a38f6e030de7 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span></span><br><span class="line">   slots: (<span class="number">0</span> slots) master</span><br><span class="line">   replicates e81eea0243d2976daca5b349ec0bc2d109ac81d0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All <span class="number">16384</span> slots covered.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当出现:<code>Can I set the above configuration? (type &#39;yes&#39; to accept):</code>的时候,输入<code>yes</code>.然后他就会自动的通知各个节点,自发组成集群.</p>
<p>到此,redis集群的官方方案就部署好了.<br>如果安装过程中出现:<code>/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_require.rb:55:in require&#39;: cannot load such file -- redis (LoadError)</code>.那是ruby缺少<code>redis</code>的依赖.<br>在控制台输入<code>gem install redis</code>即可.</p>
<h2 id="codis集群方案的部署">codis集群方案的部署</h2><p>Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有明显的区别.上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务.</p>
<p>Codis 由四部分组成:</p>
<ul>
<li>Codis Proxy (codis-proxy)</li>
<li>Codis Manager (codis-config)</li>
<li>Codis Redis (codis-server)</li>
<li>ZooKeeper</li>
</ul>
<p>codis-proxy 是客户端连接的 Redis 代理服务, codis-proxy 本身实现了 Redis 协议, 表现得和一个原生的 Redis 没什么区别 (就像 Twemproxy), 对于一个业务来说, 可以部署多个 codis-proxy, codis-proxy 本身是无状态的.</p>
<p>codis-config 是 Codis 的管理工具, 支持包括, 添加/删除 Redis 节点, 添加/删除 Proxy 节点, 发起数据迁移等操作. codis-config 本身还自带了一个 http server, 会启动一个 dashboard, 用户可以直接在浏览器上观察 Codis 集群的运行状态.</p>
<p>codis-server 是 Codis 项目维护的一个 Redis 分支, 基于 2.8.21 开发, 加入了 slot 的支持和原子的数据迁移指令. Codis 上层的 codis-proxy 和 codis-config 只能和这个版本的 Redis 交互才能正常运行.</p>
<p>Codis 依赖 ZooKeeper 来存放数据路由表和 codis-proxy 节点的元信息, codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy.</p>
<p>需要注意的是,codis的proxy是无状态的,当一个分片的master挂掉的时候,codis不会自动的将某个slave升级成master.不过他提供了一个解决方案:<a href="https://github.com/ngaut/codis-ha" target="_blank" rel="external">codis-ha</a>.这是一个通过codis开放的api实现自动切换主从的工具。该工具会在检测到master挂掉的时候将其下线并选择其中一个slave提升为master继续提供服务。但是只是在每一个分片是一主一从两台的情况下才有效.否则,该分片内其他slave实例是不会自动改变状态的，这些slave仍将试图从旧的master上同步数据，因而会导致分片内新的master和其他slave之间的数据不一致。因为redis的slave of命令切换master时会丢弃slave上的全部数据，从新master完整同步，会消耗master资源。因此建议在知情的情况下手动操作。使用 <code>codis-config server add &lt;group_id&gt; &lt;redis_addr&gt; slave</code> 命令刷新这些节点的状态即可。codis-ha不会自动刷新其他slave的状态。</p>
<hr>
<ol>
<li><p>由于codis是由GO语言写的,因此,要运行codis首先需要的就是安装<code>go</code>语言环境.</p>
<p> 在类<code>unix</code>机器上都有现成的安装包可以安装.<br> 比如<code>Macos</code> 在终端中输入<code>brew install go</code> 即可. (安装过程中需要访问<code>https://go.googlesource.com/tools.git</code>,方法你懂的)</p>
</li>
<li><p>设置GO的workspace路径.在<code>~/.bash_profiler</code>下增加<code>export GOPATH=&quot;/Volumes/WORKSPACE/openSourceWorkspace/GoWorkspace&quot;</code> 注意$GOPATH是本机所有go项目（包括项目依赖的第三方库）的所在目录，而非单纯codis的所在目录。</p>
</li>
<li>执行下面的命令下载codis源码并编译.它会自动的下载源码以及依赖包.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go get -u <span class="operator">-d</span> github.com/wandoulabs/codis</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/wandoulabs/codis</span><br><span class="line">./bootstrap.sh</span><br><span class="line">make gotest</span><br></pre></td></tr></table></figure>
<ol>
<li><p>执行完命令后,会在codis/bin下生成三个文件<code>codis-config</code> <code>codis-proxy</code> <code>codis-server</code>. <code>assets</code>文件夹里面存放的是<code>dashboard</code>服务所需要的静态文件.</p>
</li>
<li><p>默认情况下 这些命令都会读取<code>config.ini</code>里面的配置.配置很简单,按照里面的注释改就可以了.</p>
</li>
<li>启动ZK.</li>
<li>启动<code>dashboard</code>,执行 <code>./bin/codis-config dashboard</code>,就会启动dashboard</li>
<li>初始化 slots , 执行 <code>./bin/codis-config slot init</code>，该命令会在zookeeper上创建slot相关信息.</li>
<li>开始启动<code>Codis Redis</code>.执行<code>./bin/codis-server</code>,就启动的.这个就和官网的一样. 配置文件也可以跟在后面.比如:<code>./bin/codis-server redis.config</code></li>
<li><p>添加 <strong>Redis Server Group</strong> , 每一个 <strong>Server Group</strong> 作为一个 Redis 服务器组存在, 只允许有一个 <strong>master</strong>, 可以有<strong>多个 slave</strong>, <strong>group id</strong> 仅<strong>支持大于等于1的整数</strong>.这个步骤可以通过<code>dashboard</code>来增加,也可以使用命令行.比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/codis-config server add <span class="number">1</span> localhost:<span class="number">6379</span> master</span><br><span class="line">bin/codis-config server add <span class="number">1</span> localhost:<span class="number">6380</span> slave</span><br><span class="line">bin/codis-config server add <span class="number">2</span> localhost:<span class="number">6479</span> master</span><br><span class="line">bin/codis-config server add <span class="number">2</span> localhost:<span class="number">6480</span> slave</span><br></pre></td></tr></table></figure>
<p>这样就增加了4个节点,并且分成两片,每片一主一从.</p>
</li>
<li><p>设置 server group 服务的 slot 范围 Codis 采用 Pre-sharding 的技术来实现数据的分片, 默认分成 1024 个 slots (0-1023), 对于每个key来说, 通过以下公式确定所属的 Slot Id : SlotId = crc32(key) % 1024 每一个 slot 都会有一个且必须有一个特定的 server group id 来表示这个 slot 的数据由哪个 server group 来提供.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bin/codis-config slot range-set <span class="number">0</span> <span class="number">511</span> <span class="number">1</span> online</span><br><span class="line">$ bin/codis-config slot range-set <span class="number">512</span> <span class="number">1023</span> <span class="number">2</span> online</span><br></pre></td></tr></table></figure>
<p>同样,可以在界面上进行操作</p>
</li>
<li><p>启动 codis-proxy (注意,如果zk的session时间设置太短的话,proxy可能启动不起来.)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/codis-proxy -c config.ini -L ./<span class="built_in">log</span>/proxy.log  --cpu=<span class="number">8</span> --addr=<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">19000</span> --http-addr=<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">11000</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>到此就集群完毕.
</code></pre><ol>
<li><p>但是为了能在master当机的时候自动的升级slave,这就需要<a href="https://github.com/ngaut/codis-ha" target="_blank" rel="external">codis-ha</a>了.这个同样是<code>go</code>语言写的.所以直接在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/ngaut/codis-ha</span><br><span class="line"><span class="built_in">cd</span> codis-ha</span><br><span class="line">go build</span><br><span class="line">codis-ha --codis-config=localhost:<span class="number">18087</span> --productName=<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>就搞定了,他会自动的监控dashboard,然后发现节点不正确后,调用restful的接口,提升slave为master</p>
</li>
</ol>
<hr>
<p>接下来就是客户端的调用了.<br>由于codis依赖了zk作为服务的发现方.因此,整个集群的节点状态都是在zk中有的.</p>
<p>它自身也提供了一个JAVA的实现,叫<a href="https://github.com/wandoulabs/codis/tree/master/extern/jodis" target="_blank" rel="external">jodis</a>.通过这个,就可以关联<code>jedis Driver</code>.并且获取当前可用的<code>codis-server</code>.<br>不过目前这个jodis还没有提供与spring的集成.这个需要我们自己来开发.    </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Redis集群部署">Redis集群部署</h1><p>Redis作为目前最常用的内存NOSQL数据库,使用的场景非常的广泛.但是在3.0以前官方一直都是没有集群的方案的.相当于是一个单机内存数据库.为了其高可用,集群的部署是非常有必要的.因此,各种第三方厂商都推出了自己的集群方案.使用的最多的就是<code>豌豆荚</code>开源的<code>Codis</code>,<code>Twitter</code>开源的<code>Twemproxy</code>,<code>Netflix</code>的<code>Dynamo</code>.</p>
<p>目前Redis是<code>3.0.4</code>版本,其中已经自带了<code>Redis Cluster</code>.但是官方的方案有一些架构上的问题.</p>
<ul>
<li>首先,官方方案是完全的去中心化的,依靠自己Server的网络通信来进行同步.那么,在节点比较多的情况下,性能上是有影响的.</li>
<li>其二,一个redis进程既负责读写数据又负责集群交互，虽然设计者已经尽可能简化了代码和逻辑，但还是让redis从一个内存NoSQL变成了一个分布式NoSQL.</li>
<li>其三,官方方案没有采用一致性哈希,而是预分配slot的形式来进行分片.新节点的加入不是自动的,依赖于外部的ruby脚本.</li>
<li>其四,集群版本和单机版本数据不兼容,客户端不兼容.它的集群分发依赖于客户端的驱动. 目前只有JAVA的<code>Jedis Driver</code>支持了<code>Redis Cluster</code>的连接.而<code>spring-data-redis</code>目前也还没有支持官方方案.因此我们不能直接调用.</li>
<li>其五,集群至少要分三片,加上主从备份.也就是说至少需要6个节点才能组建<code>Redis</code>集群.</li>
</ul>
<p>从上面可以看出,目前官方的方案.并不适合我们.它现在还不稳定,开源社区的支持也比较少.<br>从其他三方的方案中进行对比,最后选择<code>Codis</code>作为我们<code>Redis</code>集群部署的方案.</p>]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://sunxiang0918.github.io/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka集群部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/09/28/Kafka%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/09/28/Kafka集群部署/</id>
    <published>2015-09-28T14:12:16.000Z</published>
    <updated>2015-12-28T01:16:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Kafka集群">Kafka集群</h1><p>Kafka作为新一代的消息系统,最初是由LinkedIn公司开发,之后开源成为Apache的顶级项目.<br>它与传统的消息系统相比,有以下不同:</p>
<ul>
<li>它被设计为一个分布式系统，易于向外扩展；</li>
<li>它同时为发布和订阅提供高吞吐量；</li>
<li>它支持多订阅者，当失败时能自动平衡消费者；</li>
<li>它将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。</li>
</ul>
<p>同时.Kafka提供了多种客户端的Driver.这点比阿里的<code>RocketMQ</code>要好.而阿里的RocketMQ在性能和使用方面优于Kafka,不过只提供JAVA的客户端.</p>
<p>而我们系统中不光只有JAVA应用,因此,在我们的系统中,决定使用kafka作为我们的消息服务.</p>
<a id="more"></a>
<h2 id="集群部署">集群部署</h2><ol>
<li>启动Zookeeper服务<br>　　集群部署也是需要启用Zookeeper。
　　</li>
<li><p>启动Kafka broker服务<br> 在不同的机器上拷贝kafka.然后修改它的<code>$KAFKA_HOME/config/server.properties</code>文件.<br> 主要是修改以下几个地方:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务的序号,这个需要在集群中保证唯一</span></span><br><span class="line">brokerid = <span class="number">0</span></span><br><span class="line"><span class="comment">#服务的端口,如果是一台机器上只启动一个kafka,可以不修改</span></span><br><span class="line">port = <span class="number">1234</span></span><br><span class="line"><span class="comment">#服务的数据存放位置,默认可以不修改</span></span><br><span class="line">log.dir = /tmp/kafka_<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>然后调用 <span class="escape">`.</span>/bin/kafka-server-start.sh conf/server.properties<span class="escape">` </span>即可启动
</code></pre><ol>
<li><p>然后就可以创建<code>Topic</code>了. </p>
<p> <code>bin/kafka-topics.sh --create --zookeeper 127.0.0.1:2181 --replication-factor 2 --partitions 2 --topic testTopic</code></p>
<p> 其中<code>replication-factor</code>表示要在几个节点上存放数据.一般有几个节点就配置成几个就可以了.<br> <code>partitions</code>就表示分片.一般配置成1就可以了.</p>
</li>
<li><p>到此,kafka的集群就搭建完成了.然后就可以使用我们的代码来进行试验了.</p>
<p> Spring配置:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">	<span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"jmsTemplate"</span> <span class="attribute">class</span>=<span class="value">"com.sobey.jcg.kafka.util.KafkaTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"127.0.0.1:8092,127.0.0.1:8093"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"defaultThreadPool"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 核心线程数，默认为1 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"corePoolSize"</span> <span class="attribute">value</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大线程数，默认为Integer.MAX_VALUE --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxPoolSize"</span> <span class="attribute">value</span>=<span class="value">"900"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 队列最大长度，一般需要设置值&gt;=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"queueCapacity"</span> <span class="attribute">value</span>=<span class="value">"50"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 线程池维护线程所允许的空闲时间，默认为60s --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"keepAliveSeconds"</span> <span class="attribute">value</span>=<span class="value">"60"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者     --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"rejectedExecutionHandler"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"customConsumerMessageListener"</span> <span class="attribute">class</span>=<span class="value">"com.xxx.jcg.kafka.util.KafkaMessageListenerAdapter"</span> <span class="attribute">scope</span>=<span class="value">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.xxx.jcg.kafka.test.CustomConsumer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--ZK的链接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"zookeeperConnect"</span> <span class="attribute">class</span>=<span class="value">"com.sobey.jcg.kafka.util.ZookeeperConnect"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"zkConnect"</span> <span class="attribute">value</span>=<span class="value">"127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"zkConnectionTimeout"</span> <span class="attribute">value</span>=<span class="value">"6000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"zkSessionTimeout"</span> <span class="attribute">value</span>=<span class="value">"400"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"zkSyncTime"</span> <span class="attribute">value</span>=<span class="value">"200"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.sobey.jcg.kafka.util.KafkaMessageListenerContainer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"zookeeperConnect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"defaultThreadPool"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"listener"</span> <span class="attribute">ref</span>=<span class="value">"customConsumerMessageListener"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"topic"</span> <span class="attribute">value</span>=<span class="value">"kafkatopic"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.sobey.jcg.kafka.util.KafkaMessageListenerContainer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"zookeeperConnect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"defaultThreadPool"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"listener"</span> <span class="attribute">ref</span>=<span class="value">"customConsumerMessageListener"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"topic"</span> <span class="attribute">value</span>=<span class="value">"clusterTest"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br><span class="line">	```	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	测试代码:</span><br><span class="line">	</span><br><span class="line">	```java</span><br><span class="line">	public class JMSSenderTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        CustomSpringContextUtil.getContext("applicationContext.xml").getBean("jmsTemplate");</span><br><span class="line"></span><br><span class="line">        UserInfo userInfo = new UserInfo("aaa",17,true);</span><br><span class="line">        </span><br><span class="line">        JMSSender.getInstance().sendMessage(userInfo,"clusterTest");</span><br><span class="line"></span><br><span class="line">        JMSSender.getInstance().sendMessage("这个是String","clusterTest");</span><br><span class="line"></span><br><span class="line">        HashMap<span class="tag">&lt;<span class="title">Object,Object</span>&gt;</span> objectObjectMap = new HashMap<span class="tag">&lt;<span class="title">Object,</span> <span class="attribute">Object</span>&gt;</span>();</span><br><span class="line">        objectObjectMap.put("name","bbbb");</span><br><span class="line">        objectObjectMap.put("age",20);</span><br><span class="line">        objectObjectMap.put("gender",true);</span><br><span class="line">        JMSSender.getInstance().sendMessage(objectObjectMap,"clusterTest");</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>如果正常的话,就会发送消息到kafka中. 并且程序能有消费的记录.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Kafka集群">Kafka集群</h1><p>Kafka作为新一代的消息系统,最初是由LinkedIn公司开发,之后开源成为Apache的顶级项目.<br>它与传统的消息系统相比,有以下不同:</p>
<ul>
<li>它被设计为一个分布式系统，易于向外扩展；</li>
<li>它同时为发布和订阅提供高吞吐量；</li>
<li>它支持多订阅者，当失败时能自动平衡消费者；</li>
<li>它将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。</li>
</ul>
<p>同时.Kafka提供了多种客户端的Driver.这点比阿里的<code>RocketMQ</code>要好.而阿里的RocketMQ在性能和使用方面优于Kafka,不过只提供JAVA的客户端.</p>
<p>而我们系统中不光只有JAVA应用,因此,在我们的系统中,决定使用kafka作为我们的消息服务.</p>]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://sunxiang0918.github.io/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOS下JAVA开发使用经验(一)]]></title>
    <link href="http://sunxiang0918.github.io/2015/09/21/MacOS%E4%B8%8BJAVA%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C(%E4%B8%80)/"/>
    <id>http://sunxiang0918.github.io/2015/09/21/MacOS下JAVA开发使用经验(一)/</id>
    <published>2015-09-21T13:38:36.000Z</published>
    <updated>2015-10-11T15:46:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MacOS下JAVA开发使用经验(一)">MacOS下JAVA开发使用经验(一)</h1><p>我是大概在2007年左右接触到MACOS的.当时先是折腾了半年的<code>Ubuntu</code>,然后在一个偶然的机会发现了<code>MacOS 10.4.6</code>,看到界面截图,简直是惊为天人.刚好那个时候苹果开始使用Intel的CPU.让我们有机会品尝了一下黑苹果的滋味.虽然在我的<code>HP DV2621</code>笔记本上装黑苹果又卡又热,但是还是让我深深的喜欢上了这个系统.到2009年,实在是憋不住了,买了我人生中的第一台macbook <code>mb990</code>.然后毕业后到公司上班也申请一直使用苹果系统.反正我是搞JAVA的,到是和操作系统关系不大,反而我到是觉得搞JAVA开发,Mac比Win还好用些,这么多年来也是越用越顺手.这里分享下我平时使用的一些经验或软件吧~</p>
<h2 id="硬件">硬件</h2><p>这部分没啥好说的,苹果的电脑就这么几个型号.不过对于我们上班的来说,还是推荐使用rMBP+24寸以上的显示器的组合. 苹果的视网膜屏确实相当牛逼,看代码完全是种享受.<br>配置的话,只要不是macmini和air以及现在新出的macbook的话,应该都还OK.我个人是使用的<code>2014年rMBP 15寸低配</code>那款.编译和运行的速度秒杀大多数的机器.<br>而对于键盘和鼠标的话,没有什么特殊的要求.机械键盘我还没用过,不好评价的.鼠标的话,我用的是苹果的<code>Magic Mouse</code>,有人说那鼠标完全是反人类的,其实我觉得还好,现在平均每天要用10个小时以上,也没觉得特别的不适.使用这个鼠标最大的好处肯定就是它的多点触控了.几个工具全屏再加上几个多桌面,使用那个鼠标很容易的就可以做切换.</p>
<a id="more"></a>
<h2 id="系统">系统</h2><p>系统的话就不断的保持最新的正式版即可.升级一般来说都可以放心,我从以前的<code>10.5</code>升级到<code>10.10</code>都没遇到过什么问题.<br>然后就是一些系统的设置了.</p>
<h3 id="Docker自动放大">Docker自动放大</h3><p>由于使用的程序比较多,所以Docker上有一堆的图标,自然每一个图标就比较小,因此需要把自动放大的功能给打开.而且也不能放到屏幕的左右两边,否则就会小的没法看…<br><img src="/img/2015/09/21/1.png" alt=""></p>
<h3 id="屏幕四个角触发操作">屏幕四个角触发操作</h3><p>这个是MacOS的一个比较实用的功能,就是把鼠标移动到屏幕的四个角上就可以触发一些特定的操作.比如显示桌面啊,launchpad啊等等.<br>我一般都是把左下角设置为<code>显示桌面</code>,左上角设置为<code>MissionControl</code>,右上角设置为<code>Launchpad</code><br><img src="/img/2015/09/21/2.png" alt=""></p>
<h3 id="将F1_F2等作为标准按钮">将F1 F2等作为标准按钮</h3><p>不知道是出于什么原因,MacOS系统刚装上的时候,键盘最上面的一排F1,F2的按钮是音量键这些.这完全就没法用嘛.所以必须设置成为标准的F1 F2功能. 这个只需要在<code>设置-键盘</code> 里面设置即可.<br><img src="/img/2015/09/21/3.png" alt=""></p>
<h3 id="设置浏览器的刷新快捷键">设置浏览器的刷新快捷键</h3><p>在默认的情况下,Safari和Chrome都没有提供<code>F5</code>刷新页面的功能.这让我们在浏览网页或修改页面的时候很难受,因此需要增加上这些快捷键. 这在<code>设置-键盘-快捷键</code>中设置.<br><img src="/img/2015/09/21/4.png" alt=""></p>
<h3 id="鼠标和触控板的轻触和滚动方向">鼠标和触控板的轻触和滚动方向</h3><p>自从Macos10.8以后,苹果把鼠标和触控板的滑动方向给反向了,也就是鼠标向下滑动,页面是往上走的.这和<code>Ipad</code>这些操作是一样的,但是我总觉得在电脑上有点奇怪.所以需要修改下. 同时还有就是鼠标和触控板的多点控制,比如两个指头是切换屏幕啊,轻触是右键啊等等 都是在 <code>设置-鼠标</code>和<code>设置-触控板</code>里面设置.<br><img src="/img/2015/09/21/5.png" alt=""></p>
<p><img src="/img/2015/09/21/6.png" alt=""></p>
<h3 id="增加状态栏直接锁定屏幕">增加状态栏直接锁定屏幕</h3><p>在公司上班,谁都有离开位置的时候,为了防止电脑可能被其他人随便操作,一定的安全措施还是需要的.最简单的方法就是直接把电脑屏幕给合上,那么再次打开的时候就要求输入密码.但是这样电脑就会休眠,而且如果外接了显示器的,有可能本来笔记本就是合上的(在mbp接上电源,外接键盘和鼠标的情况下.如果合并笔记本屏幕,那么就会单输出图像到外接显示器,这个时候系统是不会休眠的).那么还有一个方法就是使用<code>钥匙串</code>的功能,一键锁定计算机,并且关闭屏幕显示. 这个就是在<code>应用程序-实用工具-钥匙串访问</code>中.<br><img src="/img/2015/09/21/7.png" alt=""></p>
<p><img src="/img/2015/09/21/8.png" alt=""></p>
<h2 id="软件">软件</h2><p>软件即是工具,所谓工欲善其事，必先利其器.好的工具能让你的工作更得心应手.这里就推荐一下我平时所使用的一些工具.</p>
<p>先来看一下我的Docker,我最常用的软件基本上就在这了.<br><img src="/img/2015/09/21/9.png" alt=""></p>
<h3 id="XtraFinder">XtraFinder</h3><p>这个是Finder的增强工具.免费的,提供了很多有用的工具,基本上属于必装.</p>
<ul>
<li>提供了类似于Chrome一样的多标签操作</li>
<li>双击某一个标签,提供了两个标签的联合操作.</li>
<li>支持<code>Command+x</code>的剪切操作</li>
<li>增加了右键<code>新建文件</code>的功能</li>
<li>增加了在当前文件夹直接打开终端的功能</li>
<li>增加了快捷键显示和隐藏系统<code>隐藏文件</code>的功能.</li>
<li>提供了文件夹和文件分开排序的功能<br><img src="/img/2015/09/21/10.png" alt=""></li>
</ul>
<h3 id="1Password">1Password</h3><p>这个又是一个神器,他可以帮你保存所有的密码.这样你只需要记住一个密码就可以了,其他的密码都交由它来保存.它同时有safari和chrome的插件,以及IOS端的程序.通过加密了的文件使用iCloud进行同步,没有中心的服务器.自从CSDN被拖库而被泄露了一堆密码以后,我就开始使用这个软件,把我所有的账号都通过它设置成14位的不同的随机密码,这样减少了一个密码泄露,全部玩完的情况.要说这个软件的缺点,那就是卖的有点贵,300多一个好像.不过我觉得还是值了.(网上到是有这个的破解软件,但是如果真想使用这个软件,我建议还是买正版吧.一个用来保存密码的软件使用破解的,我怕里面的密码也一起被”破解”了..)<br><img src="/img/2015/09/21/11.png" alt=""></p>
<p><img src="/img/2015/09/21/12.png" alt=""></p>
<h3 id="Doit-im">Doit.im</h3><p>这个是国内的一个厂商推出的GTD软件.可以和IOS以及Web页面同步.我试用了很多的GTD软件,最后对比下来觉得这个软件做的比较好.提供了很完善的功能,比如<code>收集箱</code> <code>下一步行动</code> <code>明日代办</code> <code>日程</code> <code>项目</code> <code>情景</code> <code>标签</code> <code>子任务</code> <code>优先级</code> 等等.能让我很轻松的管理各种任务,有什么想法了就马上记录到收集箱中.然后再进行进一步的细分,这样就可以始终保持工作有条不紊的进行. BTW,这个软件是收取服务费的,一年100块.</p>
<p><img src="/img/2015/09/21/13.png" alt=""></p>
<h3 id="Teambition">Teambition</h3><p>这个是团队协作的工具,它提供的Mac客户端,其实就是一个Webkit的网页.这点做的就没有Doit.im好,太偷懒了.具体的用法可以参考我另外的一篇博文 <a href="http://sunxiang0918.cn/2015/09/07/使用TeamBition进行敏捷开发/" target="_blank" rel="external">使用TeamBition进行敏捷开发</a></p>
<h3 id="邮件">邮件</h3><p>这个是Macos自带的程序,前段时间还使用过腾讯的FoxMail,也还可以.两个的功能都差不多,随便选择一个就可以了.我是不想再安装一个软件,所以选择了自带的Mail程序.<br>需要注意的是,最好在Mail程序中设置一个你的签名.并且在签名中增加一个Unicode的字符.这样在发送邮件的时候,Mail会把你的邮件使用UTF-8的格式来传送,这样Win端的一些工具收到后就不会有乱码的问题.<br><img src="/img/2015/09/21/14.png" alt=""></p>
<h3 id="Reeder">Reeder</h3><p>这个是目前最好用的RSS阅读软件了.他可以订阅各种的来源,自从google的死了后,现在我使用的是Feedly提供的服务.还算稳定可靠.同样提供了IOS端的程序,两个间可以进行同步.虽然现在都在说RSS已经过时了,但是我觉得RSS还能活跃很久,毕竟这种订阅的信息收集其实是很高效和有用的.<br><img src="/img/2015/09/21/15.png" alt=""></p>
<h3 id="Safari">Safari</h3><p>没啥好说的,系统自带的游览器.速度快,稳定.配合iCloud和handoff功能,在IOS设备和笔记本间无缝的切换,体验相当的舒服.然后我把搜索引擎设置成为了百度.这意味着平时的生活和娱乐就使用的safari.</p>
<h3 id="Chrome">Chrome</h3><p>对比Safari,我更倾向于把Chrome当成一个工作相关的工具.首先就是把搜索引擎设置为google,然后安装上<code>PostMan</code>,<code>JSON-handle</code>,<code>OneTab</code>,<code>红杏</code>等扩展插件,然后再配合自带的<code>审查元素</code>功能.基本上我遇得到的一些界面分析,Rest调用,JSON格式化等等都能应付了.</p>
<h3 id="QQ和微信">QQ和微信</h3><p>这个没啥说的,国内基本上是必装的软件了.</p>
<h3 id="EverNote">EverNote</h3><p>我是把EverNote当做知识库来使用,配合它的标签和强大的搜索功能.基本上能很快的找到我以前记录的东西.这东西也是有IOS端的.平时看知乎或网页等等,看到感兴趣需要记录的了,可以直接发送到everNote中去. 而且我觉得这货在MAC上比在Win上用的顺手.不管是界面还是操作,而且没得广告.<br><img src="/img/2015/09/21/16.png" alt=""></p>
<h3 id="iTunes和网易音乐">iTunes和网易音乐</h3><p>一个是用来听本地音乐的,一个是用来听在线音乐的.现在是没有音乐作为背景,就写不出来代码… T.Tb</p>
<h3 id="IntelliJ_IDEA">IntelliJ IDEA</h3><p>Intellij是我认为最智能的JAVA IDE,推荐所有的Javaer们都尝试尝试.可以最开始从eclipse转过来的时候比较痛苦,但是一旦上手后,就会觉得以前像在使用记事本写代码一样.. IDEA提供了很强大的上下文推导以及Spring等框架的上下文管理,强大的Maven支持,再加上完备的插件支持,自己再多设置几个<code>Live Template</code> 写起代码来那叫一个顺手啊.<br>插件除了自带的,我还安装了<code>Docker Integration</code> <code>FindBugs</code> <code>JProfiler</code> <code>Mybatis plugin</code> <code>RegexpTester</code> <code>Scala</code> <code>ZooKeeper</code>.<br>总之,保证你不后悔使用<code>IntelliJ IDEA</code><br><img src="/img/2015/09/21/17.png" alt=""></p>
<h3 id="XCode">XCode</h3><p>要玩儿IOS编程,当然还是要使用官方的XCode了.当然,说实话,我觉得没有<code>IDEA</code>出的<code>AppCode</code>用起顺手,功能也没有别人的多.不过胜在官方支持,对各个功能,特别是storyboard支持的最好.XCode同样也可以安装插件,首先必装的就是<code>Alcatraz</code>-用来管理插件的插件.可以通过在终端中执行下面的代码来安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh</span><br></pre></td></tr></table></figure>
<p>而后就直接在<code>Windows-Package Manager</code>里面选择需要的插件即可.我使用了这些插件:<br><code>ClangFormat</code> <code>FuzzyAutocomplete</code> <code>HighlightSelectedString</code> <code>LinkedLog</code> <code>OMColorSense</code> <code>OMQuickHelp</code> <code>SFJumpToLine</code> <code>VVDocumenter-Xcode</code> <code>XToDo</code></p>
<p><img src="/img/2015/09/21/18.png" alt=""></p>
<h3 id="Cornerstone">Cornerstone</h3><p>可以说是MacOS下最好用的SVN工具了.他集中式的管理了SVN项目.界面的布局和操作也非常的合理.支持几乎所有的SVN功能.这个工具基本上陪伴了我5年.最多的时候管理了一百多个项目而性能不减.可以说是完爆Win上的同类软件.不过这个软件是付费的,大概60美刀左右.<br><img src="/img/2015/09/21/19.png" alt=""></p>
<h3 id="SourceTree">SourceTree</h3><p>这个软件又是一个神器,用来管理Git的.同Cornerstone一样,也是一个集中式的管理工具.界面布局和操作非常的方便.支持创建,克隆,提交,push,pull,分支,合并等等Git的功能.大大的简化了开发者与代码库之间的操作.同时在Mac的体验也比Win上的相同软件要好的多.最重要的是它是一个免费的软件,堪称业界良心啊.<br><img src="/img/2015/09/21/20.png" alt=""></p>
<h3 id="Pages_Numbers_Keynote">Pages Numbers Keynote</h3><p>苹果办公软件三剑客.我平时写东西都是使用这个软件的.觉得简洁,写出来的效果也很好.特别是Keynote,做出来的演讲稿效果相当的舒服.如果要发给别个交互,发布成为PDF就可以了.</p>
<h3 id="Word_Excel_PowerPoint">Word Excel PowerPoint</h3><p>毕竟公司里面不全都是用的Macos系统,别人写的DOC文件,你还是要打开看的,或者老总发给你的Excel教你填,你也不好意思发个PDF给人家..所以这个软件还是需要保留的.</p>
<h3 id="Fraise_SublimeText">Fraise SublimeText</h3><p>这两个都是文本编辑器,第一个支持最完整的编码格式,以及能很方便的转换各种文本的编码格式,基本上被我用来转换文档格式用了.<br>而SublimeText可以说是一个最强大的文本编辑器.平时看日志,临时改些代码,格式化XML,记录会议纪要等等都是靠它了.<br><img src="/img/2015/09/21/21.png" alt=""></p>
<h3 id="MacDown">MacDown</h3><p>用来书写MarkDown格式的文本的.这个软件是我试用了一堆MAC上的MarkDown软件后选出来的.支持的MarkDown语法算是很完整的了,非在线的编辑器,允许自定义样式和代码高亮的格式,支持各种快捷键操作.总之,非常的好用.我现在基本上所有的文本都是使用MarkDown来记录了.<br><img src="/img/2015/09/21/22.png" alt=""></p>
<h3 id="Parallels_Desktop">Parallels Desktop</h3><p>MacOS上的虚拟机软件,我对比过VMware.觉得这个软件无论是在速度还是系统占用上都有优势.<br>现在虚拟机其实很少使用了,主要就是打开一些非要用IE打开的奇葩网页.然后就是虚拟机上安装一些Linux系统或Oracle数据库来瞎折腾.这样不会影响到实体机.<br><img src="/img/2015/09/21/23.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MacOS下JAVA开发使用经验(一)">MacOS下JAVA开发使用经验(一)</h1><p>我是大概在2007年左右接触到MACOS的.当时先是折腾了半年的<code>Ubuntu</code>,然后在一个偶然的机会发现了<code>MacOS 10.4.6</code>,看到界面截图,简直是惊为天人.刚好那个时候苹果开始使用Intel的CPU.让我们有机会品尝了一下黑苹果的滋味.虽然在我的<code>HP DV2621</code>笔记本上装黑苹果又卡又热,但是还是让我深深的喜欢上了这个系统.到2009年,实在是憋不住了,买了我人生中的第一台macbook <code>mb990</code>.然后毕业后到公司上班也申请一直使用苹果系统.反正我是搞JAVA的,到是和操作系统关系不大,反而我到是觉得搞JAVA开发,Mac比Win还好用些,这么多年来也是越用越顺手.这里分享下我平时使用的一些经验或软件吧~</p>
<h2 id="硬件">硬件</h2><p>这部分没啥好说的,苹果的电脑就这么几个型号.不过对于我们上班的来说,还是推荐使用rMBP+24寸以上的显示器的组合. 苹果的视网膜屏确实相当牛逼,看代码完全是种享受.<br>配置的话,只要不是macmini和air以及现在新出的macbook的话,应该都还OK.我个人是使用的<code>2014年rMBP 15寸低配</code>那款.编译和运行的速度秒杀大多数的机器.<br>而对于键盘和鼠标的话,没有什么特殊的要求.机械键盘我还没用过,不好评价的.鼠标的话,我用的是苹果的<code>Magic Mouse</code>,有人说那鼠标完全是反人类的,其实我觉得还好,现在平均每天要用10个小时以上,也没觉得特别的不适.使用这个鼠标最大的好处肯定就是它的多点触控了.几个工具全屏再加上几个多桌面,使用那个鼠标很容易的就可以做切换.</p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="MAC" scheme="http://sunxiang0918.github.io/tags/MAC/"/>
    
  </entry>
  
</feed>