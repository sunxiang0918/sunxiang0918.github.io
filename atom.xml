<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[翔妖除魔的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://sunxiang0918.github.io//"/>
  <updated>2016-01-27T08:57:50.000Z</updated>
  <id>http://sunxiang0918.github.io//</id>
  
  <author>
    <name><![CDATA[翔妖除魔]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[常用UniqueID的生成方法]]></title>
    <link href="http://sunxiang0918.github.io/2016/01/24/%E5%B8%B8%E7%94%A8UniqueID%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/"/>
    <id>http://sunxiang0918.github.io/2016/01/24/常用UniqueID的生成方法/</id>
    <published>2016-01-24T12:58:39.000Z</published>
    <updated>2016-01-27T08:57:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="常用UniqueID的生成方法">常用UniqueID的生成方法</h1><p>这几天在与其他的系统进行联调的时候,出现了对方的唯一ID使用的是<code>Int32</code>来存储,而我们提供的UniqueID是标准的UUID,从而导致他们无法存储的问题.由于他们是一个历史的老系统,牵扯很深,所以无法进行改造,只能我们来适应它(幸好和它们交互的数据不会太多.应该不会超过Int32的上限).从而引出了对UniqueID生成方法的思考.这里列出了几种常用的UniqueID的生成办法.</p>
<h2 id="基于数据库的发号器">基于数据库的发号器</h2><p>这个是最常见和最容易想到的生成UniqueID的方法.也就是依赖数据库的自增ID来获取唯一ID,由于在分布式系统中数据库都是做了分布式或同步的,因此能保证数据库的自增键或序列是不会重复的.</p>
<ul>
<li>在Oracle中,可以创建一个序列,然后使用序列的<code>nextVal</code>来获取.</li>
<li>在Mysql中,由于没有序列的概念,只能创建一个表,表的主键设置为自增.要获取UniqueID的时候就不断的往这个表中插入记录,获取<code>last_insert_id()</code>即可.为了避免表的记录数过多,可以考虑采用使用回滚的方式来规避.</li>
<li>在redis中,可以使用<code>INCR key</code>这个命令来获取一个自增的key,每调用一次,key值增加1.如果没有这个key值,则初始化key值为0.</li>
</ul>
<p>使用这种方案的优点就是可以满足像<code>Int32</code>这种短数据的唯一.而缺点就是增加了系统的复杂性.需要在系统中强依赖数据库,并且获取<code>UniqueID</code>是需要与数据库交互的,虽然可以一次批量的获取几个ID,但是总体来说,性能会有损失.</p>
<a id="more"></a>
<h2 id="基于规则计算的UniqueID">基于规则计算的UniqueID</h2><p>这一大类就是通过某些计算的规则,在分布式的每台机器上独立计算获取UniqueID,最常见的就是UUID了.</p>
<h3 id="UUID">UUID</h3><p>UUID全称<code>Universally Unique IDentifier</code>.它是由OSF(开源软件基金会 Open Software Foundation)所颁布的一种唯一ID计算的规则.它是一个可以表示层32个16进制字符的128bit的数字.中间用<code>-</code>符号分隔.常见的形式为:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.<br>其中前面的16个字符表示的是时间戳和UUID版本号,接下来的4个字符表示的是时间序列以及保留字段,最后12个字符是节点标识.</p>
<p>目前有Version1-5 5个版本:</p>
<ul>
<li><strong>Version1</strong>:基于时间的UUID,这个版本的UUID可以保证在全球范围内的唯一性.<br>  这个版本有60位的字节来表示时间,精确到纳秒,因此基本上保证了时间上的不重复,并且最后还有48位字节的节点信息,是由MAC地址等硬件信息来表达的.中间的16位时钟序列则用于避免其他信息改变(机器时间错误,MAC地址手动填写冲突等)的情况下增加的一个随机码. 基本上可以说这个版本的UUID就可以满足高并发的分布式系统下的UniqueID的唯一.</li>
<li><strong>Version2</strong>:DCE安全的UUID,这个版本的UUID的算法和Version1的是相同的,但是会把时间戳的前4位置换为POSIX的UID或GID.这个版本的UUID使用的比较少.</li>
<li><strong>Version3</strong>:基于名字MD5的UUID,这个版本的UUID通过计算名字和名字空间的MD5散列值而得到结果.这个版本的UUID保证了:相同命名空间中不同名字生成的UUID是唯一的,不同命名空间中的UUID的唯一性,但是相同名字空间中相同名字的UUID是可能会重复的.因此,一般不用作UniqueID的生成.</li>
<li><strong>Version4</strong>:这个版本也是使用的比较多的,也是JAVA中<code>UUID.randomUUID()</code>方法的实现规则.它不关心UUID的各个位置上的规则,直接使用<code>SecureRandom</code>生成16个随机的字节.然后把第6个字节设置为<code>Version4</code>,把第8个字节设置为<code>IETF</code>标识.</li>
<li><strong>Version5</strong>:基于名字SHA1的UUID,这个版本的UUID算法和Version3的是一样的,只是把名字和命名空间的散列算法改为了SHA1</li>
</ul>
<p>从这几个版本中可以看出,<code>Version1</code>和<code>Version2</code>是最适合于分布式计算环境下,具有高度唯一性的UniqueID,而<code>Version3</code>和<code>Version5</code>适用于一定范围内名字唯一的情况.而<code>Version4</code>在分布式的情况下,最好不要用,虽然是随机的,但是说不准在高并发的情况下,就有可能重复.<br>因此,如果要在JAVA中生成Version1的UUID,可以使用以下这个jar包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>com.eaio.uuid<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>uuid<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="MongoDB的ObjectID">MongoDB的ObjectID</h3><p>在Mongo数据库中,每一个文档必须有一个”_id”建,默认情况下这个是一个ObjectId的值.而ObjectId就是使用了序列计算的方式来获取这个唯一值.</p>
<p>ObjectID使用了12个字节来进行存储,每个字节表示两位十六进制数字,是一个24位的字符串.<br>它的前4位表示的是时间戳,单位为秒.通过这个可以大致的保证唯一性,并且可以通过这4个字符来获取文档的创建时间.<br>接下来的3字节是所在主机的唯一标识符,通常是机器的主机名的散列值.<br>再后面的两字节表示的是生成这个ObjectID的进程的ID号(PID)<br>这样,前9位就保证了同一秒中不同机器不同进程产生的ObejctId是唯一的.而后3字节就是一个自增的计数器,确保相同进程同一秒内产生的ObjectId也是不一样的.这样同一秒中类允许最多每个进程拥有16777215个不同的ObjectID.这基本上是不可能重复了.</p>
<h3 id="Twitter的snowflake算法">Twitter的snowflake算法</h3><p>为了满足Twitter每秒上万条消息的请求,每条消息都必须分配一个唯一的ID,这些id还需要一些大致的顺序.因此,Twitter公布了他们的Snowflake算法来生成这个唯一UniqueID.</p>
<p>Snowflake算法生成的唯一键是由64位组成的.在默认的情况下:分为了4组.<br>第一位的0预留不使用.<br>第二组是41位的时间戳.精确到毫秒.<br>第三组的10位是工作机器的Id.默认可以使用MAC地址来唯一标识,当然使用进程号也是可以的.<br>第四组是12位的序列号,同mongo的ObjectID相同,也是一个自增的ID.可以保证1毫秒产生4095个不重复的自增序列.<br>这个算法的优势就是一个Int64就可以进行存储,比UUID等的128位减少了很多</p>
<h2 id="总结">总结</h2><p>基本上常见的分布式情况下的UniqueID的生成方法就分为了两大类,一类是基于分配的发号器,另外一类是基于规则计算的唯一序列.而后者的常用算法通常就是UUID以及OjbectID和SnowFlake<br>基于发号器的优势在于可以按照准连续的增加,可以用于Int32等的存储.但是性能和系统复杂度上存在一定的缺陷.<br>而基于计算规则的优势主要是分布式情况下,各机器独立运算,性能上有保证.但是通常都需要使用64位以上的空间来进行存储.<br>具体如何选择,需要在项目中具体的分析.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="常用UniqueID的生成方法">常用UniqueID的生成方法</h1><p>这几天在与其他的系统进行联调的时候,出现了对方的唯一ID使用的是<code>Int32</code>来存储,而我们提供的UniqueID是标准的UUID,从而导致他们无法存储的问题.由于他们是一个历史的老系统,牵扯很深,所以无法进行改造,只能我们来适应它(幸好和它们交互的数据不会太多.应该不会超过Int32的上限).从而引出了对UniqueID生成方法的思考.这里列出了几种常用的UniqueID的生成办法.</p>
<h2 id="基于数据库的发号器">基于数据库的发号器</h2><p>这个是最常见和最容易想到的生成UniqueID的方法.也就是依赖数据库的自增ID来获取唯一ID,由于在分布式系统中数据库都是做了分布式或同步的,因此能保证数据库的自增键或序列是不会重复的.</p>
<ul>
<li>在Oracle中,可以创建一个序列,然后使用序列的<code>nextVal</code>来获取.</li>
<li>在Mysql中,由于没有序列的概念,只能创建一个表,表的主键设置为自增.要获取UniqueID的时候就不断的往这个表中插入记录,获取<code>last_insert_id()</code>即可.为了避免表的记录数过多,可以考虑采用使用回滚的方式来规避.</li>
<li>在redis中,可以使用<code>INCR key</code>这个命令来获取一个自增的key,每调用一次,key值增加1.如果没有这个key值,则初始化key值为0.</li>
</ul>
<p>使用这种方案的优点就是可以满足像<code>Int32</code>这种短数据的唯一.而缺点就是增加了系统的复杂性.需要在系统中强依赖数据库,并且获取<code>UniqueID</code>是需要与数据库交互的,虽然可以一次批量的获取几个ID,但是总体来说,性能会有损失.</p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>超越继承之路：协议混合]]></title>
    <link href="http://sunxiang0918.github.io/2016/01/20/%E8%B6%85%E8%B6%8A%E7%BB%A7%E6%89%BF%E4%B9%8B%E8%B7%AF%EF%BC%9A%E5%8D%8F%E8%AE%AE%E6%B7%B7%E5%90%88/"/>
    <id>http://sunxiang0918.github.io/2016/01/20/超越继承之路：协议混合/</id>
    <published>2016-01-20T11:29:27.000Z</published>
    <updated>2016-01-20T11:45:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="超越继承之路：协议混合">超越继承之路：协议混合</h1><p>只要你学习过面向对象的语言比如 ObjC ，都知道继承的概念，他的一个用途是在多个类之间共享代码。但是这种解决方案存在一些问题。这篇文章我们来初探一下 Swift 的协议扩展，以及如何混合使用这些协议 - Mixins，英文原文<a href="http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/#fnref2" target="_blank" rel="external">地址</a></p>
<p>如果感觉太长了，读不下去，可以直接下载代码 <a href="http://alisoftware.github.io/assets/Mixins.playground.zip" target="_blank" rel="external">Swift Playground Code</a></p>
<h2 id="继承的问题">继承的问题</h2><p>比如你有个 app，其中有大量的<code>UIViewController</code>类都要共享相同的行为，例如他们都有一个相同样式的汉堡菜单。你不想在每个<code>View Controllers</code>中都实现一遍『汉堡菜单』的逻辑（设置 <code>leftBarButtonItem</code>，按钮点击时打开/关闭菜单）</p>
<p>解决方法很简单，创建一个通用的<code>CommonViewController</code>，继承自<code>UIViewController</code>，然后实现所有的行为，接着让其他的<code>UIViewController</code>继承自这个<code>CommonViewController</code>，而不是直接继承自<code>UIViewController</code>。通过这种方式，这些 VC 将拥有这些相同的方法和行为，不需要再每次都自己实现一遍了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">setupBurgerMenu</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">onBurgerMenuTapped</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="keyword">var</span> burgerMenuIsOpen: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123; … &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">CommonViewController</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    setupBurgerMenu()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在随后的开发过程中，你突然需要一个<code>UITableViewController</code>或 <code>UICollectionViewController</code>…靠！不能使用<code>CommonViewController</code>了，因为他是 <code>UIViewController</code> 而不是<code>UITableViewController</code>！</p>
<p>我们该怎么做？新建一个<code>CommonTableViewController</code>实现和<code>CommonViewController</code>一样的功能，但只是继承改为<code>UITableViewController</code>？这会产生好多重复代码，绝对是个糟糕透顶的设计。</p>
<a id="more"></a>
<h2 id="Composition_来拯救我们啦">Composition 来拯救我们啦</h2><p>当然，政治正确的答案就是：</p>
<pre><code>使用 <span class="keyword">Composition</span>，不要使用继承啦！
</code></pre><p>这就意味着为了替代继承，我们需要创建自己的<code>UIViewController</code>，该 VC 由这些内部类的集合组成，而这些内部类负责提供相应的行为。</p>
<p>在我们的例子中，可以想象一个<code>BurgerMenuManager</code>类会提供所有必须的方法来设置汉堡菜单的图标，然后使用<code>BurgerMenuManager</code>进行交互，而我们大量的<code>UIViewControllers</code>都将会设置一个 <code>property</code> 来引用这个<code>BurgerMenuManager</code>，进而与汉堡菜单交互。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BurgerMenuManager</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">setupBurgerMenu</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">onBurgerMenuTapped</span><span class="params">()</span></span> &#123; burgerMenuIsOpen = !burgerMenuisOpen &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">burgerMenuIsOpen</span>: <span class="title">Bool</span> </span>&#123; <span class="keyword">didSet</span> &#123; … &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> menuManager: <span class="type">BurgerMenuManager</span>()</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    menuManager.setupBurgerMenu()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOtherViewController</span>: <span class="title">UITableViewController</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> menuManager: <span class="type">BurgerMenuManager</span>()</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    menuManager.setupBurgerMenu()</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可悲的是这样也太笨重了吧，每次都需要引用一个中间对象<code>menuManager</code>，好麻烦~</p>
<h2 id="多重继承">多重继承</h2><p>另一个现实原因是：大部分的面向对象语言都不允许多重继承（这是因为存在一个<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank" rel="external">菱形类继承问题</a>）</p>
<p><strong>意味着一个类不能有多个父类</strong></p>
<p>假如你实现了一个模型类，用来表示科幻人物。假如你已经创建了<code>DocEmmettBrown</code>,<code>DoctorWho</code> &amp; <code>TimeLord</code>, <code>IronMan</code>, <code>Superman</code>… 然后他们如何直接关联？一些人能够时间旅行，一些能够太空旅行，还有些所有的事都能做，有些人能飞有些不能，一些是人类一些不是…</p>
<p><code>class IronMan</code>（钢铁侠）和 <code>class Superman</code>（超人）都能飞，我们可以创建一个会飞的父类 <code>class Flyer</code>，由他来提供飞行方法的实现<code>func fly()</code> 。但 <code>IronMan</code> 和 <code>DocEmmettBrown</code> 都是人类，所以我们还可以创建一个人类的父类<code>Human</code>，与此同时<code>Superman</code>和 <code>TimeLord</code> 都是外星人 <code>class Alien</code> 的子类。稍等一下… <code>IronMan</code>（钢铁侠）同时继承了 <code>Flyer</code> 和 <code>Human</code>？这在 Swift 中是不可能的（因为 Swift 也是面向对象编程的语言）</p>
<p>我们在继承中只能二选一，如果让 <code>IronMan</code> （钢铁侠）继承自 <code>Human</code>（人类），那么飞行 <code>func fly()</code> 这个方法该如何实现？我们不能显式地在 <code>Human</code>（人类）中实现飞行这个方法，因为不是所有的人都会飞啊，但是<code>Superman</code>（超人）又需要飞行方法，我们不想再重复一遍。</p>
<p>所以，我们可以在这里使用组合，如同让 <code>class SuperMan</code> 超人类包含一个<strong>飞行引擎</strong>属性 <code>var flyingEngine: Flyer</code></p>
<p>但是只是用 <code>superman.flyingEngine.fly()</code> 代替 <code>superman.fly()</code> ，看起来并不是那么优雅。</p>
<h2 id="混合_&amp;_特性">混合 &amp; 特性</h2><p>以下是 <strong>混合 &amp; 特性</strong>（Mixins &amp; Traits）施展手脚的地方</p>
<ul>
<li>通过继承，一般定义你的类是什么，比如所有的 🐶 <code>Dog</code> 都是一个动物 <code>Animal</code></li>
<li>而 <code>Traits</code> 特性，定义了你的类可以做什么，比如，所有的动物 <code>Animal</code> 都能吃 <code>eat()</code>，但人类也能吃，神秘博士 <strong>Doctor Who</strong> 虽然既不是人类也不是动物，但也能吃炸鱼条和蛋冻奶。</li>
</ul>
<p>所以对于特性来说，他们是什么并不重要，而关键在于他们能做什么</p>
<p>继承定义了这个对象是什么，而特性则定义了这个对象能做什么</p>
<p>更棒的消息是：一个类可以部署很多特性，也就是可以同时做很多事情，这是只从单一父类继承而来的子类所不可企及的，因为他们一次只能做一件事情。</p>
<p>那么在 Swift 中该如何应用？</p>
<h2 id="带默认实现的协议">带默认实现的协议</h2><p>在 Swift 2.0 中，当你定义了一个 <code>protocol</code>，可以通过 <code>extension</code> 为其附加相关的实现方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I believe I can flyyyyy ♬"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鉴于此，我们创建了一个遵守 <code>Flyer</code> 协议的类或结构体对象，该对象会免费获得 <code>fly()</code> 方法！</p>
<p>你可以根据需要随时重载这个默认实现，当然也可以什么都不做，这样就自动获得一个默认实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span>: <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="comment">// we don't implement fly() there so we get the default implementation and hear Clark sing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronMan</span>: <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="comment">// be we can also give a specific implementation if needs be</span></span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    thrusters.start()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"><span class="type">Protocols</span> 提供默认实现这一特性棒极了，正如你所愿将 **<span class="type">Traits</span>** 的概念带进了 <span class="type">Swift</span></span><br><span class="line"></span><br><span class="line">##同一身份，多种能力</span><br><span class="line">关于特性最赞的一点就是：特性不依赖于应用这些特性的对象。他们（特性）不关心这些类是什么，继承自何方，他们只是在这些类中定义了一些方法。</span><br><span class="line"></span><br><span class="line">这就解决了 `<span class="type">Doctor</span> <span class="type">Who</span>` 既是时间旅行者又是外星人，以及 `<span class="type">Dr</span> <span class="type">Emmett</span> <span class="type">Brown</span>` 既是时间旅行者又是人类的难题。再如钢铁侠作为一个人类，和超人作为外星人，但他们都能飞。</span><br><span class="line"></span><br><span class="line">你是谁并不能决定你的能力</span><br><span class="line"></span><br><span class="line">现在，让我们利用 **<span class="type">Traits</span>** 来实现我们的模型类吧</span><br><span class="line"></span><br><span class="line">首先，让我们定义各种各样的 **<span class="type">Traits</span>**（特性）：</span><br><span class="line"></span><br><span class="line">```<span class="built_in">swift</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TimeTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> currentDate: <span class="type">NSDate</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(date: NSDate)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着给出默认实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"I believe I can flyyyyy ♬"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimeTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(date: NSDate)</span></span> &#123;</span><br><span class="line">    currentDate = date</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于定义超级英雄角色这一点上（他们是谁），我们依然先使用继承，下面来实现几个父类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>: <span class="title">Character</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> countryOfOrigin: <span class="type">String</span>?</span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, countryOfOrigin: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.countryOfOrigin = countryOfOrigin</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Alien</span>: <span class="title">Character</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, species: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.species = species</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在能够同时通过他们的身份（继承）和能力（特性/协议）来定义我们的超级英雄了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeLord</span>: <span class="title">Alien</span>, <span class="title">TimeTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> currentDate = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"I'm the Doctor"</span>, species: <span class="string">"Gallifreyan"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DocEmmettBrown</span>: <span class="title">Human</span>, <span class="title">TimeTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> currentDate = <span class="type">NSDate</span>()</span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Emmett Brown"</span>, countryOfOrigin: <span class="string">"USA"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Superman</span>: <span class="title">Alien</span>, <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Clark Kent"</span>, species: <span class="string">"Kryptonian"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronMan</span>: <span class="title">Human</span>, <span class="title">Flyer</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Tony Stark"</span>, countryOfOrigin: <span class="string">"USA"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Superman</code>（超人）和 <code>IronMan</code>（钢铁侠）都使用相同的飞行 <code>fly()</code> 实现，即使他们继承自不同的父类（一个是外星人，另一个是人类），并且 Docotors（博士们）都懂得时间旅行：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tony = <span class="type">IronMan</span>()  </span><br><span class="line">tony.fly() <span class="comment">// prints "I believe I can flyyyyy ♬"  </span></span><br><span class="line">tony.name  <span class="comment">// returns "Tony Stark"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clark = <span class="type">Superman</span>()  </span><br><span class="line">clark.fly() <span class="comment">// prints "I believe I can flyyyyy ♬"  </span></span><br><span class="line">clark.species  <span class="comment">// returns "Kryptonian"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> docBrown = <span class="type">DocEmmettBrown</span>()  </span><br><span class="line">docBrown.travelTo(<span class="type">NSDate</span>(timeIntervalSince1970: <span class="number">499161600</span>))  </span><br><span class="line">docBrown.name <span class="comment">// "Emmett Brown"  </span></span><br><span class="line">docBrown.countryOfOrigin <span class="comment">// "USA"  </span></span><br><span class="line">docBrown.currentDate <span class="comment">// Oct 26, 1985, 9:00 AM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doctorWho = <span class="type">TimeLord</span>()  </span><br><span class="line">doctorWho.travelTo(<span class="type">NSDate</span>(timeIntervalSince1970: <span class="number">1303484520</span>))  </span><br><span class="line">doctorWho.species <span class="comment">// "Gallifreyan"  </span></span><br><span class="line">doctorWho.currentDate <span class="comment">// Apr 22, 2011, 5:02 PM</span></span><br></pre></td></tr></table></figure>
<h2 id="时空探险">时空探险</h2><p>现在让我们探索一种新的空间旅行能力/特性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SpaceTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(location: String)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供一个默认实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SpaceTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">travelTo</span><span class="params">(location: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Let's go to <span class="subst">\(location)</span>!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 Swift 的 <code>extensions</code> 为现有类添加共性的协议了，接下来为已定义的英雄角色添加这些能力。如果我们不计较钢铁侠在《复仇者联盟 1》『纽约之战』中英勇地抱着核弹飞到外太空的话，那么只有 Doctor（博士）和 Superman（超人）拥有空间旅行的能力：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TimeLord</span>: <span class="title">SpaceTraveler</span> </span>&#123;&#125;  </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Superman</span>: <span class="title">SpaceTraveler</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>是的，这就是需要添加超能力，现在他们可以使用 <code>travelTo()</code>飞往任何地方！代码相当整洁，不是吗？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doctorWho.travelTo(<span class="string">"Trenzalore"</span>) <span class="comment">// prints "Let's go to Trenzalore!"</span></span><br></pre></td></tr></table></figure>
<h3 id="多邀请点人加入我们的派对">多邀请点人加入我们的派对</h3><p>现在让我们为更多的英雄赋予能力：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Come along, Pond!</span></span><br><span class="line"><span class="keyword">let</span> amy = <span class="type">Human</span>(name: <span class="string">"Amelia Pond"</span>, countryOfOrigin: <span class="string">"UK"</span>)  </span><br><span class="line"><span class="comment">// Damn, isn't she not a Time and Space Traveler too? Which doesn't make her a TimeLord, though</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Astraunaut</span>: <span class="title">Human</span>, <span class="title">SpaceTraveler</span> </span>&#123;&#125;  </span><br><span class="line"><span class="keyword">let</span> neilArmstrong = <span class="type">Astraunaut</span>(name: <span class="string">"Neil Armstrong"</span>, countryOfOrigin: <span class="string">"USA"</span>)  </span><br><span class="line"><span class="keyword">let</span> laika = <span class="type">Astraunaut</span>(name: <span class="string">"Laïka"</span>, countryOfOrigin: <span class="string">"Russia"</span>)  </span><br><span class="line"><span class="comment">// Wait, Laïka is a Dog, right?</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MilleniumFalconPilot</span>: <span class="title">Human</span>, <span class="title">SpaceTraveler</span> </span>&#123;&#125;  </span><br><span class="line"><span class="keyword">let</span> hanSolo = <span class="type">MilleniumFalconPilot</span>(name: <span class="string">"Han Solo"</span>)  </span><br><span class="line"><span class="keyword">let</span> chewbacca = <span class="type">MilleniumFalconPilot</span>(name: <span class="string">"Chewie"</span>)  </span><br><span class="line"><span class="comment">// Wait, isn't MilleniumFalconPilot defined as "Human"?!</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spock</span>: <span class="title">Alien</span>, <span class="title">SpaceTraveler</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"Spock"</span>, species: <span class="string">"Vulcan"</span>)</span><br><span class="line">    <span class="comment">// Woops not 100% right</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呼叫休斯顿，我们遇到一个问题。<code>Laika</code> 不是人类也不是 <code>Chewie</code>，<code>Spock</code> 是半人类半瓦肯星人，所以这些定义都是错的。</p>
<p>我们理所应当地认为人类 <code>Human</code> 和外星人 <code>Alien</code> 都可以抽象为单独的类，如果我们继承了这些类，就会被看做是强制认同了这种身份类型。可惜在科幻小说中并不是这样，这才是困扰我们的问题所在。</p>
<p>这也是为什么我们需要在 Swift 中使用 Protocols 并提供协议默认实现的原因。它能帮助我们移除由类继承所带来的限制。</p>
<p>如果将 <code>Human</code> 和 <code>Alien</code> 由类改为协议，会获得到以下优势：</p>
<ul>
<li>我们可以定义一个 <code>MilleniumFalconPilot</code> （飞行器）类型而不用强迫他是一个人类，接着让 <code>Chewie</code> 来驾驶</li>
<li>我们可以定义 <code>Laïka</code> 是一个宇航员 <code>Astronaut</code>，即使她并不是一个人类</li>
<li>我们可以定义 <code>Spock</code> 既是人类 <code>Human</code> 又是外星人 <code>Alien</code></li>
<li>我们甚至可以将继承完全从我们的例子中移除，用结构体 <code>structs</code> 代替类 <code>classes</code> 来定义我们的类型。结构体并不支持继承，但可以遵从多个协议。</li>
</ul>
<h2 id="协议无处不在">协议无处不在</h2><p>至此可以公布我们的解决方案了：就是完全用协议来取代继承，毕竟，我们并不在乎这些超级英雄是什么？只关心他们有哪些超能力罢了。</p>
<p>我打包了一份 <strong>Playground</strong> 代码，你可以点这里下载。我用两页的篇幅演示了完全用 <code>Protocol</code> 和 <code>Structs</code> 是如何实现这一切的，别犹豫，打开看一看！</p>
<p>当然，这并不意味着你必须不惜一切代价避免继承（不要都听 Dalek 的，他们毕竟缺乏感情）。继承仍然有其用武之地，比如 <code>UILabel</code> 是 <code>UIView</code> 子类，你依然能感受到其中的逻辑性。但是，这并不妨碍我们去探索一片新天地 <strong>Mixins &amp; Protocols</strong>（附带默认实现）</p>
<h2 id="总结">总结</h2><p>你在 Swift 之路走得越远，就越能意识到这其实是一门<strong>面向协议编程</strong>的语言，Swift 中大范围应用的<strong>协议</strong>远比 OC 中要强大的多。毕竟，像 <code>Equatable</code>，<code>CustomStringConvertible</code> 以及 <code>-able</code> 这种 Swift 标准库中的协议其实也是混合在一起使用的（Mixins）</p>
<p>通过 Swift 的协议和附带的默认实现，你可以实现 <strong>Mixins &amp; Traits</strong>（混合 &amp; 特性），不仅如此，你还可以实现抽象类的功能，这一切都会让你的编码之路会更加灵活。</p>
<p>采取 <strong>Mixins &amp; Traits</strong> 方式组织的代码不仅定义了这些类型能做什么，还说明了他们是什么。更重要的，你可以按需有选择地部署能力。这有点像你去超市购物，为类型挑选他们喜欢的能力放进购物车中，而并不去关心这些类型继承自何方。</p>
<p>回到最初的例子中，你可以创建一个 <code>protocol BurgerMenuManager</code> 以及一个默认实现，然后简单地让你的 <code>View Controllers</code>（UIViewController 或 UITableViewController…）遵从这个协议就好啦，该 VC 会自动获取所有定义在 <code>BurgerMenuManager</code> 中的能力，而不用去担心 <code>UIViewController</code> 的父类是什么！</p>
<p>关于 <code>Protocol Extensions</code> 还能说很多，<strong>Don’t Panic</strong> 我会在今后的文章中徐徐道来，协议扩展可以在很多方面增强你的代码。这篇文章够长啦，今后再写啦，别走开马上回来~</p>
<hr>
<p>原文链接:<a href="http://chengway.in/chao-yue-ji-cheng-zhi-lu-xie-yi-hun-he/" target="_blank" rel="external">http://chengway.in/chao-yue-ji-cheng-zhi-lu-xie-yi-hun-he/</a></p>
<p>PS:现在JAVA的JDK1.8中也支持了接口的默认实现,也就是说,JAVA也可以面向协议来编程了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="超越继承之路：协议混合">超越继承之路：协议混合</h1><p>只要你学习过面向对象的语言比如 ObjC ，都知道继承的概念，他的一个用途是在多个类之间共享代码。但是这种解决方案存在一些问题。这篇文章我们来初探一下 Swift 的协议扩展，以及如何混合使用这些协议 - Mixins，英文原文<a href="http://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritance/#fnref2">地址</a></p>
<p>如果感觉太长了，读不下去，可以直接下载代码 <a href="http://alisoftware.github.io/assets/Mixins.playground.zip">Swift Playground Code</a></p>
<h2 id="继承的问题">继承的问题</h2><p>比如你有个 app，其中有大量的<code>UIViewController</code>类都要共享相同的行为，例如他们都有一个相同样式的汉堡菜单。你不想在每个<code>View Controllers</code>中都实现一遍『汉堡菜单』的逻辑（设置 <code>leftBarButtonItem</code>，按钮点击时打开/关闭菜单）</p>
<p>解决方法很简单，创建一个通用的<code>CommonViewController</code>，继承自<code>UIViewController</code>，然后实现所有的行为，接着让其他的<code>UIViewController</code>继承自这个<code>CommonViewController</code>，而不是直接继承自<code>UIViewController</code>。通过这种方式，这些 VC 将拥有这些相同的方法和行为，不需要再每次都自己实现一遍了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonViewController</span>: <span class="title">UIViewController</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">setupBurgerMenu</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">onBurgerMenuTapped</span><span class="params">()</span></span> &#123; … &#125;</span><br><span class="line">  <span class="keyword">var</span> burgerMenuIsOpen: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123; … &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">CommonViewController</span> </span>&#123;  </span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    setupBurgerMenu()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在随后的开发过程中，你突然需要一个<code>UITableViewController</code>或 <code>UICollectionViewController</code>…靠！不能使用<code>CommonViewController</code>了，因为他是 <code>UIViewController</code> 而不是<code>UITableViewController</code>！</p>
<p>我们该怎么做？新建一个<code>CommonTableViewController</code>实现和<code>CommonViewController</code>一样的功能，但只是继承改为<code>UITableViewController</code>？这会产生好多重复代码，绝对是个糟糕透顶的设计。</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in JAVA(二)]]></title>
    <link href="http://sunxiang0918.github.io/2016/01/13/Akka-in-JAVA-2/"/>
    <id>http://sunxiang0918.github.io/2016/01/13/Akka-in-JAVA-2/</id>
    <published>2016-01-13T14:43:04.000Z</published>
    <updated>2016-01-27T06:42:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Akka_in_JAVA(二)">Akka in JAVA(二)</h1><p>继续<a href="/2016/01/10/Akka-in-JAVA-1/">Akka in JAVA(一)</a>中所讲.</p>
<h2 id="Actor调用">Actor调用</h2><p>从上面的例子中,我们可以大概的对AKKA在JAVA中的使用有一个全局的概念.这里我们在稍微细致的讲解一下.</p>
<p>在JAVA中使用AKKA进行开发主要有这几个步骤:</p>
<ol>
<li>定义消息模型.</li>
<li>创建Actor的实现,以及业务逻辑</li>
<li>在需要使用AKKA的地方获取到ActorSystem,然后根据业务的数据流,获取到合适的Actor,给Actor发送消息.</li>
<li>在Actor的实现用,对接收到的消息进行具体的处理或转发.从而形成业务逻辑流.</li>
</ol>
<p>下面我们分别讲解一下这几个步骤.</p>
<a id="more"></a>
<h3 id="定义消息模型">定义消息模型</h3><p>在AKKA中的消息模型可以是任意实现了<code>Serializable</code>接口的对象.和大多数的远程调用框架一样,为了AKKA的高可用,以后可能会牵涉到远程调用和集群,那么消息模型就需要跨网络的进行传输,这就要求对消息模型进行序列化和反序列化.因此,要求消息模型必须实现<code>Serializable</code>接口.具体的序列化和反序列化在后面讲解远程调用的时候再细谈.</p>
<h3 id="创建Actor的实现-">创建Actor的实现.</h3><p>有了消息模型后,就需要有Actor对这些消息进行消费了.<br>在AKKA中Actor分为了<code>TypedActor</code>和<code>UnTypedActor</code>.</p>
<p>其中<code>TypedActor</code>是<code>Akka</code>基于<code>Active对象</code>(Active Object)设计模式的一个实现,该设计模式解耦了在一个对象上执行方法和调用方法的逻辑,执行方法和调用方法分别在各自的线程上独立运行.该模式的目标是通过使用异步的方法调用和内部的调度器来处理请求,从而实现方法的执行时异步处理的.通俗点来讲,<code>TypedActor</code>就是可以预先的定义一系列的接口和实现,然后通过<code>ActorSystem</code>来创建这个<code>TypedActor</code>的实例,当调用这个实例的方法的时候,其实是会异步的执行方法的,而不是同步的.至于如何异步的,这就交由AKKA内部来实现了,开发人员不需要关心.这其实就比较像<code>goLang</code>语言中的<code>fmt</code>的一些方法或<code>go</code>关键字,很简单的方法调用背后隐藏了异步的执行操作.</p>
<p>而<code>UnTypedActor</code>更像是JAVA中的JMS调用.方法的调用和执行完全依赖了消息,通过消息的类型或内容来区别不同的执行.对于消息的发送方式都是相同的,那就是直接给这个Actor的邮箱中发送Message.也就是说<code>UnTypedActor</code>更接近于我们前两个小节中所说的<code>Actor</code>这个概念.</p>
<p>事实也是如此,在AKKA中我们更多的是倾向于使用<code>UnTypedActor</code>向<code>Actor</code>系统间传递消息,而<code>TypedActor</code>更多的是用来桥接<code>Actor</code>系统和<code>非Actor</code>的.</p>
<h4 id="创建UnTypedActor">创建<code>UnTypedActor</code></h4><p>在<code>AKKA for JAVA</code>中,创建一个<code>UnTypedActor</code>非常的简单.直接继承<code>UnTypedActor</code>类,并实现<code>public void onReceive(Object message) throws Exception</code>方法即可.在<code>onReceive</code>方法中就是需要实现的业务逻辑.比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetPrinter</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Greeting)</span><br><span class="line">            System.out.println(((Greeting) message).message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建TypedActor">创建<code>TypedActor</code></h4><p>由于AKKA是由<code>scala</code>写的,因此它其实最切合的就是使用<code>scala</code>进行开发,而JAVA作为一个强类型的静态语言,很多<code>scala</code>的特性其实是不好模仿出来的.因此,在JAVA中使用<code>TypedActor</code>其实是比较麻烦的.</p>
<ol>
<li><p>首先需要定义<code>Actor</code>的接口.对于异步的方法,需要返回<code>scala.concurrent.Future</code>对象.阻塞的异步调用,需要返回<code>akka.japi.Option</code>.同步调用直接返回结果对象.比如:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Squarer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   	<span class="function">Future&lt;Integer&gt; <span class="title">square</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">//non-blocking send-request-reply</span></span><br><span class="line"></span><br><span class="line">   	<span class="function">Option&lt;Integer&gt; <span class="title">squareNowPlease</span><span class="params">(<span class="keyword">int</span> i)</span></span>;<span class="comment">//blocking send-request-reply</span></span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">int</span> <span class="title">squareNow</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">//blocking send-request-reply</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写<code>TypedActor</code>的实现:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SquarerImpl</span> <span class="keyword">implements</span> <span class="title">Squarer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SquarerImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SquarerImpl</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Integer&gt; <span class="title">square</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Futures.successful(squareNow(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Option&lt;Integer&gt; <span class="title">squareNowPlease</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Option.some(squareNow(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">squareNow</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"执行里面"</span>);</span><br><span class="line">        <span class="keyword">return</span> i * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在调用AKKA的地方实例化<code>TypedActor</code>的实例:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActorSystem system = ActorSystem.create(<span class="string">"helloakka"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*默认构造方法的Actor*/</span></span><br><span class="line">       Squarer mySquarer = TypedActor.get(system).typedActorOf(<span class="keyword">new</span> TypedProps&lt;&gt;(Squarer.class, SquarerImpl.class));</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*传参构造的Actor*/</span></span><br><span class="line">       Squarer otherSquarer =</span><br><span class="line">               TypedActor.get(system).typedActorOf(<span class="keyword">new</span> TypedProps&lt;&gt;(Squarer.class,</span><br><span class="line">                               <span class="keyword">new</span> Creator&lt;SquarerImpl&gt;() &#123;</span><br><span class="line">                                   <span class="function"><span class="keyword">public</span> SquarerImpl <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                       <span class="keyword">return</span> <span class="keyword">new</span> SquarerImpl(<span class="string">"foo"</span>);</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;),</span><br><span class="line">                       <span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>TypedActor</code>中的方法:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Option&lt;Integer&gt; oSquare = mySquarer.squareNowPlease(<span class="number">10</span>); <span class="comment">//Option[Int]</span></span><br><span class="line">      System.out.println(<span class="string">"阻塞异步调用执行外面"</span>);</span><br><span class="line">      <span class="comment">//获取结果</span></span><br><span class="line">      System.out.println(oSquare.get());</span><br><span class="line">      </span><br><span class="line">      Future&lt;Integer&gt; fSquare = mySquarer.square(<span class="number">10</span>); <span class="comment">//A Future[Int]</span></span><br><span class="line">      System.out.println(<span class="string">"非阻塞异步执行外面"</span>);</span><br><span class="line">      <span class="comment">//等待5秒内返回结果</span></span><br><span class="line">      System.out.println(Await.result(fSquare, Duration.apply(<span class="number">5</span>, TimeUnit.SECONDS)));</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后会在控制台打印:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行里面</span><br><span class="line">阻塞异步调用执行外面</span><br><span class="line"><span class="number">100</span></span><br><span class="line">非阻塞异步执行外面</span><br><span class="line">执行里面</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从这个结果很容易的看出成功的异步调用了Actor.</p>
<h4 id="小结">小结</h4><p>从上面的例子可以看出<code>TypedActor</code>其实在JAVA中是比较麻烦的,因此我们会更多的使用<code>UnTypedActor</code>.后面的例子中<code>Actor</code>指的都是<code>UnTypedActor</code></p>
<h3 id="获取Actor">获取Actor</h3><p>在创建了Actor后,接下来就是需要实例化或获取Actor了.其主要是通过<code>ActorSystem</code>中的<code>actorOf</code>和<code>actorSelection</code>以及<code>actorFor</code>三个方法.</p>
<ul>
<li><strong>actorOf</strong>：创建一个新的Actor。创建的Actor为调用该方法时所属的Context下的直接子Actor；</li>
<li><strong>actorSelection</strong>：当消息传递来时，只查找现有的Actor，而不会创建新的Actor；在创建了selection时，也不会验证目标Actors是否存在；</li>
<li><strong>actorFor</strong>(<em>已经被actorSelection所deprecated</em>):只会查找现有的Actor，而不会创建新的Actor。</li>
</ul>
<h2 id="Actor生命周期">Actor生命周期</h2><p>AKKA为Actor生命周期的每个阶段都提供了一个钩子(hook),我们可以在必要的时候重载这些方法来完成一些事情。如下图所示:</p>
<p><img src="/img/2016/01/13/2.png" alt=""><br>因此,基本上,一个Actor的生命周期依此为:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actorOf -&gt; preStart -&gt; start -&gt; receive -&gt; stop -&gt; postStop</span><br></pre></td></tr></table></figure>
<p>为了更好的理解Actor的生命周期,官方还出了一个图来进行描述:<br><img src="/img/2016/01/13/1.png" alt=""></p>
<p>从上图我们可以看到,一个Actor初始的时候路径是空的,通过调用<code>actorOf</code>方法实例化一个Actor的实例,会返回一个<code>ActorRef</code>来表示<code>Actor</code>的引用.它包含了一个<code>UID</code>和一个<code>Path</code>,这两个值共同的标识了一个Actor的唯一.重启操作<code>Path</code>和<code>UID</code>不会改变,因此重启前获取到的<code>ActorRef</code>继续有效.</p>
<p>但是<code>ActorRef</code>的生命周期在actor停止的时候结束.此时适当的生命周期Hook会被调用, 处于监控状态的actor会收到通知.在该Actor结束后, 此路径可以通过<code>actorOf</code>方法重用.此时新的<code>ActorRef</code>的路径和之前一样但是UID不同.所以在停止前获取到的<code>ActorRef</code>不再有效.</p>
<p>与<code>ActorRef</code>不同,<code>ActorSelection</code>只关心<code>Path</code>而不关心具体是哪一个<code>Actor</code>.也就是说对一个明确路径的<code>ActorSelection</code>来说,无论对应的<code>Actor</code>是重启还是重新创建,只要是路径一样的,那么都是有效的.如果要通过<code>ActorSelection</code>来获取一个具体的<code>Actor</code>,需要调用<code>ActorSelection</code>的<code>resolveOne</code>的方法来获取.</p>
<h2 id="Dispatcher">Dispatcher</h2><p>在AKKA中,actor之间都是通过消息的传递来完成彼此的交互的.而当Actor的数量比较多后,彼此之间的通信就需要协调,从而能更好的平衡整个系统的执行性能.</p>
<p>在AKKA中,负责协调Actor之间通信的就是<code>Dispatcher</code>.它在自己独立的线程上不断的进行协调,把来自各个Actor的消息分配到执行线程上.</p>
<p>在AKKA中提供了四种不同的<code>Dispatcher</code>,我们可以根据不同的情况选择不同的<code>Dispatcher</code>.</p>
<ul>
<li><strong>Dispatcher</strong>:这个是AKKA默认的<code>Dispatcher</code>.对于这种Dispatcher,每一个Actor都由自己的MailBox支持,它可以被多个Actor所共享.而Dispatcher则由ThreadPool和ForkJoinPool支持.比较适合于非阻塞的情况.</li>
<li><strong>PinnedDispatcher</strong>:这种Dispatcher为每一个Actor都单独提供了专有的线程,这意味着该Dispatcher不能再Actor之间共享.因此,这种Dispatcher比较适合处理对外部资源的操作或者是耗时比较长的Actor.PinnedDispatcher在内部使用了ThreaddPool和Executor,并针对阻塞操作进行了优化.所以这个Dispatcher比较适合阻塞的情况.但是在使用这个Dispatcher的时候需要考虑到线程资源的问题,不能启动的太多.</li>
<li><strong>BalancingDispatcher</strong>(已被废弃):它是基于事件的Dispatcher,它可以针对相同类型的Actor的任务进行协调,若某个Actor上的任务较为繁忙,就可以将它的工作分发给闲置的Actor,前提是这些Actor都属于相同的类型.对于这种Dispatcher,所有Actor只有唯一的一个MailBox,被所有相同类型的Actor所共享.</li>
<li><strong>CallingThreadDispatcher</strong>:这种Dispatcher主要用于测试,它会将任务执行在当前的线程上,不会启动新的线程,也不提供执行顺序的保证.如果调用没有及时的执行,那么任务就会放入ThreadLocal的队列中,等待前面的调用任务结束后再执行.对于这个Dispatcher,每一个Actor都有自己的MailBox,它可以被多个Actor共享.</li>
</ul>
<p>如果要配置<code>Dispatcher</code>,可以在项目的<code>resource</code>目录中创建一个<code>conf</code>文件(默认名字为<code>application.conf</code>).然后修改其中的配置:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">demo5 &#123;</span><br><span class="line">  writer-dispatcher &#123;</span><br><span class="line">    type = Dispatcher   //Dispatcher类型,Dispatcher  PinnedDispatcher</span><br><span class="line">    executor = "fork-join-executor"   //底层实现方式  fork-join-executor  thread-pool-executor</span><br><span class="line">    //执行器方式的参数</span><br><span class="line">    fork-join-executor &#123;</span><br><span class="line">      parallelism-min = 2</span><br><span class="line">      parallelism-factor = 2.0</span><br><span class="line">      parallelism-max = 10</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread-pool-executor &#123;</span><br><span class="line">      core-pool-size-min = 2</span><br><span class="line">      core-pool-size-factor = 2.0</span><br><span class="line">      core-pool-size-max = 10</span><br><span class="line">    &#125;</span><br><span class="line">    throughput = 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>writer-dispatcher</code>是dispatcher的名字,同一个配置文件中可以配置多个.<code>type</code>为四种类型中的某一个.<code>executor</code>是底层实现方式,通常有两种<code>fork-join-executor</code>和<code>thread-pool-executor</code>.这两种的参数为:</p>
<ul>
<li><strong>core-pool-size-min/parallelism-min</strong> : 最小线程数</li>
<li><strong>core-pool-size-max/parallelism-max</strong> : 最大线程数</li>
<li><strong>core-pool-size-factor/parallelism-factor</strong>: 线程层级因子,通常和CPU核数相关.</li>
</ul>
<p>要在AKKA中使用配置文件,需要在创建ActorSystem的时候进行指定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ActorSystem system = ActorSystem.create(<span class="string">"demo5"</span>, ConfigFactory.load(<span class="string">"demo5"</span>).getConfig(<span class="string">"demo5"</span>));</span><br></pre></td></tr></table></figure>
<p><code>ConfigFactory.load(&quot;demo5&quot;)</code>读取的就是<code>Resource</code>文件夹中的<code>demo5.conf</code>这个配置文件.<code>getConfig(&quot;demo5&quot;)</code>读取的是这个配置文件中的<code>demo5</code>这部分的配置.</p>
<p>而要使用配置的<code>Dispatcher</code>需要在创建Actor实例的时候,使用<code>withDispatcher(String)</code>方法来指定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Props props = Props.create(WriterActor.class).withDispatcher(<span class="string">"writer-dispatcher"</span>);</span><br><span class="line">getContext().actorOf(props,<span class="string">"writer_"</span>+i)</span><br></pre></td></tr></table></figure>
<p>这里有一个简单的例子,就是发送消息给一堆的Actor,每一个Actor接收到消息后打印出线程的名字:</p>
<p><strong>StartCommand.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartCommand</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> actorCount =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StartCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StartCommand</span><span class="params">(<span class="keyword">int</span> actorCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actorCount = actorCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActorCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actorCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setActorCount</span><span class="params">(<span class="keyword">int</span> actorCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actorCount = actorCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WriterActor.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterActor</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ControlActor.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlActor</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> StartCommand) &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;ActorRef&gt; actors = createActors(((StartCommand) message).getActorCount());</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*这里使用了JDK1.8中的StreamAPI*/</span></span><br><span class="line">            actors.stream().parallel().forEach(actorRef -&gt; actorRef.tell(<span class="string">"Insert"</span>, ActorRef.noSender()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;ActorRef&gt; <span class="title">createActors</span><span class="params">(<span class="keyword">int</span> actorCount)</span> </span>&#123;</span><br><span class="line">        Props props = Props.create(WriterActor.class).withDispatcher(<span class="string">"writer-dispatcher"</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;ActorRef&gt; actors = <span class="keyword">new</span> ArrayList&lt;&gt;(actorCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; actorCount; i++) &#123;</span><br><span class="line">            actors.add(getContext().actorOf(props,<span class="string">"writer_"</span>+ i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> actors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AkkaMain5.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AkkaMain5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ActorSystem system = ActorSystem.create(<span class="string">"demo5"</span>, ConfigFactory.load(<span class="string">"demo5"</span>)</span><br><span class="line">                .getConfig(<span class="string">"demo5"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个到greeter Actor的管道</span></span><br><span class="line">        <span class="keyword">final</span> ActorRef controlActor = system.actorOf(Props.create(ControlActor.class), <span class="string">"control"</span>);</span><br><span class="line"></span><br><span class="line">        controlActor.tell(<span class="keyword">new</span> StartCommand(<span class="number">100</span>),ActorRef.noSender());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//system.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行这个程序,执行的结果为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">demo5-writer-dispatcher-<span class="number">11</span></span><br><span class="line">demo5-writer-dispatcher-<span class="number">14</span></span><br><span class="line">demo5-writer-dispatcher-<span class="number">8</span></span><br><span class="line">demo5-writer-dispatcher-<span class="number">7</span></span><br><span class="line">demo5-writer-dispatcher-<span class="number">13</span></span><br><span class="line">demo5-writer-dispatcher-<span class="number">7</span></span><br><span class="line">demo5-writer-dispatcher-<span class="number">8</span></span><br><span class="line">demo5-writer-dispatcher-<span class="number">14</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看出线程被重复的利用了.仔细数的话,一共只有10个线程.</p>
<p>而如果把Dispatcher的类型改成<code>PinnedDispatcher</code>的话,系统就会创建100个线程出来.符合开始说的区别.</p>
<h2 id="Router">Router</h2><p>在真实的情况中,通常针对某一种消息,会启动很多个相同的Actor来进行处理.当然,你可以在程序中循环的启动很多个相同的Actor来实现,就如上一小结中启动100个Actor那样,但是这就牵涉到Actor任务的平衡,Actor个数的维护等等,比较的麻烦.因此,在AKKA中存在一种特殊的Actor,即<code>Router</code>.Akka通过<code>Router</code>机制,来有效的分配消息给actor来完成工作.而在AKKA中,被<code>Router</code>管理的actor被称作<code>Routee</code>.</p>
<p>根据项目的需求,可以使用不同的路由策略来分发一个消息到actor中.Akka附带了几个常用的路由策略,配置起就可以使用.当然,也可以自定义一个路由器.</p>
<h3 id="使用Router">使用Router</h3><p>要使用Router非常的简单,可以在Actor内通过实例化<code>Router</code>对象的方式来使用,也可以在Actor外通过<code>withRouter</code>的方式直接创建一个<code>RouterActor</code>来使用.</p>
<h4 id="Actor内使用">Actor内使用</h4><p>这种方式是通过AKKA提供的API,手动的创建<code>Router</code>对象,然后调用<code>addRoutee</code>方法手动的添加<code>Actor</code>(需要注意,每一次调用addRoutee都会返回一个新的Router对象),然后通过<code>route</code>来发送消息.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ActorRef&gt; actors = createActors(((StartCommand) message).getActorCount());</span><br><span class="line"></span><br><span class="line">  Router router = <span class="keyword">new</span> Router(<span class="keyword">new</span> RoundRobinRoutingLogic());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ActorRef actor : actors) &#123;</span><br><span class="line">      router = router.addRoutee(actor);</span><br><span class="line">      <span class="comment">//需要注意,需要接收addRoutee的返回</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  router.route(<span class="string">"Insert"</span>,ActorRef.noSender());</span><br></pre></td></tr></table></figure>
<p>这段代码首先创建了100个相同类型的Actor,然后实例化了一个<code>Router</code>,路由策略是轮询.然后把这100个Actor显式的加入到Router中. 最后,发送消息的时候通过<code>router.route</code>的方式进行发送.AKKA会把这个消息按照路由策略分发给某一个Actor中执行.</p>
<h4 id="Actor外使用">Actor外使用</h4><p>这种方式是通过创建一个<code>RouteActor</code>来使用路由.<code>RouteActor</code>和一般的<code>Actor</code>没有什么不同,区别在于它没有什么业务逻辑,在创建它的时候,它会创建N个具备业务逻辑的子Actor.当它接收到消息后,会把消息转发给它的某个子Actor.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用Router方式启动100个Actor*/</span></span><br><span class="line">       Props props = Props.create(WriterActor.class).withRouter(<span class="keyword">new</span> RoundRobinPool(((StartCommand) message).getActorCount())).withDispatcher(<span class="string">"writer-dispatcher"</span>);</span><br><span class="line">       ActorRef actorRef = getContext().actorOf(props);</span><br><span class="line">       actorRef.tell(<span class="string">"Insert"</span>,ActorRef.noSender());</span><br></pre></td></tr></table></figure>
<p>这段代码确定了子Actor的类型,然后定义了路由策略.而后创建了<code>RouteActor</code>.最后发送消息的时候通过给路由Actor发送消息的方式进行处理.</p>
<h4 id="配置使用">配置使用</h4><p>这种方式是通过在AKKA的配置中来定义<code>Router</code>,创建的时候直接读取配置来获取<code>Router</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">akka.actor.deployment &#123;</span><br><span class="line">  /router &#123;</span><br><span class="line">    router = round-robin</span><br><span class="line">    nr-of-instances = <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是在配置中指定了一个router,策略是轮询,子Actor数是5个.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActorRef router = system.actorOf(<span class="keyword">new</span> Props(ExampleActor.class).withRouter(<span class="keyword">new</span> FromConfig()), <span class="string">"router"</span>);</span><br></pre></td></tr></table></figure>
<p>然后通过<code>FromConfig()</code>配置加载<code>Router</code>.加载的时候需要指定<code>router</code>的名字.这个名字需要和配置中的<code>Router</code>的路径相对应.</p>
<h3 id="内置Router">内置Router</h3><p>AKKA中一共内置了8种路由策略,他们分别是:</p>
<ul>
<li><p><strong>RoundRobinPool</strong>:    这个是最常用的,轮询方式分发消息</p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">akka.actor.deployment &#123;</span><br><span class="line">  	/parent/router1 &#123;</span><br><span class="line">    	router = <span class="command">round</span>-robin-pool</span><br><span class="line">    	nr-<span class="keyword">of</span>-instances = <span class="number">5</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RandomPool</strong>:    这个是随机方式分发消息</p>
  <figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">akka.actor.deployment </span><span class="expression">&#123;</span><br><span class="line"> 		<span class="end-block">/parent</span><span class="end-block">/router</span>5 &#123;</span><br><span class="line">   		<span class="variable">router</span> = <span class="variable">random-pool</span></span><br><span class="line">   		<span class="variable">nr-of-instances</span> = 5</span><br><span class="line"> 		&#125;</span><span class="xml"></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>BalancingPool</strong>: 均衡分发消息,所有的子Routee共享一个邮箱,它会尝试重新从繁忙routee分配任务到空闲routee</p>
  <figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">akka.actor.deployment </span><span class="expression">&#123;</span><br><span class="line"> 		<span class="end-block">/parent</span><span class="end-block">/router</span>9 &#123;</span><br><span class="line">   		<span class="variable">router</span> = <span class="variable">balancing-pool</span></span><br><span class="line">   		<span class="variable">nr-of-instances</span> = 5</span><br><span class="line"> 		&#125;</span><span class="xml"></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SmallestMailboxPool</strong>:    最少消息邮箱分发,这个按照</p>
<ul>
<li>选择有空邮箱的空闲Routee处理</li>
<li>选择任意空邮箱的Routee</li>
<li>选择邮箱中有最少挂起消息的routee</li>
<li><p>选择任一远程routee,远程actor优先级最低,因为其邮箱大小未知</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">akka.actor.deployment </span><span class="expression">&#123;</span><br><span class="line"> 		<span class="end-block">/parent</span><span class="end-block">/router</span>11 &#123;</span><br><span class="line">   		<span class="variable">router</span> = <span class="variable">smallest-mailbox-pool</span></span><br><span class="line">   		<span class="variable">nr-of-instances</span> = 5</span><br><span class="line"> 		&#125;</span><span class="xml"></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>BroadcastPool</strong>:这个Router比较特殊,是广播消息,也就是一个消息会被他所有的子Actor接收到,而不仅仅是其中的某一个.</p>
  <figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">akka.actor.deployment </span><span class="expression">&#123;</span><br><span class="line"> 		<span class="end-block">/parent</span><span class="end-block">/router</span>13 &#123;</span><br><span class="line">   		<span class="variable">router</span> = <span class="variable">broadcast-pool</span></span><br><span class="line">   		<span class="variable">nr-of-instances</span> = 5</span><br><span class="line"> 		&#125;</span><span class="xml"></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ScatterGatherFirstCompletedPool</strong>:这个Router也比较特殊,它会把消息发送到它所有的子Routee中,然后它会等待直到接收到第一个答复,该结果将发送回原始发送者.而其他的答复将会被丢弃.</p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">akka.actor.deployment &#123;</span><br><span class="line"> 		/parent/router17 &#123;</span><br><span class="line">   		router = scatter-gather-pool</span><br><span class="line">   		nr-<span class="operator">of</span>-instances = <span class="number">5</span></span><br><span class="line">   		<span class="operator">within</span> = <span class="number">10</span> <span class="built_in">seconds</span></span><br><span class="line"> 		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TailChoppingPool</strong>:这个Router将首先发送消息到一个随机挑取的routee,短暂的延迟后发给第二个routee(从剩余的routee中随机挑选),以此类推.它等待第一个答复,并将它转回给原始发送者.其他答复将被丢弃.这样设计的目的在于使用冗余来加快分布式情况下的查询等业务.</p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">akka.actor.deployment &#123;</span><br><span class="line"> 		/parent/router21 &#123;</span><br><span class="line">   		router = tail-chopping-pool</span><br><span class="line">   		nr-<span class="operator">of</span>-instances = <span class="number">5</span></span><br><span class="line">   		<span class="operator">within</span> = <span class="number">10</span> <span class="built_in">seconds</span></span><br><span class="line">   		tail-chopping-router.interval = <span class="number">20</span> <span class="built_in">milliseconds</span></span><br><span class="line"> 		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ConsistentHashingPool</strong>:使用一致性hash的方式来分发消息.它会把传送的消息映射到它的消息环上,然后进行Actor的选择.</p>
  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">akka.actor.deployment &#123;</span><br><span class="line"> 		/parent/router25 &#123;</span><br><span class="line">   		<span class="variable">router =</span> consistent-hashing-pool</span><br><span class="line">   		<span class="variable">nr-of-instances =</span> <span class="number">5</span></span><br><span class="line">   		<span class="variable">virtual-nodes-factor =</span> <span class="number">10</span></span><br><span class="line"> 		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="动态改变Routee数量">动态改变Routee数量</h3><p>上述的大多数Route除了在配置或实例化的时候指定固定数量的Routee外,还能配置一个resize的策略,指定最大最小的Routee的数量:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">akka.actor.deployment &#123;</span><br><span class="line">  /router2 &#123;</span><br><span class="line">    router = <span class="built_in">round</span>-robin</span><br><span class="line">    resizer &#123;</span><br><span class="line">      <span class="built_in">lower</span>-bound = <span class="number">2</span></span><br><span class="line">      <span class="built_in">upper</span>-bound = <span class="number">15</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lowerBound = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> upperBound = <span class="number">15</span>;</span><br><span class="line">DefaultResizer resizer = <span class="keyword">new</span> DefaultResizer(lowerBound, upperBound);</span><br><span class="line">ActorRef router3 = system.actorOf(<span class="keyword">new</span> Props(ExampleActor.class).withRouter(<span class="keyword">new</span> RoundRobinRouter(nrOfInstances)));</span><br></pre></td></tr></table></figure>
<h2 id="Scheduler">Scheduler</h2><p>在实际使用AKKA中,可能会需要定时或重复的发送消息给某些Actor.要处理这类的问题,除了直接使用JAVA的API或<code>Quartz</code>显式的重复调用<code>ActorRef.tell</code>外,AKKA还提供了一个简单的Scheduler.</p>
<p>AKKA的<code>Scheduler</code>比较简单,是由<code>ActorSystem</code>提供的,可以简单的对Actor发送重复或定时任务.<br>比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActorRef actorRef = system.actorOf(Props.create(WriterActor.class));</span><br><span class="line"></span><br><span class="line">     system.scheduler().scheduleOnce(Duration.create(<span class="number">5</span>, TimeUnit.SECONDS),actorRef,<span class="string">"1111"</span>,system.dispatcher(),ActorRef.noSender());</span><br></pre></td></tr></table></figure>
<p>这个例子中,实例化了一个Actor.然后调用<code>system.scheduler()</code>获取到<code>Scheduler</code>,然后调用<code>scheduleOnce(延迟时间,目标Actor,消息,调度器,发送者)</code>方法延迟5秒再发送消息给某个Actor.</p>
<p>此外,除了延迟发送消息,Akka的<code>Scheduler</code>还提供了定时重复发送消息,比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActorRef actorRef = system.actorOf(Props.create(WriterActor.class));</span><br><span class="line"></span><br><span class="line">system.scheduler().schedule(Duration.Zero(),Duration.create(<span class="number">1</span>, TimeUnit.SECONDS),actorRef,<span class="string">"1111"</span>,system.dispatcher(),ActorRef.noSender());</span><br></pre></td></tr></table></figure>
<p>这个例子中,调用了<code>Scheduler</code>的<code>schedule(第一次调用时间,间隔时间,目标Actor,消息,调度器,发送者)</code>方法每一秒发送一个消息给Actor.</p>
<p>需要注意的是<code>Scheduler</code>的这两个方法都会返回一个<code>Cancellable</code>对象.通过这个对象,我们可以显式的调用<code>cancellable.cancel();</code>来取消重复任务.</p>
<p>其实,除了能重复的给Actor发送消息外,AKKA的<code>scheduler</code>由于可以接收<code>Runnable</code>接口,所以基本上可以做任何的事情.例如,在Spark中,AppClient中的ClientActor需要与Master这个Remote Actor通信,从而注册所有的Spark Master.由于注册过程中牵涉到远程通信,可能会因为网络原因导致通信错误,因此需要引入重试的机会.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Akka_in_JAVA(二)">Akka in JAVA(二)</h1><p>继续<a href="/2016/01/10/Akka-in-JAVA-1/">Akka in JAVA(一)</a>中所讲.</p>
<h2 id="Actor调用">Actor调用</h2><p>从上面的例子中,我们可以大概的对AKKA在JAVA中的使用有一个全局的概念.这里我们在稍微细致的讲解一下.</p>
<p>在JAVA中使用AKKA进行开发主要有这几个步骤:</p>
<ol>
<li>定义消息模型.</li>
<li>创建Actor的实现,以及业务逻辑</li>
<li>在需要使用AKKA的地方获取到ActorSystem,然后根据业务的数据流,获取到合适的Actor,给Actor发送消息.</li>
<li>在Actor的实现用,对接收到的消息进行具体的处理或转发.从而形成业务逻辑流.</li>
</ol>
<p>下面我们分别讲解一下这几个步骤.</p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Akka in JAVA(一)]]></title>
    <link href="http://sunxiang0918.github.io/2016/01/10/Akka-in-JAVA-1/"/>
    <id>http://sunxiang0918.github.io/2016/01/10/Akka-in-JAVA-1/</id>
    <published>2016-01-10T08:46:28.000Z</published>
    <updated>2016-01-23T14:44:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Akka_in_JAVA(一)">Akka in JAVA(一)</h1><h2 id="AKKA简介">AKKA简介</h2><h3 id="什么是AKKA">什么是AKKA</h3><p>Akka是一个由<code>Scala</code>编写的,能兼容<code>Sacala</code>和<code>JAVA</code>的,用于编写高可用和高伸缩性的<code>Actor模型</code>框架.它基于了事件驱动的并发处理模式,性能非常的高,并且有很高的可用性.大大的简化了我们在应用系统中开发并发处理的过程.它在各个领域都有很好的表现.</p>
<h3 id="使用AKKA的好处">使用AKKA的好处</h3><p>就如上面简介中所说的,AKKA把并发操作的各种复杂的东西都统一的做了封装.我们主要关心的是业务逻辑的实现,只需要少量的关心<code>Actor模型</code>的串联即可构建出高可用,高性能,高扩展的应用.</p>
<h3 id="Akka_for_JAVA">Akka for JAVA</h3><p>由于AKKA是使用<code>Scala</code>编写的,而<code>Scala</code>是一种基于JVM的语言.因此<code>JAVA</code>对AKKA的支持也是很不错的.Akka自身又是采用微内核的方式来实现的,这就意味着能很容易的在自己的项目中应用AKKA,只需要引入几个akka的Lib包即可.而官方直接就提供了<code>Maven</code>库供我们在JAVA中使用AKKA.<br>这些AKKA的依赖包主要有:</p>
<ul>
<li><strong>akka-actor</strong>:最核心的依赖包,里面实现了Actor模型的大部分东西</li>
<li><strong>akka-agent</strong>:代理/整合了Scala中的一些STM特性</li>
<li><strong>akka-camel</strong>:整合了Apache的Camel</li>
<li><strong>akka-cluster</strong>:akka集群依赖,封装了集群成员的管理和路由</li>
<li><strong>akka-kernel</strong>:akka的一个极简化的应用服务器,可以脱离项目单独运行.</li>
<li><strong>akka-osgi</strong>:对OSGI容器的支持,有akka的最基本的Bundle</li>
<li><strong>akka-remote</strong>:akka远程调用</li>
<li><strong>akka-slf4j</strong>:Akka的日志事件监听</li>
<li><strong>akka-testkit</strong>:Akka的各种测试工具</li>
<li><strong>akka-zeromq</strong>:整合ZeroMQ<br>其中最总要的就是<code>akka-actor</code>,最简单的AKKA使用的话,只需要引入这个包就可以了.</li>
</ul>
<a id="more"></a>
<h2 id="Actor模型">Actor模型</h2><h3 id="什么是Actor">什么是Actor</h3><p>既然说AKKA是一个<code>Actor模型</code>框架,那么就需要搞清楚什么是<code>Actor模型</code>.<code>Actor模型</code>是由<code>Carl Hewitt</code>于上世纪70年代提出的,目的是为了解决分布式编程中的一系列问题而产生.<br>在<code>Actor模型</code>中,<strong>一切都可以抽象为Actor</strong>.<br>而Actor是封装了状态和行为的对象,他们的唯一通讯方式就是交换消息,交换的消息放在接收方的邮箱(Inbox)里.也就是说Actor之间并不直接通信,而是通过了消息来相互沟通,每一个Actor都把它要做的事情都封装在了它的内部.<br>每一个Actor是可以有状态也可以是无状态的,理论上来讲,每一个Actor都拥有属于自己的轻量级线程,保护它不会被系统中的其他部分影响.因此,我们在编写Actor时,就不用担心并发的问题.<br>通过Actor能够简化锁以及线程管理,Actor具有以下的特性:</p>
<ul>
<li>提供了一种高级的抽象,能够封装状态和操作.简化并发应用的开发.</li>
<li>提供了异步的非阻塞的/高性能的事件驱动模型</li>
<li>超级轻量级的线程事件处理能力.</li>
</ul>
<p>要在JAVA中实现一个<code>Actor</code>也非常的简单,直接继承<code>akka.actor.UntypedActor</code>类,然后实现<code>public void onReceive(Object message) throws Exception</code>方法即可.</p>
<h3 id="Actor系统">Actor系统</h3><p>光有一个一个独立的Actor显然是不行的.Akka中还有一个<code>Actor System</code>.<br><code>Actor System</code>统管了<code>Actor</code>,是Actor的系统工厂或管理者,掌控了Actor的生命周期.</p>
<p><img src="/img/2016/01/10/1.png" alt=""><br>如上图所示,我们可以通过<code>ActorSystem.create</code>来创建一个ActorSystem的实例.然后通过<code>actorOf</code>等方法来获取<code>ActorRef</code>对象.<code>ActorRef</code>即为<code>Actor Reference</code>.它是Actor的一个引用,主要的作用是发送消息给它表示的Actor.而Actor可以通过访问<code>self()</code>或<code>sender()</code>方法来获取到自身或消息发送者的Actor引用.通过引用发送消息.在Akka中,Actor之间永远都不能直接的通信,必须通过他们的代理<code>ActorRef</code>建立通信.</p>
<h3 id="Actor路径">Actor路径</h3><p>为了实现一切事物都是Actor,为了能把一个复杂的事物划分的更细致.Akka引入了父子Actor.也就是Actor是有树形结构的关系的.这样的父子结构就能递归的把任何复杂的事物原子化.这也是Actor模型的精髓所在.这样做不仅使任务本身被清晰地划分出结构,而且最终的Actor也能按照他们明确的消息类型以及处理流程来进行解析.这样的递归结构使得消息能够在正确的层次进行处理.</p>
<p><img src="/img/2016/01/10/2.png" alt=""></p>
<p>为了能管理父子结构的Actor,Akka又引入了<code>Actor Path</code>,也就是Actor路径.<br>Actor路径使用类似于URL的方式来描述一个Actor,<code>Actor Path</code>在一个<code>Actor System</code>中是唯一的.通过路径,可以很明确的看出某个Actor的父级关系是怎样的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//本地Actor</span><br><span class="line"><span class="string">"akka://my-sys/user/service-a/worker1"</span></span><br><span class="line"></span><br><span class="line">//远程Actor</span><br><span class="line"><span class="string">"akka.tcp://my-sys@host.example.com:2552/user/service-b"</span></span><br><span class="line"></span><br><span class="line">//集群Actor服务</span><br><span class="line"><span class="string">"cluster://my-cluster/service-c"</span></span><br></pre></td></tr></table></figure>
<p>以上三种就是Akka中支持的<code>Actor</code>路径. 每一个通过ActorSystem创建出来的Actor都会有一个这样的路径.也可以通过这个路径从ActorSystem中获取一个<code>Actor</code>.</p>
<p>当我们创建一个ActorSystem的时候,AKKA会为该System默认的创建三个Actor,并处于不同的层次:</p>
<p><img src="/img/2016/01/10/3.png" alt=""><br>其中的<code>root guardian</code>是所有Actor的父.<br>而<code>User</code>Actor是所有用户创建的Actor的父.它的路径是<code>/user</code>,通过system.actorOf()创建出来的Actor都算是用户的Actor,也都是这个Actor的子.<br><code>System</code>Actor是所有系统创建的Actor的父.它的路径是<code>/system</code>,主要的作用是提供了一系列的系统的功能.</p>
<p>当我们查找一个Actor的时候,可以使用ActorSystem.actorSelection()方法.并且可以使用绝对路径或者相对路径来获取.如果是相对路径,那么<code>..</code>表示的是父Actor.比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActorSelection selection = system.actorSelection(<span class="string">"../brother"</span>);</span><br><span class="line">ActorRef actor = selection.anchor();</span><br><span class="line">selection.tell(xxx);</span><br></pre></td></tr></table></figure>
<p>同时,也可以通过通配符来查询逻辑的Actor层级,比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ActorSelection selection = system.actorSelection(<span class="string">"../*"</span>);</span><br><span class="line">selection.tell(xxx);</span><br></pre></td></tr></table></figure>
<p>这个就表示把消息发送给当前Actor之外的所有同级的Actor.</p>
<h2 id="Hello_AKKA_Demo">Hello AKKA Demo</h2><p>原理讲了这么多,那么我们就来看一看一个最简单的Akka的例子吧.<br>这个是一个最简单的打招呼的例子,这个例子中,定义了招呼,打招呼的人两个对象或者说消息.然后定义了执行打招呼和打印招呼两个Actor.然后通过ActorSystem整合整个打招呼的过程.</p>
<p><strong>Greet.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 用于表示执行打招呼这个操作的消息</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:43</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Greeting.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 招呼体,里面有打的什么招呼</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:44</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Greeting</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>WhoToGreet.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 打招呼的人</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:41</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhoToGreet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String who;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WhoToGreet</span><span class="params">(String who)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.who = who;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Greeter.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 打招呼的Actor</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:40</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String greeting = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> WhoToGreet)</span><br><span class="line">            greeting = <span class="string">"hello, "</span> + ((WhoToGreet) message).who;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Greet)</span><br><span class="line">            <span class="comment">// 发送招呼消息给发送消息给这个Actor的Actor</span></span><br><span class="line">            getSender().tell(<span class="keyword">new</span> Greeting(greeting), getSelf());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> unhandled(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>GreetPrinter.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 打印招呼</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:45</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetPrinter</span> <span class="keyword">extends</span> <span class="title">UntypedActor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Greeting)</span><br><span class="line">            System.out.println(((Greeting) message).message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DemoMain.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@author</span> SUN</span><br><span class="line"> * <span class="doctag">@version</span> 1.0</span><br><span class="line"> * <span class="doctag">@Date</span> 16/1/6 21:39</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ActorSystem system = ActorSystem.create(<span class="string">"helloakka"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个到greeter Actor的管道</span></span><br><span class="line">        <span class="keyword">final</span> ActorRef greeter = system.actorOf(Props.create(Greeter.class), <span class="string">"greeter"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建邮箱</span></span><br><span class="line">        <span class="keyword">final</span> Inbox inbox = Inbox.create(system);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先发第一个消息,消息类型为WhoToGreet</span></span><br><span class="line">        greeter.tell(<span class="keyword">new</span> WhoToGreet(<span class="string">"akka"</span>), ActorRef.noSender());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正的发送消息,消息体为Greet</span></span><br><span class="line">        inbox.send(greeter, <span class="keyword">new</span> Greet());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待5秒尝试接收Greeter返回的消息</span></span><br><span class="line">        Greeting greeting1 = (Greeting) inbox.receive(Duration.create(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(<span class="string">"Greeting: "</span> + greeting1.message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送第三个消息,修改名字</span></span><br><span class="line">        greeter.tell(<span class="keyword">new</span> WhoToGreet(<span class="string">"typesafe"</span>), ActorRef.noSender());</span><br><span class="line">        <span class="comment">// 发送第四个消息</span></span><br><span class="line">        inbox.send(greeter, <span class="keyword">new</span> Greet());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待5秒尝试接收Greeter返回的消息</span></span><br><span class="line">        Greeting greeting2 = (Greeting) inbox.receive(Duration.create(<span class="number">5</span>, TimeUnit.SECONDS));</span><br><span class="line">        System.out.println(<span class="string">"Greeting: "</span> + greeting2.message);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新创建一个Actor的管道</span></span><br><span class="line">        ActorRef greetPrinter = system.actorOf(Props.create(GreetPrinter.class));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用schedule 每一秒发送一个Greet消息给 greeterActor,然后把greeterActor的消息返回给greetPrinterActor </span></span><br><span class="line">        system.scheduler().schedule(Duration.Zero(), Duration.create(<span class="number">1</span>, TimeUnit.SECONDS), greeter, <span class="keyword">new</span> Greet(), system.dispatcher(), greetPrinter);</span><br><span class="line">        <span class="comment">//system.shutdown();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是整个Demo的所有代码,并不多.接下来我们就分析一下这个程序.</p>
<p>首先是定义的几个消息.在Akka中传递的消息必须实现<code>Serializable</code>接口.<code>WhoToGreet</code>消息表示了打招呼的人,<code>Greeting</code>表示了招呼的内容,而<code>Greet</code>表示了打招呼这个动作.</p>
<p>接着就是两个最重要的Actor了.<code>GreetPrinter</code>非常简单,接收到消息后,判断消息的类型,如果是<code>Greeting</code>招呼内容,那么就直接打印消息到控制台.而<code>Greeter</code>这个Actor稍微复杂点,它消费两种不同的消息,如果是<code>WhoToGreet</code>,那么就把要打招呼的人记录到自己的上下文中,如果是<code>Greet</code>,那么就构造出招呼的内容,并把消息反馈回sender.</p>
<p>最后,再来分析下DemoMain.</p>
<ol>
<li>一来,先创建了一个<code>ActorSystem</code>,</li>
<li>然后创建了一个<code>Greeter</code>Actor的实例,命名为<code>greeter</code>.</li>
<li>接着,为这个Actor,显示的创建了一个<code>邮箱</code>.</li>
<li>而后,调用<code>greeter.tell(new WhoToGreet(&quot;akka&quot;), ActorRef.noSender());</code>,表示给greeter这个Actor发送一个消息,消息的内容是<code>WhoToGreet</code>,发送者是空.这就意味着在greeter这个Actor内部,调用sender是不能获取到发送者的.通过这个动作,就把消息限定为了单向的.</li>
<li>再然后,通过<code>inbox.send(greeter, new Greet());</code>,使用邮箱显示的发送一个Greet消息给greeter.这是给Actor发送消息的另外一种方法,这种方法通常会有更高的自主性,能完成更多更复杂的操作.但是调用起来比直接使用<code>ActorRef</code>来的复杂.</li>
<li><code>Greeting greeting1 = (Greeting) inbox.receive(Duration.create(5, TimeUnit.SECONDS));</code>表示的就是尝试在5秒钟内,从<code>Inbox</code>邮箱中获取到反馈消息.如果5秒内没有获取到,那么就抛出<code>TimeoutException</code>异常. 由于我们在greeter这个Actor中有处理,接收到<code>Greet</code>消息后,就构造一个<code>Greeting</code>消息给<code>sender</code>,因此这个地方是能够正确的获取到消息的反馈的.</li>
<li>后面的操作都是一样的,就不再重复描述.</li>
<li>只有最后一个代码稍微有点不一样<code>system.scheduler().schedule(Duration.Zero(), Duration.create(1, TimeUnit.SECONDS), greeter, new Greet(), system.dispatcher(), greetPrinter);</code>,这个使用了<code>ActorSystem</code>中的调度功能.每一秒钟给greeter这个Actor发送一个<code>Greet</code>消息,并指定消息的发送者是<code>greetPrinter</code>.这样每隔一秒钟,greeter就会收到<code>Greet</code>消息,然后构造成<code>Greeting</code>消息,又返回给<code>GreetPrinter</code>这个Actor,这个Actor接收到消息后,打印出来.形成一个环流.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Akka_in_JAVA(一)">Akka in JAVA(一)</h1><h2 id="AKKA简介">AKKA简介</h2><h3 id="什么是AKKA">什么是AKKA</h3><p>Akka是一个由<code>Scala</code>编写的,能兼容<code>Sacala</code>和<code>JAVA</code>的,用于编写高可用和高伸缩性的<code>Actor模型</code>框架.它基于了事件驱动的并发处理模式,性能非常的高,并且有很高的可用性.大大的简化了我们在应用系统中开发并发处理的过程.它在各个领域都有很好的表现.</p>
<h3 id="使用AKKA的好处">使用AKKA的好处</h3><p>就如上面简介中所说的,AKKA把并发操作的各种复杂的东西都统一的做了封装.我们主要关心的是业务逻辑的实现,只需要少量的关心<code>Actor模型</code>的串联即可构建出高可用,高性能,高扩展的应用.</p>
<h3 id="Akka_for_JAVA">Akka for JAVA</h3><p>由于AKKA是使用<code>Scala</code>编写的,而<code>Scala</code>是一种基于JVM的语言.因此<code>JAVA</code>对AKKA的支持也是很不错的.Akka自身又是采用微内核的方式来实现的,这就意味着能很容易的在自己的项目中应用AKKA,只需要引入几个akka的Lib包即可.而官方直接就提供了<code>Maven</code>库供我们在JAVA中使用AKKA.<br>这些AKKA的依赖包主要有:</p>
<ul>
<li><strong>akka-actor</strong>:最核心的依赖包,里面实现了Actor模型的大部分东西</li>
<li><strong>akka-agent</strong>:代理/整合了Scala中的一些STM特性</li>
<li><strong>akka-camel</strong>:整合了Apache的Camel</li>
<li><strong>akka-cluster</strong>:akka集群依赖,封装了集群成员的管理和路由</li>
<li><strong>akka-kernel</strong>:akka的一个极简化的应用服务器,可以脱离项目单独运行.</li>
<li><strong>akka-osgi</strong>:对OSGI容器的支持,有akka的最基本的Bundle</li>
<li><strong>akka-remote</strong>:akka远程调用</li>
<li><strong>akka-slf4j</strong>:Akka的日志事件监听</li>
<li><strong>akka-testkit</strong>:Akka的各种测试工具</li>
<li><strong>akka-zeromq</strong>:整合ZeroMQ<br>其中最总要的就是<code>akka-actor</code>,最简单的AKKA使用的话,只需要引入这个包就可以了.</li>
</ul>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在IOS中使用swift调用系统相机]]></title>
    <link href="http://sunxiang0918.github.io/2016/01/02/%E5%9C%A8IOS%E4%B8%AD%E4%BD%BF%E7%94%A8swift%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA/"/>
    <id>http://sunxiang0918.github.io/2016/01/02/在IOS中使用swift调用系统相机/</id>
    <published>2016-01-02T12:03:41.000Z</published>
    <updated>2016-01-10T13:48:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在IOS中使用swift调用系统相机">在IOS中使用swift调用系统相机</h1><p>在IOS的APP开发中,很容易就会遇到使用拍照或录制视频的功能.如果要求并不是太多的话,最简单方式就是调用系统自带的图像获取器<code>UIImagePickerController</code>. </p>
<p>由于<code>UIImagePickerController</code>继承自<code>UINavigationController</code>,所以它的<code>delegate</code>需要实现<code>UIImagePickerControllerDelegate</code>和<code>UINavigationControllerDelegate</code>两个协议.</p>
<h2 id="基本知识">基本知识</h2><p>要使用这个类主要要做以下几件事情:</p>
<ol>
<li>首先要创建一个全局的<code>UIImagePickerController</code>实例.</li>
<li>判断设备是否支持数据来源:<ul>
<li><code>UIImagePickerController.isSourceTypeAvailable(.Camera)</code></li>
<li><code>UIImagePickerController.isSourceTypeAvailable(.PhotoLibrary)</code></li>
<li><code>UIImagePickerController.isSourceTypeAvailable(.SavedPhotosAlbum)</code></li>
</ul>
</li>
<li><p>然后指定数据的来源.一共有三种来源:</p>
<ul>
<li><code>UIImagePickerControllerSourceType.PhotoLibrary</code>    来自系统图库</li>
<li><code>UIImagePickerControllerSourceType.Camera</code>       来自相机</li>
<li><code>UIImagePickerControllerSourceType.SavedPhotosAlbum</code>      来自相册</li>
</ul>
</li>
<li><p>如果数据来源是相机,那么还需要设置相机的捕获模式<code>cameraCaptureMode</code>. 主要分为<code>.Photo</code>和<code>.Video</code></p>
</li>
<li><p>实现各种代理方法接收保存和获取图像的方法.</p>
</li>
<li><p>设置媒体类型,<code>UIImagePickerController</code>根据这个的值来决定选择或拍摄的媒体类型.这个是一个[String] 字符串数组.多个值就表明了可以在拍摄的界面上切换.需要注意的是这个<code>mediaTypes</code>的定义是在<code>MobileCoreService</code>框架下的.当然也可以直接使用<code>String</code>的常量来描述.常用的媒体类型为:</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">常量名</th>
<th style="text-align:center">常量值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kUTTypeImage</td>
<td style="text-align:center">public.image</td>
<td style="text-align:center">照片</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeMovie</td>
<td style="text-align:center">public.movie</td>
<td style="text-align:center">音视频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeVideo</td>
<td style="text-align:center">public.video</td>
<td style="text-align:center">纯视频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeAudio</td>
<td style="text-align:center">public.audio</td>
<td style="text-align:center">纯音频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeLivePhoto</td>
<td style="text-align:center">com.apple.live-photo</td>
<td style="text-align:center">IOS9的动态照片(关于动态图片后面再单独开博文来说)</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>除了上面说的几个设置外,在使用<code>UIImagePickerController</code>过程中可能还用得到的设置主要有:</p>
<ul>
<li><strong>modalTransitionStyle</strong>:        取景框出现效果</li>
<li><strong>allowsEditing</strong>:    是否允许编辑,只有在<code>showsCameraControls</code>属性为<code>true</code>时才有效</li>
<li><strong>showsCameraControls</strong>:  是否显示拍照时的工具栏,如果要自定义拍摄界面,需要把这个工具栏隐藏掉</li>
<li><strong>videoMaximumDuration</strong>: 录制视频的时长, 默认是10秒</li>
<li><strong>videoQuality</strong>:  视频质量,枚举定义在<code>UIImagePickerControllerQualityType</code>中</li>
<li><strong>cameraDevice</strong>: 前置,还是后置摄像头,枚举定义在<code>UIImagePickerControllerCameraDevice</code></li>
<li><strong>cameraFlashMode</strong>:闪光灯模式,枚举定义在<code>UIImagePickerControllerCameraFlashMode</code></li>
</ul>
<p>有了这些准备,就可以开始来实现一个最简单的DEMO了.</p>
<h2 id="Demo">Demo</h2><p>DEMO很简单,在一个APP上增加一个按钮,点击这个按钮,打开系统自带的摄像头.然后可以进行拍摄,最后把拍摄结果保存到相册中.</p>
<ol>
<li><p>首先先创建一个<code>UIImagePickerController</code>:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imagePickerController:<span class="type">UIImagePickerController</span> = <span class="type">UIImagePickerController</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>给某个ViewController上增加<code>UIImagePickerControllerDelegate</code>和<code>UINavigationControllerDelegate</code>两个协议.</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">UIImagePickerControllerDelegate</span>,<span class="title">UINavigationControllerDelegate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">		imagePickerController.delegate = <span class="keyword">self</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后设置PickerController的初始值:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">imagePickerController.modalTransitionStyle = .<span class="type">FlipHorizontal</span></span><br><span class="line">   imagePickerController.allowsEditing = <span class="literal">true</span>	<span class="comment">//是否允许编辑</span></span><br><span class="line">   imagePickerController.sourceType = .<span class="type">Camera</span>	<span class="comment">//数据来源为摄像头</span></span><br><span class="line">    imagePickerController.videoMaximumDuration = <span class="number">15</span>      <span class="comment">//模式录制视频长度,单位秒</span></span><br><span class="line">    imagePickerController.mediaTypes = [<span class="string">"public.image"</span>,<span class="string">"public.movie"</span>]        <span class="comment">//允许的相机类型(拍照,摄像....)</span></span><br><span class="line">    imagePickerController.videoQuality = .<span class="type">TypeHigh</span>		     <span class="comment">//视频质量</span></span><br><span class="line">    imagePickerController.cameraCaptureMode = .<span class="type">Photo</span>		<span class="comment">//初始摄像头的模式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置界面按钮的事件响应,在相应中增加打开<code>imagePickerController</code>视图的方法:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.presentViewController(imagePickerController, animated: <span class="literal">true</span>) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现完成照片或视频的拍摄回调代理方法:<code>func imagePickerController(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject])</code>:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject])</span></span> &#123;</span><br><span class="line">	  <span class="comment">//获取媒体的类型</span></span><br><span class="line">       <span class="keyword">let</span> mediaType = info[<span class="type">UIImagePickerControllerMediaType</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//如果媒体是照片</span></span><br><span class="line">       <span class="keyword">if</span> mediaType == kUTTypeImage <span class="keyword">as</span> <span class="type">String</span> &#123;</span><br><span class="line">           <span class="comment">//获取到拍摄的照片, UIImagePickerControllerEditedImage是经过剪裁过的照片,UIImagePickerControllerOriginalImage是原始的照片</span></span><br><span class="line">           <span class="keyword">let</span> image = info[<span class="type">UIImagePickerControllerEditedImage</span>] <span class="keyword">as</span>! <span class="type">UIImage</span></span><br><span class="line">           </span><br><span class="line">           <span class="comment">//调用方法保存到图像库中</span></span><br><span class="line">           <span class="type">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>,<span class="string">"image:didFinishSavingWithError:contextInfo:"</span>, <span class="literal">nil</span>)</span><br><span class="line">           </span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//视频</span></span><br><span class="line">           <span class="comment">//获取到视频的临时路径</span></span><br><span class="line">           <span class="keyword">let</span> urlStr =  (info[<span class="type">UIImagePickerControllerMediaURL</span>] <span class="keyword">as</span>! <span class="type">NSURL</span>).path</span><br><span class="line">           <span class="comment">//启动异步线程保存视频到图像库中</span></span><br><span class="line">           dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">           <span class="comment">//调用方法保存到图像库中</span></span><br><span class="line">               <span class="type">UISaveVideoAtPathToSavedPhotosAlbum</span>(urlStr!, <span class="keyword">self</span>, <span class="string">"video:didFinishSavingWithError:contextInfo:"</span>, <span class="literal">nil</span>)</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//关闭照相框</span></span><br><span class="line">       <span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现完成保存后的结果回调方法<code>func image(image: UIImage, didFinishSavingWithError error: NSError?, contextInfo:UnsafePointer&lt;Void&gt;)</code>:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">image</span><span class="params">(image: UIImage, didFinishSavingWithError error: NSError?, contextInfo:UnsafePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> ac = <span class="type">UIAlertController</span>(title: <span class="string">"Saved!"</span>, message: <span class="string">"成功保存照片到图库"</span>, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">           ac.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">           presentViewController(ac, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> ac = <span class="type">UIAlertController</span>(title: <span class="string">"Save error"</span>, message: error?.localizedDescription, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">           ac.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">           presentViewController(ac, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现完成保存视频后的结果回调方法<code>func video(videoPath: String, didFinishSavingWithError error: NSError?, contextInfo:UnsafePointer&lt;Void&gt;)</code>:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">video</span><span class="params">(videoPath: String, didFinishSavingWithError error: NSError?, contextInfo:UnsafePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> error == <span class="literal">nil</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> ac = <span class="type">UIAlertController</span>(title: <span class="string">"Saved!"</span>, message: <span class="string">"成功保存视频到图库"</span>, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">           ac.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">           presentViewController(ac, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">let</span> ac = <span class="type">UIAlertController</span>(title: <span class="string">"Save error"</span>, message: error?.localizedDescription, preferredStyle: .<span class="type">Alert</span>)</span><br><span class="line">           ac.addAction(<span class="type">UIAlertAction</span>(title: <span class="string">"OK"</span>, style: .<span class="type">Default</span>, handler: <span class="literal">nil</span>))</span><br><span class="line">           presentViewController(ac, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样就完成了打开系统相机,并把拍摄的结果放入系统默认的相薄中的全部功能了.</p>
<h2 id="自定义相薄">自定义相薄</h2><p>到目前为止照片等都是保存到系统默认的<code>相机胶卷</code>这个相薄中. 但是像<code>QQ</code> <code>微信</code>这些应用都是可以把图片存放到自己的相薄中的.这就要求程序中对相薄进行操作了.</p>
<p>在IOS9中,要操作相薄的话,需要引入<code>import Photos</code>库.然后使用<code>PHPhotoLibrary</code>这个类.</p>
<p>先说创建相薄:</p>
<ol>
<li><p>首先需要定义一个<code>PHAssetCollection</code>对象:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">var</span> assetCollection:<span class="type">PHAssetCollection</span>?</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增一个创建相薄的方法<code>createAlbum</code>: </p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createAlbum</span><span class="params">()</span></span> &#123;</span><br><span class="line">	 <span class="comment">//创建一个FetchOptions,属性选择器</span></span><br><span class="line">       <span class="keyword">let</span> fetchOptions = <span class="type">PHFetchOptions</span>()</span><br><span class="line">       <span class="comment">//指定相薄的名称</span></span><br><span class="line">       fetchOptions.predicate = <span class="type">NSPredicate</span>(format: <span class="string">"title = %@"</span>, <span class="string">"测试用"</span>)</span><br><span class="line">       <span class="comment">//获取相薄的对象</span></span><br><span class="line">       <span class="keyword">let</span> collection = <span class="type">PHAssetCollection</span>.fetchAssetCollectionsWithType(.<span class="type">Album</span>, subtype: .<span class="type">Any</span>, options: fetchOptions)</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//如果查询出的第一个对象存在,那么就说明相薄已经存在了,直接赋值</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = collection.firstObject &#123;</span><br><span class="line">           assetCollection =  collection.firstObject <span class="keyword">as</span>? <span class="type">PHAssetCollection</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">       	  <span class="comment">//否则需要创建一个新的相薄</span></span><br><span class="line">           <span class="keyword">var</span> assetCollectionPlaceholder:<span class="type">PHObjectPlaceholder</span>!</span><br><span class="line">           <span class="comment">//调用performChanges方法来创建相薄</span></span><br><span class="line">           <span class="type">PHPhotoLibrary</span>.sharedPhotoLibrary().performChanges(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">               <span class="comment">//根据title来创建一个相薄的请求</span></span><br><span class="line">               <span class="keyword">let</span> createAlbumRequest = <span class="type">PHAssetCollectionChangeRequest</span>.creationRequestForAssetCollectionWithTitle(<span class="string">"测试用"</span>)</span><br><span class="line">               <span class="comment">//获取出请求中的placeholder</span></span><br><span class="line">               assetCollectionPlaceholder = createAlbumRequest.placeholderForCreatedAssetCollection</span><br><span class="line">               &#125;) &#123; (success, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                   <span class="comment">//创建完成的回调</span></span><br><span class="line">                   <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                       <span class="type">NSLog</span>(<span class="string">"Error creating album: <span class="subst">\(error)</span>"</span>);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   	<span class="comment">//如果创建成功.那么就要获取到PHAssetCollection,只有有了这个才能把照片存放到这个相薄中</span></span><br><span class="line">                       <span class="keyword">let</span> collectionFetchResult = <span class="type">PHAssetCollection</span>.fetchAssetCollectionsWithLocalIdentifiers([assetCollectionPlaceholder.localIdentifier], options: <span class="literal">nil</span>)</span><br><span class="line">                       <span class="keyword">self</span>.assetCollection =  collectionFetchResult.firstObject <span class="keyword">as</span>? <span class="type">PHAssetCollection</span></span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建完成相薄后,就可以保存照片到相薄中了: </p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imagePickerController</span><span class="params">(picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : AnyObject])</span></span> &#123;</span><br><span class="line">       <span class="keyword">let</span> mediaType = info[<span class="type">UIImagePickerControllerMediaType</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//尝试创建相薄</span></span><br><span class="line">       createAlbum()</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> mediaType == kUTTypeImage <span class="keyword">as</span> <span class="type">String</span> &#123;</span><br><span class="line">           <span class="comment">//图片</span></span><br><span class="line">           <span class="keyword">let</span> image = info[<span class="type">UIImagePickerControllerEditedImage</span>] <span class="keyword">as</span>! <span class="type">UIImage</span></span><br><span class="line">           <span class="comment">//使用线程同步     </span></span><br><span class="line">                  dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), &#123;</span><br><span class="line">               <span class="comment">//保存到自定义的相薄中</span></span><br><span class="line">               <span class="type">PHPhotoLibrary</span>.sharedPhotoLibrary().performChanges(&#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                   <span class="comment">//根据相片得到保存的请求</span></span><br><span class="line">                   <span class="keyword">let</span> assetRequest = <span class="type">PHAssetChangeRequest</span>.creationRequestForAssetFromImage(image)</span><br><span class="line">                   <span class="comment">//找到placehodler</span></span><br><span class="line">                   <span class="keyword">let</span> assetPlaceholder = assetRequest.placeholderForCreatedAsset</span><br><span class="line">                   <span class="comment">//创建photosAsset</span></span><br><span class="line">                   <span class="keyword">let</span> photosAsset = <span class="type">PHAsset</span>.fetchAssetsInAssetCollection(<span class="keyword">self</span>.assetCollection!, options: <span class="literal">nil</span>)</span><br><span class="line">                   <span class="comment">//实例化 保存事件</span></span><br><span class="line">                   <span class="keyword">if</span> <span class="keyword">let</span> albumChangeRequest = <span class="type">PHAssetCollectionChangeRequest</span>(forAssetCollection: <span class="keyword">self</span>.assetCollection!, assets: photosAsset) &#123;</span><br><span class="line">                   	<span class="comment">//执行相薄照片的保存</span></span><br><span class="line">                       albumChangeRequest.addAssets([assetPlaceholder!])</span><br><span class="line">                   &#125;</span><br><span class="line">                   </span><br><span class="line">                   &#125;, completionHandler: &#123; (success, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                       dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">                           <span class="type">NSLog</span>(<span class="string">"Adding Image to Library -&gt; %@"</span>, (success ? <span class="string">"Sucess"</span>:<span class="string">"Error!"</span>))</span><br><span class="line">                           <span class="comment">//</span></span><br><span class="line">                           <span class="keyword">if</span> !success &#123;</span><br><span class="line">                               <span class="comment">//表示没有保存成功,尝试保存到系统自带的里面</span></span><br><span class="line">                               <span class="comment">//保存到图库</span></span><br><span class="line">                               <span class="type">UIImageWriteToSavedPhotosAlbum</span>(image, <span class="keyword">self</span>,<span class="string">"image:didFinishSavingWithError:contextInfo:"</span>, <span class="literal">nil</span>)</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//保存陈红</span></span><br><span class="line">                           <span class="keyword">self</span>.dismissViewControllerAnimated(<span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">                       &#125;)</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;)</span><br><span class="line">           </span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//视频</span></span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如此就能保存相片到自定义的相薄中了,其实对相薄还可以有其他的操作,比如列出所有相薄的名字,删除相薄等等.这个具体的参考<code>PHPhotoLibrary</code>类即可.</p>
<h2 id="总结">总结</h2><p>本文简单的介绍了一下,如何调用系统自带的相机和相册来进行照片和视频的拍摄.同时也介绍了如何自定义相薄,为以后更高级的拍摄功能做了准备.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在IOS中使用swift调用系统相机">在IOS中使用swift调用系统相机</h1><p>在IOS的APP开发中,很容易就会遇到使用拍照或录制视频的功能.如果要求并不是太多的话,最简单方式就是调用系统自带的图像获取器<code>UIImagePickerController</code>. </p>
<p>由于<code>UIImagePickerController</code>继承自<code>UINavigationController</code>,所以它的<code>delegate</code>需要实现<code>UIImagePickerControllerDelegate</code>和<code>UINavigationControllerDelegate</code>两个协议.</p>
<h2 id="基本知识">基本知识</h2><p>要使用这个类主要要做以下几件事情:</p>
<ol>
<li>首先要创建一个全局的<code>UIImagePickerController</code>实例.</li>
<li>判断设备是否支持数据来源:<ul>
<li><code>UIImagePickerController.isSourceTypeAvailable(.Camera)</code></li>
<li><code>UIImagePickerController.isSourceTypeAvailable(.PhotoLibrary)</code></li>
<li><code>UIImagePickerController.isSourceTypeAvailable(.SavedPhotosAlbum)</code></li>
</ul>
</li>
<li><p>然后指定数据的来源.一共有三种来源:</p>
<ul>
<li><code>UIImagePickerControllerSourceType.PhotoLibrary</code>    来自系统图库</li>
<li><code>UIImagePickerControllerSourceType.Camera</code>       来自相机</li>
<li><code>UIImagePickerControllerSourceType.SavedPhotosAlbum</code>      来自相册</li>
</ul>
</li>
<li><p>如果数据来源是相机,那么还需要设置相机的捕获模式<code>cameraCaptureMode</code>. 主要分为<code>.Photo</code>和<code>.Video</code></p>
</li>
<li><p>实现各种代理方法接收保存和获取图像的方法.</p>
</li>
<li><p>设置媒体类型,<code>UIImagePickerController</code>根据这个的值来决定选择或拍摄的媒体类型.这个是一个[String] 字符串数组.多个值就表明了可以在拍摄的界面上切换.需要注意的是这个<code>mediaTypes</code>的定义是在<code>MobileCoreService</code>框架下的.当然也可以直接使用<code>String</code>的常量来描述.常用的媒体类型为:</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">常量名</th>
<th style="text-align:center">常量值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kUTTypeImage</td>
<td style="text-align:center">public.image</td>
<td style="text-align:center">照片</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeMovie</td>
<td style="text-align:center">public.movie</td>
<td style="text-align:center">音视频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeVideo</td>
<td style="text-align:center">public.video</td>
<td style="text-align:center">纯视频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeAudio</td>
<td style="text-align:center">public.audio</td>
<td style="text-align:center">纯音频</td>
</tr>
<tr>
<td style="text-align:center">kUTTypeLivePhoto</td>
<td style="text-align:center">com.apple.live-photo</td>
<td style="text-align:center">IOS9的动态照片(关于动态图片后面再单独开博文来说)</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再见2015]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/31/%E5%86%8D%E8%A7%812015/"/>
    <id>http://sunxiang0918.github.io/2015/12/31/再见2015/</id>
    <published>2015-12-31T14:13:48.000Z</published>
    <updated>2016-01-01T16:12:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="再见2015">再见2015</h1><p>时光匆匆,转眼2015年就要过去了.2015开年的事情仿佛刚过去没有多久,2016又要来了.今年是忙碌的一年,不管是在生活上还是在工作上都发生了很多的变化.本文将回顾一下作为程序猿的自己在今年的成长,做一个简单的总结.</p>
<h2 id="博客">博客</h2><p>今年年中,自己在github.io上搭建了自己的个人博客,并且把以前的一些文章从evernote上迁移了过来.以前,从来没有写博客的习惯,一个是觉得写博客比较麻烦,因为可能不是自己一个人看,不能像在evernote上那样随便乱写.还有一个就是觉得东西有个地方保存就好了,没必要分享出来.不过,最后还是决定把博客搭建出来,既能锻炼自己的书写,也能强迫自己把东西记录的更规范更细致,最后也能分享给有需要的人.从事了5年的软件行业了,渐渐的开始理解开源人的心态了,也从各位开源的大神中得到了很多的好处,是时候把自己力所能及的东西分享出来了.</p>
<p>今年一共写了<a href="/archives/2015">43篇博客</a>,从数量上来说不算多.主要涉及的是<code>JAVA研发体系</code>以及<code>Swift</code>方面的内容.<br>对于明年,目标是60篇博客,内容上更有深度与广度.希望能够达成.</p>
<a id="more"></a>
<h2 id="阅读">阅读</h2><p>今年阅读的书不多,更大的变化是技术类的书从以前的只阅读实体书,到渐渐的开始接受电子书了.</p>
<table>
<thead>
<tr>
<th style="text-align:left">书名</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">完成度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://book.douban.com/subject/26274206/" target="_blank" rel="external">写给大忙人看的JAVA SE8</a></td>
<td style="text-align:center">实体书</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://book.douban.com/subject/26261153/" target="_blank" rel="external">Spark大数据处理</a></td>
<td style="text-align:center">实体书</td>
<td style="text-align:center">60%</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://book.douban.com/subject/2347790/" target="_blank" rel="external">敏捷软件开发 原则,模式与实践</a></td>
<td style="text-align:center">实体书</td>
<td style="text-align:center">重读</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://github.com/numbbbbb/the-swift-programming-language-in-chinese" target="_blank" rel="external">The Swift Programming Language</a></td>
<td style="text-align:center">电子书</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://leanpub.com/swifter" target="_blank" rel="external">SWIFTER 100个Swift必备Tips</a></td>
<td style="text-align:center">电子书</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker —— 从入门到实践</a></td>
<td style="text-align:center">电子书</td>
<td style="text-align:center">完成</td>
</tr>
<tr>
<td style="text-align:left">快学Scala</td>
<td style="text-align:center">PDF电子书</td>
<td style="text-align:center">40%</td>
</tr>
</tbody>
</table>
<h2 id="团队实践">团队实践</h2><p>今年由于公司新开项目的原因,能够有机会对团队的运作有较大的改变.<br>首先,终于把所有的代码都从SVN上迁移到了GIT上.这个过程看似简单,其实是比较麻烦的.当一个团队在SVN上都搞了5年了,然后更换了整个工作的流程,并不是想象中的这么容易的.要让十多号人都熟悉GIT的概念,熟悉基于分支的开发模式.终于彻底贯彻了我在2012年摘抄到evernote上&lt;<a href="/2012/08/18/A-successful-Git-branching-model/">A successful Git branching model</a>&gt;这篇文章上所描述的工作模式.感觉到了GIT的强大与方便.<br>其次,尝试在项目中引入SCRUM敏捷开发,由于团队人数不多,需求比较灵活.因此,尝试了引入SCRUM敏捷开发,并且使用了Teambition作为管理工具,每天进行站立会议,阶段评审等等.就目前执行了3个多月的效果来看,一半的一半.一半的成功是坚持了站立会议,阶段任务制定,阶段成果评审等等,确实清晰了当前的项目状态.一半的失败是没有坚持下来使用Teambition工具,并且任务墙也没有坚持下来.除了让所有团队成员事无巨细的拆分任务和记录任务状态不容易外,自己对于Scrum的不熟悉也是一个原因.搞了这么多年的瀑布式开发,开发的习惯还没有更改过来.<br>希望明年会有进步,把任务墙的机制彻底的落实下来.</p>
<h2 id="JAVA">JAVA</h2><p>今年在JAVA方面主要的进步是在于扩展了大数据方面的知识.以前搞了这么久的JAVA,一直停留在了JAVA语言本身,各种业务逻辑,J2EE,检索引擎这些上面.而今年开始有机会接触了<code>Hadoop</code>,<code>HBase</code>,<code>HIVE</code>,<code>Spark</code>这些东西,虽然还很基础.不过总算也是入门了.<br>明年的目标就是以项目作为机会深入的了解大数据,以及数据挖掘方面的东西.</p>
<h2 id="互联网技术">互联网技术</h2><p>今年还有一个显著的变化就是接触了大量的互联网的技术.公司的新项目是一个类似于互联网的项目,因此需要掌握一些以前接触比较少的互联网技术.比如:<code>mongoDB</code>,<code>Kafka</code>,<code>Redis</code>,<code>Zabbix</code>,<code>ELK</code>,<code>S3</code>,<code>ceph</code>等等.相较于以前的项目,变化还是相当的大的.接触了很多新颖的东西,也趟了很多的坑.总的来说就是痛并快乐着.<br>互联网的趋势势必会席卷整个IT行业,你在哪一个垂直行业都是躲不了的.这也是件好事.就我个人而言,也比较高兴的,找到了以前学习软件的时候的那种兴奋感.<code>勿忘初心,重新学习</code>一直作为我整个2015年写在QQ签名上的座右铭.</p>
<h2 id="其他语言">其他语言</h2><p>2015年还有一个重大的变化就是我开始把眼界从JAVA的生态环境中跳出去.接触了更多的语言以及它们的一些思想.其实搞软件的不能只关注于自己的那一小块圈子,在其他语言中也有很多可以借鉴和启发你的东西,就算暂时没有,开拓开拓眼界也是好的,指不定哪天就会用上呢.</p>
<p>在年中,接触到<code>Kafka</code>的时候了解到了它是使用<code>scala</code>写的,和<code>JRuby</code>,<code>JPtyhon</code>这些类似,它是基于JVM上的一门新的语言.其实这门语言已经出来很久了,不过一直不算很广泛.这次在<code>Kafka</code>和<code>akka</code>中看到使用了<code>scala</code>,于是就去了解了一下.然后就被它的语法所吸引了,它解决了JAVA很多以前很烦琐的东西.JAVA由于一直要兼容以前版本的东西,所以这几年变化一直不大.哪怕最新的JDK1.8新增了很多的东西,但是整个体系还是在那摆着的.比如闭包的实现,完全比不上其他的语言,要实现一个闭包还需要提前的定义一个接口.而<code>scala</code>真是解决了这些的问题,它以简洁的语法漂亮的增加了我们的效率,并且还兼容了大部分的JAVA库,要知道这些JAVA库可是JAVA现在一直坐稳第一语言最大的依仗.C#语言本身其实经过这几年的发展已经比JAVA要优秀了,但是背后缺少了开源社区的支持,以及长年累月积累起来的各种库,始终在5 6名左右徘徊.因此,明年的目标就是继续学习<code>scala</code>,争取能拿<code>scala</code>写一些东西出来.</p>
<p>在年底,由于<code>codis</code>和<code>docker</code>的原因,近距离的接触到了<code>golang</code>,这个被google誉为下一代开发语言的语言.也大致的了解了一下,它的一些思想确实比较先进,比如<code>协程</code>,<code>严格的书写格式</code>等等.不过由于时间和精力的原因并未有太深入,现在还停留在大致能看懂别人的源码的程度.明年的目标是系统的学习一下<code>golang</code>.我对这门语言还是比较看好的,它从语言级别就支持多并发的特性,是比较适合于大数据高并发的系统的.</p>
<p>贯穿整年,得益于Apple对开源的态度,以及IOS9对IOS开发者真机调试的免费开放(是的,这个理由就是这么low,真的是被这个吸引了,可以自己给自己的手机开发APP了).我深入的学习了<code>Swfit</code>,这是从2012年在公司项目上使用<code>Objective-C</code>写过一个<code>MacOS</code>上的工具外,时隔3年又一次投入Apple的怀抱,这次的感觉很好.由于从大学开始就一直学习的是<code>JAVA</code>和<code>Python</code>,对于自己手动的管理内存实在是头痛.因此,信仰没有抵过现实,把<code>MacOS</code>上的工具开发完成后,就再没有接触过<code>Objective-C</code>了.<br>但是,在2014年WWDC上看了Swift的演示,我一下就被吸引了.类似于动态语言的语法,静态语言的本质,各种语法糖以及现代语言的思想,无不吸引了我.再加上年底的开源,更是把Swfit推上了一个小高潮.<br>现在Swfit已经是我第二熟悉的语言了,又时甚至会想要是JAVA有 Swfit的这个特性就好了~<br>基于Swfit,今年断断续续的写了两个完整的应用以及几个框架或代码片段.也算是入了Swift的门了.第三个应用也在筹划的阶段.明年的目标就是更加的熟悉Swift以及IOS的开发,不指望以后靠IOS吃饭,自娱自乐写点有意思的应用还是不错的.</p>
<h2 id="DevOps">DevOps</h2><p>以前在这方面接触的最多的就是 搭建了 Maven+Jenkins进行持续化集成,并且一直使用了3年.<br>今年开始涉及了云计算以及容器化技术.开始在各种云上实验各种东西.并且把Docker引入了今年公司的新项目中.Docker可以说是今年获得的最重要的技能之一.</p>
<h2 id="开源">开源</h2><p>单独把这个写出来,也是想说明现在对于开源越来越有认同感.自己也在<a href="http://git.oschina.net" target="_blank" rel="external">Git@oschina</a>以及<a href="https://github.com/sunxiang0918" target="_blank" rel="external">github.com</a>上分享了几个东西.有<code>Swift</code>的,也有<code>JAVA</code>的.其中拿来练手而写的<a href="http://git.oschina.net/xycm/ZhiHuDaily-Swift" target="_blank" rel="external">ZhiHuDaily-Swift</a>更是拿到了<code>git@OSC</code>上<code>Swift</code>分类下最高的Star数以及收到了知乎官方的电邮(当然不是法律侵权这些),这让我非常的高兴,更加的坚定了开源的决心.<br>明年的目标是希望能参与一个他人的开源项目,或是协作,或是<code>pull request</code>.现在Swift开源了,要是能在<code>Swfit</code>上留下自己的印记,那可是很值得开心的,加油!</p>
<h2 id="总结">总结</h2><p>总结今年的成长,比去年的多姿多彩,涉及了更多的方面.并且成功的进入了IOS Programmer的世界,也算是圆了资深脑残果粉的一个心愿.其他技术方面,很多东西都只能算是入了个门,更多的精彩和挑战还在后面.<br><strong>期待2016!再见2015!</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="再见2015">再见2015</h1><p>时光匆匆,转眼2015年就要过去了.2015开年的事情仿佛刚过去没有多久,2016又要来了.今年是忙碌的一年,不管是在生活上还是在工作上都发生了很多的变化.本文将回顾一下作为程序猿的自己在今年的成长,做一个简单的总结.</p>
<h2 id="博客">博客</h2><p>今年年中,自己在github.io上搭建了自己的个人博客,并且把以前的一些文章从evernote上迁移了过来.以前,从来没有写博客的习惯,一个是觉得写博客比较麻烦,因为可能不是自己一个人看,不能像在evernote上那样随便乱写.还有一个就是觉得东西有个地方保存就好了,没必要分享出来.不过,最后还是决定把博客搭建出来,既能锻炼自己的书写,也能强迫自己把东西记录的更规范更细致,最后也能分享给有需要的人.从事了5年的软件行业了,渐渐的开始理解开源人的心态了,也从各位开源的大神中得到了很多的好处,是时候把自己力所能及的东西分享出来了.</p>
<p>今年一共写了<a href="/archives/2015">43篇博客</a>,从数量上来说不算多.主要涉及的是<code>JAVA研发体系</code>以及<code>Swift</code>方面的内容.<br>对于明年,目标是60篇博客,内容上更有深度与广度.希望能够达成.</p>]]>
    
    </summary>
    
      <category term="其他" scheme="http://sunxiang0918.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>Swift-LOG输出]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/30/Swift-LOG%E8%BE%93%E5%87%BA/"/>
    <id>http://sunxiang0918.github.io/2015/12/30/Swift-LOG输出/</id>
    <published>2015-12-30T14:17:30.000Z</published>
    <updated>2015-12-30T14:23:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="LOG输出">LOG输出</h1><p>Log 输出是程序开发中很重要的组成部分，虽然它并不是直接的业务代码，但是却可以忠实地反映我们的程序是如何工作的，以及记录程序运行的过程中发生了什么。</p>
<p>在 Swift 中，最简单的输出方法就是使用 print，在我们关心的地方输出字符串和值。但是这并不够，试想一下当程序变得非常复杂的时候，我们可能会输出很多内容，而想在其中寻找到我们希望的输出其实并不容易。我们往往需要更好更精确的输出，这包括输出这个 log 的文件，调用的行号以及所处的方法名字等等。</p>
<p>我们当然可以在 print 的时候将当前的文件名字和那些必要的信息作为参数同我们的消息一起进行打印：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"文件名:Test.swift, 方法名:method，这是一条输出"</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是这显然非常麻烦，每次输入文件名和方法名不说，随着代码的改变，这些 Log 的位置也可能发生改变，这时我们可能还需要不断地去维护这些输出，代价实在太大。</p>
<p>在 Swift 中，编译器为我们准备了几个很有用的编译符号，用来处理类似这样的需求，它们分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FILE</td>
<td style="text-align:left">String</td>
<td style="text-align:left">包含这个符号的文件的路径</td>
</tr>
<tr>
<td style="text-align:left">LINE</td>
<td style="text-align:left">Int</td>
<td style="text-align:left">符号出现处的行号</td>
</tr>
<tr>
<td style="text-align:left">COLUMN</td>
<td style="text-align:left">Int</td>
<td style="text-align:left">符号出现处的列</td>
</tr>
<tr>
<td style="text-align:left">FUNCTION</td>
<td style="text-align:left">String</td>
<td style="text-align:left">包含这个符号的方法名字</td>
</tr>
</tbody>
</table>
<p>因此，我们可以通过使用这些符号来写一个好一些的 Log 输出方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printLog</span><span class="generics">&lt;T&gt;</span><span class="params">(message: T,  </span><br><span class="line">                    file: String = <span class="keyword">__FILE__</span>,</span><br><span class="line">                  method: String = <span class="keyword">__FUNCTION__</span>,</span><br><span class="line">                    line: Int = <span class="keyword">__LINE__</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\((file <span class="keyword">as</span> NSString)</span>.lastPathComponent)[<span class="subst">\(line)</span>], <span class="subst">\(method)</span>: <span class="subst">\(message)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在进行 log 的时候我们只需要使用这个方法就能完成文件名，行号以及方法名的输出了。最棒的是，我们不再需要对这样的输出进行维护，无论在哪里它都能正确地输出各个参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    printLog(<span class="string">"这是一条输出"</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Test.swift[62], method(): 这是一条输出</span></span><br></pre></td></tr></table></figure>
<p>另外，对于 log 输出更多地其实是用在程序开发和调试的过程中的，过多的输出有可能对运行的性能造成影响。在 Release 版本中关闭掉向控制台的输出也是软件开发中一种常见的做法。如果我们在开发中就注意使用了统一的 log 输出的话，这就变得非常简单了。使用<a href="http://swifter.tips/condition-compile" target="_blank" rel="external">条件编译</a>的方法，我们可以添加条件，并设置合适的编译配置，使 printLog 的内容在 Release 时被去掉，从而成为一个空方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printLog</span><span class="generics">&lt;T&gt;</span><span class="params">(message: T,  </span><br><span class="line">                    file: String = <span class="keyword">__FILE__</span>,</span><br><span class="line">                  method: String = <span class="keyword">__FUNCTION__</span>,</span><br><span class="line">                    line: Int = <span class="keyword">__LINE__</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\((file <span class="keyword">as</span> NSString)</span>.lastPathComponent)[<span class="subst">\(line)</span>], <span class="subst">\(method)</span>: <span class="subst">\(message)</span>"</span>)</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版本的 LLVM 编译器在遇到这个空方法时，甚至会直接将这个方法整个去掉，完全不去调用它，从而实现零成本。</p>
<hr>
<p>原文链接: <a href="http://swifter.tips/log/" target="_blank" rel="external">http://swifter.tips/log/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="LOG输出">LOG输出</h1><p>Log 输出是程序开发中很重要的组成部分，虽然它并不是直接的业务代码，但是却可以忠实地反映我们的程序是如何工作的，以及记录程序运行的过程中发生了什么。</p>
<p>在 Swift 中，最简单的输出方法就是使用 print，在我们关心的地方输出字符串和值。但是这并不够，试想一下当程序变得非常复杂的时候，我们可能会输出很多内容，而想在其中寻找到我们希望的输出其实并不容易。我们往往需要更好更精确的输出，这包括输出这个 log 的文件，调用的行号以及所处的方法名字等等。</p>
<p>我们当然可以在 print 的时候将当前的文件名字和那些必要的信息作为参数同我们的消息一起进行打印：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test.swift</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"文件名:Test.swift, 方法名:method，这是一条输出"</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Swift中使用随机数]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/27/%E5%9C%A8Swift%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>http://sunxiang0918.github.io/2015/12/27/在Swift中使用随机数/</id>
    <published>2015-12-27T12:27:49.000Z</published>
    <updated>2015-12-27T13:11:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Swift中使用随机数">在Swift中使用随机数</h1><p>在我们的开发过程中,有时需要产生一些随机数.而Swift中并没有像JAVA中一样提供一个专门的<code>Random</code>类来集中的生成随机数.<br>在Swift中,提供了几个全局的函数来生成随机数.一个是<code>random()</code>,还有一个是<code>arc4random()</code>,以及专门生成浮点的<code>srand48(Int)</code>和<code>drand48()</code>.<br>这些方法并没有进行封装,其实并不符合面向对象的思想.并且如果想要限制生成的随机数的最大最小值也不得行.因此,我们有必要对他们进行一个封装.</p>
<a id="more"></a>
<h2 id="arc4random()">arc4random()</h2><p>arc4random 是一个非常优秀的随机数算法,它会返回给我们一个任意的整数,如果我们想要在某一个范围里的话,做一次取模运算取余数就可以了.但是由于<code>arc4random()</code>函数返回的值无论上什么平台上都是返回一个<code>UInt32</code>(无符号32位整数)的值.因此,在32位的平台上进行<code>Int(arc4random())</code>转换的话,就有一半的几率出现转换越界,这就会造成程序的崩溃.</p>
<p>因此,在这种情况下,我们可以使用<code>arc4random_uniform</code>这个改良的<code>arc4random</code>函数:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">arc4random_uniform</span><span class="params">(<span class="number">_</span>: UInt32)</span></span> -&gt; <span class="type">UInt32</span></span><br></pre></td></tr></table></figure>
<p>这个函数接收一个UInt32的数字n作为输入,返回一个0到n-1之间的随机数.那么,只要我们传入的n不超过Int的范围,就可以避免像上面一样的转换越界的问题了.</p>
<p>因此,我们Int的随机数生成函数可以写成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Int = <span class="number">0</span>, <span class="number">_</span> upper: Int = Int.<span class="built_in">max</span>)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lower + <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(upper - lower + <span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(range: Range&lt;Int&gt;)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> random(range.startIndex, range.endIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码使用了<code>扩展</code>,对Int类型增加了一个扩展,并实现了<code>random(lower: Int = 0, _ upper: Int = Int.max) -&gt; Int</code>和<code>random(range: Range&lt;Int&gt;) -&gt; Int</code>两个方法.这样,如果我们需要一个整数的随机数的话,就可以这样调用了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span>.random()</span><br><span class="line"><span class="type">Int</span>.random(<span class="number">0</span>, <span class="number">50</span>)</span><br><span class="line"><span class="type">Int</span>.random(<span class="number">20</span>...<span class="number">50</span>)</span><br></pre></td></tr></table></figure>
<p>这里不得不夸一下<code>扩展</code>机制,真心方便.它可以不修改原有类的源码的情况下,给这个类增加新的功能.这就大大的增加了编写代码的方便.毕竟很多时候最开始时是考虑不周全的,我们并不能给某个类增加所有的方法,到后面进行修改的时候,就必然牵涉到修改源码.如果源码是自己写的还好,如果源码不是自己写的或者根本就没有源码了.那么给这个类增加方法就非常的不方便了.JAVA中有大量的<code>XXXXUtils</code>类,其实干的就是这个事情,比如<code>StringUtils</code>,由于JAVA中的<code>String</code>类是不能继承和修改的,因此就只有定义了一个工具类,里面就是对String做了一堆的扩展.调用的时候更不符合面向对象的思想.全是<code>StringUtils.xxxx(sourceStr,destStr)</code>这样的.</p>
<h2 id="其他类型的随机数">其他类型的随机数</h2><p>除了整数的随机数以外,浮点的随机数也是很常用的.因此我们同样可以对浮点数进行扩展.这里就有两种思路,第一种是继续使用<code>arc4random()</code>函数,把生成的随机整数转换成为浮点数.还有一种就是调用<code>srand48(Int)</code>和<code>drand48()</code>直接生成随机浮点数.这两个方案都是差不多的,不过由于每次调用<code>drand48()</code>前都需要调用<code>srand48(Int)</code>设置随机初始化的种子,因此我个人更倾向于使用<code>arc4random()</code>.于是就有以下的方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Bool</span> </span>&#123;</span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>.random(<span class="number">0</span>, <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Double = <span class="number">0</span>, <span class="number">_</span> upper: Double = <span class="number">100</span>)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">Double</span>(arc4random()) / <span class="number">0xFFFFFFFF</span>) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">Float</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: Float = <span class="number">0</span>, <span class="number">_</span> upper: Float = <span class="number">100</span>)</span></span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">Float</span>(arc4random()) / <span class="number">0xFFFFFFFF</span>) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">CGFloat</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// SwiftRandom extension</span></span><br><span class="line">    public <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">(lower: CGFloat = <span class="number">0</span>, <span class="number">_</span> upper: CGFloat = <span class="number">1</span>)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CGFloat</span>(<span class="type">Float</span>(arc4random()) / <span class="type">Float</span>(<span class="type">UINT32_MAX</span>)) * (upper - lower) + lower</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样集中常用数据类型的随机数的生成就都有了,并且使用起来也非常的方便.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bool</span>.random()</span><br><span class="line"><span class="type">Double</span>.random(<span class="number">1.5</span>,<span class="number">10.8</span>)</span><br><span class="line"><span class="type">Float</span>.random()</span><br><span class="line"><span class="type">CGFloat</span>.random()</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在Swift中使用随机数">在Swift中使用随机数</h1><p>在我们的开发过程中,有时需要产生一些随机数.而Swift中并没有像JAVA中一样提供一个专门的<code>Random</code>类来集中的生成随机数.<br>在Swift中,提供了几个全局的函数来生成随机数.一个是<code>random()</code>,还有一个是<code>arc4random()</code>,以及专门生成浮点的<code>srand48(Int)</code>和<code>drand48()</code>.<br>这些方法并没有进行封装,其实并不符合面向对象的思想.并且如果想要限制生成的随机数的最大最小值也不得行.因此,我们有必要对他们进行一个封装.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ELK初实践]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/21/ELK%E5%88%9D%E5%AE%9E%E8%B7%B5/"/>
    <id>http://sunxiang0918.github.io/2015/12/21/ELK初实践/</id>
    <published>2015-12-21T12:07:47.000Z</published>
    <updated>2015-12-22T03:00:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ELK(ElasticSearch+Logstash+Kiabana)初实践">ELK(ElasticSearch+Logstash+Kiabana)初实践</h1><p>ELK是由<a href="https://www.elastic.co" target="_blank" rel="external">elastic</a>公司维护的开源的实时日志采集与分析三剑客.它能够在分布式的架构下,使用<a href="https://www.elastic.co/products/logstash" target="_blank" rel="external">Logstash</a>实时的采集各种不同来源的日志,并通过清洗/ETL转换,形成有意义的数据,存入到<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="external">ElasticSearch</a>全文检索引擎中,再通过<a href="https://www.elastic.co/products/kibana" target="_blank" rel="external">Kiabana</a>呈现出来.<br>我们可以通过这套开源系统实时的了解服务器的软硬件信息,业务负载,错误异常等等.同时也能统一收集日志并做归档处理.当管理的机器非常多的时候这就非常的有意义了.</p>
<p><img src="/img/2015/12/21/1.png" alt=""></p>
<a id="more"></a>
<h2 id="ElasticSearch">ElasticSearch</h2><p>Elasticsearch是一个基于<a href="https://lucene.apache.org/core/" target="_blank" rel="external">Apache Lucene(TM)</a>的开源搜索引擎.与Solr类似,它隐藏了Lucene的复杂性.并提供大量分布式的功能.使用者能够很简单的就构建起一个全文检索引擎,并提供出<code>Restful</code>的API.而不需要编写任何的代码.</p>
<h3 id="安装">安装</h3><p>Elasticsearch的安装非常的简单,它只依赖JAVA的运行环境.最简的运行方式就是直接下载它编译好了的压缩包.然后解压即可用.<br>(默认JAVA运行环境已经配置完成)</p>
<ol>
<li>从<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="external">https://www.elastic.co/downloads/elasticsearch</a>下载最新的运行包.</li>
<li>使用<code>tar -xvf elasticsearch-2.1.0.tar.gz</code>解压</li>
<li>在<code>elasticsearch-2.1.0</code>文件夹下执行<code>./bin/elasticsearch</code></li>
<li><p>在浏览器中访问<a href="http://127.0.0.1:9200" target="_blank" rel="external">http://127.0.0.1:9200</a>.如果得到一个JSON的结果,就表明ES启动成功</p>
 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> "<span class="attribute">name</span>" : <span class="value"><span class="string">"Hood"</span></span>,</span><br><span class="line"> "<span class="attribute">cluster_name</span>" : <span class="value"><span class="string">"elasticsearch"</span></span>,</span><br><span class="line"> "<span class="attribute">version</span>" : <span class="value">&#123;</span><br><span class="line">   "<span class="attribute">number</span>" : <span class="value"><span class="string">"2.1.0"</span></span>,</span><br><span class="line">   "<span class="attribute">build_hash</span>" : <span class="value"><span class="string">"72cd1f1a3eee09505e036106146dc1949dc5dc87"</span></span>,</span><br><span class="line">   "<span class="attribute">build_timestamp</span>" : <span class="value"><span class="string">"2015-11-18T22:40:03Z"</span></span>,</span><br><span class="line">   "<span class="attribute">build_snapshot</span>" : <span class="value"><span class="literal">false</span></span>,</span><br><span class="line">   "<span class="attribute">lucene_version</span>" : <span class="value"><span class="string">"5.3.1"</span></span><br><span class="line"> </span>&#125;</span>,</span><br><span class="line"> "<span class="attribute">tagline</span>" : <span class="value"><span class="string">"You Know, for Search"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你想要一个监控界面来控制和了解ES的话,可以下载<a href="https://www.elastic.co/products/marvel" target="_blank" rel="external">marvel</a>.<code>Marvel</code>是Elasticsearch的管理和监控工具，在开发环境下免费使用.它包含了一个叫做Sense的交互式控制台，使用户方便的通过浏览器直接与Elasticsearch进行交互.不过这个东西不能进行商用.另外一个可视化的插件是<a href="https://github.com/mobz/elasticsearch-head.git" target="_blank" rel="external">Header</a>,同样是一个ES的管理和监控的工具,不过它的功能稍微要少一些.</p>
</li>
<li>安装<code>Header</code>的话非常简单,直接在es的<code>bin</code>目录中执行<code>sudo ./plugin install mobz/elasticsearch-head</code>即可,它会自动的下载并解压安装包到<code>plugins</code>目录.</li>
<li><p>安装完成后,在浏览器中浏览<a href="http://localhost:9200/_plugin/head/" target="_blank" rel="external">http://localhost:9200/_plugin/head/</a></p>
<p> <img src="/img/2015/12/21/2.png" alt="Header主界面"></p>
</li>
<li><p>安装<code>Marvel</code>稍微要麻烦一点,最新的<code>Marvel2.X</code>需要依赖<code>Kiabana</code>了.首先需要安装<code>License</code>模块:<code>./plugin install license</code>,然后在ES中安装<code>marvel-agent</code>:<code>./plugin install marvel-agent</code>,最后需要在<code>Kiabana</code>中安装<code>marvel</code>:<code>./kibana plugin --install elasticsearch/marvel/latest</code></p>
</li>
<li><p>安装完成后,启动<code>Elasticsearch</code>和<code>Kiabana</code>.然后在浏览器中浏览<a href="http://localhost:5601/app/marvel" target="_blank" rel="external">http://localhost:5601/app/marvel</a>即可.</p>
<p> <img src="/img/2015/12/21/3.png" alt="Marvel主界面"></p>
</li>
</ol>
<p>剩下的<code>Elasticsearch</code>的其他使用,我会另开博文来讲述,这里主要是讲ELK的整合使用~</p>
<h2 id="Kiabana">Kiabana</h2><p>Kibana是一个基于浏览器页面的<code>Elasticsearch</code>前端展示工具,提供了非常牛逼的图表和表现能力。Kibana全部使用HTML语言和Javascript编写的.因此可以部署到任意的Web容器中去.当然,官网上下载的安装包中已经内置了一个Web容器,直接运行即可.</p>
<h3 id="安装-1">安装</h3><ol>
<li>从<a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="external">https://www.elastic.co/downloads/kibana</a>下载最新的运行包.</li>
<li>使用<code>tar -xvf kibana-4.3.0-darwin-x64.tar.gz</code>解压</li>
<li><p>修改<code>/config/kibana.yml</code>文件,指定<code>Elasticsearch</code>的访问地址:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The Elasticsearch instance to use for all your queries.</span></span><br><span class="line">elasticsearch.url: <span class="string">"http://localhost:9200"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>kibana-4.3.0-darwin-x64</code>文件夹下执行<code>./kibana</code>即可. 他会自动的在ES中创建它自己所需的索引文件.</p>
</li>
<li><p>在浏览器中打开<a href="http://127.0.0.1:5601/app/kibana" target="_blank" rel="external">http://127.0.0.1:5601/app/kibana</a>即可.这个时候就可以在界面的<code>Discover</code>中进行索引的查询了.</p>
<p> <img src="/img/2015/12/21/4.png" alt=""></p>
</li>
<li><p>同时,也可以使用<code>Visualize</code>功能,建立不同的报表.我们对日志的处理也主要就是通过记录的不同维度,建立不同的图表.然后订阅到<code>Dashboard</code>中.这样就能对日志进行实时的监控和分析.</p>
<p> <img src="/img/2015/12/21/5.png" alt=""></p>
</li>
</ol>
<h2 id="Logstash">Logstash</h2><p>Logstash是一个应用程序日志、事件的传输、处理、管理和搜索的平台.你可以用它来统一对应用程序日志进行收集管理.这点上它的功能其实和<code>Flume</code>是有点类似的.<br><img src="/img/2015/12/21/6.png" alt=""></p>
<h3 id="安装-2">安装</h3><p>Logstash是使用JRuby写的,因此需要依赖JAVA的运行环境.</p>
<ol>
<li>从<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">https://www.elastic.co/downloads/logstash</a>下载最新的运行包.</li>
<li>使用<code>tar -xvf logstash-2.1.0.tar.gz</code>解压</li>
<li>在<code>logstash-2.1.0</code>文件夹下执行<code>./bin/logstash agent -f logstash.conf</code>即可.</li>
</ol>
<p>这里主要是使用了<code>agent</code>模式运行,采集日志的配置记录到<code>logstash.conf</code>文件中. 接下来就介绍一下<code>logstash.conf</code>这个文件.</p>
<h3 id="配置">配置</h3><p>Logstash的日志采集过程主要有三个部分,分别是<code>Input</code> <code>Filter</code>和<code>Output</code>.对应了日志的收集,日志的整理和日志的输出,同时在Filter的前后允许配置<code>Codec</code>也就是编解码.每一个过程都提供了非常多的插件来辅助处理.具体有哪些插件可以访问<a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html" target="_blank" rel="external">Input</a>,<a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" target="_blank" rel="external">Filter</a>,<a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html" target="_blank" rel="external">Output</a>以及<a href="https://www.elastic.co/guide/en/logstash/current/codec-plugins.html" target="_blank" rel="external">Codec</a>.</p>
<p>比如最简单的一个conf文件为:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input &#123; stdin &#123; &#125; &#125;</span><br><span class="line">output &#123;</span><br><span class="line">   stdout &#123; codec=&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它指定了日志采集的输入源为命令行输入,不经过任何的处理,输出源为控制台输出,输出的时候编码为ruby的debug格式</p>
<p>执行这个采集的效果就是:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/local/logstash-2.1.0/bin/logstash agent -f logstash-simple.conf</span></span><br><span class="line">Logstash startup completed</span><br><span class="line">hello World </span><br><span class="line">&#123;</span><br><span class="line">      <span class="string">"message"</span> =&gt; <span class="string">"helloWorld"</span>,</span><br><span class="line">     <span class="string">"@version"</span> =&gt; <span class="string">"1"</span>,</span><br><span class="line">   <span class="string">"@timestamp"</span> =&gt; <span class="string">"2015-12-14T12:08:28.688Z"</span>,</span><br><span class="line">         <span class="string">"host"</span> =&gt; <span class="string">"localhost"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在再来看一个复杂点的例子,这个是我们测试环境抓取业务日志的conf配置:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">    	type =&gt; <span class="string">"my_app"</span></span><br><span class="line">        path =&gt; <span class="string">"/Applications/tomcat7/logs/fpLog/ALL/fpServer.log"</span></span><br><span class="line">        tags =&gt; [ <span class="string">"my_app"</span>, <span class="string">"logback"</span> ]</span><br><span class="line">        sincedb_path =&gt; <span class="string">"./sincedb"</span>	<span class="comment"># sincedb会记录日志文件的inode信息及当前读了多少bytes,以确保logstash停掉重启后可接着之前的位置继续收集日志</span></span><br><span class="line">		sincedb_write_interval =&gt; <span class="number">10</span>	<span class="comment"># 写sincedb的频率,logstash停止时会自动将当前收集位置记录到sincedb</span></span><br><span class="line">		<span class="comment">#start_position =&gt; "beginning"	# 注意,一定要设为beginning,默认是end.因为如果在logstash停掉期间,日志被rotate了两次,意味着有一整个日志文件是完全没有sincedb记录,logstash重启后就直接从start_position开始读,所以一定要设置为beginning.对于有sincedb记录的,logstash会接着停掉时的sincedb记录的位置继续收集日志</span></span><br><span class="line">		discover_interval =&gt; <span class="number">10</span></span><br><span class="line">		stat_interval =&gt; <span class="number">1</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> [message] =~ <span class="string">"^\[.+?\]"</span> &#123;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		drop&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	grok &#123;</span><br><span class="line">		match =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"\[(?&lt;log_id&gt;.*?)\] (?&lt;log_level&gt;\w+)  %&#123;TIMESTAMP_ISO8601:log_time&#125; (?&lt;system&gt;\w+) \[(?&lt;thread_name&gt;.+?)\] (?&lt;class_name&gt;.+)\- (?&lt;content&gt;.*)"</span> &#125;</span><br><span class="line">		remove_field =&gt; [ <span class="string">"message"</span> ]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	date &#123;</span><br><span class="line">    	match =&gt; [ <span class="string">"log_time"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>, <span class="string">"ISO8601"</span> ]</span><br><span class="line">    	timezone =&gt; <span class="string">"Asia/Shanghai"</span></span><br><span class="line">    	target =&gt; <span class="string">"@timestamp"</span></span><br><span class="line">    	remove_field =&gt; [ <span class="string">"log_time"</span> ]</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">if</span> [content] =~ <span class="string">"^\&#123;.*?\&#125;$"</span> &#123;</span><br><span class="line">  	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  		drop&#123;&#125;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">	json &#123;</span><br><span class="line">        source =&gt; <span class="string">"content"</span></span><br><span class="line">        target =&gt; <span class="string">"jsoncontent"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">	stdout &#123;&#125;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">  		hosts =&gt; <span class="string">"localhost:9200"</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先来看看Input{}. 他使用了<code>file</code>插件,从文件读取读取日志,并且给日志增加了一个Type属性用于区别来源.同时,1秒一次的监控日志的变化,把已扫描了的日志偏移量记录到<code>./sincedb</code>中去.</li>
<li>接下来就是filter{}了.<ul>
<li>一来,使用if语句,正则匹配<code>[]</code>开头的日志行,这个符合这个正则的日志才予以保留,其他的日志直接删除掉.</li>
<li>而后使用了grok插件,这个插件最重要的功能就是进行ETL转换,把非结构化的日志,转换成结构化的对象. 它使用正则表达式,以及<code>&lt;xxxx&gt;</code>的形式用来匹配和挖取有用的变量.</li>
<li>比如这个例子中的:<code>\[(?&lt;log_id&gt;.*?)\] (?&lt;log_level&gt;\w+)  %{TIMESTAMP_ISO8601:log_time} (?&lt;system&gt;\w+) \[(?&lt;thread_name&gt;.+?)\] (?&lt;class_name&gt;.+)\- (?&lt;content&gt;.*)</code>就是用来匹配<code>[1450580425858_394] INFO  2015-12-20 11:00:25.873 XXXXXX [myScheduler-4] c.s.j.s.c.c.AbstractTaskDispatcher- {&quot;site&quot;:&quot;unknown_site&quot;,&quot;tags&quot;:[&quot;unknown_tag&quot;],&quot;throwable&quot;:&quot;&quot;,&quot;detail&quot;:&quot;扫描模式,fileanalysis组件调度器,开始恢复上次待分配的任务.isChangePriority=false&quot;,&quot;time&quot;:&quot;2015-12-20 11:00:25.873&quot;,&quot;system&quot;:&quot;XXXXXX&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;source&quot;:&quot;unknown_source&quot;,&quot;extends&quot;:{},&quot;tool&quot;:&quot;unknown_tool&quot;,&quot;user&quot;:&quot;unknown_user&quot;,&quot;client_ip&quot;:&quot;unknown_ip&quot;,&quot;ip&quot;:&quot;172.16.129.7&quot;}</code>日志的.</li>
<li>通过grok插件的处理,这个时候日志事件就变为一个结构化的数据了.针对这个数据我们就可以进行很多其他的处理.</li>
<li>下面使用了<code>date</code>插件来处理日期.它定义了日期的标准格式,以及时区.然后把解析出来的时间赋值给模型上的某个字段.</li>
<li>接下来,再次使用<code>if</code>语句,对模型中的<code>content</code>字段再次进行清洗,对于不是JSON格式的日志,直接删除.</li>
<li>最后,使用<code>json</code>插件,把<code>content</code>字段JSON化.<br>最后使用output{}把转换好的日志输出到两个地方,一个是控制台,另外一个就是前文所说的<code>elasticsearch</code>了.</li>
</ul>
</li>
</ul>
<p>当我们执行这个日志采集Agent后,他就会不断的监控日志文件.一旦日志文件有变化,他就会采集到,并做处理,然后发送到es中. 最后我们就可以使用kibana来进行查看了.</p>
<h2 id="总结">总结</h2><p>本文主要介绍了ELK的作用,以及安装. 以一个简单的配置例子,介绍了ELK整合的常用方式以及效果.<br>通过ELK,可以把以前很麻烦的分布式日志的收集和整理简单化了.<br>更高级的功能,随着我使用的深入,会继续更新博文.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ELK(ElasticSearch+Logstash+Kiabana)初实践">ELK(ElasticSearch+Logstash+Kiabana)初实践</h1><p>ELK是由<a href="https://www.elastic.co">elastic</a>公司维护的开源的实时日志采集与分析三剑客.它能够在分布式的架构下,使用<a href="https://www.elastic.co/products/logstash">Logstash</a>实时的采集各种不同来源的日志,并通过清洗/ETL转换,形成有意义的数据,存入到<a href="https://www.elastic.co/products/elasticsearch">ElasticSearch</a>全文检索引擎中,再通过<a href="https://www.elastic.co/products/kibana">Kiabana</a>呈现出来.<br>我们可以通过这套开源系统实时的了解服务器的软硬件信息,业务负载,错误异常等等.同时也能统一收集日志并做归档处理.当管理的机器非常多的时候这就非常的有意义了.</p>
<p><img src="/img/2015/12/21/1.png" alt=""></p>]]>
    
    </summary>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="日志挖掘" scheme="http://sunxiang0918.github.io/tags/%E6%97%A5%E5%BF%97%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>如何关闭OSX 10.11 SIP]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/10/%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%ADOSX-10-11-SIP/"/>
    <id>http://sunxiang0918.github.io/2015/12/10/如何关闭OSX-10-11-SIP/</id>
    <published>2015-12-10T14:27:09.000Z</published>
    <updated>2015-12-10T14:35:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何关闭OSX_10-11_SIP_(System_Integrity_Protection)">如何关闭OSX 10.11 SIP (System Integrity Protection)</h1><p>2015.10.8 01:50更新：实在忍不住，看完池老师的公众号，就升级了。问题果然是有的，池老师你还我睡眠时间，又整到凌晨……</p>
<ol>
<li>关于Homebrew的安装参考链接</li>
<li>Cocoapods使用这个命令安装sudo gem install -n /usr/local/bin cocoapods原因是原来使用的/usr/bin这个目录被rootless保护了，那个-n参数作用是把二进制文件安装到指定目录，参考stackoverflow解决Cocoapods无法安装 注意stackoverflow中提到的使用这个参数「rootless=0」就不要用了，该方法apple官方已经封了，要停用rootless就用我下述的方法（也是官方推荐方法）</li>
<li>……暂时就这些，有问题在更新，或者留言给我你的问题，我看看能不能解决</li>
</ol>
<p>注意：SIP功能是Apple在OSX上推出的系统完整性保护功能，对于普通MAC用户来说是一项安全保护功能，如果不了解他的作用请不要随意关闭，对于开发者来说，因为会使用到很多的第三方辅助工具（例如：Cocoapods、Homebrew），而这些工具可能会修改系统目录，在这些工具未推出适应OSX 10.11的版本时，有必要临时关闭SIP以确保开发工具的使用。</p>
<p>建议：普通用户随意，开发者目前请谨慎升级，如果你已经升级，相信你可能需要恶心一阵了，因为有些工具没有更新不能正常使用或部分功能失效，甚至在关闭SIP后也有点问题，当然你只要耐心等待软件更新和网友的智慧或是自己动手丰衣足食，很多问题还是可以解决的。</p>
<a id="more"></a>
<ol>
<li><p><strong>进入RecoveryHD</strong><br>开机按住<code>Option</code>键在出现的启动选择菜单中选择<code>RecoveryHD</code>进入恢复模式</p>
</li>
<li><p><strong>使用csrutil命令</strong><br>打开终端Terminal，键入<code>csrutil</code>可以显示该命令的使用方法</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">usage: csrutil &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">Modify the System Integrity Protection configuration. All configuration changes apply to the entire machine.</span><br><span class="line">Available commands:</span><br><span class="line"></span><br><span class="line">    clear</span><br><span class="line">        Clear the existing configuration. Only available <span class="keyword">in</span> Recovery OS.</span><br><span class="line">    <span class="built_in">disable</span></span><br><span class="line">        Disable the protection on the machine. Only available <span class="keyword">in</span> Recovery OS.</span><br><span class="line">    <span class="built_in">enable</span></span><br><span class="line">        Enable the protection on the machine. Only available <span class="keyword">in</span> Recovery OS.</span><br><span class="line">    status</span><br><span class="line">        Display the current configuration.</span><br><span class="line"></span><br><span class="line">    netboot</span><br><span class="line">        add &lt;address&gt;</span><br><span class="line">            Insert a new IPv4 address <span class="keyword">in</span> the list of allowed NetBoot sources.</span><br><span class="line">        list</span><br><span class="line">            Print the list of allowed NetBoot sources.</span><br><span class="line">        remove &lt;address&gt;</span><br><span class="line">            Remove an IPv4 address from the list of allowed NetBoot sources.</span><br></pre></td></tr></table></figure>
<p> 可以看到在正常系统模式下中仅可以用status命令查询SIP状态</p>
</li>
<li><p><strong>常用参数</strong></p>
<ul>
<li>clear：清除配置设置，等同于完全开启SIP(<code>仅在恢复模式下有效</code>)</li>
<li>disable：关闭SIP(<code>仅在恢复模式下有效</code>)</li>
<li>enable：开启SIP(<code>仅在恢复模式下有效</code>)</li>
<li>status：查询SIP状态</li>
</ul>
</li>
<li><p><strong>常用参数进阶</strong><br>除了可以完全关闭/打开，还可以进行单项和多项组合关闭相关功能，用法如下</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil <span class="built_in">enable</span> [--without kext|fs|debug|dtrace|nvram] [--no-internal]</span><br></pre></td></tr></table></figure>
<p> 单项使用：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo csrutil <span class="built_in">enable</span> –without fs：Filesystem Protections <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without kext：Kext Signing <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without debug：Debugging Restrictions <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without nvram：NVRAM Protections <span class="built_in">disable</span></span><br><span class="line">sudo csrutil <span class="built_in">enable</span> –without dtrace：DTrace Restrictions <span class="built_in">disable</span></span><br></pre></td></tr></table></figure>
<p> 组合使用：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo csrutil <span class="built_in">enable</span> –without kext –without fs：Filesystem Protections and Kext Signing are disabled</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更多详情请参考：<br><a href="http://cms.35g.tw/coding/關閉-osx-10-11-sip-system-integrity-protection-功能/zh-hans/" target="_blank" rel="external">可丁丹尼@一路往前走2.0</a><br><a href="https://pikeralpha.wordpress.com/2015/08/19/csrutil-updated/" target="_blank" rel="external">csrutil updated in DP7</a><br><a href="http://www.idelta.info/archives/sip-rootless-internal-in-el-capitan/" target="_blank" rel="external">SIP/Rootless Internal in El Capitan</a></p>
<hr>
<p>原文链接:<a href="http://www.jianshu.com/p/0572336a0771" target="_blank" rel="external">http://www.jianshu.com/p/0572336a0771</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="如何关闭OSX_10-11_SIP_(System_Integrity_Protection)">如何关闭OSX 10.11 SIP (System Integrity Protection)</h1><p>2015.10.8 01:50更新：实在忍不住，看完池老师的公众号，就升级了。问题果然是有的，池老师你还我睡眠时间，又整到凌晨……</p>
<ol>
<li>关于Homebrew的安装参考链接</li>
<li>Cocoapods使用这个命令安装sudo gem install -n /usr/local/bin cocoapods原因是原来使用的/usr/bin这个目录被rootless保护了，那个-n参数作用是把二进制文件安装到指定目录，参考stackoverflow解决Cocoapods无法安装 注意stackoverflow中提到的使用这个参数「rootless=0」就不要用了，该方法apple官方已经封了，要停用rootless就用我下述的方法（也是官方推荐方法）</li>
<li>……暂时就这些，有问题在更新，或者留言给我你的问题，我看看能不能解决</li>
</ol>
<p>注意：SIP功能是Apple在OSX上推出的系统完整性保护功能，对于普通MAC用户来说是一项安全保护功能，如果不了解他的作用请不要随意关闭，对于开发者来说，因为会使用到很多的第三方辅助工具（例如：Cocoapods、Homebrew），而这些工具可能会修改系统目录，在这些工具未推出适应OSX 10.11的版本时，有必要临时关闭SIP以确保开发工具的使用。</p>
<p>建议：普通用户随意，开发者目前请谨慎升级，如果你已经升级，相信你可能需要恶心一阵了，因为有些工具没有更新不能正常使用或部分功能失效，甚至在关闭SIP后也有点问题，当然你只要耐心等待软件更新和网友的智慧或是自己动手丰衣足食，很多问题还是可以解决的。</p>]]>
    
    </summary>
    
      <category term="MAC" scheme="http://sunxiang0918.github.io/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nutch2.3 安装与部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/08/Nutch2-3-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/12/08/Nutch2-3-安装与部署/</id>
    <published>2015-12-08T14:15:32.000Z</published>
    <updated>2015-12-08T15:26:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Nutch2-3_安装与部署">Nutch2.3 安装与部署</h1><p><a href="http://nutch.apache.org" target="_blank" rel="external">Nutch</a>是由JAVA开发的开源的全文检索引擎.不过更多的被用来当成Web爬虫来使用.现在Nutch分为了1.x和2.x两个版本在维护.而这两个版本的最主要的区别在于底层存储的抽象.1.x版本是基于Hadoop架构的,底层存储只能使用HDFS.而2.x版本通过<a href="http://gora.apache.org" target="_blank" rel="external">Apache Gora</a>对底层存储做了抽象,能访问HBase,MYSQL,MongoDB,Solr,AvroStore等等.</p>
<p>但是从2.X开始,官方就只提供源码的下载了,不再提供编译后的发布版本,因此就需要我们自己去进行编译.</p>
<a id="more"></a>
<h2 id="编译">编译</h2><p>为了简便起见,我们准备底层的存储使用mongoDB. 因此,这个演示是基于 Nutch+MongoDB的.</p>
<ol>
<li><p>下载源码<br> 从官网上下载<a href="http://www.apache.org/dyn/closer.lua/nutch/2.3/apache-nutch-2.3-src.tar.gz" target="_blank" rel="external">http://www.apache.org/dyn/closer.lua/nutch/2.3/apache-nutch-2.3-src.tar.gz</a>.然后执行命令 <code>tar -xvf apache-nutch-2.3-src.tar.gz</code>进行解压.</p>
</li>
<li><p>修改<code>$NUTCH_HOME/conf/nutch-site.xml</code>,增加以下内容:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>storage.data.store.class<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>org.apache.gora.mongodb.store.MongoStore<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">description</span>&gt;</span>Default class for storing data<span class="tag">&lt;/<span class="title">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">name</span>&gt;</span>http.agent.name<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">value</span>&gt;</span>My Nutch Spider<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改<code>$NUTCH_HOME/conf/gora.properties</code>,在最下面找到<code># MongoDBStore properties  #</code>,然后打开注释:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################</span></span><br><span class="line"><span class="comment"># MongoDBStore properties  #</span></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line">gora.datastore.default=org.apache.gora.mongodb.store.MongoStore</span><br><span class="line">gora.mongodb.override_hadoop_configuration=<span class="literal">false</span></span><br><span class="line">gora.mongodb.mapping.file=/gora-mongodb-mapping.xml</span><br><span class="line">gora.mongodb.servers=localhost:<span class="number">27017</span></span><br><span class="line">gora.mongodb.db=mytestdatabase</span><br><span class="line"><span class="comment">#gora.mongodb.login=login</span></span><br><span class="line"><span class="comment">#gora.mongodb.secret=secret</span></span><br></pre></td></tr></table></figure>
<p> 注意,如果你的mongo数据库没有auth,最后两行需要注释掉.</p>
</li>
<li><p>修改<code>$NUTCH_HOME/ivy/ivy.xml</code>.去掉下面的注释,使用gora-hbase:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Uncomment this to use MongoDB as Gora backend. --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">dependency</span> <span class="attribute">org</span>=<span class="value">"org.apache.gora"</span> <span class="attribute">name</span>=<span class="value">"gora-mongodb"</span> <span class="attribute">rev</span>=<span class="value">"0.5"</span> <span class="attribute">conf</span>=<span class="value">"*-&gt;default"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p> 这个地方需要特别注意一下,这里虽然使用了<code>gora-mongodb-0.5</code>,但是这个版本其实是有问题的,会在后面抓取记录保存到MongoDB的时候报:<code>java.lang.IllegalArgumentException: can&#39;t serialize class
org.apache.avro.util.Utf8</code>的异常,开始折腾了我很久.最后发现了这个是<code>gora-mongodb-0.5</code>自身的一个<a href="https://issues.apache.org/jira/browse/GORA-388" target="_blank" rel="external">Bug</a>,在0.6中是被修复了的.因此,我最开始想把整个gora升级成为0.6,结果Nutch不能执行.因此,目前阶段如果你底层想要使用MongoDB进行存储的话,需要单个把<code>gora-mongodb</code>升级到<code>0.6</code>版本,而其他的不动.</p>
</li>
<li><p>接下来就是编译了,直接在<code>$NUTCH_HOME</code>根目录上执行<code>ant runtime</code>即可.<br> 但是这个速度不得不吐槽.非常的坑爹,基本上下了我3个多小时.不知道是什么原因,我平时使用JAVA的Maven环境的时候下载其实是非常的快的.但是IVY的依赖下载就非常非常非常的慢.理论上他们是同一个网络地址啊. 为了能加速那么一丢丢.可以把<code>$NUTCH_HOME/ivy/ivysettings.xml</code>中的<code>repo.maven.org</code>给替换成国内的镜像.比如:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"repo.maven.org"</span></span><br><span class="line">   <span class="attribute">value</span>=<span class="value">"http://maven.oschina.net/content/groups/public/"</span></span><br><span class="line">   <span class="attribute">override</span>=<span class="value">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p> 其他的两个不能替换,我换了以后会找不到包的.</p>
<p> 如果你的编译长时间的停在<code>[ivy:resolve] :: loading settings :: file = $NUTCH_HOME/ivy/ivysettings.xml</code>.那么你可以把进程杀了重新执行一次<code>ant runtime</code>.可能执行个十来次就能编译成功了.</p>
<p> 最终,会显示:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">job:</span><br><span class="line">     [jar] Building jar: <span class="variable">$NUTCH_HOME</span>/build/apache-nutch-<span class="number">2.3</span>.job</span><br><span class="line">runtime:</span><br><span class="line">    [copy] Copying <span class="number">1</span> file to <span class="variable">$NUTCH_HOME</span>/nutch/runtime/deploy</span><br><span class="line">    [copy] Copying <span class="number">2</span> files to <span class="variable">$NUTCH_HOME</span>/nutch/runtime/<span class="built_in">local</span>/lib</span><br><span class="line">BUILD SUCCESSFUL</span><br></pre></td></tr></table></figure>
<p> 然后会在你的<code>$NUTCH_HOME</code>目录下,创建<code>runtime</code>和<code>build</code>目录. 其中的<code>runtime</code>目录即为你编译好了的<code>Nutch2.3</code>.</p>
<p> 如果在编译过程中出现<code>Could not load definitions from resource org/sonar/ant/antlib.xml.It could not be found.</code>的警告的话,不要着急,这个错误不影响你最后的编译是否成功.如果你有强迫症,见不得有警告的话.那么可以到<a href="http://search.maven.org" target="_blank" rel="external">Maven</a>中下载<code>sonar-ant-task-2.2.jar</code>包,然后放入<code>$NUTCH_HOME/lib</code>,然后修改<code>$NTUCH_HOME/build.xml</code>即可:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Define the Sonar task if this hasn't been done in a common script --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">taskdef</span> <span class="attribute">uri</span>=<span class="value">"antlib:org.sonar.ant"</span> <span class="attribute">resource</span>=<span class="value">"org/sonar/ant/antlib.xml"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classpath</span> <span class="attribute">path</span>=<span class="value">"$&#123;ant.library.dir&#125;"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classpath</span> <span class="attribute">path</span>=<span class="value">"$&#123;mysql.library.dir&#125;"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classpath</span>&gt;</span><span class="tag">&lt;<span class="title">fileset</span> <span class="attribute">dir</span>=<span class="value">"lib/"</span> <span class="attribute">includes</span>=<span class="value">"sonar*.jar"</span> /&gt;</span><span class="tag">&lt;/<span class="title">classpath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">taskdef</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="部署">部署</h2><p>其实编译完成后的<code>runtime</code>文件夹就已经是一个完整的可以运行的环境了.<br>我们在这里做一个简单的测试:使用Nutch爬取<a href="http://www.cnbeta.com" target="_blank" rel="external">cnbeta</a>中的新闻文章.</p>
<ol>
<li><p>在<code>$NUTCH_HOME/runtime/local</code>下创建一个文件<code>seed.txt</code>. 里面就是需要爬取的网站,一行一个.我们在这里只写一行:<code>www.cnbeta.com</code></p>
</li>
<li><p>修改<code>$NUTCH_HOME/runtime/cong/automaton-urlfilter.txt</code>文件,这个文件就是URL的过滤.避免爬取到不需要的网站.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># accept anything else</span></span><br><span class="line">+^http://www.cnbeta.com/$</span><br><span class="line">+^http://www.cnbeta.com/articles/\d\.htm$</span><br><span class="line"><span class="comment"># skip everything else</span></span><br><span class="line">-.</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在命令行中执行<code>$NUTCH_HOME/runtime/bin/crawl seed.txt test 2</code>.<br> 这个时候就会开始爬取目标网站了.你会看到很多的日志信息:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	fetching http://www.cnbeta.com/topics/<span class="number">8</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">71</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">28</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">464</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">72</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">27</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">455</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">73</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">68</span> <span class="number">102</span> kb/s, <span class="number">26</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">83</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">49</span>/<span class="number">50</span> spinwaiting/active, <span class="number">73</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">0</span> kb/s, <span class="number">25</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">74</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">25</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">444</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">75</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">68</span> <span class="number">102</span> kb/s, <span class="number">24</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/commentrss.php (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">76</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">0</span> kb/s, <span class="number">23</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br><span class="line">fetching http://www.cnbeta.com/topics/<span class="number">197</span>.htm (queue crawl delay=<span class="number">5000</span>ms)</span><br><span class="line"><span class="number">50</span>/<span class="number">50</span> spinwaiting/active, <span class="number">77</span> pages, <span class="number">10</span> errors, <span class="number">0.2</span> <span class="number">0</span> pages/s, <span class="number">67</span> <span class="number">102</span> kb/s, <span class="number">22</span> URLs <span class="keyword">in</span> <span class="number">1</span> queues</span><br></pre></td></tr></table></figure>
<p> 等一段时间后,爬取就完成了.然后打开Mongo数据库,就会看到有一个<code>mytestdatabase</code>的库.里面有一个<code>test_webpage</code>的表,其中的东西就是爬虫爬取的内容了.随便抓取一个举例:</p>
 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">	&#123;</span><br><span class="line">  "_id": "com.cnbeta.www:http/articles/447355.htm",</span><br><span class="line">  "status": 2,</span><br><span class="line">  "fetchTime": NumberLong(1449587050404),</span><br><span class="line">  "fetchInterval": 2592000,</span><br><span class="line">  "retriesSinceFetch": 0,</span><br><span class="line">  "score": 0.0,</span><br><span class="line">  "inlinks": &#123;</span><br><span class="line">    "http://www·cnbeta·com/": ""</span><br><span class="line">  &#125;,</span><br><span class="line">  "markers": &#123;</span><br><span class="line">    "_gnmrk_": "1449586889-28161",</span><br><span class="line">    "_ftcmrk_": "1449586889-28161",</span><br><span class="line">    "dist": "1"</span><br><span class="line">  &#125;,</span><br><span class="line">  "metadata": &#123;</span><br><span class="line">    "_rs_": BinData(0, "AAABzw==")</span><br><span class="line">  &#125;,</span><br><span class="line">  "batchId": "1449586889-28161",</span><br><span class="line">  "baseUrl": "http://www.cnbeta.com/articles/447355.htm",</span><br><span class="line">  "prevFetchTime": NumberLong(1449586888595),</span><br><span class="line">  "protocolStatus": &#123;</span><br><span class="line">    "code": 1,</span><br><span class="line">    "args": [</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line">    "lastModified": NumberLong(0)</span><br><span class="line">  &#125;,</span><br><span class="line">  "content": BinData(0, "XXXXXX网页的内容,太长了,就省略了"),</span><br><span class="line">  "contentType": "application/xhtml+xml",</span><br><span class="line">  "headers": &#123;</span><br><span class="line">    "Vary": "Accept-Encoding",</span><br><span class="line">    "Date": "Tue, 08 Dec 2015 15:04:10 GMT",</span><br><span class="line">    "Last-Modified": "Sun, 06 Dec 2015 02:11:14 GMT",</span><br><span class="line">    "Content-Encoding": "gzip",</span><br><span class="line">    "Content-Type": "text/html",</span><br><span class="line">    "Accept-Ranges": "bytes",</span><br><span class="line">    "Connection": "close",</span><br><span class="line">    "Server": "grid-cache/1.4.4",</span><br><span class="line">    "X-CDNZZ-FCACHE": "EXPIRED"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这就是爬取下来的内容.就可以通过我们进一步处理了.<br> 而这个字段的定义是在<code>$NUTCH_HOME/runtime/local/conf/gora-mongodb-mapping.xml</code>中定义的.</p>
</li>
</ol>
<h2 id="结束语">结束语</h2><p>这样,一个最简单的Nutch的运行环境就搭建成功了.更多的更高级的功能,我们后面再慢慢来试验.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Nutch2-3_安装与部署">Nutch2.3 安装与部署</h1><p><a href="http://nutch.apache.org">Nutch</a>是由JAVA开发的开源的全文检索引擎.不过更多的被用来当成Web爬虫来使用.现在Nutch分为了1.x和2.x两个版本在维护.而这两个版本的最主要的区别在于底层存储的抽象.1.x版本是基于Hadoop架构的,底层存储只能使用HDFS.而2.x版本通过<a href="http://gora.apache.org">Apache Gora</a>对底层存储做了抽象,能访问HBase,MYSQL,MongoDB,Solr,AvroStore等等.</p>
<p>但是从2.X开始,官方就只提供源码的下载了,不再提供编译后的发布版本,因此就需要我们自己去进行编译.</p>]]>
    
    </summary>
    
      <category term="Nutch" scheme="http://sunxiang0918.github.io/tags/Nutch/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="爬虫" scheme="http://sunxiang0918.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Linux上运行Swift]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/05/%E5%9C%A8Linux%E4%B8%8A%E8%BF%90%E8%A1%8CSwift/"/>
    <id>http://sunxiang0918.github.io/2015/12/05/在Linux上运行Swift/</id>
    <published>2015-12-05T15:26:26.000Z</published>
    <updated>2015-12-05T16:29:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在Linux上运行Swift">在Linux上运行Swift</h1><p>盼星星盼月亮,等了半年,终于在12月的头几天,苹果开源了<code>Swift</code>语言.并建立了一个<a href="http://swift.org" target="_blank" rel="external">Swift.org</a>社区以及<a href="http://github.com/apple" target="_blank" rel="external">Github</a>来维护.开源以后,最大的好处当然是有更多的人来参与Swift语言的发展,让Swift语言增加更多的新的特性,更多的开源框架,工作在更多的平台上面.这对于一个开发语言来说无疑是一个很好的消息.而对于我来说,除了在编写代码的时候能更了解Swift某些函数的参数意义和工作的原理(作为一个JAVA Coder,平时如果遇到搞不定的问题或者是不明白的地方,习惯了直接翻它的源码来了解原委的)外,让我基本上抛弃了<code>Python</code>脚本,平时有什么小东西小程序需要写一下的话,现在可以直接写一个Swift文件,然后在命令行直接调用<code>swift xxx.swift</code>或者<code>swiftc -O xxxx.swift</code>即可.</p>
<h2 id="在Linux上安装Swift">在Linux上安装Swift</h2><p>前面废话说了这么多.现在就来看看如何在Linux上安装Swift的运行环境.MACOS上的就不用说了,直接安装一个Xcode就可以了.</p>
<a id="more"></a>
<h3 id="环境">环境</h3><p>目前Swift提供了<code>Ubuntu</code>上编译好了的安装包. 因此需要Ubuntu14.04以上的操作系统.<br>同时,Swift的编译环境还需要<code>clang</code>.这个也是需要安装的.</p>
<ol>
<li><p>由于<code>clang</code>目前才出来,比较的新.因此在<code>cn.archive.ubuntu.com</code>上还没有,需要切换到官方源上去.</p>
<ol>
<li>备份原来的源列表 <code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></li>
<li><p>使用编辑器打开<code>sources.list</code>文件,修改里面的内容为:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-security main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-updates main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-proposed main restricted universe multiverse  </span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ vivid-backports main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-security main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-updates main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-proposed main restricted universe multiverse  </span><br><span class="line">deb-src http://archive.ubuntu.com/ubuntu/ vivid-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后更新一下源 <code>sudo apt-get update</code></p>
</li>
<li><p>安装<code>clang</code></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install clang libicu-dev</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>下载,并安装<code>Swift</code></p>
<ol>
<li>在<a href="https://swift.org/download/" target="_blank" rel="external">官方网站</a>上下载与你操作系统对应的安装包.比如我用的<code>Ubuntu 14.10</code>操作系统,那么就下载<a href="https://swift.org/builds/ubuntu1404/swift-2.2-SNAPSHOT-2015-12-01-b/swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu14.04.tar.gz" target="_blank" rel="external">swift-2.2-SNAPSHOT-2015-12-01-b-ubuntu14.04.tar.gz</a></li>
<li><p>下载后,解压到本地目录.由于它都是安排好了目录的.都是<code>/usr</code>下面.因此.只需要拷贝到/usr下面即可.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -R /swift/usr/ /</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样,Swift的运行环境就算是安装完成了.我们可以输入<code>swift --version</code>来做验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Parallels-Virtual-Platform:~$ swift --versionSwift version <span class="number">2.2</span>-dev (LLVM <span class="number">46</span>be9ff861, Clang <span class="number">4</span>deb154edc, Swift <span class="number">778</span>f82939c)Target: x86_64-unknown-linux-gnu</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="在命令行中执行一个简单程序">在命令行中执行一个简单程序</h2><p>既然安装完成了运行环境,那么接下来我们就试着编写一个最简单的程序.然后执行.</p>
<ol>
<li>创建一个<code>test.swift</code>文件.</li>
<li>在其中写上</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Hello Swift!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<ol>
<li>保存文件后,在命令行中执行 <code>swift test.swift</code>.即可得到程序执行的结果.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Parallels-Virtual-Platform:~$ swift test.swift</span><br><span class="line">Hello Swift!</span><br></pre></td></tr></table></figure>
<ol>
<li>我们也可以把这个文件直接编译成可执行的程序:<code>swift -O test.swift</code>.执行了这个命令后,会在当前目录生成一个<code>test</code>可执行文件. 直接在命令行中执行<code>./test</code>也是可以得到结果的.</li>
</ol>
<p>Swift的命令行程序与其他的语言不同,它不需要一个特殊约定的<code>main</code>函数. 只要你执行的命令的作用于是全局的,那么在就会在执行的时候按顺序的先执行这些全局作用于的语句.相当于它的全局作用域就是一个大的<code>main</code>函数.<br>又由于一个Swift文件中可以写很多的类或方法,不想<code>JAVA</code>一样,一个<code>java</code>文件只能有一个公开的类.因此,对于一个简单的小程序来说,我们完全可以把所有的代码都写在一个<code>swift</code>文件中,然后进行执行,不用考虑什么包依赖等等,非常的方便.</p>
<h2 id="在命令行中执行一个多文件编译的程序">在命令行中执行一个多文件编译的程序</h2><p>当然,除了最最简单的只有1个文件的程序外,更多的程序都是有代码结构的,都是由多个<code>swift</code>文件组成的.<br>在这种情况下,就需要使用<code>swift build</code>命令来 多文件协同编译了.</p>
<ol>
<li><p>这种情况下的swift程序源码需要按照一定的约定来创建.</p>
<ol>
<li>项目的名称即为目录的名称. 比如我现在有个<code>TestProgram</code>的项目,那么就需要创建一个<code>TestProgram</code>的目录.</li>
<li>在这个目录下创建一个<code>Package.swift</code>文件,这个文件是必须的,它用于提供给包管理器进行包依赖的信息.这就类似于JAVA中的<code>package-info.java</code></li>
<li>创建一个<code>Sources</code>文件夹,所有的源码都应该放在这里</li>
<li>在<code>Sources</code>文件夹下,创建一个<code>main.swift</code>文件,这个就是应用的入口文件.</li>
<li><p>最终,项目的结构就是这样的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/TestProgram</span><br><span class="line">/TestProgram/Package.swift</span><br><span class="line">/TestProgram/Sources/main.swift</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>为了体现多文件协同编译,现在再在<code>Sources</code>目录下新增加一个文件<code>Hello.swif</code></p>
</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(a:<span class="params">(name:String)</span></span></span>-&gt;<span class="type">Void</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> args = <span class="type">Process</span>.arguments</span><br><span class="line">		<span class="keyword">if</span> args.<span class="built_in">count</span> &gt;= <span class="number">2</span>&#123;</span><br><span class="line">			a(name:args[<span class="number">1</span>])</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"Hello Swift!"</span>)</span><br><span class="line">		&#125;       &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>然后在<code>main.swift</code>中编写:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello(&#123;name <span class="keyword">in</span> <span class="built_in">print</span>(<span class="string">"Hello <span class="subst">\(name)</span> on Linux!"</span>)&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>回到项目的根目录<code>/TestProgram</code>.执行<code>swift build</code>编译即可.正确的话它会输出以下信息</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Parallels-Virtual-Platform:~/TestProject$ swift buildCompiling Swift Module <span class="string">'TestProject'</span> (<span class="number">2</span> sources)Linking Executable:  .build/debug/TestProjectroot@Parallels-Virtual-Platform:~/TestProject$ .build/debug/TestProject</span><br></pre></td></tr></table></figure>
<p> 需要注意的是,<code>swift build</code>会在工程目录下生成一个<code>.build</code>文件夹,里面就是编译后的可执行的文件,默认是使用的<code>debug target</code>. 并且<code>Linux</code>下编译的可执行文件是不能直接在<code>OSX</code>上使用的,反之亦然.</p>
</li>
<li><p>直接调用<code>.build/debug/TestProject</code> 便可执行程序.</p>
</li>
<li><p>第二步的代码中有一句<code>let args = Process.arguments</code>.我们可以通过此函数获取命令行的输入,它肯定是一个大于等于1的数组,第一个元素就是程序自己的名字.后面是用户在命令行中输入的参数,并且不仅仅限于<code>main.swift</code>才能获取,任何的Swift文件中都可以取得这个值.因此,我们刚才的程序也可以这样输入:<code>.build/debug/TestProject SUN</code>.那么程序的<code>args[1]</code>即为<code>SUN</code>.</p>
</li>
<li>由于Swift不需要像<code>JAVA</code>或者<code>OC</code>一样,如果源码在两个源文件中就需要编写一堆无用的<code>import</code>语句,只要在同一个项目中,<code>Swift</code>的不同源文件定义的类或函数都可以直接的调用,只有在跨工程或<code>Framework</code>的时候,才需要<code>import Package</code>.这大大的方便了我们编写项目.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在Linux上运行Swift">在Linux上运行Swift</h1><p>盼星星盼月亮,等了半年,终于在12月的头几天,苹果开源了<code>Swift</code>语言.并建立了一个<a href="http://swift.org">Swift.org</a>社区以及<a href="http://github.com/apple">Github</a>来维护.开源以后,最大的好处当然是有更多的人来参与Swift语言的发展,让Swift语言增加更多的新的特性,更多的开源框架,工作在更多的平台上面.这对于一个开发语言来说无疑是一个很好的消息.而对于我来说,除了在编写代码的时候能更了解Swift某些函数的参数意义和工作的原理(作为一个JAVA Coder,平时如果遇到搞不定的问题或者是不明白的地方,习惯了直接翻它的源码来了解原委的)外,让我基本上抛弃了<code>Python</code>脚本,平时有什么小东西小程序需要写一下的话,现在可以直接写一个Swift文件,然后在命令行直接调用<code>swift xxx.swift</code>或者<code>swiftc -O xxxx.swift</code>即可.</p>
<h2 id="在Linux上安装Swift">在Linux上安装Swift</h2><p>前面废话说了这么多.现在就来看看如何在Linux上安装Swift的运行环境.MACOS上的就不用说了,直接安装一个Xcode就可以了.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MYSQL支持utf8mb4]]></title>
    <link href="http://sunxiang0918.github.io/2015/12/02/MYSQL%E6%94%AF%E6%8C%81utf8mb4/"/>
    <id>http://sunxiang0918.github.io/2015/12/02/MYSQL支持utf8mb4/</id>
    <published>2015-12-02T14:41:52.000Z</published>
    <updated>2015-12-02T14:59:54.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MYSQL支持utf8mb4">MYSQL支持utf8mb4</h1><p>MYSQL默认的utf8字符集采用了3个字节来进行保存.这就存在了一个问题,那就是有部分的UTF8的字符其实是保存不进MYSQL的,比如现在流行的emoji表情,这和以前的认知是不同的.为了避免以后出现问题,找了这方面的信息.推荐如果有保存扩展字符的用户,提前就把MYSQL的字符集给修改了.具体MYSQL的默认utf8支持哪些字符编码,可以参见这个:<a href="http://witmax.cn/unicode-list.html" target="_blank" rel="external">Unicode编码表</a>,前126行就是它支持的,后面的就是不支持的.</p>
<p>发现这个问题其实相当的偶然,在知乎上看到了一个问题<a href="http://www.zhihu.com/question/35901422/answer/64960598" target="_blank" rel="external">为什么知乎不支持non-BMP的汉字？</a>.突然发现了这个问题,一验证果然如此.<br>具体来说就是MYSQL的utf8字符集只使用了3个字节来保存字符.因此UTF8扩展区的字符就无法保存.这个在MYSQL5.5后引入了<code>utf8mb4</code>的字符集来解决这个问题,它使用了4个字节来存储字符,扩展了存储的数量.因此,如果各位是使用的MYSQL5.5以上的版本,推荐在可能存入扩展字符的字段上设置字符集为utf8mb4.虽然这样可能会造成空间的浪费,但是比以后在上线的系统上升级数据库的风险要小的多.</p>
<a id="more"></a>
<h2 id="修改方法">修改方法</h2><h3 id="MYSQL服务器端">MYSQL服务器端</h3><p>只需要修改数据库的配置文件 <code>/etc/my.cnf</code>,增加或修改以下两行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">character-set-server=utf8mb4 </span><br><span class="line">collation_server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>
<p>然后重启数据库即可.<br>对于已有的表,执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span></span><br></pre></td></tr></table></figure>
<p>即可.</p>
<h3 id="客户端">客户端</h3><p>由于JDBC的MYSQL驱动现在不支持显示的设置<code>utf8mb4</code>字符集,所以不能在url连接上增加<code>characterEncoding=utf8mb4</code>.<br>那么就只能采取以下的三种方法了(都需要高版本的JDBC驱动):</p>
<ol>
<li>在服务器上设置了<code>character-set-server=utf8mb4</code>后,在客户端url上不显示的设置字符集,它会自动继承服务器的设置</li>
<li>在执行SQL之前,运行<code>set names utf8mb4</code>.例如:<code>connection.prepareStatement(&quot;set names utf8mb4&quot;).executeQuery();</code></li>
<li>设置MYSQL的 init_connect参数,设置<code>set names utf8mb4</code>.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MYSQL支持utf8mb4">MYSQL支持utf8mb4</h1><p>MYSQL默认的utf8字符集采用了3个字节来进行保存.这就存在了一个问题,那就是有部分的UTF8的字符其实是保存不进MYSQL的,比如现在流行的emoji表情,这和以前的认知是不同的.为了避免以后出现问题,找了这方面的信息.推荐如果有保存扩展字符的用户,提前就把MYSQL的字符集给修改了.具体MYSQL的默认utf8支持哪些字符编码,可以参见这个:<a href="http://witmax.cn/unicode-list.html">Unicode编码表</a>,前126行就是它支持的,后面的就是不支持的.</p>
<p>发现这个问题其实相当的偶然,在知乎上看到了一个问题<a href="http://www.zhihu.com/question/35901422/answer/64960598">为什么知乎不支持non-BMP的汉字？</a>.突然发现了这个问题,一验证果然如此.<br>具体来说就是MYSQL的utf8字符集只使用了3个字节来保存字符.因此UTF8扩展区的字符就无法保存.这个在MYSQL5.5后引入了<code>utf8mb4</code>的字符集来解决这个问题,它使用了4个字节来存储字符,扩展了存储的数量.因此,如果各位是使用的MYSQL5.5以上的版本,推荐在可能存入扩展字符的字段上设置字符集为utf8mb4.虽然这样可能会造成空间的浪费,但是比以后在上线的系统上升级数据库的风险要小的多.</p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="Mysql" scheme="http://sunxiang0918.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在自己的App中嵌入onePassword密码管理]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/30/%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84App%E4%B8%AD%E5%B5%8C%E5%85%A5onePassword%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    <id>http://sunxiang0918.github.io/2015/11/30/在自己的App中嵌入onePassword密码管理/</id>
    <published>2015-11-30T11:36:31.000Z</published>
    <updated>2015-12-02T15:19:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="在自己的App中嵌入onePassword密码管理">在自己的App中嵌入onePassword密码管理</h1><p><a href="https://agilebits.com/onepassword/" target="_blank" rel="external">1Password</a>是一个密码管理软件,它可以方便和安全的管理你的密码.它提供反钓鱼保护功能和卓越的密码管理,并具有自动生成强密码功能.所有的机密资料,包括密码,身份卡和信用卡,都是保存在一个安全的地方.在OSX和IOS系统上非常的流行.在我的博文<a href="/2015/09/21/MacOS下JAVA开发使用经验(一">MacOS下JAVA开发使用经验(一)</a> )也有介绍.<br>自从我的账号被CSDN泄露的干干净净以后的一段时间里,我的其他账号是不是的就会收到更改密码的邮件.于是,一下狠心购买了<code>1Password</code>,并且把我所有的差不多200多个账号的密码通过<code>1Password</code>都给改成了14位的随机字符,以后就不用担心一个密码丢失导致其他的账号也丢失了(1Password自己本身在它的网上没有所谓的用户名密码,密码是通过加密文件整体在WIFI或iCloud中同步的.).但是这就带来了一个麻烦,就是我的密码都变成了类似于这样的<code>RxCa9vdBUB3fCU</code>的字符串.当使用safari这些的时候还好,它有浏览器的插件可以自动填充.遇到一些App,就只能手动的输入了(类似于光大银行和QQ不允许粘贴密码).这相当的麻烦,又容易出错.因此,自己开发APP的时候,就特别的注意了在输入密码的地方要与<code>1Password</code>的整合,这点网易系的APP就做的比较好,<code>网易云音乐</code>和<code>考拉海淘</code>就是支持了<code>1Password</code>的.<br>要在自己的App中引入<code>1Password</code>其实也不麻烦,可以说是相当的简单.<code>1Password</code>在<code>GitHub</code>上开源了App与它的软件交互的扩展<a href="https://github.com/AgileBits/onepassword-app-extension" target="_blank" rel="external">1PasswordExtension</a>.我们通过这个扩展就可以在自己的App中嵌入<code>1Password</code>的密码管理了.</p>
<a id="more"></a>
<h2 id="导入1PasswordExtension扩展">导入1PasswordExtension扩展</h2><p>这个可以使用<code>cocoaPods</code>. 在项目的<code>Pods</code>文件中增加<code>pod &#39;1PasswordExtension&#39;</code>,然后执行<code>pod install</code>即可.由于它已经兼容了<code>swift</code>了,所以不需要特别的再链接OC的头文件了.</p>
<h2 id="使用1Password进行登陆框的填充">使用1Password进行登陆框的填充</h2><p>这个过程也非常的简单.</p>
<ol>
<li>在登录的页面上增加一个按钮,<code>1PasswordExtension</code>内置好了它的图片,你可以直接使用.</li>
<li>给这个按钮增加点击的事件.</li>
<li><p>在Controller类中增加事件的实现,调用<code>public func findLoginForURLString(URLString: String, forViewController viewController: UIViewController, sender: AnyObject?, completion: (([NSObject : AnyObject]?, NSError?) -&gt; Void)?)</code>方法:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OnePasswordExtension</span>.sharedExtension().findLoginForURLString(<span class="string">""</span>, forViewController: <span class="keyword">self</span>, sender: sender) &#123; (_loginDictionary, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">			   <span class="comment">//loginDictionary中即用调用1Password后,用户选择的用户名和密码</span></span><br><span class="line">               guard <span class="keyword">let</span> loginDictionary = _loginDictionary <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> loginDictionary.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">               		<span class="comment">//如果用户点的是取消,这里就是0</span></span><br><span class="line">                   <span class="keyword">if</span> error!.code != <span class="type">Int</span>(<span class="type">AppExtensionErrorCodeCancelledByUser</span>) &#123;</span><br><span class="line">                       <span class="comment">//<span class="doctag"><span class="keyword">TODO</span></span></span></span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span></span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//把用户名和密码赋值给输入框即可.更进一步的可以直接激活登录操作</span></span><br><span class="line">               view?.userNameField.text = loginDictionary[<span class="type">AppExtensionUsernameKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">               view?.passwordField.text = loginDictionary[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">               </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p> 效果如图:</p>
<p> <img src="/img/2015/11/30/1.PNG" alt=""><br> <img src="/img/2015/11/30/2.PNG" alt=""></p>
</li>
<li><p>如果更想进一步,只有当判断到安装了<code>1Password</code>程序,按钮才出现的话.可以调用<code>view?.onePasswordButton.hidden = !OnePasswordExtension.sharedExtension().isAppExtensionAvailable()</code>.这个方法会判断系统中是否有应用程序能处理<code>org-appextension-feature-password-management</code>这个特性.如果有程序可以执行,那么就返回<code>true</code>. 需要注意的是:在IOS9中你需要给<code>Info.plist</code>文件中增加一行记录:<br> <img src="/img/2015/11/30/3.png" alt=""><br> 更多的信息可以参见<a href="https://developer.apple.com/videos/wwdc/2015/?id=703" target="_blank" rel="external">Privacy and Your Apps session</a></p>
</li>
</ol>
<h2 id="使用1Password进行新用户的注册">使用1Password进行新用户的注册</h2><p>同使用1Password进行用户登陆差不多,新用户的注册也是很简单的.</p>
<ol>
<li>在登录的页面上增加一个按钮,<code>1PasswordExtension</code>内置好了它的图片,你可以直接使用.</li>
<li>给这个按钮增加点击的事件.</li>
<li><p>在Controller类中增加事件的实现,调用<code>public func storeLoginForURLString(URLString: String, loginDetails loginDetailsDictionary: [NSObject : AnyObject]?, passwordGenerationOptions: [NSObject : AnyObject]?, forViewController viewController: UIViewController, sender: AnyObject?, completion: (([NSObject : AnyObject]?, NSError?) -&gt; Void)?)</code>方法</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造1Password新注册用户页面的一些信息</span></span><br><span class="line"><span class="keyword">let</span> newLoginDetails:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="type">AppExtensionTitleKey</span>: <span class="string">"ACME"</span>,</span><br><span class="line">		<span class="type">AppExtensionUsernameKey</span>: <span class="keyword">self</span>.usernameTextField.text!,</span><br><span class="line">		<span class="type">AppExtensionPasswordKey</span>: <span class="keyword">self</span>.passwordTextField.text!,</span><br><span class="line">		<span class="type">AppExtensionNotesKey</span>: <span class="string">"Saved with the ACME app"</span>,</span><br><span class="line">		<span class="type">AppExtensionSectionTitleKey</span>: <span class="string">"ACME Browser"</span>,</span><br><span class="line">		<span class="type">AppExtensionFieldsKey</span>: [</span><br><span class="line">			<span class="string">"firstname"</span> : <span class="keyword">self</span>.firstnameTextField.text!,</span><br><span class="line">			<span class="string">"lastname"</span> : <span class="keyword">self</span>.lastnameTextField.text!</span><br><span class="line">			<span class="comment">// Add as many string fields as you please.</span></span><br><span class="line">		]</span><br><span class="line">	]</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置密码生成规则</span></span><br><span class="line">	<span class="keyword">let</span> passwordGenerationOptions:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="comment">// 密码最小长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMinLengthKey</span>: (<span class="number">8</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 最大密码长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMaxLengthKey</span>: (<span class="number">30</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 是否必须包含数字</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireDigitsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 字符必须包含符号</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireSymbolsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Here are all the symbols available in the the 1Password Password Generator:</span></span><br><span class="line">		<span class="comment">// !@#$%^&amp;*()_-+=|[]&#123;&#125;'\";.,&gt;?/~`</span></span><br><span class="line">		<span class="comment">// The string for AppExtensionGeneratedPasswordForbiddenCharactersKey should contain the symbols and characters that you wish 1Password to exclude from the generated password.</span></span><br><span class="line">		<span class="comment">//生成密码的时候排除的字符</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordForbiddenCharactersKey</span>: <span class="string">"!@#$%/0lIO"</span></span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用1Password,打开它的页面输入用户注册信息</span></span><br><span class="line">	<span class="type">OnePasswordExtension</span>.sharedExtension().storeLoginForURLString(<span class="string">"https://www.acme.com"</span>, loginDetails: newLoginDetails, passwordGenerationOptions: passwordGenerationOptions, forViewController: <span class="keyword">self</span>, sender: sender) &#123; (loginDictionary, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">		<span class="keyword">if</span> loginDictionary == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> error!.code != <span class="type">Int</span>(<span class="type">AppExtensionErrorCodeCancelledByUser</span>) &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"Error invoking 1Password App Extension for find login: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把用户输入的注册信息返回给界面组件</span></span><br><span class="line">		<span class="keyword">self</span>.usernameTextField.text = loginDictionary?[<span class="type">AppExtensionUsernameKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.passwordTextField.text = loginDictionary?[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.firstnameTextField.text = loginDictionary?[<span class="type">AppExtensionReturnedFieldsKey</span>]?[<span class="string">"firstname"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.lastnameTextField.text = loginDictionary?[<span class="type">AppExtensionReturnedFieldsKey</span>]?[<span class="string">"lastname"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p> 效果如图:</p>
<p> <img src="/img/2015/11/30/4.PNG" alt=""><br> <img src="/img/2015/11/30/5.PNG" alt=""></p>
</li>
</ol>
<h2 id="使用1Password进行密码的修改">使用1Password进行密码的修改</h2><p>既然有新用户的注册以及登陆,那么密码管理中还有一个就是密码的修改.</p>
<ol>
<li>在登录的页面上增加一个按钮,<code>1PasswordExtension</code>内置好了它的图片,你可以直接使用.</li>
<li>给这个按钮增加点击的事件.</li>
<li><p>在Controller类中增加事件的实现,调用<code>public func changePasswordForLoginForURLString(URLString: String, loginDetails loginDetailsDictionary: [NSObject : AnyObject]?, passwordGenerationOptions: [NSObject : AnyObject]?, forViewController viewController: UIViewController, sender: AnyObject?, completion: (([NSObject : AnyObject]?, NSError?) -&gt; Void)?)</code></p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造1Password修改密码页面的一些信息</span></span><br><span class="line"><span class="keyword">let</span> newLoginDetails:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="type">AppExtensionTitleKey</span>: <span class="string">"ACME"</span>, <span class="comment">// Optional, used for the third schenario only</span></span><br><span class="line">		<span class="type">AppExtensionUsernameKey</span>: <span class="string">"aUsername"</span>, <span class="comment">// Optional, used for the third schenario only</span></span><br><span class="line">		<span class="type">AppExtensionPasswordKey</span>: changedPassword,</span><br><span class="line">		<span class="type">AppExtensionOldPasswordKey</span>: oldPassword,</span><br><span class="line">		<span class="type">AppExtensionNotesKey</span>: <span class="string">"Saved with the ACME app"</span>, <span class="comment">// Optional, used for the third schenario only</span></span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置密码生成规则</span></span><br><span class="line">	<span class="keyword">let</span> passwordGenerationOptions:[<span class="type">String</span>: <span class="type">AnyObject</span>] = [</span><br><span class="line">		<span class="comment">// 密码最小长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMinLengthKey</span>: (<span class="number">8</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 最大密码长度</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordMaxLengthKey</span>: (<span class="number">30</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 是否必须包含数字</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireDigitsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 字符必须包含符号</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordRequireSymbolsKey</span>: (<span class="literal">true</span>),</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Here are all the symbols available in the the 1Password Password Generator:</span></span><br><span class="line">		<span class="comment">// !@#$%^&amp;*()_-+=|[]&#123;&#125;'\";.,&gt;?/~`</span></span><br><span class="line">		<span class="comment">// The string for AppExtensionGeneratedPasswordForbiddenCharactersKey should contain the symbols and characters that you wish 1Password to exclude from the generated password.</span></span><br><span class="line">		<span class="comment">//生成密码的时候排除的字符</span></span><br><span class="line">		<span class="type">AppExtensionGeneratedPasswordForbiddenCharactersKey</span>: <span class="string">"!@#$%/0lIO"</span></span><br><span class="line">	]</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用1Password,打开它的页面输入密码修改信息OnePasswordExtension.sharedExtension().changePasswordForLoginForURLString("https://www.acme.com", loginDetails: newLoginDetails, passwordGenerationOptions: passwordGenerationOptions, forViewController: self, sender: sender) &#123; (loginDictionary, error) -&gt; Void in</span></span><br><span class="line">		<span class="keyword">if</span> loginDictionary == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> error!.code != <span class="type">Int</span>(<span class="type">AppExtensionErrorCodeCancelledByUser</span>) &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"Error invoking 1Password App Extension for find login: <span class="subst">\(error)</span>"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//把用户的修改返还给界面</span></span><br><span class="line">		<span class="keyword">self</span>.oldPasswordTextField.text = loginDictionary?[<span class="type">AppExtensionOldPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.freshPasswordTextField.text = loginDictionary?[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">		<span class="keyword">self</span>.confirmPasswordTextField.text = loginDictionary?[<span class="type">AppExtensionPasswordKey</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p> 效果如图:</p>
<p> <img src="/img/2015/11/30/6.PNG" alt=""><br> <img src="/img/2015/11/30/7.PNG" alt=""></p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="在自己的App中嵌入onePassword密码管理">在自己的App中嵌入onePassword密码管理</h1><p><a href="https://agilebits.com/onepassword/">1Password</a>是一个密码管理软件,它可以方便和安全的管理你的密码.它提供反钓鱼保护功能和卓越的密码管理,并具有自动生成强密码功能.所有的机密资料,包括密码,身份卡和信用卡,都是保存在一个安全的地方.在OSX和IOS系统上非常的流行.在我的博文<a href="/2015/09/21/MacOS下JAVA开发使用经验(一">MacOS下JAVA开发使用经验(一)</a> )也有介绍.<br>自从我的账号被CSDN泄露的干干净净以后的一段时间里,我的其他账号是不是的就会收到更改密码的邮件.于是,一下狠心购买了<code>1Password</code>,并且把我所有的差不多200多个账号的密码通过<code>1Password</code>都给改成了14位的随机字符,以后就不用担心一个密码丢失导致其他的账号也丢失了(1Password自己本身在它的网上没有所谓的用户名密码,密码是通过加密文件整体在WIFI或iCloud中同步的.).但是这就带来了一个麻烦,就是我的密码都变成了类似于这样的<code>RxCa9vdBUB3fCU</code>的字符串.当使用safari这些的时候还好,它有浏览器的插件可以自动填充.遇到一些App,就只能手动的输入了(类似于光大银行和QQ不允许粘贴密码).这相当的麻烦,又容易出错.因此,自己开发APP的时候,就特别的注意了在输入密码的地方要与<code>1Password</code>的整合,这点网易系的APP就做的比较好,<code>网易云音乐</code>和<code>考拉海淘</code>就是支持了<code>1Password</code>的.<br>要在自己的App中引入<code>1Password</code>其实也不麻烦,可以说是相当的简单.<code>1Password</code>在<code>GitHub</code>上开源了App与它的软件交互的扩展<a href="https://github.com/AgileBits/onepassword-app-extension">1PasswordExtension</a>.我们通过这个扩展就可以在自己的App中嵌入<code>1Password</code>的密码管理了.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为自己的APP增加OpenIn功能]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/27/%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84APP%E5%A2%9E%E5%8A%A0OpenIn%E5%8A%9F%E8%83%BD/"/>
    <id>http://sunxiang0918.github.io/2015/11/27/为自己的APP增加OpenIn功能/</id>
    <published>2015-11-27T01:55:25.000Z</published>
    <updated>2015-11-30T09:56:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为自己的APP增加OpenIn功能">为自己的APP增加OpenIn功能</h1><p>在做App的时候,可能会遇到你的程序可以打开某种类型的文档.比如用户在safari中下载了一个torrent类型的文件,然后需要直接使用你写的App打开.那么这个时候就需要在编写App的时候进行文档类型的注册了.</p>
<p><img src="/img/2015/11/27/1.png" alt=""></p>
<a id="more"></a>
<h2 id="1-在Info-plist中注册文档类型">1.在Info.plist中注册文档类型</h2><p>首先要做的就是在Info.plist中增加文档类型的注册,表示这个程序能处理哪些文档.</p>
<p>这里有两种方式,一种是通过项目的Info栏直接增加<code>Document Types</code>和<code>Exported UTIs</code>.<br>就像这样:</p>
<p><img src="/img/2015/11/27/3.png" alt=""></p>
<p>还有一种就是直接修改info.plist文件:</p>
<p><img src="/img/2015/11/27/2.png" alt=""></p>
<p>其xml为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleDocumentTypes<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>LSItemContentTypes<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>cn.sunxiang0918.transmission.torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleTypeRole<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>Viewer<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleTypeName<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>torrent file<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>LSHandlerRank<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>Owner<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTExportedTypeDeclarations<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTTypeConformsTo<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>public.data<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTTypeIdentifier<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">string</span>&gt;</span>cn.sunxiang0918.transmission.torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">key</span>&gt;</span>UTTypeTagSpecification<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">dict</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">key</span>&gt;</span>public.mime-type<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>application/torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">key</span>&gt;</span>public.filename-extension<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">string</span>&gt;</span>torrent<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里稍作解释.</p>
<ul>
<li><strong>CFBundleDocumentTypes</strong>:为注册文档类型以及角色</li>
<li><strong>UTExportedTypeDeclarations</strong>:为注册处理类型与方式</li>
<li><strong>LSItemContentTypes</strong>:自己定义的一种文档的唯一串</li>
<li><strong>CFBundleTypeName</strong>:文档的类型名字</li>
<li><strong>UTTypeTagSpecification</strong>:指定文档的类型以及后缀名</li>
</ul>
<p>通过这个的指定,现在程序就能关联到某种文档文件了.</p>
<h2 id="处理文档的打开操作">处理文档的打开操作</h2><p>有了与文档的关联后,还需要进行的操作就是当用户指定APP打开文档后需要执行的操作了.</p>
<p><del>在<code>AppDelegate</code>这个程序的入口类中,有一个方法:<code>func application(application: UIApplication, openURL url: NSURL, sourceApplication: String?, annotation: AnyObject) -&gt; Bool</code>.<br>我们只要重载这个方法就可以了.<br>这个方法中最总要的两个入参就是<code>openURL url: NSURL</code>以及<code>sourceApplication: String?</code><br>它说明了是哪一个其他程序传过来的文档,以及文档目前的路径是什么.<br>当有了这个参数后,我们就可以直接读取文档的内容了.</del><code>IOS9废弃</code></p>
<p>在<code>AppDelegate</code>这个程序的入口类中,有一个方法:<code>func application(application: UIApplication, openURL url: NSURL, options: [String : AnyObject]) -&gt; Bool</code>.<br>我们只要重载这个方法就可以了.<br>这个方法中最重要的两个入参就是<code>openURL url: NSURL</code>以及<code>options: [String : AnyObject]</code><br>它说明了是哪一个其他程序传过来的文档,以及文档目前的路径是什么.<br>当有了这个参数后,我们就可以直接读取文档的内容了.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, openURL url: NSURL,options: [String : AnyObject])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> encrypteddata = <span class="type">NSData</span>(contentsOfURL: url)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> base64 = encrypteddata!.base64EncodedStringWithOptions(<span class="type">NSDataBase64EncodingOptions</span>(rawValue: <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//尝试删除文件</span></span><br><span class="line">            try <span class="type">NSFileManager</span>.defaultManager().removeItemAtURL(url)</span><br><span class="line">        &#125; catch <span class="keyword">let</span> e &#123;</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>NSData(contentsOfURL: url)</code>可以读取文档的二进制的内容.<br>文档读取后可以通过<code>NSFileManager.defaultManager().removeItemAtURL(url)</code>删除磁盘上的文档.<br>最后返回一个true,表示是这个程序是能处理这个文档的.</p>
<p>到此,我们的自己的程序就能打开任意的文档并进行相应的处理了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为自己的APP增加OpenIn功能">为自己的APP增加OpenIn功能</h1><p>在做App的时候,可能会遇到你的程序可以打开某种类型的文档.比如用户在safari中下载了一个torrent类型的文件,然后需要直接使用你写的App打开.那么这个时候就需要在编写App的时候进行文档类型的注册了.</p>
<p><img src="/img/2015/11/27/1.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift中使用NSUserDefaults保存自定义对象]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/24/Swift%E4%B8%AD%E4%BD%BF%E7%94%A8NSUserDefaults%E4%BF%9D%E5%AD%98%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1/"/>
    <id>http://sunxiang0918.github.io/2015/11/24/Swift中使用NSUserDefaults保存自定义对象/</id>
    <published>2015-11-24T03:32:07.000Z</published>
    <updated>2015-11-24T04:08:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift中使用NSUserDefaults保存自定义对象">Swift中使用NSUserDefaults保存自定义对象</h1><p>NSUserDefaults适合存储轻量级的本地客户端数据,比如保存一些系统的基本配置等东西,使用NSUserDefaults是首选,它非常的简单,不依赖其他的什么东西,屏蔽了Plist文件的读写等等.</p>
<p>但是NSUserDefaults支持的数据格式比较有限,只支持了<code>Int</code>、<code>Float</code>、<code>Double</code>，<code>String</code>，<code>NSDate</code>，<code>NSArray</code>，<code>NSDictionary</code>，<code>Bool</code>.不支持自定义对象的存取.</p>
<p>这个特性对于简单的数值来说还算比较容易.只需要简单的操作(一个Value 一个Key ),例如，想要保存一个NSString的对象，代码实现为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().setInteger(<span class="number">10</span>, forKey: <span class="string">"aaa"</span>)</span><br><span class="line"><span class="comment">//取</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().integerForKey(<span class="string">"aaaa"</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是涉及到复杂的对象的时候,就需要我们进行特殊的处理了.</p>
<p>其实这个特殊处理也很简单,既然<code>NSUserDefaults</code>支持<code>NSDate</code>类型的数据.那么我们在存取自定义对象的时候,就可以预先把我们的自定义对象转换成为<code>NSData</code>类型的即可.</p>
<p>在Swift中如果要把一个自定义对象能转换成为<code>NSData</code>.需要在自定义对象上实现<code>NSObject</code>和<code>NSCoding</code>协议,并且实现<code>func encodeWithCoder(aCoder: NSCoder)</code>和<code>init?(coder aDecoder: NSCoder)</code>方法,比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Foundation</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SiteInfoVO</span> : <span class="title">NSObject</span>,<span class="title">NSCoding</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> url:<span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> userName:<span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> password:<span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(url:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@objc</span> internal <span class="func"><span class="keyword">func</span> <span class="title">encodeWithCoder</span><span class="params">(aCoder: NSCoder)</span></span> &#123;</span><br><span class="line">        aCoder.encodeObject(url, forKey: <span class="string">"url"</span>)</span><br><span class="line">        aCoder.encodeObject(userName, forKey: <span class="string">"userName"</span>)</span><br><span class="line">        aCoder.encodeObject(password, forKey: <span class="string">"password"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">@objc</span> internal required <span class="keyword">init</span>?(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        url = aDecoder.decodeObjectForKey(<span class="string">"url"</span>) <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">        </span><br><span class="line">        userName = aDecoder.decodeObjectForKey(<span class="string">"userName"</span>) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        password = aDecoder.decodeObjectForKey(<span class="string">"password"</span>) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用<code>NSKeyedUnarchiver</code>类来进行转换了.</p>
<p>那么保存一个自定义对象到<code>NSUserDefaults</code>就变为了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _value = <span class="type">SiteInfoVO</span>(url:<span class="string">"123"</span>)</span><br><span class="line"><span class="keyword">let</span> modelData:<span class="type">NSData</span> = <span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject(_value)</span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().setObject(modelData, forKey: <span class="string">"defaultName"</span>)</span><br></pre></td></tr></table></figure>
<p>而读取一个自定义对象就成为了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">NSUserDefaults</span>.standardUserDefaults().objectForKey(<span class="string">"defaultName"</span>) <span class="keyword">as</span>? <span class="type">NSData</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> _data = data &#123;</span><br><span class="line">   <span class="keyword">let</span> model = <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(_data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我们可以给<code>NSUserDefaults</code>增加一个扩展,把编解码自定义对象进行一次封装:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Foundation</span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">extension</span> <span class="title">NSUserDefaults</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">modelForKey</span><span class="params">(defaultName: String)</span></span> -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> obj = <span class="keyword">self</span>.objectForKey(defaultName) <span class="keyword">as</span>? <span class="type">NSData</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> tmp = obj &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(tmp)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">arrayModelForKey</span><span class="params">(defaultName: String)</span></span> -&gt; [<span class="type">AnyObject</span>]? &#123;</span><br><span class="line">        <span class="keyword">let</span> obj = <span class="keyword">self</span>.objectForKey(defaultName) <span class="keyword">as</span>? [<span class="type">NSData</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> result:[<span class="type">AnyObject</span>]?</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> _obj = obj &#123;</span><br><span class="line">            result = []</span><br><span class="line">            <span class="keyword">for</span> tmp <span class="keyword">in</span> _obj &#123;</span><br><span class="line">                <span class="keyword">let</span> myModel = <span class="type">NSKeyedUnarchiver</span>.unarchiveObjectWithData(tmp)</span><br><span class="line">                result?.append(myModel!)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">setModel</span><span class="params">(value: AnyObject?, forKey defaultName: String)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        guard <span class="keyword">let</span> _value = value <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.setObject(<span class="literal">nil</span>, forKey: defaultName)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> modelData:<span class="type">NSData</span> = <span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject(_value)</span><br><span class="line">        <span class="keyword">self</span>.setObject(modelData, forKey: defaultName)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public <span class="func"><span class="keyword">func</span> <span class="title">setArrayModels</span><span class="params">(value: [AnyObject]?, forKey defaultName: String)</span></span> &#123;</span><br><span class="line">        guard <span class="keyword">let</span> _value = value <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.setObject(<span class="literal">nil</span>, forKey: defaultName)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> data:[<span class="type">NSData</span>] = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> _value &#123;</span><br><span class="line">            data.append(<span class="type">NSKeyedArchiver</span>.archivedDataWithRootObject(v))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.setObject(data, forKey: defaultName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:按照这个思路,其实把自定义对象转换成JSON字符串等都是可以的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift中使用NSUserDefaults保存自定义对象">Swift中使用NSUserDefaults保存自定义对象</h1><p>NSUserDefaults适合存储轻量级的本地客户端数据,比如保存一些系统的基本配置等东西,使用NSUserDefaults是首选,它非常的简单,不依赖其他的什么东西,屏蔽了Plist文件的读写等等.</p>
<p>但是NSUserDefaults支持的数据格式比较有限,只支持了<code>Int</code>、<code>Float</code>、<code>Double</code>，<code>String</code>，<code>NSDate</code>，<code>NSArray</code>，<code>NSDictionary</code>，<code>Bool</code>.不支持自定义对象的存取.</p>
<p>这个特性对于简单的数值来说还算比较容易.只需要简单的操作(一个Value 一个Key ),例如，想要保存一个NSString的对象，代码实现为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().setInteger(<span class="number">10</span>, forKey: <span class="string">"aaa"</span>)</span><br><span class="line"><span class="comment">//取</span></span><br><span class="line"><span class="type">NSUserDefaults</span>.standardUserDefaults().integerForKey(<span class="string">"aaaa"</span>)</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker1.9新特性-跨物理机的多容器网络连接]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/09/Docker1-9%E6%96%B0%E7%89%B9%E6%80%A7-%E8%B7%A8%E7%89%A9%E7%90%86%E6%9C%BA%E7%9A%84%E5%A4%9A%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
    <id>http://sunxiang0918.github.io/2015/11/09/Docker1-9新特性-跨物理机的多容器网络连接/</id>
    <published>2015-11-09T13:47:08.000Z</published>
    <updated>2015-12-29T06:00:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Docker1-9新特性-跨物理机的多容器网络连接">Docker1.9新特性-跨物理机的多容器网络连接</h1><p>近日，Docker公司正式发布Docker 1.9版本。他带来了很多新的特性,其中最重要的新特性无疑就是多宿主机互联功能.</p>
<p>在今年6月份的DockerCon上，互联曾经作为测试版本的特性被提出。目前，该特性正式集成在了Docker引擎的稳定版中，并将在产品中使用。其主要功能是为跨宿主机创建Docker引擎中的虚拟网络提供支持。用户可以把其所属的容器挂载到网络中，并控制网络拓扑和通信方式。此外，系统还允许用户在不修改应用的情况下直接与任何网络进行集成。</p>
<p>那么,我们现在就来试一试如何简单的实现多宿主机互联功能.</p>
<h2 id="原理">原理</h2><p>Docker新的网络拓扑是采用的<code>overlay network</code>模式的网络.<br>它需要一个分布式的<code>Key-Value Storage</code>作为辅助的存储.当前Docker支持<code>Consul</code>,<code>Etcd</code>和<code>ZooKeeper</code>.当创建网络之前,你首先是需要安装并运行<code>KVS</code>.然后在启动Docker的时候加上一定的参数,这样Docker就会把网络拓扑信息保存在<code>KVS</code>上,形成全局唯一的网络.</p>
<p><img src="/img/2015/11/09/1.png" alt=""></p>
<a id="more"></a>
<h2 id="安装Docker1-9前的准备">安装Docker1.9前的准备</h2><p>由于Docker1.9多宿主机联网的功能设计为可插拔式，毫无保留兼容<code>VXLAN</code>或者IPVLAN等技术。使用ovs（Open vSwitch）和VXLAN隧道进行实现。因此,需要操作系统支持<code>VXLAN</code>.而在<code>Kernel3.16</code>以下支持这个是有问题的,虽然看得到网络,但是使用这个网络启动容器的时候会报:<code>subnet sandbox join failed for &quot;10.0.0.0/24&quot;: error creating vxlan interface: file exists</code>,这个问题具体可以参见<a href="https://github.com/docker/docker/issues/14145" target="_blank" rel="external">Issues14145</a>.因此我们首先就是需要把操作系统的内核升级.具体的升级方法可以参考我之前的博文<a href="/2015/11/08/升级CentOS7的Linux内核/">升级CentOS7的Linux内核</a>.</p>
<p>然后还需要关闭Selinux. 直接编辑<code>/etc/selinux/config</code>文件中设置<code>SELINUX=disabled</code> ，然后重启服务器。</p>
<p>还需要做的就是关闭防火墙:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service <span class="comment">#停止firewall</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service <span class="comment">#禁止firewall开机启动</span></span><br></pre></td></tr></table></figure>
<h2 id="安装Docker1-9">安装Docker1.9</h2><p>接下来就是安装最新的Docker1.9了. 在安装最新版之前,需要把旧的版本删除了.<br>然后在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>
<p>等他执行完成后,最新版就安装完成了.</p>
<h2 id="启动Zookeeper">启动Zookeeper</h2><p>这里我使用<code>Zookeeper</code>来做试验,官网上的是使用<code>Consul</code>做的演示,如果想使用<code>Consul</code>可以看<a href="http://docs.docker.com/engine/userguide/networking/get-started-overlay/" target="_blank" rel="external">这里</a>.</p>
<p>安装<code>Zookeeper</code>集群就不在这里细说了,可以参考之前的博文<a href="/2014/09/20/zookeeper-集群部署/">zookeeper 集群部署</a>.</p>
<p>安装完后启动<code>zookeeper</code>.  这里假设 我的ZK的地址为:<code>10.211.55.2:2181</code></p>
<h2 id="启动Docker服务">启动Docker服务</h2><p>接下来就是需要启动Docker服务了.<br>以前的启动方式是:<code>service docker start</code>.<br>但是这样就不会增加<code>KVS</code>的参数,因此我们需要手动的启动Docker服务:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker daemon --cluster-store=zk://<span class="number">10.211</span>.<span class="number">55.2</span>:<span class="number">2181</span> --cluster-advertise=eth0:<span class="number">2376</span></span><br></pre></td></tr></table></figure>
<p>这里主要有两个参数:</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">—cluster-store=PROVIDER://URL</td>
<td style="text-align:center">这个指的就是KVS的存储位置,比如zookeeper的就是:zk://xxxx,Consul的就是 consul://xxxxx</td>
</tr>
<tr>
<td style="text-align:center">—cluster-advertise=HOST_IP</td>
<td style="text-align:center">这个就是本机Docker服务需要对外公布的集群地址,可以直接写网卡地址</td>
</tr>
</tbody>
</table>
<p>使用上面的参数启动后,Docker会在Zookeeper上建立一个目录.里面存放的就是网络的配置信息.</p>
<p><img src="/img/2015/11/09/2.png" alt=""></p>
<p>直接把所有宿主机上的Docker都像这样的方式启动.</p>
<p>如果你想直接使用<code>service docker start</code>方式启动的话,需要修改<code>/usr/lib/systemd/system/docker.service</code>这个文件.在<code>ExecStart=/usr/bin/docker daemon</code>后面加上<code>--cluster-store=zk://10.211.55.2:2181 --cluster-advertise=eth0:2376</code>.然后执行<code>systemctl daemon-reload</code>,重新加载<code>docker.service</code>即可. 以后就可以在命令行中直接输入<code>service docker start</code>启动带1.9跨网的Docker服务了.注意,一定要先启动Zookeeper哦!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network.target docker.socket</span><br><span class="line">Requires=docker.socket</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/docker daemon --cluster-store=zk://<span class="number">10.211</span>.<span class="number">55.2</span>:<span class="number">2181</span> --cluster-advertise=eth0:<span class="number">2376</span> --insecure-registry <span class="number">172.16</span>.<span class="number">129.222</span>:<span class="number">5000</span> -H fd://</span><br><span class="line">MountFlags=slave</span><br><span class="line">LimitNOFILE=<span class="number">1048576</span></span><br><span class="line">LimitNPROC=<span class="number">1048576</span></span><br><span class="line">LimitCORE=infinity</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<h2 id="创建网络">创建网络</h2><p>Docker1.9新增加了一个命令<code>network</code>,用于配置网络.在Docker1.9中,它把网络也当成了一种类似于容器的东西.可以创建,查询,删除网络.</p>
<p>比如在单机下 可以输入<code>docker network create my-single-net</code>创建一个网络.<br>然后在启动容器的时候使用:<code>docker run -itd --net=my-single-net --name web nginx</code>来使一个容器使用指定的网络来通信. 只要是在<strong>同一个网络</strong>下的容器,他们之间都可以通过<strong>容器的名字</strong>进行互联.而不需要像以前一样,写一堆的<code>-Link</code>了.<br>而对于不同的网络之间也可以使用<code>docker network connect</code>命令来使两个网络之间进行互联.<br>比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker network create app</span><br><span class="line">docker run -itd --name myapp --net=app myapp</span><br><span class="line">docker network connect app web</span><br></pre></td></tr></table></figure>
<p>这样,就可以在容器中使用<code>myapp.app</code>来访问其他的容器.</p>
<p>铺垫了这么多,现在我们就来创建<code>overlay</code>类型的网络.<br>直接在终端中输入:<code>docker network create --driver overlay my-net</code><br>这个命令就可以创建一个<code>overlay</code>类型的网络,Docker接收到命令后会自动的在ZK上创建相应的节点.<br>那么这个时候,在其他机器上通过输入<code>docker network ls</code>就应该能看到这个网络了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7_with_kernel4 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER</span><br><span class="line"><span class="number">65</span>a73f31fd82        my-net              overlay</span><br><span class="line"><span class="number">8</span>dc2d1533977        docker_gwbridge     bridge</span><br><span class="line"><span class="number">4</span>e4dcdfbe708        none                null</span><br><span class="line"><span class="number">53509</span>e0d8617        host                host</span><br><span class="line">a1dd3a2d90ce        bridge              bridge</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7_with_kernel4_2 ~]<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID          NAME                DRIVER</span><br><span class="line"><span class="number">65</span>a73f31fd82        my-net              overlay</span><br><span class="line"><span class="number">1</span>fac52653a98        host                host</span><br><span class="line"><span class="number">8</span>dc2d1533977        docker_gwbridge     bridge</span><br><span class="line">cc8810e5a932        bridge              bridge</span><br><span class="line"><span class="number">59</span>ae81d5b75f        none                null</span><br></pre></td></tr></table></figure>
<p>正如上面所显示的.两台不同的宿主机上 现在都有一个ID为<code>65a73f31fd82</code>的<code>overlay</code>类型的网络了.</p>
<p>这个时候如果是调用<code>ifconfig</code>命令来查看宿主机的网络配置,会发现他现在是有<code>docker0</code>,<code>docker_gwbridge</code>,<code>eth0</code>等几个网卡的.其中<code>docker_gwbridge</code>其实就是一个桥接网卡,它就负责了多个宿主机间的通信.</p>
<p><img src="/img/2015/11/09/3.png" alt=""></p>
<h2 id="启动容器">启动容器</h2><p>既然网络已经配置好了,那么接下来要做的就是 启动容器了.这里我们已启动<code>jplock/zookeeper</code>容器为例,在跨宿主机的Docker中创建一个<code>Zookeeper</code>的集群.</p>
<p>一号宿主机(10.211.55.13):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jplock/zookeeper</span><br><span class="line">docker run --name zookeeper1 --privileged=<span class="literal">true</span> -p <span class="number">2181</span>:<span class="number">2181</span> -p <span class="number">2888</span>:<span class="number">2888</span> -p <span class="number">3888</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br><span class="line">docker run --name zookeeper3 --privileged=<span class="literal">true</span> -p <span class="number">2182</span>:<span class="number">2181</span> -p <span class="number">2882</span>:<span class="number">2888</span> -p <span class="number">3882</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br></pre></td></tr></table></figure></p>
<p>二号宿主机(10.211.55.16):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull jplock/zookeeper</span><br><span class="line">docker run --name zookeeper2 --privileged=<span class="literal">true</span> -p <span class="number">2181</span>:<span class="number">2181</span> -p <span class="number">2888</span>:<span class="number">2888</span> -p <span class="number">3888</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br><span class="line">docker run --name zookeeper4 --privileged=<span class="literal">true</span> -p <span class="number">2182</span>:<span class="number">2181</span> -p <span class="number">2882</span>:<span class="number">2888</span> -p <span class="number">3882</span>:<span class="number">3888</span> --net=my-net <span class="operator">-d</span> jplock/zookeeper</span><br></pre></td></tr></table></figure></p>
<p>这样就在每一个宿主机上启动了两个<code>Zookeeper</code>的容器,并且都使用了相同的<code>my-net</code>网络.</p>
<p>这个时候使用<code>docker exec -ti zookeeper1 /bin/bash</code>进入到容器当中.使用<code>ip address show</code>命令查看容器的IP的话,会显示为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">3</span>cfba8da9b6f:/opt/zookeeper<span class="comment"># ip address show</span></span><br><span class="line"><span class="number">1</span>: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span class="number">65536</span> qdisc noqueue state UNKNOWN group default</span><br><span class="line">    link/loopback <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> brd <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">    inet <span class="number">127.0</span>.<span class="number">0.1</span>/<span class="number">8</span> scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::<span class="number">1</span>/<span class="number">128</span> scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">6</span>: eth0@<span class="keyword">if</span>7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1450</span> qdisc noqueue state UP group default</span><br><span class="line">    link/ether <span class="number">02</span>:<span class="number">42</span>:<span class="number">0</span>a:<span class="number">00</span>:<span class="number">00</span>:<span class="number">03</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">10.0</span>.<span class="number">0.3</span>/<span class="number">24</span> scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::<span class="number">42</span>:aff:fe00:<span class="number">3</span>/<span class="number">64</span> scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="number">8</span>: eth1@<span class="keyword">if</span>9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span class="number">1500</span> qdisc noqueue state UP group default</span><br><span class="line">    link/ether <span class="number">02</span>:<span class="number">42</span>:ac:<span class="number">12</span>:<span class="number">00</span>:<span class="number">02</span> brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet <span class="number">172.18</span>.<span class="number">0.2</span>/<span class="number">16</span> scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::<span class="number">42</span>:acff:fe12:<span class="number">2</span>/<span class="number">64</span> scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>其中的<code>eth0</code>就是容器全局唯一的一个<code>IP地址</code>.</p>
<p>这个时候再调用<code>cat /etc/hosts</code>来查看容器的<code>hosts</code>配置,会发现:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">3</span>cfba8da9b6f:/opt/zookeeper<span class="comment"># cat /etc/hosts</span></span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.3</span>	<span class="number">3</span>cfba8da9b6f</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>	localhost</span><br><span class="line">::<span class="number">1</span>	localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::<span class="number">0</span>	ip6-localnet</span><br><span class="line">ff00::<span class="number">0</span>	ip6-mcastprefix</span><br><span class="line">ff02::<span class="number">1</span>	ip6-allnodes</span><br><span class="line">ff02::<span class="number">2</span>	ip6-allrouters</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.2</span>	zookeeper1</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.2</span>	zookeeper1.my-net</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.4</span>	zookeeper3</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.4</span>	zookeeper3.my-net</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.5</span>	zookeeper4</span><br><span class="line"><span class="number">10.0</span>.<span class="number">0.5</span>	zookeeper4.my-net</span><br></pre></td></tr></table></figure>
<p>Docker每启动一个容器,就会在相同网络下的其他容器的Hosts中加入hosts.因此,这个时候其实4个ZooKeeper的网络都是通的了,并且通过<code>容器名</code>.<code>网络名</code>是可以直接访问的.</p>
<p>这个时候在宿主机上使用<code>docker network inspect my-net</code>命令就可以查看<code>my-net</code>网络当前的状况,有什么容器在使用这个网络等等信息.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect my-net</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"my-net"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"65a73f31fd820732ebbf665072311c36e2938105a3b42b26597340fc217ff47c"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"global"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"overlay"</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"0d790e0dafd8af213fa81e98c5833539f000dfd5c2c35065e9dbc07d1b40dc7b"</span>: &#123;</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"6434fc9a7a477779e73874d2ec508b4c139d3cb5cd56c7e0ded8d3d5b0bf6457"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:00:00:04"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"10.0.0.4/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"20a8b20914b11c52b6285ebe4414cf492d1bc71001919c62a5a1e7bc5018fa0c"</span>: &#123;</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"14cf4810b09849ae0b197fabd52d155bcaee5debd68a3d982027c5856ba84afe"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:00:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"10.0.0.2/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样,Docker很简单的就实现了多宿主机的网络互通,每一个容器只需要通过全局唯一的<code>容器名</code>就可以访问任意一个在<strong>相同网络</strong>中的容器了.</p>
<p><img src="/img/2015/11/09/4.png" alt=""></p>
<h2 id="注意">注意</h2><p>目前还有一个问题,就是采用这种模式的情况下,其实容器的IP地址还是会改变的.因为它其实是在容器启动的时候,在ZK中去询问一个可用的IP地址,然后创建一个临时节点保存容器名和IP地址的映射. 当容器关闭后,这个IP地址就被释放了出来.下一次再申请可用的IP地址的时候,IP地址可能就变化了.这点需要我们在开发的时候注意,如果程序是依赖于IP地址的话,可能每次重启就会出现问题.尽量的使用Hosts来代替IP地址.</p>
<p>如果确实有固定IP的需求,这个还需要再进一步的研究.</p>
<p><img src="/img/2015/11/09/5.png" alt=""></p>
<hr>
<p>参考文章:<br><a href="http://blog.docker.com/2015/11/docker-multi-host-networking-ga/" target="_blank" rel="external">http://blog.docker.com/2015/11/docker-multi-host-networking-ga/</a><br><a href="https://github.com/docker/libnetwork/issues/" target="_blank" rel="external">https://github.com/docker/libnetwork/issues/</a></p>
<p><a href="http://qiita.com/simota/items/06ad3400224e98d43fc5" target="_blank" rel="external">http://qiita.com/simota/items/06ad3400224e98d43fc5</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Docker1-9新特性-跨物理机的多容器网络连接">Docker1.9新特性-跨物理机的多容器网络连接</h1><p>近日，Docker公司正式发布Docker 1.9版本。他带来了很多新的特性,其中最重要的新特性无疑就是多宿主机互联功能.</p>
<p>在今年6月份的DockerCon上，互联曾经作为测试版本的特性被提出。目前，该特性正式集成在了Docker引擎的稳定版中，并将在产品中使用。其主要功能是为跨宿主机创建Docker引擎中的虚拟网络提供支持。用户可以把其所属的容器挂载到网络中，并控制网络拓扑和通信方式。此外，系统还允许用户在不修改应用的情况下直接与任何网络进行集成。</p>
<p>那么,我们现在就来试一试如何简单的实现多宿主机互联功能.</p>
<h2 id="原理">原理</h2><p>Docker新的网络拓扑是采用的<code>overlay network</code>模式的网络.<br>它需要一个分布式的<code>Key-Value Storage</code>作为辅助的存储.当前Docker支持<code>Consul</code>,<code>Etcd</code>和<code>ZooKeeper</code>.当创建网络之前,你首先是需要安装并运行<code>KVS</code>.然后在启动Docker的时候加上一定的参数,这样Docker就会把网络拓扑信息保存在<code>KVS</code>上,形成全局唯一的网络.</p>
<p><img src="/img/2015/11/09/1.png" alt=""></p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://sunxiang0918.github.io/tags/Docker/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[升级CentOS7的Linux内核]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/08/%E5%8D%87%E7%BA%A7CentOS7%E7%9A%84Linux%E5%86%85%E6%A0%B8/"/>
    <id>http://sunxiang0918.github.io/2015/11/08/升级CentOS7的Linux内核/</id>
    <published>2015-11-08T07:56:29.000Z</published>
    <updated>2015-12-29T05:59:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="升级CentOS7的Linux内核">升级CentOS7的Linux内核</h1><p>默认刚安装的CentOS7的内核是3.10的.</p>
<p>这个可以在 终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="number">3.10</span>.<span class="number">0</span>-<span class="number">229</span>.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>来确认.</p>
<p>由于我需要试验docker1.9中的新功能.而它的新功能需要<code>vxlan</code>的相关功能.而这个在3.16以上版本才正确.因此,就需要给CentOS7升级内核.</p>
<a id="more"></a>
<h2 id="步骤">步骤</h2><ol>
<li><p>首先在命令行中输入:<code>uname -r</code> 来确定你现在的版本是什么</p>
</li>
<li><p>而后输入:<code>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</code> 导入Key</p>
</li>
<li><p>输入:<code>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</code>来安装elrepo的yum源</p>
</li>
<li><p>在这个源中,保留了内核的最新两个版本.应用名字叫:<code>kernel-ml</code>.因此 我们输入:<code>yum --enablerepo=elrepo-kernel install kernel-ml -y</code>.就可以安装最新的内核了.</p>
</li>
<li><p>而后输入<code>awk -F\&#39; &#39;$1==&quot;menuentry &quot; {print $2}&#39; /etc/grub2.cfg</code> 可以查看启动CentOS的顺序.</p>
</li>
<li><p>如果想自动的进入第一个内核就是最新的话,可以输入:<code>grub2-set-default 0</code></p>
</li>
<li><p>这样,重启的话.系统就会是最新的内核了.</p>
</li>
</ol>
<p>PS: 如果不想安装最新的内核版本.而是想选一个早先的版本的话.可以访问这个地址:<a href="http://dfw.mirror.rackspace.com" target="_blank" rel="external">dfw.mirror.rackspace.com</a>.他里面有很多版本的镜像.找到你想要的版本的rpm.直接下载下来.然后上传到Centos中.然后执行<code>yum localinstall xxxx.rpm -y</code> 就可以本地安装内核了. 剩下的操作和在线的是一样的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="升级CentOS7的Linux内核">升级CentOS7的Linux内核</h1><p>默认刚安装的CentOS7的内核是3.10的.</p>
<p>这个可以在 终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br><span class="line"><span class="number">3.10</span>.<span class="number">0</span>-<span class="number">229</span>.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>来确认.</p>
<p>由于我需要试验docker1.9中的新功能.而它的新功能需要<code>vxlan</code>的相关功能.而这个在3.16以上版本才正确.因此,就需要给CentOS7升级内核.</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://sunxiang0918.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hive1.2的部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/04/Hive1-2%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/11/04/Hive1-2的部署/</id>
    <published>2015-11-04T14:55:26.000Z</published>
    <updated>2015-11-04T15:14:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Hive1-2的部署">Hive1.2的部署</h1><h2 id="简介">简介</h2><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
<p>听起来HBase与Hive有些类似，概念也有点模糊，那我们先了解下他们之间有什么区别：</p>
<p>HBase是一种分布式、面向列的NoSQL数据库，基于HDFS存储，以表的形式存储数据，表由行和列组成，列划分到列族中。HBase不提供类SQL查询语言，要想像SQL这样查询数据，可以使用Phonix，让SQL查询转换成hbase的扫描和对应的操作，也可以使用现在说讲Hive仓库工具，让HBase作为Hive存储。</p>
<p>Hive是运行在Hadoop之上的数据仓库，将结构化的数据文件映射为一张数据库表，提供简单类SQL查询语言，称为HQL，并将SQL语句转换成MapReduce任务运算。有利于利用SQL语言查询、分析数据，适于处理不频繁变动的数据。Hive底层可以是HBase或者HDFS存储的文件。</p>
<p>两者都是基于Hadoop上不同的技术，相互结合使用，可处理企业中不同类型的业务，利用Hive处理非结构化离线分析统计，利用HBase处理在线查询。</p>
<p>由于HDFS不能存储元数据,因此Hive需要一个辅助的关系数据库来保存它的元数据信息.<br>可以使用它本地的derby数据库,也可以使用本地或远程的MYSQL数据库来存储.通常我们都是存放在MYSQL中的.</p>
<a id="more"></a>
<h2 id="部署">部署</h2><p>由于Hive是运行在Hadoop之上的数据仓库.它的所有数据都是存放在Hadoop兼容的存储上的.因此它本身的集群其实就是启动N多个相同的Hive节点就可以了.也就是说,我们可以完全安装修改一台的Hive.然后直接把整个Hive文件夹拷贝到其他机器上即可.</p>
<ol>
<li>在MYSQL中创建一个独立的database.命名为<code>hive</code></li>
<li>解压<code>apache-hive-1.2.1-bin.tar.gz</code>到/home/hadoop/下 然后改名为<code>hive</code></li>
<li><p>修改环境变量  </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/hadoop/hadoop  </span><br><span class="line"><span class="built_in">export</span> HIVE_HOME=/home/hadoop/hive  </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HIVE_HOME</span>/bin  </span><br><span class="line"><span class="built_in">export</span> CLASS_PATH=<span class="variable">$CALSSPATH</span>:<span class="variable">$HIVE_HOME</span>/lib</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>hive/conf</code>下 拷贝 <code>hive_env.sh.template</code> 改名成 <code>hive_env.sh</code></p>
</li>
<li><p>修改这个文件里面的HADOOP_HOME和HIVE_CONF_DIR</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Set HADOOP_HOME to point to a specific hadoop install directory</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/home/hadoop/hadoop-<span class="number">2.6</span>.<span class="number">0</span></span><br><span class="line">	<span class="comment">#Hive Configuration Directory can be controlled by:</span></span><br><span class="line"><span class="built_in">export</span> HIVE_CONF_DIR=/home/hadoop/apache-hive-<span class="number">1.2</span>.<span class="number">0</span>-bin/conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>在hive/conf下 拷贝 hive-default.xml.template 改名成 hive-site.xml</p>
</li>
<li><p>修改里面的所有内容为:(因为会先自动的加载hive-default.xml里面的所有内容,所以hive-site里面的内容就是自定义的配置)</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>jdbc:mysql://10.211.55.2:3306/hive<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>驱动名<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>root<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>用户名<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>admin<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>密码<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="title">property</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>/home/hadoop/hive/warehouse<span class="tag">&lt;/<span class="title">value</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="title">description</span>&gt;</span>数据路径（相对hdfs）<span class="tag">&lt;/<span class="title">description</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>放入mysql的驱动到 hive/lib中 比如: <code>mysql-connector-java-5.1.31-bin.jar</code></p>
</li>
<li>找到一个叫<code>jline-2.12.jar</code>的文件，复制他，去hadoop主目录将<code>hadoop/yarn/lib</code>下的<code>jline0.9.94.jar</code>替换成刚刚复制的,否则会出现包冲突.</li>
<li>切换到hive/bin,输入 <code>bin/hive --service metastore</code><br>当显示<code>Starting Hive Metastore Server</code>就表示启动成功了.</li>
</ol>
<h2 id="验证">验证</h2><p>启动以后,在终端中输入<code>JPS</code>.可以 看到一个 <code>RunJar</code>的服务,这就表示启动成功了.</p>
<p>然后再输入<code>./hive</code>可以进入hive的命令行.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HMaster0 ~]<span class="comment"># hive</span></span><br><span class="line">Logging initialized usingconfiguration <span class="keyword">in</span> file:/opt/apache-hive-<span class="number">1.2</span>.<span class="number">0</span>-bin/conf/hive-log4j.properties</span><br><span class="line">hive&gt; show databases;</span><br><span class="line">OK</span><br><span class="line">default</span><br><span class="line">Time taken: <span class="number">0.986</span> seconds,Fetched: <span class="number">1</span> row(s)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建一个测试库</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create database <span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个hive_test的表,并指定字段分隔符为tab建</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; create table hive_<span class="built_in">test</span>(id int,name string) row format delimited fields terminated by <span class="string">'\t'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从本地文件中导入数据到Hive表中</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; load data <span class="built_in">local</span> inpath <span class="string">'/home/hadoop/hive/examples/files/kv1.txt'</span> overwrite into table hive_<span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行最简单的查询</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hive&gt; select * from hive_<span class="built_in">test</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到此,Hive的最简单的安装就结束了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hive1-2的部署">Hive1.2的部署</h1><h2 id="简介">简介</h2><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
<p>听起来HBase与Hive有些类似，概念也有点模糊，那我们先了解下他们之间有什么区别：</p>
<p>HBase是一种分布式、面向列的NoSQL数据库，基于HDFS存储，以表的形式存储数据，表由行和列组成，列划分到列族中。HBase不提供类SQL查询语言，要想像SQL这样查询数据，可以使用Phonix，让SQL查询转换成hbase的扫描和对应的操作，也可以使用现在说讲Hive仓库工具，让HBase作为Hive存储。</p>
<p>Hive是运行在Hadoop之上的数据仓库，将结构化的数据文件映射为一张数据库表，提供简单类SQL查询语言，称为HQL，并将SQL语句转换成MapReduce任务运算。有利于利用SQL语言查询、分析数据，适于处理不频繁变动的数据。Hive底层可以是HBase或者HDFS存储的文件。</p>
<p>两者都是基于Hadoop上不同的技术，相互结合使用，可处理企业中不同类型的业务，利用Hive处理非结构化离线分析统计，利用HBase处理在线查询。</p>
<p>由于HDFS不能存储元数据,因此Hive需要一个辅助的关系数据库来保存它的元数据信息.<br>可以使用它本地的derby数据库,也可以使用本地或远程的MYSQL数据库来存储.通常我们都是存放在MYSQL中的.</p>]]>
    
    </summary>
    
      <category term="Hive" scheme="http://sunxiang0918.github.io/tags/Hive/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hbase分布式部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/11/03/Hbase%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/11/03/Hbase分布式部署/</id>
    <published>2015-11-03T15:12:39.000Z</published>
    <updated>2015-11-03T15:30:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Hbase分布式部署">Hbase分布式部署</h1><p>HBase的安装首先是有两个先决条件的,第一个就是需要zookeeper的支持,另外一个就是需要HDFS的支持了.<br>因此,安装Hbase的头两部就是安装<code>zookeeper</code>和<code>hadoop</code></p>
<p>这两个东西的安装可以参考我以前的博文:<a href="http://sunxiang0918.cn/2015/11/03/Hadoop全分布式部署/" target="_blank" rel="external">Hadoop全分布式部署</a>以及<a href="http://sunxiang0918.cn/2014/09/20/zookeeper-集群部署/" target="_blank" rel="external">zookeeper 集群部署</a>.这里就不再复述了.</p>
<h2 id="环境">环境</h2><p>环境: centos7 + hadoop2.6.2 + hbase1.1.2</p>
<p>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h2 id="安装步骤">安装步骤</h2><ol>
<li>首先还是需要把<code>hbase-1.1.2-bin.tar.gz</code>拷贝到几台机器上.然后使用<code>tar -xvf</code>命令解压,并重命名为hbase.  当前路径也就是 <code>/home/hadoop/hbase</code></li>
</ol>
<a id="more"></a>
<ol>
<li><p>配置<code>conf/hbase-site.xml</code></p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="pi">&lt;?xml version="1.0"?&gt;</span>  </span><br><span class="line">	<span class="pi">&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">configuration</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="title">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>hdfs://master:9000/hbase<span class="tag">&lt;/<span class="title">value</span>&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>区域服务器使用存储HBase数据库数据的目录,服务器名称不能填IP，不然会报错<span class="tag">&lt;/<span class="title">description</span>&gt;</span>          </span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>              </span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span>                </span><br><span class="line">     <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="title">name</span>&gt;</span>                 </span><br><span class="line">     <span class="tag">&lt;<span class="title">value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">value</span>&gt;</span>                     </span><br><span class="line">     <span class="tag">&lt;<span class="title">description</span>&gt;</span>指定HBase运行的模式： false: 单机模式或者为分布式模式   true: 全分布模式 <span class="tag">&lt;/<span class="title">description</span>&gt;</span>             </span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>                                                   </span><br><span class="line">  <span class="tag">&lt;<span class="title">property</span>&gt;</span>                                                     </span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="title">name</span>&gt;</span>                                                       </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span> master,slave01, slave02 <span class="tag">&lt;/<span class="title">value</span>&gt;</span>                                                           </span><br><span class="line">    <span class="tag">&lt;<span class="title">description</span>&gt;</span>ZooKeeper集群服务器的位置<span class="tag">&lt;/<span class="title">description</span>&gt;</span>                                                                 </span><br><span class="line">  <span class="tag">&lt;/<span class="title">property</span>&gt;</span>                                                                  </span><br><span class="line"><span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 完整的配置可以看<a href="http://hbase.apache.org/book.html#config.files" target="_blank" rel="external">此处</a></p>
</li>
<li><p>配置数据服务器的地址<br> 也就是修改<code>/conf/regionservers</code>,把三台机器的host都写进去</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">slave01</span><br><span class="line">slave02</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置HBase的JDK<br> 修改<code>/conf/hbase-env.sh</code>文件.<br> 打开注释 <code>export JAVA_HOME=xxxxxxx</code> 这里指向JDK的目录,要求是JDK1.7+</p>
</li>
<li><p>配置ZK的使用方式.默认情况下是使用的hbase内置的ZK,这个在集群下是不行的.因此我们需要给他改成使用外部的集群的ZK.<br> 修改<code>/conf/hbase-env.sh</code>文件最后面.<br> 打开注释 <code>export HBASE_MANAGES_ZK=false</code> 这里的false指的就是使用外部的Zookeeper</p>
</li>
<li><p>所有其他的机器都这样配置</p>
</li>
<li><p>在主节点上 启动,验证<br> 配置好上面的这些东西后,就可以在主节点上启动hbase了.<br> 直接在<code>bin</code>中 输入 <code>./start-hbase.sh</code> 即可启动.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	starting master, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-master-master.out</span><br><span class="line">slave01: starting regionserver, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-regionserver-slave01.out</span><br><span class="line">slave02: starting regionserver, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-regionserver-slave02.out</span><br><span class="line">master: starting regionserver, logging to /home/hadoop/hbase/bin/../logs/hbase-hadoop-regionserver-master.out</span><br></pre></td></tr></table></figure>
<p> 出现上面的东西 就说明是启动完成了.<br> 这个时候使用<code>jps</code>命令 应该可以看到有一个 <code>HMaster</code> 和 <code>HRegionServer</code> 服务.<br> 而在其他的从节点上 应该看得到<code>HRegionServer</code>服务.</p>
<p> 这个时候随便在某一台机器上输入 <code>./hbase shell</code> 进入hbase的终端,并输入<code>status</code>的话,应该可以看到集群的状态:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	[hadoop@master bin]$ ./hbase shell</span><br><span class="line"><span class="number">2015</span>-<span class="number">11</span>-<span class="number">03</span> <span class="number">23</span>:<span class="number">02</span>:<span class="number">05</span>,<span class="number">690</span> WARN  [main] util.NativeCodeLoader: Unable to load native-hadoop library <span class="keyword">for</span> your platform... using <span class="built_in">builtin</span>-java classes <span class="built_in">where</span> applicable</span><br><span class="line">HBase Shell; enter <span class="string">'help&lt;RETURN&gt;'</span> <span class="keyword">for</span> list of supported commands.</span><br><span class="line">Type <span class="string">"exit&lt;RETURN&gt;"</span> to leave the HBase Shell</span><br><span class="line">Version <span class="number">1.1</span>.<span class="number">2</span>, rcc2b70cf03e3378800661ec5cab11eb43fafe0<span class="built_in">fc</span>, Wed Aug <span class="number">26</span> <span class="number">20</span>:<span class="number">11</span>:<span class="number">27</span> PDT <span class="number">2015</span></span><br><span class="line">hbase(main):<span class="number">001</span>:<span class="number">0</span>&gt; status</span><br><span class="line"><span class="number">3</span> servers, <span class="number">0</span> dead, <span class="number">0.6667</span> average load</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code><span class="label">同时也可以通过在浏览器中输入: `http://master:</span><span class="number">16010</span><span class="escape">` </span>打开<span class="escape">`H</span>Base<span class="escape">`的</span>管理页面.也是可以的
</code></pre><p>到此,最简单的HBASE集群就搭建成功了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hbase分布式部署">Hbase分布式部署</h1><p>HBase的安装首先是有两个先决条件的,第一个就是需要zookeeper的支持,另外一个就是需要HDFS的支持了.<br>因此,安装Hbase的头两部就是安装<code>zookeeper</code>和<code>hadoop</code></p>
<p>这两个东西的安装可以参考我以前的博文:<a href="http://sunxiang0918.cn/2015/11/03/Hadoop全分布式部署/">Hadoop全分布式部署</a>以及<a href="http://sunxiang0918.cn/2014/09/20/zookeeper-集群部署/">zookeeper 集群部署</a>.这里就不再复述了.</p>
<h2 id="环境">环境</h2><p>环境: centos7 + hadoop2.6.2 + hbase1.1.2</p>
<p>虚拟机三台:</p>
<table>
<thead>
<tr>
<th style="text-align:center">hostname</th>
<th style="text-align:center">ip地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">master</td>
<td style="text-align:center">10.211.55.15</td>
</tr>
<tr>
<td style="text-align:center">slave01</td>
<td style="text-align:center">10.211.55.12</td>
</tr>
<tr>
<td style="text-align:center">slave02</td>
<td style="text-align:center">10.211.55.14</td>
</tr>
</tbody>
</table>
<h2 id="安装步骤">安装步骤</h2><ol>
<li>首先还是需要把<code>hbase-1.1.2-bin.tar.gz</code>拷贝到几台机器上.然后使用<code>tar -xvf</code>命令解压,并重命名为hbase.  当前路径也就是 <code>/home/hadoop/hbase</code></li>
</ol>]]>
    
    </summary>
    
      <category term="Hbase" scheme="http://sunxiang0918.github.io/tags/Hbase/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
</feed>