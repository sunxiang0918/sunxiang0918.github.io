<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[翔妖除魔的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://sunxiang0918.github.io//"/>
  <updated>2015-07-29T03:02:02.000Z</updated>
  <id>http://sunxiang0918.github.io//</id>
  
  <author>
    <name><![CDATA[翔妖除魔]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[<转>Swift局部SCOPE]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/29/Swift%E5%B1%80%E9%83%A8SCOPE/"/>
    <id>http://sunxiang0918.github.io/2015/07/29/Swift局部SCOPE/</id>
    <published>2015-07-29T02:06:40.000Z</published>
    <updated>2015-07-29T03:02:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="局部SCOPE">局部SCOPE</h1><p>C 系语言中在方法内部我们是可以任意添加成对的大括号 {} 来限定代码的作用范围的。这么做一般来说有两个好处，首先是超过作用域后里面的临时变量就将失效，这不仅可以使方法内的命名更加容易，也使得那些不被需要的引用的回收提前进行了，可以稍微提高一些代码的效率；另外，在合适的位置插入括号也利于方法的梳理，对于那些不太方便提取为一个单独方法，但是又应该和当前方法内的其他部分进行一些区分的代码，使用大括号可以将这样的结构进行一个相对自然的划分。</p>
<p>举一个不失一般性的例子，虽然我个人不太喜欢使用代码手写 UI，但钟情于这么做的人还是不在少数。如果我们要在 Objective-C 中用代码构建 UI 的话，我们一般会选择在 -loadView 里写一些类似这样的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *titleLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    titleLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    titleLabel<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">    [view addSubview:titleLabel];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    textLabel<span class="variable">.text</span> = <span class="string">@"Text"</span>;</span><br><span class="line">    [view addSubview:textLabel];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在这里只添加了两个 view，就已经够让人心烦的了。真实的界面当然会比这个复杂很多，想想看如果有十来个 view 的话，这段代码会变成什么样子吧。我们需要考虑对各个子 view 的命名，以确保它们的意义明确。如果我们在上面的代码中把某个配置 textLabel 的代码写错成了 titleLabel 的话，编译器也不会给我们任何警告。这种 bug 是非常难以发现的，因此在类似这种一大堆代码但是又不太可能进行重用的时候，我更推荐使用局部 scope 将它们分隔开来。比如上面的代码建议加上括号重写为以下形式，这样至少编译器会提醒我们一些低级错误，我们也可能更专注于每个代码块：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>)];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UILabel</span> *titleLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">                initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">        titleLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">        titleLabel<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">        [view addSubview:titleLabel];    </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">                initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">        textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">        textLabel<span class="variable">.text</span> = <span class="string">@"Text"</span>;</span><br><span class="line">        [view addSubview:textLabel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，直接使用大括号的写法是不支持的，因为这和闭包的定义产生了冲突。如果我们想类似地使用局部 scope 来分隔代码的话，一个不错的选择是定义一个接受 ()-&gt;() 作为函数的全局方法，然后执行它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">local</span><span class="params">(closure: <span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用时，可以利用尾随闭包的特性模拟局部 scope：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="type">UIView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>))</span><br><span class="line"></span><br><span class="line">    local &#123;</span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>))</span><br><span class="line">        titleLabel.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">        titleLabel.text = <span class="string">"Title"</span></span><br><span class="line">        view.addSubview(titleLabel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    local &#123;</span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>))</span><br><span class="line">        textLabel.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">        textLabel.text = <span class="string">"Text"</span></span><br><span class="line">        view.addSubview(textLabel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.view = view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Objective-C 中还有一个很棒的技巧是使用 GNU C 的<a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs" target="_blank" rel="external">声明扩展</a>来在限制局部作用域的时候同时进行赋值，运用得当的话，可以使代码更加紧凑和整洁。比如上面的 titleLabel 如果我们需要保留一个引用的话，在 Objective-C 中可以写为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.titleLabel</span> = (&#123;</span><br><span class="line">    <span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    label<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    label<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">    [view addSubview:label];</span><br><span class="line">    label;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Swift 里当然没有 GNU C 的扩展，但是使用匿名的闭包的话，写出类似的代码也不是难事：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">titleLabel = &#123;</span><br><span class="line">    <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="type">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>))</span><br><span class="line">    label.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">    label.text = <span class="string">"Title"</span></span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(label)</span><br><span class="line">    <span class="keyword">return</span> label</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>这也是一种隔离代码的很好的方式。</p>
<hr>
<p>原文链接:<a href="http://swifter.tips/local-scope/" target="_blank" rel="external">http://swifter.tips/local-scope/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="局部SCOPE">局部SCOPE</h1><p>C 系语言中在方法内部我们是可以任意添加成对的大括号 {} 来限定代码的作用范围的。这么做一般来说有两个好处，首先是超过作用域后里面的临时变量就将失效，这不仅可以使方法内的命名更加容易，也使得那些不被需要的引用的回收提前进行了，可以稍微提高一些代码的效率；另外，在合适的位置插入括号也利于方法的梳理，对于那些不太方便提取为一个单独方法，但是又应该和当前方法内的其他部分进行一些区分的代码，使用大括号可以将这样的结构进行一个相对自然的划分。</p>
<p>举一个不失一般性的例子，虽然我个人不太喜欢使用代码手写 UI，但钟情于这么做的人还是不在少数。如果我们要在 Objective-C 中用代码构建 UI 的话，我们一般会选择在 -loadView 里写一些类似这样的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *titleLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    titleLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    titleLabel<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">    [view addSubview:titleLabel];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    textLabel<span class="variable">.text</span> = <span class="string">@"Text"</span>;</span><br><span class="line">    [view addSubview:textLabel];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<翻译>Swift2.0中字符串的设计]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/29/Swift2-0%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://sunxiang0918.github.io/2015/07/29/Swift2-0中字符串的设计/</id>
    <published>2015-07-28T16:19:28.000Z</published>
    <updated>2015-07-28T16:22:27.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift2-0中字符串的设计">Swift2.0中字符串的设计</h1><p>Swift中提供了一个高性能的,兼容Unicode的字符串实现作为其标准库中的一部分.在Swift2中,<code>String</code>类型不再实现<code>CollectionType</code>协议.在以前<code>String</code>字符串是一个由<code>Character</code>字符组成的集合,其表现类似于一个数组.而现在,<code>String</code>则是提供了一个<code>characters</code>属性用来暴露字符集合.</p>
<p>为什么会有这样的变化呢?尽管把字符串当做一个字符的集合看起来更自然.但是其实<code>String</code>字符串类型的操作与<code>Array</code>,<code>Set</code>或者<code>Dictionary</code>等集合一直都是完全不同的.但自从Swift2增加了协议扩展后,针对这些差异有必要进行一些根本性的变化了.</p>
<a id="more"></a>
<h2 id="Different_Than_the_Sum_of_Its_Parts">Different Than the Sum of Its Parts</h2><h4 id="每一个部分和的不同计算">每一个部分和的不同计算</h4><p>当你给一个集合增加一个元素的时候,你期望的是这个集合将包含这个元素.换句话说,当你给一个数组增加一个值后,这个数组将会包含这个值.这同样适用于<code>Set</code>和<code>Dictionary</code>.但是,当你给字符串增加一个组合标记字符(<em>combining mark character</em>)的时候,这个字符串内容本身会发生变化.</p>
<p>比如以字符串<code>cafe</code>为例,它由<code>c</code>,<code>a</code>,<code>f</code>,<code>e</code>四个字符组成:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters: [<span class="type">Character</span>] = [<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"f"</span>, <span class="string">"e"</span>]</span><br><span class="line"><span class="keyword">var</span> string: <span class="type">String</span> = <span class="type">String</span>(letters)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(letters.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">print</span>(string) <span class="comment">// cafe</span></span><br><span class="line"><span class="built_in">print</span>(string.characters.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>这个时候如果你给字符串增加一个组合重音字符<code>U+0301</code>也就是<code>´</code>.这个字符串仍然只有四个字符,但是最后一个字符现在变成了<code>é</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> acuteAccent: <span class="type">Character</span> = <span class="string">"\u&#123;0301&#125;"</span> <span class="comment">// ´ COMBINING ACUTE ACCENT' (U+0301)</span></span><br><span class="line"></span><br><span class="line">string.append(acuteAccent)</span><br><span class="line"><span class="built_in">print</span>(string.characters.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">print</span>(string.characters.last!) <span class="comment">// é</span></span><br></pre></td></tr></table></figure>
<p>这个时候,这个字符串的<code>characters</code>属性中并没有包含原来的小写字符<code>e</code>,并且也没有包含新加的组合重音字符<code>´</code>.相反的,现在字符串包含了加上了重音符的小写字符<code>é</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string.characters.<span class="built_in">contains</span>(<span class="string">"e"</span>) <span class="comment">// false</span></span><br><span class="line">string.characters.<span class="built_in">contains</span>(<span class="string">"´"</span>) <span class="comment">// false</span></span><br><span class="line">string.characters.<span class="built_in">contains</span>(<span class="string">"é"</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果其他的集合操作也像字符串那样.那么,它们的结果就会有令人出乎意料的表现.比如把<code>UIColor.redColor()</code>和<code>UIColor.greenColor()</code>放入到一个<code>Set</code>集合中,那么这个时候集合中就应该会包含一个<code>UIColor.yellowColor()</code></p>
<h2 id="Judged_by_the_Contents_of_Its_Characters">Judged by the Contents of Its Characters</h2><h4 id="判断字符内容的相等">判断字符内容的相等</h4><p>另外一个字符串与集合不同的地方在于他们判断相等的方式.</p>
<ul>
<li>两个数组只有当他们有相同数量的元素,并且每一个相同下标的元素都相同,那么这两个数组才相等.</li>
<li>两个Set只有当他们有相同数量的元素,并且在一个Set中的所有元素都在第二个Set中都存在,那么这两个Set才相等.</li>
<li>两个Dictonary只有当他们有相同的<code>Key</code>和<code>Value</code>Set,那么这两个字典才相等.</li>
</ul>
<p>但是,<code>String</code>字符串的相等是基于一种<em>规则相等(canonically equivalent)</em>的方式.当字符拥有相同的语义和表现的时候,我们就认为字符是<em>规则相等</em>的.这个时候,两个字符背后的<code>Unicode</code>有可能是不一样的.</p>
<p>比如朝鲜的文字系统,它是由24个字母,<em>Jamo</em>,元音以及辅音组成的.当我们写字的时候会把这些元素进行组合.比如,字<code>가</code>([ga])是由两个字符<code>ᄀ</code>([g])和<code>ᅡ</code>([a])组成.这在Swift中,无论两个字符串是由分解的字符或者是由预组合的字符序列组成的.只要他们的语义和表现是相同的,那么就认为它们是相同的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decomposed = <span class="string">"\u&#123;1100&#125;\u&#123;1161&#125;"</span> <span class="comment">// ᄀ + ᅡ</span></span><br><span class="line"><span class="keyword">let</span> precomposed = <span class="string">"\u&#123;AC00&#125;"</span> <span class="comment">// 가</span></span><br><span class="line"></span><br><span class="line">decomposed == precomposed <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这再次说明,字符串的这种行为与Swift中其他的集合类型是完全不同的.否则如果一个数组中有<code>🐟</code>和<code>🍚</code>两个值,那么他们就是被认为是与<code>🍣</code>相等的.</p>
<h2 id="Depends_on_Your_Point_of_View">Depends on Your Point of View</h2><h4 id="选择何种表现取决于你的使用">选择何种表现取决于你的使用</h4><p>字符串并不是一个集合,但是它确实又提供了一些与<code>CollectionType</code>协议相同的表现</p>
<ul>
<li><code>characters</code>是一个<code>Character</code>字符值或扩展字元簇(<em><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html" target="_blank" rel="external">extended grapheme clusters</a></em>)的集合.</li>
<li><code>unicodeScalars</code> 是一个Unicode纯量(<em><a href="http://www.unicode.org/glossary/#unicode_scalar_value" target="_blank" rel="external">Unicode scalar values</a></em>)的集合</li>
<li><code>uft8</code> 是一个UTF-8字符集编码的集合</li>
<li><code>uft16</code> 是一个UTF-16字符集编码的集合</li>
</ul>
<p>如果我们把前面<code>café</code>这个例子中的[c,a,f,e]和[´]这几个字符,用字符串中的这几个属性来表示.那么他们就应该是如下表所示:<br><img src="/img/2015/07/29/1.png" alt=""></p>
<ul>
<li><code>characters</code>属性表示的是扩展字元簇.它与用户所直观看到的字符是相近的(由c,a,f,é四个字符组成).这是因为一个字符串必须能迭代整个串中的每一个位置(每一个位置都被成为一个代码点(<em>code point</em>)),以便能在<code>O(n)</code>时间复杂度上执行存取该属性的操作,并获取字符串的边界.当处理一个包含了人类可读的文字或者高度地域敏感的Unicode编码算法,比如用作<code>localizedStandardCompare(_:)</code>方法的入参或者<code>localizedLowercaseString</code>属性的值的时候,应该使用这种逐个字符的处理方式.</li>
<li><code>unicodeScalars</code>属性暴露了字符串中基本Unicode纯量的存储.当一个原始的字符串是由预组合字符(<em> precomposed character</em>)<code>é</code>组成,而不是由分解成的两个字符<code>e</code>+<code>´</code>组成,那么你应该更倾向于使用这个API来进行更底层的字符串数据的操作.</li>
<li><code>utf8</code>和<code>utf16</code>属性分别被用来提供UTF-8与UTF-16的代码点的操作.这些值通常被用于在写入真正的文件系统的时候转换成某些特定的编码.UTF-8编码通常被用作许多POSIX字符串API的处理.而UTF-16则是更多的用于<code>Cocoa&amp;Cocoa Touch</code>框架,以计算字符串的长度与偏移量.</li>
</ul>
<p>有关如何在Swift中使用字符串以及字符的更多信息,可以阅读<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" target="_blank" rel="external">The Swift Programming Language</a>和<a href="https://developer.apple.com/library/prerelease/ios//documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/swift/struct/s:SS" target="_blank" rel="external">Swift Standard Library Reference</a>.</p>
<hr>
<p>原文链接:<a href="https://developer.apple.com/swift/blog/?id=30" target="_blank" rel="external">Strings in Swift 2</a><br>翻译:<a href="http://sunxiang0918.github.io/">翔妖除魔</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift2-0中字符串的设计">Swift2.0中字符串的设计</h1><p>Swift中提供了一个高性能的,兼容Unicode的字符串实现作为其标准库中的一部分.在Swift2中,<code>String</code>类型不再实现<code>CollectionType</code>协议.在以前<code>String</code>字符串是一个由<code>Character</code>字符组成的集合,其表现类似于一个数组.而现在,<code>String</code>则是提供了一个<code>characters</code>属性用来暴露字符集合.</p>
<p>为什么会有这样的变化呢?尽管把字符串当做一个字符的集合看起来更自然.但是其实<code>String</code>字符串类型的操作与<code>Array</code>,<code>Set</code>或者<code>Dictionary</code>等集合一直都是完全不同的.但自从Swift2增加了协议扩展后,针对这些差异有必要进行一些根本性的变化了.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Macos 通过安装Hexo 来搭建 GitHub Pages 博客系统]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/25/hello-world/"/>
    <id>http://sunxiang0918.github.io/2015/07/25/hello-world/</id>
    <published>2015-07-25T10:06:02.000Z</published>
    <updated>2015-07-25T10:06:02.000Z</updated>
    <content type="html"><![CDATA[<p>现在越来越多的人愿意使用独立的技术博客.如果自己搭建Wordpress等,需要涉及到服务器的问题.所以,很多人选择了GitHub提供的Pages来搭建个人博客,我也赶一回潮流.在MacOS 上 使用Hexo来搭建GitHubPages博客.</p>
<h2 id="Hexo">Hexo</h2><p>hexo出自台湾大学生 <a href="http://twitter.com/tommy351" target="_blank" rel="external">tommy351</a> 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。</p>
<h3 id="安装Hexo">安装Hexo</h3><p>要安装<code>Hexo</code>需要先安装<code>Npm</code>以及<code>NodeJs</code>.<br>我在MacOS上,是使用<a href="http://brew.sh" target="_blank" rel="external">Brew</a>安装的.</p>
<ol>
<li><p>安装<strong>NodeJS</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<strong>Git</strong><br>由于我安装了XCode的,并且安装了<code>Command Line Tool</code>,因此,这一步可以省略了.否则还是在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>安装<strong>npm</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install npm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<strong>hexo</strong><br>这个就使用nodeJS的安装程序了.<br>同样在终端输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>这个步骤比较慢.因为你懂的</p>
</li>
<li><p>这个时候可以验证一下是否安装好了.<br>在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    $ node -v</span><br><span class="line">v0.<span class="number">12.7</span></span><br><span class="line">$ npm -v</span><br><span class="line">    <span class="number">2.12</span>.<span class="number">1</span></span><br><span class="line">    $ hexo -v</span><br><span class="line">    hexo: <span class="number">3.1</span>.<span class="number">1</span></span><br><span class="line">os: Darwin <span class="number">14.4</span>.<span class="number">0</span> darwin x64</span><br><span class="line">http_parser: <span class="number">2.3</span></span><br><span class="line">node: <span class="number">0.12</span>.<span class="number">7</span></span><br><span class="line">v8: <span class="number">3.28</span>.<span class="number">71.19</span></span><br><span class="line">uv: <span class="number">1.6</span>.<span class="number">1</span></span><br><span class="line">zlib: <span class="number">1.2</span>.<span class="number">8</span></span><br><span class="line">modules: <span class="number">14</span></span><br><span class="line">openssl: <span class="number">1.0</span>.<span class="number">1</span>p</span><br></pre></td></tr></table></figure>
<p>这样就说明安装完成了.<br>但是如果是显示的: <figure class="highlight"><figcaption><span>command not found ```. 说明环境变量没有设置.我也不知道为什么.但是只要补上环境变量就可以了.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    &#62; **hexo&#29615;&#22659;&#21464;&#37327;&#30340;&#35774;&#32622;:** &#22312;`~/` &#29992;&#25143;&#30340;&#26681;&#30446;&#24405;&#19979;&#21019;&#24314;&#19968;&#20010;&#30446;&#24405;:`.bash_profile`.&#20854;&#20013;&#30340;&#20869;&#23481;&#20026;:`export PATH=&#34;/usr/local/Cellar/node/0.12.7/libexec/npm/lib/node_modules/hexo/bi$`  &#20854;&#20013;&#30340;&#36335;&#24452;&#23601;&#26159;hexo&#30340;&#23433;&#35013;&#36335;&#24452;&#10;&#10;### &#20351;&#29992;Hexo&#21019;&#24314;&#21338;&#23458;&#10;&#24403;&#23433;&#35013;&#23436;&#25104;&#21518;,&#23601;&#21487;&#20197;&#24320;&#22987;&#21019;&#24314;&#21338;&#23458;&#20102;.&#10;&#10; 1. &#22312;&#26412;&#22320;&#21019;&#24314;&#21338;&#23458;&#25991;&#20214;&#22841;&#10;    &#36825;&#19968;&#27493;&#30340;&#30446;&#30340;&#26159;&#22312;&#20320;&#30340;&#26412;&#22320;&#21019;&#24314;&#19968;&#20010;&#21338;&#23458;&#30340;&#25991;&#20214;&#22841;.&#20197;&#21518;&#21338;&#23458;&#30340;source&#20197;&#21450;&#32534;&#35793;&#21518;&#30340;&#38745;&#24577;&#25991;&#20214;&#37117;&#20250;&#22312;&#36825;&#20010;&#30446;&#24405;&#20013;.&#10;&#10;    ``` bash&#10;    $ cd ~/&#10;    $ mkdir blog</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<ol>
<li><p>初始化博客文件夹<br>这一步是用于初始化hexo的一些文件的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    $ <span class="built_in">cd</span> ~/  </span><br><span class="line">    $ hexo init blog  </span><br><span class="line">    $ <span class="built_in">cd</span> blog  </span><br><span class="line">    $ ls  </span><br><span class="line">    _config.yml	node_modules	public		<span class="built_in">source</span></span><br><span class="line">db.json		package.json	scaffolds	themes</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化上下文</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的步骤完成后,就完成了hexo的初始化的过程了.<br>接着就可以开始关注于博客的编写了.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"新博客的名字"</span></span><br></pre></td></tr></table></figure>
<p>这样就在<code>_posts</code>文件夹里面新增加了一个<strong>md</strong>文件.直接对这一篇文档进行内容的编写就可以了.</p>
<p>而后,就在命令行中执行 <code>$ hexo generate</code> 就可以生成新的静态文件.新生成的文件全部放在<code>public</code>文件夹中的.</p>
<h3 id="使用Hexo部署博客到github">使用Hexo部署博客到github</h3><p>要使用github的pages功能的话,就需要创建一个 <code>xxxx.github.io</code>的<strong>repository</strong>. 其中<code>xxxx</code>表示的是你的github账号.这样github就会为你分配一个<code>xxxx.github.io</code>的地址.以后你的博客的访问地址也就是这个了.</p>
<p>有了这个地址以后,就要开始使用hexo部署了.<br>修改博客文件夹下的<code>_config.yml</code></p>
<p>主要是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/xxxx/xxxx.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>这个部分.<br>而后就在命令行中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>而后他就会自动的部署到你的github的pages中了.<br>如果报错说 未找到部署类型的话. 就需要安装<code>hexo-deployer-git</code></p>
<p>同样是在博客的目录中执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="后续">后续</h3><p>这样就搭建完毕了, 后续我会慢慢的把以前记录到 evernote的东西 精选一些转过来. </p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章记录了如何使用Hexo和github搭建个人博客]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://sunxiang0918.github.io/tags/Hexo/"/>
    
      <category term="github" scheme="http://sunxiang0918.github.io/tags/github/"/>
    
      <category term="博客" scheme="http://sunxiang0918.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="其他" scheme="http://sunxiang0918.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>G1垃圾收集器入门]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/23/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://sunxiang0918.github.io/2015/07/23/G1垃圾收集器入门/</id>
    <published>2015-07-23T00:37:28.000Z</published>
    <updated>2015-07-28T01:52:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="G1垃圾收集器入门">G1垃圾收集器入门</h1><h2 id="说明">说明</h2><hr>
<p><strong>concurrent</strong>: 并发, 多个线程协同做同一件事情(有状态)</p>
<p><strong>parallel</strong>: 并行, 多个线程各做各的事情(互相间无共享状态)</p>
<p>参考: <a href="http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html" target="_blank" rel="external">What’s the difference between concurrency and parallelism</a></p>
<h2 id="概述">概述</h2><h3 id="目的">目的</h3><p>本文介绍如何使用G1,及在 Hotspot JVM 中怎么使用G1垃圾收集器。 您将了解 G1 收集器的内部原理, 切换为 G1 收集器的命令行参数, 以及让其记录GC日志的选项。</p>
<h3 id="需要的时间">需要的时间</h3><p>大约 1 个小时</p>
<h3 id="简介">简介</h3><p>本文涵盖了Java虚拟机(JVM, Java Virtual Machine)中 G1 的基础知识。</p>
<ol>
<li>第一部分, 简单概述JVM的同时介绍了垃圾收集和性能.</li>
<li>接下来讲述了 Hotspot JVM 中 CMS 收集器是如何工作的.</li>
<li>接着再一步一步地指导在 Hotspot JVM 中使用G1进行垃圾回收的工作方式.</li>
<li>之后的一个小节介绍 G1 垃圾收集器可用的命令行参数.</li>
<li>最后,您将了解如何配置使G1收集器记录日志.</li>
</ol>
<h3 id="硬件与软件环境需求">硬件与软件环境需求</h3><p>下面是 硬件与软件环境需求 清单:</p>
<ul>
<li>一台PC机, 运行 Windows XP 以上操作系统, Mac OS X 或者 Linux 都可以. 注意,因为作者在Windows 7上进行开发和测试, 尚未在所有平台上完成测试。 但在 OS X和Linux 上应该也是正常的。最好配置了多核CPU.</li>
<li>Java 7 Update 9 或更高版本</li>
<li>最新的 Java 7 Demos and Samples Zip 文件</li>
</ul>
<h3 id="准备条件">准备条件</h3><p>在开始学习本教程之前, 你需要:</p>
<ul>
<li><p>下载并安装最新的 Java JDK (JDK 7 u9 或 以后的版本): Java 7 JDK 下载页面</p>
</li>
<li><p>下载并安装 Demos and Samples (示例与样例) zip 文件, 下载页面和JDK相同. 然后解压到合适的位置. 如:C:\javademos</p>
</li>
</ul>
<a id="more"></a>
<h2 id="Java_技术_和_JVM">Java 技术 和 JVM</h2><h3 id="Java_概述">Java 概述</h3><p>Java 是 Sun Microsystems 公司在1995年发布的一门编程语言. 同时也是一个运行Java程序的底层平台. 提供工具、游戏和企业应用程序支持。Java 运行在全世界超过8.5亿的PC,以及数十亿的智能设备上,包括 mobile 和 TV. Java 是由许多关键部件组成的一个整体, 统称为Java平台。</p>
<h3 id="JRE(Java_Runtime_Edition)">JRE(Java Runtime Edition)</h3><p>一般来说下载了Java以后, 你就得到了一个Java运行时: Java Runtime Environment (JRE). JRE 由Java虚拟机 Java Virtual Machine (JVM), Java 平台核心类(core classes), 以及 Java平台支持库组成. 必须有这三大组件的支持才能在你的电脑上运行 Java 程序. 例如 Java 7, 可以在操作系统上作为桌面应用程序运行, 还可以通过 Java Web Start 从Web上安装, 或者是作为嵌入式Web程序在浏览器中运行 (通过 JavaFX).</p>
<h3 id="Java_编程语言">Java 编程语言</h3><p>Java 是一门面向对象编程语言(object-oriented programming language), 包涵以下特性.</p>
<ul>
<li>Platform Independence - Java 应用程序被编译为字节码(bytecode)存放到 class 文件中, 由JVM加载. 因为程序在 JVM 中运行, 所以可以跨平台运行在各种操作系统/设备上.</li>
<li>Object-Oriented - Java 是一门面向对象的语言, 继承了 C 和 C++ 的很多特性,并在此基础上进行扩充和优化.</li>
<li>Automatic Garbage Collection - Java对内存进行 自动分配(allocates) 和自动释放(deallocates). 所以程序不再执行这一繁琐的任务(其实自动内存回收,更多的好处是减少了编程需要重复处理的这种细节,另一个例子是对JDBC的封装).</li>
<li>Rich Standard Library - Java包含大量的标准对象,可以执行诸如输入输出(input/output), 网络操作以及日期处理等任务.</li>
</ul>
<h3 id="JDK(Java_Development_Kit)">JDK(Java Development Kit)</h3><p>JDK 是用来开发Java程序的一系列工具集. 通过JDK, 你可以编译用Java语言书写的程序, 并在 JVM 中运行. 另外, JDK 还提供了打包(packaging)和分发(distributing)程序的工具.</p>
<p>JDK 和 JRE 使用同样的 Java Application Programming Interfaces (<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="external">Java API</a>).Java API 是预先打包好以供程序员用来开发程序的类库集合. 通过 Java API 使得很多常规任务可以很轻松的就完成,如 字符串操作(string manipulation), 时间日期处理(date/time processing), 网络编程(networking), 以及实现各种数据结构(data structures, 如 lists, maps, stacks, and queues).</p>
<h3 id="JVM(Java_Virtual_Machine)">JVM(Java Virtual Machine)</h3><p>Java Virtual Machine (JVM) 是一台抽象的计算机(abstract computing machine). JVM 本质是一个程序, 但在运行于JVM上的程序看来, 他就像一台真实机器一样. 这样, Java程序就能使用相同的接口和库. 每种特定操作系统上的 JVM 实现, 都将 Java 程序指令转换为本地机器的指令(instructions)和命令(commands). 由此,实现了Java程序的平台独立性.</p>
<p>Java虚拟机的第一个原型实现,由 Sun Microsystems, Inc. 完成, 在一台手持设备上用软件模拟了 Java虚拟机指令集, 类似于今天的 PDA(Personal Digital Assistant). Oracle 当前在移动设备,桌面系统和服务器上都提供了Java虚拟机实现, 但Java虚拟机不限制使用任何特定的技术,硬件,或操作系统。JVM也不一定都是基于软件的,你可以直接在硬件CPU上实现JVM指令, 还可以芯片上实现,或者采用 microcode 的方式来实现.</p>
<p>Java 虚拟机完全不关心Java语言的细节, 只识别 class 文件这种特定的二进制格式. 一个 class 文件包含 Java虚拟机指令(或称之为字节码 bytecode) 及符号变量表(symbol table), 还有一些辅助信息.</p>
<p>基于安全性考虑, Java虚拟机对 class 文件中的代码执行 强语法检查和组成结构规范限制. 既然虚拟机有这种特征, 那么任何一门编程语言,只要能编译为合法的 class 文件，都可以加载到 Java虚拟机 里面执行。由于具有通用性,跨平台特性, 其他语言的实现者可以把Java虚拟机作为该语言的加载执行工具。(1) <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-1.html" target="_blank" rel="external">The Java Virtual Machine</a></p>
<h2 id="探索_JVM_体系架构">探索 JVM 体系架构</h2><h3 id="Hotspot_架构">Hotspot 架构</h3><p>HotSpot JVM 有一个稳定强悍的架构, 支持强大的功能与特性, 具备实现高性能和大规模可伸缩性的能力。例如,HotSpot JVM JIT编译器能动态进行优化生成。换句话说,他们运行Java程序时,会针对底层系统架构动态生成高性能的本地机器指令。此外,通过成熟的演进和运行时环境的持续工程,加上多线程垃圾收集器,HotSpot JVM即使实在大型计算机系统上也能获得很高的伸缩性.</p>
<p><img src="/img/2015/07/23/01_1_JVM_Arch_CN.png" alt="HotSpot JVM: Architecture"></p>
<p>JVM 的主要组件包括: 类加载器(class loader), 运行时数据区(runtime data areas), 以及执行引擎(execution engine).</p>
<h3 id="Hotspot_关键部分">Hotspot 关键部分</h3><p>与性能(performance)有关的部分是 JVM 最重要的组件,下图中用高亮的颜色来显示.</p>
<p><img src="/img/2015/07/23/01_2_Key_Hotspot_Components_CN.png" alt=""></p>
<p>对JVM进行性能调优时有三大组件需要重点关注。堆(Heap)是存放对象的内存空间。这个区域由JVM启动时选择的垃圾收集器进行管理。大多数调优参数都是调整堆内存的大小,以及根据实际情况选择最合适的垃圾收集器. JIT编译器也对性能有很大的影响, 但新版本的JVM调优中很少需要关注.</p>
<h2 id="性能基础">性能基础</h2><p>大多数情况下对 Java 程序进行调优, 主要关注两个目标之一: 响应速度(responsiveness) 和/或 吞吐量(throughput). 下面的教程中我们将讲述这些概念.</p>
<h3 id="响应能力(Responsiveness)">响应能力(Responsiveness)</h3><p>响应能力就是程序或系统对一个请求的响应有多迅速. 比如:</p>
<ul>
<li>程序UI响应速度有多灵敏</li>
<li>网站页面响应有多快</li>
<li>数据库查询有多快<br>对响应速度要求很高的系统, 较大的停顿时间(large pause times) 是不可接受的. 重点是在非常短的时间周期内快速响应.</li>
</ul>
<h3 id="吞吐量(Throughput)">吞吐量(Throughput)</h3><p>吞吐量关注在一个特定时间段内应用系统的最大工作量。衡量吞吐量的指标/示例包括:</p>
<ul>
<li>给定时间内完成的事务数.</li>
<li>每小时批处理系统能完成的作业(jobs)数量.</li>
<li>每小时能完成多少次数据库查询</li>
</ul>
<p>在吞吐量方面优化的系统, 停顿时间长(High pause times)也是可以接受的。由于高吞吐量应用运行时间长,所以此时更关心的是如何尽可能快地完成整个任务，而不考虑快速响应。</p>
<h2 id="G1_垃圾收集器(Garbage_Collector)">G1 垃圾收集器(Garbage Collector)</h2><h3 id="G1_垃圾收集器">G1 垃圾收集器</h3><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 在Oracle JDK 7 update 4 及以上版本中得到完全支持, 专为以下应用程序设计:</p>
<ul>
<li>可以像CMS收集器一样,GC操作与应用的线程一起并发执行</li>
<li>紧凑的空闲内存区间且没有很长的GC停顿时间.</li>
<li>需要可预测的GC暂停耗时.</li>
<li>不想牺牲太多吞吐量性能.</li>
<li>启动后不需要请求更大的Java堆.</li>
</ul>
<p>G1的长期目标是取代CMS(Concurrent Mark-Sweep Collector, 并发标记-清除). 因为特性的不同使G1成为比CMS更好的解决方案. 一个区别是,G1是一款压缩型的收集器.G1通过有效的压缩完全避免了对细微空闲内存空间的分配,不用依赖于regions，这不仅大大简化了收集器，而且还消除了潜在的内存碎片问题。除压缩以外，G1的垃圾收集停顿也比CMS容易估计，也允许用户自定义所希望的停顿参数(pause targets)</p>
<h3 id="G1_操作概述">G1 操作概述</h3><p>上一代的垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation).</p>
<p><img src="/img/2015/07/23/02_1_HeapStructure_CN.png" alt=""></p>
<p>内存中的每个对象都存放在这三个区域中的一个.</p>
<p>而 G1 收集器采用一种不同的方式来管理堆内存.</p>
<p><img src="/img/2015/07/23/02_2_G1HeapAllocation_CN.png" alt=""></p>
<p>堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性。</p>
<p>G1执行垃圾回收的处理方式与CMS相似. G1在全局标记阶段(global marking phase)并发执行, 以确定堆内存中哪些对象是存活的。标记阶段完成后,G1就可以知道哪些heap区的empty空间最大。它会首先回收这些区,通常会得到大量的自由空间. 这也是为什么这种垃圾收集方法叫做Garbage-First(垃圾优先)的原因。顾名思义, G1将精力集中放在可能布满可收回对象的区域, 可回收对象(reclaimable objects)也就是所谓的垃圾. G1使用暂停预测模型(pause prediction model)来达到用户定义的目标暂停时间,并根据目标暂停时间来选择此次进行垃圾回收的heap区域数量.</p>
<p>被G1标记为适合回收的heap区将使用转移(evacuation)的方式进行垃圾回收. G1将一个或多个heap区域中的对象拷贝到其他的单个区域中,并在此过程中压缩和释放内存. 在多核CPU上转移是并行执行的(parallel on multi-processors), 这样能减少停顿时间并增加吞吐量. 因此,每次垃圾收集时, G1都会持续不断地减少碎片, 并且在用户给定的暂停时间内执行. 这比以前的方法强大了很多. CMS垃圾收集器(Concurrent Mark Sweep,并发标记清理)不进行压缩. ParallelOld 垃圾收集只对整个堆执行压缩,从而导致相当长的暂停时间。</p>
<p>需要强调的是, G1并不是一款实时垃圾收集器(real-time collector). 能以极高的概率在设定的目标暂停时间内完成,但不保证绝对在这个时间内完成。 基于以前收集的各种监控数据, G1会根据用户指定的目标时间来预估能回收多少个heap区. 因此,收集器有一个相当精确的heap区耗时计算模型,并根据该模型来确定在给定时间内去回收哪些heap区.</p>
<p><strong>注意 G1</strong>分为两个阶段: 并发阶段(concurrent, 与应用线程一起运行, 如: 细化 refinement、标记 marking、清理 cleanup) 和 并行阶段(parallel, 多线程执行, 如: 停止所有JVM线程, stop the world). 而 FullGC(完整垃圾收集)仍然是单线程的, 但如果进行适当的调优,则应用程序应该能够避免 full GC。</p>
<h3 id="G1_的内存占用(Footprint)">G1 的内存占用(Footprint)</h3><p>如果从 ParallelOldGC 或者 CMS收集器迁移到 G1, 您可能会看到JVM进程占用更多的内存(a larger JVM process size). 这在很大程度上与 “accounting” 数据结构有关, 如 Remembered Sets 和 Collection Sets.</p>
<p><strong>Remembered Sets</strong> 简称 RSets, 跟踪指向某个heap区内的对象引用. 堆内存中的每个区都有一个 RSet. RSet 使heap区能并行独立地进行垃圾集合. RSets的总体影响小于5%.</p>
<p><strong>Collection Sets</strong> 简称 CSets, 收集集合, 在一次GC中将执行垃圾回收的heap区. GC时在CSet中的所有存活数据(live data)都会被转移(复制/移动). 集合中的heap区可以是 Eden, survivor, 和/或 old generation. CSets所占用的JVM内存小于1%.</p>
<h3 id="推荐使用_G1_的场景(Recommended_Use_Cases)">推荐使用 G1 的场景(Recommended Use Cases)</h3><p>G1的首要目标是为需要大量内存的系统提供一个保证GC低延迟的解决方案. 也就是说堆内存在6GB及以上,稳定和可预测的暂停时间小于0.5秒.</p>
<p>如果应用程序具有如下的一个或多个特征,那么将垃圾收集器从CMS或ParallelOldGC切换到G1将会大大提升性能.</p>
<ul>
<li>Full GC 次数太频繁或者消耗时间太长.</li>
<li>对象分配的频率或代数提升(promotion)显著变化.</li>
<li>受够了太长的垃圾回收或内存整理时间(超过0.5~1秒)</li>
</ul>
<p><strong>注意: </strong>如果正在使用CMS或ParallelOldGC,而应用程序的垃圾收集停顿时间并不长,那么继续使用现在的垃圾收集器是个好主意. 使用最新的JDK时并不要求切换到G1收集器。</p>
<h2 id="CMS的GC概述">CMS的GC概述</h2><h3 id="分代GC(Generational_GC)与_CMS">分代GC(Generational GC)与 CMS</h3><p>并发标记清理(CMS, Concurrent Mark Sweep)收集器(也称为多并发低暂停的收集器)回收老年代内存(tenured generation). 它将垃圾回收中的绝大部分工作与应用程序的线程一起并发执行,以期能最小化暂停时间. 通常多并发低暂停收集器收集器不复制或也不压缩存活的对象. 垃圾回收不移动存活的对象, 如果产生内存碎片问题,就会分配/占用更大的堆内存空间。</p>
<p><strong>注意: </strong>年轻代使用的CMS收集器也和并行收集器采用一样的算法.</p>
<h3 id="CMS_垃圾收集阶段划分(Collection_Phases)">CMS 垃圾收集阶段划分(Collection Phases)</h3><p>CMS收集器在老年代堆内存的回收中执行分为以下阶段:</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1) 初始标记 (Initial Mark)</td>
<td>(Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable).对象在旧一代“标志”可以包括这些对象可能可以从年轻一代。暂停时间一般持续时间较短,相对小的收集暂停时间.</td>
</tr>
<tr>
<td>(2) 并发标记 (Concurrent Marking)</td>
<td>在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象. 调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态.</td>
</tr>
<tr>
<td>(3) 再次标记(Remark)</td>
<td>(Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的.</td>
</tr>
<tr>
<td>(4) 并发清理(Concurrent Sweep)</td>
<td>回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动.</td>
</tr>
<tr>
<td>(5) 重置(Resetting)</td>
<td>清理数据结构,为下一个并发收集做准备.</td>
</tr>
</tbody>
</table>
<h3 id="CMS的GC步骤">CMS的GC步骤</h3><p>接下来,让我们一步步地讲述CMS收集器的操作.</p>
<h4 id="1-_CMS的堆内存结构(Heap_Structure)">1. CMS的堆内存结构(Heap Structure)</h4><p>堆内存被分为3个空间.</p>
<p><img src="/img/2015/07/23/03_1_CMS_Heap_Structure_CN.png" alt=""></p>
<p>年轻代(Young generation)分为 1个新生代空间(Eden)和2个存活区(survivor spaces). 老年代(Old generation)是一大块连续的空间, 垃圾回收(Object collection)就地解决(is done in place), 除了 Full GC, 否则不会进行压缩(compaction).</p>
<h4 id="2-_CMS年轻代(Young)_GC_的工作方式">2. CMS年轻代(Young) GC 的工作方式</h4><p>年轻代(young generation)用高亮的绿色表示, 老年代(old generation)用蓝色表示。如果程序运行了一段时间,那么 CMS 看起来就像下图这个样子. 对象散落在老年代中的各处地方.</p>
<p><img src="/img/2015/07/23/03_2_How_yong_GC_Works_CN.png" alt=""></p>
<p>在使用 CMS 时, 老年代的对象回收就地进行(deallocated in place). 他们不会被移动到其他地方. 除了 Full GC, 否则内存空间不会进行压缩.</p>
<h4 id="3-_年轻代垃圾回收(Young_Generation_Collection)">3. 年轻代垃圾回收(Young Generation Collection)</h4><p>Eden区和survivor区中的存活对象被拷贝到另一个空的survivor 区. 存活时间更长,达到阀值的对象会被提升到老年代(promoted to old generation).</p>
<p><img src="/img/2015/07/23/03_3_Yong_Generation_Collection_CN.png" alt=""></p>
<h4 id="4-_年轻代(Young)_GC_之后">4. 年轻代(Young) GC 之后</h4><p>年轻代(Young)进行一次垃圾回收之后, Eden 区被清理干净(cleared),两个 survivor 区中的一个也被清理干净了. 如下图所示:</p>
<p><img src="/img/2015/07/23/03_4_After_Young_GC_CN.png" alt=""></p>
<p>图中新提升的对象用深蓝色来标识. 绿色的部分是年轻代中存活的对象,但还没被提升到老年代中.</p>
<h4 id="5-_CMS的老年代回收(Old_Generation_Collection)">5. CMS的老年代回收(Old Generation Collection)</h4><p>两次stop the world事件发生在: 初始标记(initial mark)以及重新标记(remark)阶段. 当老年代达到一定的占有率时,CMS垃圾回收器就开始工作.</p>
<p><img src="/img/2015/07/23/03_5_Old_Generation_Collection_in_CMS_CN.png" alt=""></p>
<p>(1) 初始标记(Initial mark)阶段的停顿时间很短,在此阶段存活的(live,reachable,可及的) 对象被记下来. (2) 并发标记(Concurrent marking)在程序继续运行的同时找出存活的对象. 最后, 在第(3)阶段(remark phase), 查找在第(2)阶段(concurrent marking)中错过的对象.</p>
<h4 id="6-_老年代回收_-_并发清理(Concurrent_Sweep)">6. 老年代回收 - 并发清理(Concurrent Sweep)</h4><p>在前面阶段未被标记的对象将会就地释放(deallocated in place). 此处没有压缩(compaction).</p>
<p><img src="/img/2015/07/23/03_6_Concurrent_Sweep_CN.png" alt=""></p>
<p><strong>备注:</strong> 未标记(Unmarked)的对象 == 已死对象(Dead Objects)</p>
<h4 id="7-_老年代回收_-_清理之后(After_Sweeping)">7. 老年代回收 - 清理之后(After Sweeping)</h4><p>在第(4)步(Sweeping phase)之后, 可以看到很多内存被释放了. 还应该注意到,这里并没有执行内存压缩整理(no compaction).</p>
<p><img src="/img/2015/07/23/03_7_After_Sweeping_CN.png" alt=""></p>
<p>最后, CMS 收集器进入(move through)第(5)阶段, 重置(resetting phase), 然后等候下一次的GC阀值到来(GC threshold).</p>
<h2 id="G1垃圾收集器概述">G1垃圾收集器概述</h2><h3 id="一步步介绍G1">一步步介绍G1</h3><p>G1收集器采用一种不同的方式来分配堆. 下面通过图解的方式一步步地讲述G1系统.</p>
<h4 id="1-_G1的堆内存结构">1. G1的堆内存结构</h4><p>堆内存被划分为固定大小的多个区域.</p>
<p><img src="/img/2015/07/23/04_1_G1_Heap_Structure_CN.png" alt=""></p>
<p>每个heap区(Region)的大小在JVM启动时就确定了. JVM 通常生成 2000 个左右的heap区, 根据堆内存的总大小,区的size范围允许为 1Mb 到 32Mb.</p>
<h4 id="2-_G1_堆空间分配">2. G1 堆空间分配</h4><p>实际上,这些区域(regions)被映射为逻辑上的 Eden, Survivor, 和 old generation(老年代)空间.</p>
<p><img src="/img/2015/07/23/02_2_G1HeapAllocation_CN.png" alt=""></p>
<p>图中的颜色标识了每一个区域属于哪个角色. 存活的对象从一块区域转移(复制或移动)到另一块区域。设计成 heap 区的目的是为了并行地进行垃圾回收(的同时停止/或不停止其他应用程序线程).</p>
<p>如图所示,heap区可以分配为 Eden, Survivor, 或 old generation(老年代)区. 此外,还有第四种类型的对象被称为巨无霸区域(Humongous regions),这种巨无霸区是设计了用来保存比标准heap区大50%及以上的对象, 它们存储在一组连续的区中. 最后一个类型是堆内存中的未使用区(unused areas).</p>
<p><strong>备注:</strong> 截止英文原文发表时,巨无霸对象的回收还没有得到优化. 因此,您应该尽量避免创建太大(大于32MB?)的对象.</p>
<h4 id="3-_G1中的年轻代(Young_Generation)">3. G1中的年轻代(Young Generation)</h4><p>堆被分为大约2000个区. 最小size为1 Mb, 最大size为 32Mb. 蓝色的区保存老年代对象,绿色区域保存年轻代对象.</p>
<p><img src="/img/2015/07/23/04_3_Young_Generation_in_G1_CN.png" alt=""></p>
<p>注意G1中各代的heap区不像老一代垃圾收集器一样要求各部分是连续的.</p>
<h4 id="4-_G1中的一次年轻代GC">4. G1中的一次年轻代GC</h4><p>存活的对象被转移(copied or moved)到一个/或多个存活区(survivor regions). 如果存活时间达到阀值,这部分对象就会被提升到老年代(promoted to old generation regions).</p>
<p><img src="/img/2015/07/23/04_4_A_Young_GC_in_G1_CN.png" alt=""></p>
<p>此时会有一次 stop the world(STW)暂停. 会计算出 Eden大小和 survivor 大小,给下一次年轻代GC使用. 清单统计信息(Accounting)保存了用来辅助计算size. 诸如暂停时间目标之类的东西也会纳入考虑.</p>
<p>这种方法使得调整各代区域的尺寸很容易, 让其更大或更小一些以满足需要.</p>
<h4 id="5-_G1的一次年轻代GC完成后">5. G1的一次年轻代GC完成后</h4><p>存活对象被转移到存活区(survivor regions) 或 老年代(old generation regions).</p>
<p><img src="/img/2015/07/23/04_5_End_of_Young_GC_with_G1_CN.png" alt=""></p>
<p>刚刚被提升上来的对象用深绿色显示. Survivor 区用绿色表示.</p>
<p>总结起来,G1的年轻代收集归纳如下:</p>
<ul>
<li>堆一整块内存空间,被分为多个heap区(regions).</li>
<li>年轻代内存由一组不连续的heap区组成. 这使得在需要时很容易进行容量调整.</li>
<li>年轻代的垃圾收集,或者叫 young GCs, 会有 stop the world 事件. 在操作时所有的应用程序线程都会被暂停(stopped).</li>
<li>年轻代 GC 通过多线程并行进行.</li>
<li>存活的对象被拷贝到新的 survivor 区或者老年代.</li>
</ul>
<h3 id="Old_Generation_Collection_with_G1">Old Generation Collection with G1</h3><p>和 CMS 收集器相似, G1 收集器也被设计为用来对老年代的对象进行低延迟(low pause)的垃圾收集. 下表描述了G1收集器在老年代进行垃圾回收的各个阶段.</p>
<h4 id="G1_收集阶段_-_并发标记周期阶段(Concurrent_Marking_Cycle_Phases)">G1 收集阶段 - 并发标记周期阶段(Concurrent Marking Cycle Phases)</h4><p>G1 收集器在老年代堆内存中执行下面的这些阶段. 注意有些阶段也是年轻代垃圾收集的一部分.</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1) 初始标记(Initial Mark)</td>
<td>(Stop the World Event,所有应用线程暂停) 此时会有一次 stop the world(STW)暂停事件. 在G1中, 这附加在(piggybacked on)一次正常的年轻代GC. 标记可能有引用指向老年代对象的survivor区(根regions).</td>
</tr>
<tr>
<td>(2) 扫描根区域(Root Region Scanning)</td>
<td>扫描 survivor 区中引用到老年代的引用. 这个阶段应用程序的线程会继续运行. 在年轻代GC可能发生之前此阶段必须完成.</td>
</tr>
<tr>
<td>(3) 并发标记(Concurrent Marking)</td>
<td>在整个堆中查找活着的对象. 此阶段应用程序的线程正在运行. 此阶段可以被年轻代GC打断(interrupted).</td>
</tr>
<tr>
<td>(4) 再次标记(Remark)</td>
<td>(Stop the World Event,所有应用线程暂停) 完成堆内存中存活对象的标记. 使用一个叫做 snapshot-at-the-beginning(SATB, 起始快照)的算法, 该算法比CMS所使用的算法要快速的多.</td>
</tr>
<tr>
<td>(5) 清理(Cleanup)</td>
<td>(Stop the World Event,所有应用线程暂停,并发执行)</td>
</tr>
</tbody>
</table>
<p>在存活对象和完全空闲的区域上执行统计(accounting). (Stop the world)<br>擦写 Remembered Sets. (Stop the world)<br>重置空heap区并将他们返还给空闲列表(free list). (Concurrent, 并发)|<br>|(*) 拷贝(Copying)|    (Stop the World Event,所有应用线程暂停) 产生STW事件来转移或拷贝存活的对象到新的未使用的heap区(new unused regions). 只在年轻代发生时日志会记录为 <code>[GC pause (young)]</code>. 如果在年轻代和老年代一起执行则会被日志记录为 <code>[GC Pause (mixed)]</code>.|</p>
<h3 id="G1老年代收集步骤">G1老年代收集步骤</h3><p>顺着定义的阶段,让我们看看G1收集器如何处理老年代(old generation).</p>
<h4 id="6-_初始标记阶段(Initial_Marking_Phase)">6. 初始标记阶段(Initial Marking Phase)</h4><p>存活对象的初始标记被固定在年轻代垃圾收集里面. 在日志中被记为 GC pause (young)(inital-mark)。</p>
<p><img src="/img/2015/07/23/04_6_Initial_Marking_Phase_CN.png" alt=""></p>
<h4 id="7-_并发标记阶段(Concurrent_Marking_Phase)">7. 并发标记阶段(Concurrent Marking Phase)</h4><p>如果找到空的区域(如用红叉“X”标示的区域), 则会在 Remark 阶段立即移除. 当然,”清单(accounting)”信息决定了活跃度(liveness)的计算.</p>
<p><img src="/img/2015/07/23/04_7_Concurrent_Marking_Phase_CN.png" alt=""></p>
<h4 id="8-_再次标记阶段(Remark_Phase)">8. 再次标记阶段(Remark Phase)</h4><p>空的区域被移除并回收。现在计算所有区域的活跃度(Region liveness).</p>
<p><img src="/img/2015/07/23/04_8_Remark_Phase_CN.png" alt=""></p>
<h4 id="9-_拷贝/清理阶段(Copying/Cleanup)">9. 拷贝/清理阶段(Copying/Cleanup)</h4><p>G1选择“活跃度(liveness)”最低的区域, 这些区域可以最快的完成回收. 然后这些区域和年轻代GC在同时被垃圾收集 . 在日志被标识为 [GC pause (mixed)]. 所以年轻代和老年代都在同一时间被垃圾收集.</p>
<p><img src="/img/2015/07/23/04_9_Copying_Cleanup_Phase_CN.png" alt=""></p>
<h4 id="10-拷贝/清理之后(After_Copying/Cleanup)">10.拷贝/清理之后(After Copying/Cleanup)</h4><p>所选择的区域被收集和压缩到下图所示的深蓝色区域和深绿色区域.</p>
<p><img src="/img/2015/07/23/04_10_After_Copying_Cleanup_Phase_CN.png" alt=""></p>
<h3 id="老年代GC(Old_Generation_GC)总结">老年代GC(Old Generation GC)总结</h3><p>总结下来,G1对老年代的GC有如下几个关键点:</p>
<ul>
<li>并发标记清理阶段(Concurrent Marking Phase)<ul>
<li>活跃度信息在程序运行的时候被并行计算出来</li>
<li>活跃度(liveness)信息标识出哪些区域在转移暂停期间最适合回收.</li>
<li>不像CMS一样有清理阶段(sweeping phase).</li>
</ul>
</li>
<li>再次标记阶段(Remark Phase)<ul>
<li>使用的 Snapshot-at-the-Beginning (SATB, 开始快照) 算法比起 CMS所用的算法要快得多.</li>
<li>完全空的区域直接被回收.</li>
</ul>
</li>
<li>拷贝/清理阶段(Copying/Cleanup Phase)<ul>
<li>年轻代与老年代同时进行回收.</li>
<li>老年代的选择基于其活跃度(liveness).</li>
</ul>
</li>
</ul>
<h2 id="命令行参数与最佳实践">命令行参数与最佳实践</h2><h3 id="命令行参数与最佳实践-1">命令行参数与最佳实践</h3><p>在本节中,让我们看看G1的各种命令行选项.</p>
<h3 id="命令行基本参数">命令行基本参数</h3><p>要启用 G1 收集器请使用: <code>-XX:+UseG1GC</code></p>
<p>下面是启动 Java2Demo示例程序的命令行示例. Java2Demo位于下载 JDK demos and samples 后解压的文件夹中:</p>
<p><code>java -Xmx50m -Xms50m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar c:\javademos\demo\jfc\Java2D\Java2demo.jar</code></p>
<h3 id="关键命令行开关">关键命令行开关</h3><p><strong>-XX:+UseG1GC</strong> - 让 JVM 使用 G1 垃圾收集器.</p>
<p><strong>-XX:MaxGCPauseMillis=200</strong> - 设置最大GC停顿时间(GC pause time)指标(target). 这是一个软性指标(soft goal), JVM 会尽力去达成这个目标. 所以有时候这个目标并不能达成. 默认值为 200 毫秒.</p>
<p><strong>-XX:InitiatingHeapOccupancyPercent=45</strong> - 启动并发GC时的堆内存占用百分比. G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比例。值为 0 则表示“一直执行GC循环)’. 默认值为 45 (例如, 全部的 45% 或者使用了45%).</p>
<h3 id="最佳实践">最佳实践</h3><p>在使用 G1 作为垃圾收集器时,你应该遵循下面这些最佳实践的指导.</p>
<h4 id="不要设置年轻代的大小(Young_Generation_Size)">不要设置年轻代的大小(Young Generation Size)</h4><p>假若通过 -Xmn 显式地指定了年轻代的大小, 则会干扰到 G1收集器的默认行为.</p>
<ul>
<li>G1在垃圾收集时将不再关心暂停时间指标. 所以从本质上说,设置年轻代的大小将禁用暂停时间目标.</li>
<li>G1在必要时也不能够增加或者缩小年轻代的空间. 因为大小是固定的,所以对更改大小无能为力.</li>
</ul>
<h4 id="响应时间指标(Response_Time_Metrics)">响应时间指标(Response Time Metrics)</h4><p>设置 <code>XX:MaxGCPauseMillis=&lt;N&gt;</code> 时不应该使用平均响应时间(ART, average response time) 作为指标,而应该考虑使用目标时间的90%或者更大作为响应时间指标. 也就是说90%的用户(客户端/?)请求响应时间不会超过预设的目标值. 记住,暂停时间只是一个目标,并不能保证总是得到满足.</p>
<h4 id="什么是转移失败(Evacuation_Failure)?">什么是转移失败(Evacuation Failure)?</h4><p>对 survivors 或 promoted objects 进行GC时如果JVM的heap区不足就会发生提升失败(promotion failure). 堆内存不能继续扩充,因为已经达到最大值了. 当使用 -XX:+PrintGCDetails 时将会在GC日志中显示 <strong>to-space overflow</strong> (to-空间溢出)。</p>
<p><strong>这是很昂贵的操作!</strong></p>
<ul>
<li>GC仍继续所以空间必须被释放.</li>
<li>拷贝失败的对象必须被放到正确的位置(tenured in place).</li>
<li>CSet指向区域中的任何 RSets 更新都必须重新生成(regenerated).</li>
<li>所有这些步骤都是代价高昂的.</li>
</ul>
<h4 id="如何避免转移失败(Evacuation_Failure)">如何避免转移失败(Evacuation Failure)</h4><p>要避免避免转移失败, 考虑采纳下列选项.</p>
<ul>
<li>增加堆内存大小<ul>
<li>增加 <strong>-XX:G1ReservePercent=n</strong>, 其默认值是 10.</li>
<li>G1创建了一个假天花板(false ceiling),在需要更大 ‘to-space’ 的情况下会尝试从保留内存获取(leave the reserve memory free).</li>
</ul>
</li>
<li>更早启动标记周期(marking cycle)</li>
<li>通过采用 <strong>-XX:ConcGCThreads=n</strong> 选项增加标记线程(marking threads)的数量.</li>
</ul>
<h4 id="G1_的_GC_参数完全列表">G1 的 GC 参数完全列表</h4><p>下面是完整的 G1 的 GC 开关参数列表. 在使用时请记住上面所述的最佳实践.</p>
<table>
<thead>
<tr>
<th>选项/默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseG1GC</td>
<td>使用 G1 (Garbage First) 垃圾收集器</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis=n</td>
<td>设置最大GC停顿时间(GC pause time)指标(target). 这是一个软性指标(soft goal), JVM 会尽量去达成这个目标.</td>
</tr>
<tr>
<td>-XX:InitiatingHeapOccupancyPercent=n</td>
<td>启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示”一直执行GC循环”. 默认值为 45.</td>
</tr>
<tr>
<td>-XX:NewRatio=n</td>
<td>新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2.</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=n</td>
<td>eden/survivor 空间大小的比例(Ratio). 默认值为 8.</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold=n</td>
<td>提升年老代的最大临界值(tenuring threshold). 默认值为 15.</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads=n</td>
<td>设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同.</td>
</tr>
<tr>
<td>-XX:ConcGCThreads=n</td>
<td>并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而不同.</td>
</tr>
<tr>
<td>-XX:G1ReservePercent=n</td>
<td>设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认值是 10.</td>
</tr>
<tr>
<td>-XX:G1HeapRegionSize=n</td>
<td>使用G1时Java堆会被分为大小统一的的区(region)。此参数可以指定每个heap区的大小. 默认值将根据 heap size 算出最优解. 最小值为 1Mb, 最大值为 32Mb.</td>
</tr>
</tbody>
</table>
<h2 id="记录G1的GC日志">记录G1的GC日志</h2><h3 id="记录G1的GC日志-1">记录G1的GC日志</h3><p>我们要介绍的最后一个主题是使用日志信息来分享G1收集器的性能. 本节简要介绍垃圾收集的相关参数,以及日志中打印的相关信息.</p>
<h3 id="设置日志细节(Log_Detail)">设置日志细节(Log Detail)</h3><p>可以设置3种不同的日志级别.</p>
<p><strong>(1) -verbosegc (等价于 -XX:+PrintGC)</strong> 设置日志级别为 <strong>好</strong> <em>fine</em>.</p>
<p><strong>日志输出示例</strong></p>
<pre><code><span class="list">[<span class="keyword">GC</span> pause <span class="list">(<span class="keyword">G1</span> Humongous Allocation)</span> <span class="list">(<span class="keyword">young</span>)</span> <span class="list">(<span class="keyword">initial-mark</span>)</span> <span class="number">24</span>M- &gt;21M<span class="list">(<span class="keyword">64M</span>)</span>, <span class="number">0.2349730</span> secs]
<span class="list">[<span class="keyword">GC</span> pause <span class="list">(<span class="keyword">G1</span> Evacuation Pause)</span> <span class="list">(<span class="keyword">mixed</span>)</span> <span class="number">66</span>M-&gt;21M<span class="list">(<span class="keyword">236M</span>)</span>, <span class="number">0.1625268</span> secs]  </span></span>
</code></pre><p><strong>(2) -XX:+PrintGCDetails</strong> 设置日志级别为 <strong>更好</strong> <em>finer</em>. 使用此选项会显示以下信息:</p>
<ul>
<li>每个阶段的 Average, Min, 以及 Max 时间.</li>
<li>根扫描(Root Scan), RSet 更新(同时处理缓冲区信息), RSet扫描(Scan), 对象拷贝(Object Copy), 终止(Termination, 包括尝试次数).</li>
<li>还显示 “other” 执行时间, 比如选择 CSet, 引用处理(reference processing), 引用排队(reference enqueuing) 以及释放(freeing) CSet等.</li>
<li>显示 Eden, Survivors 以及总的 Heap 占用信息(occupancies).</li>
</ul>
<p><strong>日志输出示例</strong></p>
<pre><code><span class="list">[<span class="keyword">Ext</span> Root Scanning <span class="list">(<span class="keyword">ms</span>)</span>: Avg: <span class="number">1.7</span> Min: <span class="number">0.0</span> Max: <span class="number">3.7</span> Diff: <span class="number">3.7</span>]
<span class="list">[<span class="keyword">Eden:</span> <span class="number">818</span>M<span class="list">(<span class="keyword">818M</span>)</span>-&gt;0B<span class="list">(<span class="keyword">714M</span>)</span> Survivors: <span class="number">0</span>B-&gt;104M Heap: <span class="number">836</span>M<span class="list">(<span class="keyword">4096M</span>)</span>-&gt;409M<span class="list">(<span class="keyword">4096M</span>)</span>]</span></span>
</code></pre><p><strong>(3) -XX:+UnlockExperimentalVMOptions -XX:G1LogLevel=finest</strong> 设置日志级别为 <strong>最好</strong> <em>finest</em>. 和 finer 级别类似, 包含每个 worker 线程信息.</p>
<pre><code>[Ext Root Scanning (ms): <span class="number">2.1</span> <span class="number">2.4</span> <span class="number">2.0</span> <span class="number">0.0</span>
<span class="label">       Avg:</span> <span class="number">1.6</span> <span class="string">Min:</span> <span class="number">0.0</span> <span class="string">Max:</span> <span class="number">2.4</span> <span class="string">Diff:</span> <span class="number">2.3</span>]
   [Update RS (ms):  <span class="number">0.4</span>  <span class="number">0.2</span>  <span class="number">0.4</span>  <span class="number">0.0</span>
<span class="label">       Avg:</span> <span class="number">0.2</span> <span class="string">Min:</span> <span class="number">0.0</span> <span class="string">Max:</span> <span class="number">0.4</span> <span class="string">Diff:</span> <span class="number">0.4</span>]
       [Processed <span class="string">Buffers :</span> <span class="number">5</span> <span class="number">1</span> <span class="number">10</span> <span class="number">0</span>
<span class="label">       Sum:</span> <span class="number">16</span>, <span class="string">Avg:</span> <span class="number">4</span>, <span class="string">Min:</span> <span class="number">0</span>, <span class="string">Max:</span> <span class="number">10</span>, <span class="string">Diff:</span> <span class="number">10</span>]
</code></pre><h3 id="Determining_Time">Determining Time</h3><p>有两个参数决定了GC日志中打印的时间显示形式.</p>
<p><strong>(1) -XX:+PrintGCTimeStamps</strong> - 显示从JVM启动时算起的运行时间.</p>
<p><strong>日志输出示例</strong></p>
<pre><code>1<span class="class">.729</span>: <span class="attr_selector">[GC pause (young) 46M-&gt;35M(1332M), 0.0310029 secs]</span>
</code></pre><p><strong>(2) -XX:+PrintGCDateStamps</strong> - 在每条记录前加上日期时间.</p>
<p><strong>日志输出示例</strong></p>
<pre><code>2012<span class="tag">-05-02T11</span><span class="pseudo">:16</span><span class="pseudo">:32</span><span class="class">.057</span>+0200: <span class="attr_selector">[GC pause (young) 46M-&gt;35M(1332M), 0.0317225 secs]</span>
</code></pre><h3 id="理解_G1_日志">理解 G1 日志</h3><p>为了使你更好地理解GC日志, 本节通过实际的日志输出，定义了许多专业术语. 下面的例子显示了GC日志的内容,并加上日志中出现的术语和值的解释说明.</p>
<p><strong>Note:</strong> 更多信息请参考 <a href="https://blogs.oracle.com/poonam/entry/understanding_g1_gc_logs" target="_blank" rel="external">Poonam Bajaj的博客： G1垃圾回收日志</a>.</p>
<h3 id="G1_日志相关术语">G1 日志相关术语</h3><ul>
<li>Clear CT</li>
<li>CSet</li>
<li>External Root Scanning</li>
<li>Free CSet</li>
<li>GC Worker End</li>
<li>GC Worker Other</li>
<li>Object Copy</li>
<li>Other</li>
<li>Parallel Time</li>
<li>Ref Eng</li>
<li>Ref Proc</li>
<li>Scanning Remembered Sets</li>
<li>Termination Time</li>
<li>Update Remembered Set</li>
<li>Worker Start</li>
</ul>
<h4 id="Parallel_Time(并行阶段耗时)">Parallel Time(并行阶段耗时)</h4><pre><code><span class="number">414.557</span>: [GC pause (young), <span class="number">0.03039600</span> secs] [Parallel Time: 22.9 ms]
[GC Worker Start (ms): <span class="number">7096.0 70</span><span class="number">96.0 7096</span>.<span class="number">1 7096.1</span> <span class="number">706.1 70</span><span class="number">96.1 7096</span>.<span class="number">1 7096.1</span> <span class="number">7096.2 70</span><span class="number">96.2 7096</span>.<span class="number">2 7096.2</span>
   Avg: 7096.1, Min: 7096.0, Max: 7096.2, Diff: 0.2]
</code></pre><p><code>Parallel Time</code> – 主要并行部分运行停顿的整体时间</p>
<p><code>Worker Start</code>– 各个工作线程(workers)启动时的时间戳(Timestamp)</p>
<p><strong>Note: </strong>日志是根据 thread id 排序,并且每条记录都是一致的.</p>
<h4 id="External_Root_Scanning(外部根扫描)">External Root Scanning(外部根扫描)</h4><pre><code>[Ext Root Scanning (ms): <span class="number">3.1 3.4</span> <span class="number">3.4 3.0</span> <span class="number">4.2 2.0</span> <span class="number">3.6 3.2</span> <span class="number">3.4 7.7</span> <span class="number">3.7 4.4</span>
 Avg: 3.8, Min: 2.0, Max: 7.7, Diff: 5.7]
</code></pre><p><code>External root scanning</code> - 扫描外部根花费的时间(如指向堆内存的系统词典(system dictionary)等部分)</p>
<h4 id="Update_Remembered_Set(更新_RSet)">Update Remembered Set(更新 RSet)</h4><pre><code>[Update RS (ms): <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> Avg: <span class="number">0.0</span>, Min: <span class="number">0.0</span>, Max: <span class="number">0.1</span>, Diff: <span class="number">0.1</span>]
[Processed Buffers : <span class="number">26</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>
Sum: <span class="number">26</span>, Avg: <span class="number">2</span>, Min: <span class="number">0</span>, Max: <span class="number">26</span>, Diff: <span class="number">26</span>]
</code></pre><p><code>Update Remembered Set</code> - 必须更新在pause之前已经完成但尚未处理的缓冲. 花费的时间取决于cards的密度。cards越多,耗费的时间就越长。</p>
<h4 id="Scanning_Remembered_Sets(扫描_RSets)">Scanning Remembered Sets(扫描 RSets)</h4><pre><code>[Scan RS (ms): <span class="number">0.4 0.2</span> <span class="number">0.1 0.3</span> <span class="number">0.0 0.0</span> <span class="number">0.1 0.2</span> <span class="number">0.0 0.1</span> <span class="number">0.0 0.0</span> Avg: 0.1, Min: 0.0, Max: 0.4, Diff: 0.3]F
</code></pre><p><code>Scanning Remembered Sets</code> - 查找指向 Collection Set 的指针(pointers)</p>
<h4 id="Object_Copy(对象拷贝)">Object Copy(对象拷贝)</h4><pre><code>[Object Copy (ms): <span class="number">16.7 16.7</span> <span class="number">16.7 16.9</span> <span class="number">16.0 18.1</span> <span class="number">16.5 16.8</span> <span class="number">16.7 12.3</span> <span class="number">16.4 15.7</span> Avg: 16.3, Min: 12.3, Max:  18.1, Diff: 5.8]
</code></pre><p><code>Object copy</code> – 每个独立的线程在拷贝和转移对象时所消耗的时间.</p>
<h4 id="Termination_Time(结束时间)">Termination Time(结束时间)</h4><pre><code>[Termination (ms): <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span>
<span class="number">0.0</span> Avg: <span class="number">0.0</span>, Min: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>] [Termination Attempts : <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> Sum: <span class="number">12</span>, Avg: <span class="number">1</span>, Min: <span class="number">1</span>, Max: <span class="number">1</span>, Diff: <span class="number">0</span>]
</code></pre><p><code>Termination time</code> - 当worker线程完成了自己那部分对象的复制和扫描,就进入终止协议(termination protocol)。它查找未完成的工作(looks for work to steal), 一旦它完成就会再进入终止协议。 终止尝试记录(Termination attempt counts)所有查找工作的尝试次数(attempts to steal work).</p>
<h4 id="GC_Worker_End">GC Worker End</h4><pre><code>[GC Worker End (ms): <span class="number">7116.4 71</span><span class="number">16.3 7116</span>.<span class="number">4 7116.3</span> <span class="number">7116.4 71</span><span class="number">16.3 7116</span>.<span class="number">4 7116.4</span> <span class="number">7116.4 71</span><span class="number">16.4 7116</span>.<span class="number">3 7116.3</span>
Avg: 7116.4, Min: 7116.3, Max: 7116.4, Diff:   0.1]
[GC Worker (ms): <span class="number">20.4 20.3</span> <span class="number">20.3 20.2</span> <span class="number">20.3 20.2</span> <span class="number">20.2 20.2</span> <span class="number">20.3 20.2</span> <span class="number">20.1 20.1</span>
 Avg: 20.2, Min: 20.1, Max: 20.4, Diff: 0.3]
</code></pre><p><code>GC worker end time</code> – 独立的 GC worker 停止时的时间戳.</p>
<p><code>GC worker time</code> – 每个独立的 GC worker 线程消耗的时间.</p>
<h4 id="GC_Worker_Other">GC Worker Other</h4><pre><code>[GC Worker Other (ms): <span class="number">2.6 2.6</span> <span class="number">2.7 2.7</span> <span class="number">2.7 2.7</span> <span class="number">2.7 2.8</span> <span class="number">2.8 2.8</span> <span class="number">2.8 2.8</span>
Avg: 2.7, Min: 2.6, Max: 2.8, Diff: 0.2]
</code></pre><p><code>GC worker other</code> – 每个GC线程中不能归属到之前列出的worker阶段的其他时间. 这个值应该很低. 过去我们见过很高的值,是由于JVM的其他部分的瓶颈引起的(例如在分层[Tiered]代码缓存[Code Cache]占有率的增加)。</p>
<h4 id="Clear_CT">Clear CT</h4><pre><code>[Clear CT: <span class="number">0.6</span> ms]
</code></pre><p>清除 RSet 扫描元数据(scanning meta-data)的 card table 消耗的时间.</p>
<h4 id="Other">Other</h4><pre><code>[Other: <span class="number">6.8</span> ms]
</code></pre><p>其他各种GC暂停的连续阶段花费的时间.</p>
<h4 id="CSet">CSet</h4><pre><code>[Choose CSet: <span class="number">0.1</span> ms]
</code></pre><p>敲定要进行垃圾回收的region集合时消耗的时间. 通常很小,在必须选择 old 区时会稍微长一点点.</p>
<h4 id="Ref_Proc">Ref Proc</h4><pre><code>[Ref Proc: <span class="number">4.4</span> ms]
</code></pre><p>处理 soft, weak, 等引用所花费的时间,不同于前面的GC阶段</p>
<h4 id="Ref_Enq">Ref Enq</h4><pre><code>[Ref Enq: <span class="number">0.1</span> ms]
</code></pre><p>将 soft, weak, 等引用放置到待处理列表(pending list)花费的时间.</p>
<h4 id="Free_CSet">Free CSet</h4><pre><code>[Free CSet: <span class="number">2.0</span> ms]
</code></pre><p>释放刚被垃圾收集的 heap区所消耗的时间,包括对应的remembered sets。</p>
<h2 id="总结">总结</h2><p>在此OBE中, 您对Java JVM 中的G1垃圾收集器有了个大致的了解。首先你学到了为何堆和垃圾收集器是所有Java JVM的关键部分。接下来讲述了使用CMS和G1收集器进行垃圾回收的工作方式. 接下来,您了解了G1的命令行参数/开关以及和使用它们的最佳实践。最后,您了解了日志对象以及GC日志中的数据。</p>
<p>在本教程中,你学到了这些知识:</p>
<ul>
<li>Java JVM 的组成部分</li>
<li>对 G1 的概述</li>
<li>概述 CMS 垃圾收集器</li>
<li>概述 G1 垃圾收集器</li>
<li>命令行参数与最佳实践</li>
<li>G1 的日志信息</li>
</ul>
<h2 id="相关资源">相关资源</h2><p>更多相关信息请参考以下网站链接.</p>
<p><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="external">HotSpot 虚拟机参数</a><br><a href="http://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html" target="_blank" rel="external">G1(垃圾优先)收集器</a><br><a href="https://blogs.oracle.com/poonam/entry/understanding_g1_gc_logs" target="_blank" rel="external">Poonam Bajaj的博客： G1垃圾回收日志</a><br><a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=609&amp;p_org_id=1001&amp;lang=US&amp;get_params=dc:D67232GC10,p_preview:N" target="_blank" rel="external">Java SE 7: 开发富客户端应用程序</a><br><a href="http://www.amazon.cn/gp/product/B00IOB0K1Q" target="_blank" rel="external">Java性能优化权威指南 - 中文版</a><br><a href="http://www.oracle.com/oll" target="_blank" rel="external">Oracle 学习资料库</a>  </p>
<h2 id="作者信息">作者信息</h2><ul>
<li>课程开发人员: Michael J Williams</li>
<li>质量保证: Krishnanjani Chitta</li>
<li>翻译人员: <a href="http://blog.csdn.net/renfufei" target="_blank" rel="external">铁锚 http://blog.csdn.net/renfufei</a></li>
<li>参考: <a href="http://www.infoq.com/cn/news/2008/05/g1" target="_blank" rel="external">JavaOne: Garbage First</a></li>
<li>这里有一群纯技术Java程序员: <a href="http://jq.qq.com/?_wv=1027&amp;k=cXLDjh" target="_blank" rel="external">欢迎大牛和爱好者加入【Java高级交流群: 329019348】
</a></li>
<li>原文链接: <a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="external">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html</a></li>
</ul>
<hr>
<p>转帖地址:<a href="http://blog.csdn.net/renfufei/article/details/41897113" target="_blank" rel="external">http://blog.csdn.net/renfufei/article/details/41897113</a></p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章非常详细的介绍了G1垃圾收集器的相关知识]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="JVM" scheme="http://sunxiang0918.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>如何在Git中撤销一切]]></title>
    <link href="http://sunxiang0918.github.io/2015/06/24/%E5%A6%82%E4%BD%95%E5%9C%A8Git%E4%B8%AD%E6%92%A4%E9%94%80%E4%B8%80%E5%88%87/"/>
    <id>http://sunxiang0918.github.io/2015/06/24/如何在Git中撤销一切/</id>
    <published>2015-06-24T12:23:29.000Z</published>
    <updated>2015-07-28T01:52:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何在Git中撤销一切">如何在Git中撤销一切</h1><p>翻译：李伟<br>审校：张帆<br>译自：<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">Github</a></p>
<p><img src="https://jf-bucket-public.oss-cn-qingdao.aliyuncs.com/jfperiodical/attached/image/20150612/2016242594.png" alt=""></p>
<p>任何一个版本控制系统中，最有用的特性之一莫过于 “撤销（undo）”操作。在Git中，“撤销”有很多种含义。<br>当你完成了一次新的提交（commit），Git会及时存储当前时刻仓库（repository）的快照（snapshot）；你能够使用Git将项目回退到任何之前的版本。<br>下文中，我将列举几个常见的、需要“撤销”的场景，并且展示如何使用Git来完成这些操作。</p>
<h3 id="一、撤销一个公共修改_Undo_a_“public”_change">一、撤销一个公共修改 Undo a “public” change</h3><p><strong>场景：</strong>你刚刚用git push将本地修改推送到了GitHub，这时你意识到在提交中有一个错误。你想撤销这次提交。</p>
<p><strong>使用撤销命令：</strong><code>git revert</code></p>
<p><strong>发生了什么：</strong>git revert将根据给定SHA的相反值，创建一个新的提交。如果旧提交是“matter”，那么新的提交就是“anti-matter”——旧提交中所有已移除的东西将会被添加进到新提交中，旧提交中增加的东西将在新提交中移除。</p>
<p>这是Git最安全、也是最简单的“撤销”场景，因为这样不会修改历史记录——你现在可以git push下刚刚revert之后的提交来纠正错误了。</p>
<a id="more"></a>
<h3 id="二、修改最近一次的提交信息_Fix_the_last_commit_message">二、修改最近一次的提交信息 Fix the last commit message</h3><p><strong>场景：</strong>你只是在最后的提交信息中敲错了字，比如你敲了git commit -m “Fxies bug #42”，而在执行git push之前你已经意识到你应该敲”Fixes bug #42”。</p>
<p><strong>使用撤销命令：</strong><code>git commit –amend或git commit --amend -m &quot;Fixes bug #42&quot;</code></p>
<p><strong>发生了什么：</strong>git commit –amend将使用一个包含了刚刚错误提交所有变更的新提交，来更新并替换这个错误提交。由于没有staged的提交，所以实际上这个提交只是重写了先前的提交信息。</p>
<h3 id="三、撤销本地更改_Undo_“local”_changes">三、撤销本地更改 Undo “local” changes</h3><p><strong>场景：</strong>当你的猫爬过键盘时，你正在编辑的文件恰好被保存了，你的编辑器也恰在此时崩溃了。此时你并没有提交过代码。你期望撤销这个文件中的所有修改——将这个文件回退到上次提交的状态。</p>
<p><strong>使用撤销命令：</strong><code>git checkout --</code></p>
<p><strong>发生了什么：</strong>git checkout将工作目录（working directory）里的文件修改成先前Git已知的状态。你可以提供一个期待回退分支的名字或者一个确切的SHA码，Git也会默认检出HEAD——即：当前分支的上一次提交。</p>
<p><strong>注意：</strong>用这种方法“撤销”的修改都将真正的消失。它们永远不会被提交。因此Git不能恢复它们。此时，一定要明确自己在做什么！（或许可以用git diff来确定）</p>
<h3 id="四、重置本地修改_Reset_“local”_changes">四、重置本地修改 Reset “local” changes</h3><p><strong>场景：</strong>你已经在本地做了一些提交（还没push），但所有的东西都糟糕透了，你想撤销最近的三次提交——就像它们从没发生过一样。<br><strong>使用撤销命令：</strong><code>git reset或git reset --hard</code><br><strong>发生了什么：</strong>git reset将你的仓库纪录一直回退到指定的最后一个SHA代表的提交，那些提交就像从未发生过一样。默认情况下，git reset会保留工作目录（working directory）。这些提交虽然消失了，但是内容还在磁盘上。这是最安全的做法，但通常情况是：你想使用一个命令来“撤销”所有提交和本地修改——那么请使用—hard参数吧。</p>
<h3 id="五、撤销本地后重做_Redo_after_undo_“local”">五、撤销本地后重做 Redo after undo “local”</h3><p><strong>场景：</strong>你已经提交了一些内容，并使用git reset –hard撤销了这些更改（见上面），突然意识到：你想还原这些修改！<br><strong>使用撤销命令：</strong><code>git reflog和git reset, 或者git checkout</code><br><strong>发生了什么：</strong>git reflog是一个用来恢复项目历史记录的好办法。你可以通过git reflog恢复几乎任何已提交的内容。<br>你或许对git log命令比较熟悉，它能显示提交列表。git reflog与之类似，只不过git reflog显示的是HEAD变更次数的列表。</p>
<h3 id="一些说明：">一些说明：</h3><ol>
<li>只有HEAD会改变。当你切换分支时，用git commit提交变更时，或是用git reset撤销提交时，HEAD都会改变。但当你用git checkout —时， HEAD不会发生改变。（就像上文提到的情形，那些更改根本就没有提交，因此reflog就不能帮助我们进行恢复了）</li>
<li>git reflog不会永远存在。Git将会定期清理那些“不可达（unreachable）”的对象。不要期望能够在reflog里找到数月前的提交记录。</li>
<li>reflog只是你个人的。你不能用你的reflog来恢复其他开发者未push的提交。  </li>
</ol>
<p><img src="/img/2015/06/24/1.png" alt="">  </p>
<p>因此，怎样合理使用reflog来找回之前“未完成”的提交呢？这要看你究竟要做什么：  </p>
<ol>
<li>如果你想恢复项目历史到某次提交，那请使用git reset —hard</li>
<li>如果你想在工作目录（working direcotry）中恢复某次提交中的一个或多个文件，并且不改变提交历史，那请使用git checkout—</li>
<li>如果你想确切的回滚到某次提交，那么请使用git cherry-pick。</li>
</ol>
<h3 id="六、与分支有关的那些事_Once_more,_with_branching">六、与分支有关的那些事 Once more, with branching</h3><p><strong>场景：</strong>你提交了一些变更，然后你意识到你正在master分支上，但你期望的是在feature分支上执行这些提交。<br><strong>使用撤销命令：</strong><code>git branch feature, git reset --hard origin/master, 和 git checkout feature</code><br><strong>发生了什么：</strong>你可能用的是git checkout -b来建立新的分支，这是创建和检出分支的便捷方法——但实际你并不想立刻切换分支。git branch feature会建立一个叫feature的分支，这个分支指向你最近的提交，但是你还停留在master分支上。<br>git reset —hard将master回退至origin/master，并忽略所有新提交。别担心，那些提交都还保留在feature上。<br>最后，git checkout将分支切换到feature，这个分支原封不动的保留了你最近的所有工作。</p>
<h3 id="七、事半功倍处理分支_Branch_in_time_saves_nine">七、事半功倍处理分支 Branch in time saves nine</h3><p><strong>场景：</strong>你基于master新建了一个feature分支，但是master分支远远落后与origin/master。现在master分支与origin/master同步了，你期望此刻能在feature下立刻commit代码，并且不是在远远落后master的情况下。<br><strong>使用撤销命令：</strong><code>git checkout feature和git rebase master</code><br><strong>发生了什么：</strong>你也许已经敲了命令：git reset（但是没用—hard,有意在磁盘上保存这些提交内容），然后敲了git checkout -b，之后重新提交更改，但是那样的话，你将失去本地的提交记录。不过，一个更好的方法：</p>
<p><strong>使用git rebase master可以做到一些事情：</strong></p>
<ol>
<li>首先，它定位你当前检出分支和master之间的共同祖先节点（common ancestor）。</li>
<li>然后，它将当前检出的分支重置到祖先节点（ancestor），并将后来所有的提交都暂存起来。</li>
<li>最后，它将当前检出分支推进至master末尾，同时在master最后一次提交之后，再次提交那些在暂存区的变更。</li>
</ol>
<h3 id="八、批量撤销/找回_Mass_undo/redo">八、批量撤销/找回 Mass undo/redo</h3><p><strong>场景：</strong>你开始朝一个既定目标开发功能，但是中途你感觉用另一个方法更好。你已经有十几个提交，但是你只想要其中的某几个，其他的都可以删除不要。<br><strong>使用撤销命令：</strong><code>git rebase -i</code><br><strong>发生了什么：</strong>-i将rebases设置为“交互模式（interactive mode）”。rebase开始执行的操作就像上文讨论的一样，但是在重新执行某个提交时，它会暂停下来，让你修改每一次提交。<br>rebase –i将会打开你的默认文本编辑器，然后列出正在执行的提交，就像这样：<br><img src="/img/2015/06/24/2.png" alt=""><br>前两列最关键：第一列是选择命令，它会根据第二列中的SHA码选择相应的提交。默认情况下，rebase –i会认为每个更改都正通过pick命令被提交。<br>要撤销一个提交，直接在编辑器删除对应的行就可以了。如果在你的项目不再需要这些错误的提交，你可以直接删除上图中的第1行和3-4行。<br>如果你想保留提交但修改提交信息，你可以使用reword命令。即，将命令关键字pick换成reword（或者r）。你现在可能想立刻修改提交消息，但这么做不会生效——rebase –i将忽略SHA列后的所有东西。现有的提交信息会帮助我们记住0835fe2代表什么。当你敲完rebase –i命令后，Git才开始提示你重写那些新提交消息。<br>如果你需要将2个提交合并，你可以用squash或者fixup命令，如下图：<br><img src="/img/2015/06/24/3.png" alt=""><br>squash和fixup都是“向上”结合的——那些用了这些合并命令（编者按：指squash、fixup）的提交，将会和它之前的提交合并：上图中，0835fe2和6943e85将会合并成一个提交，而38f5e4e和af67f82将会合并成另一个提交。<br>当你用squash时，Git将会提示是否填写新的提交消息；fixup则会给出列表中第一个提交的提交信息。在上图中，af67f82是一个“Ooops”信息，因为这个提交信息已经同38f5e4e一样了。但是你可以为0835fe2和6943e85合并的新提交编写提交信息。<br>当你保存并退出编辑器时，Git将会按照从上到下的顺序执行你的提交。你可以在保存这些提交之前，修改提交的执行顺序。如果有需要，你可以将af67f82和0835fe2合并，并且可以这样排序：<br><img src="/img/2015/06/24/4.png" alt="">  </p>
<h3 id="九、修复早先的提交_Fix_an_earlier_commit">九、修复早先的提交 Fix an earlier commit</h3><p><strong>场景：</strong>之前的提交里落下了一个文件，如果先前的提交能有你留下的东西就好了。你还没有push，并且这个提交也不是最近的提交，因此你不能用commit –amend。<br><strong>使用撤销命令：</strong><code>git commit --squash和git rebase --autosquash -i</code><br><strong>发生了什么：</strong>git commit –squash将会创建一个新的提交，该提交信息可能像这样“squash! Earlier commit”。（你也可以手写这些提交信息，commit –squash只是省得让你打字了）。<br>如果你不想为合并的提交编写信息，也可以考虑使用命令git commit —fixup。这种情况下，你可能会使用commit —fixup，因为你仅希望在rebase中使用之前的提交信息。<br>rebase —autosquash –i将会启动rebase交互编辑器，编辑器会列出任何已完成的squash!和fixup!提交，如下图：<br><img src="/img/2015/06/24/5.png" alt=""><br>当使用—squash和–fixup时，你或许记不清你想修复的某个提交的SHA码——只知道它可能在一个或五个提交之前。你或许可以使用Git的^和~操作符手动找回。HEAD^表示HEAD的前一次提交。HEAD~4表示HEAD前的4次提交，加起来总共是前5次提交。</p>
<h3 id="十、停止跟踪一个已被跟踪的文件_Stop_tracking_a_tracked_file">十、停止跟踪一个已被跟踪的文件 Stop tracking a tracked file</h3><p><strong>场景：</strong>你意外将application.log添加到仓库中，现在你每次运行程序，Git都提示application.log中有unstaged的提交。你在.gitignore中写上”<em>.log”，但仍旧没用——怎样告诉Git“撤销”跟踪这个文件的变化呢？<br><strong>使用撤销命令：</strong> git rm —cached application.log<br><em>*发生了什么：</em></em>尽管.gitignore阻止Git跟踪文件的变化，甚至是之前没被跟踪的文件是否存在，但是，一旦文件被add或者commit，Git会开始持续跟踪这个文件的变化。类似的，如果你用git add –f来“强制”add，或者覆盖.gitignore，Git还是会继续监视变化。所以以后最好不要使用–f来add .gitignore文件。<br>如果你希望移除那些应当被忽略的文件，git rm –cached可以帮助你，并将这些文件保留在磁盘上。因为这个文件现在被忽略了，你将不会在git status中看到它，也不会再把这个文件commit了。<br>以上就是如何在Git上撤销的方法。如果你想学习更多Git命令用法，可以移步下面相关的文档：<br>· <a href="http://git-scm.com/docs/git-checkout" target="_blank" rel="external">checkout</a><br>· <a href="http://git-scm.com/docs/git-commit" target="_blank" rel="external">commit</a><br>· <a href="http://git-scm.com/docs/git-rebase" target="_blank" rel="external">rebase</a><br>· <a href="http://git-scm.com/docs/git-reflog" target="_blank" rel="external">reflog</a><br>· <a href="http://git-scm.com/docs/git-reset" target="_blank" rel="external">reset</a><br>· <a href="http://git-scm.com/docs/git-revert" target="_blank" rel="external">revert</a><br>· <a href="http://git-scm.com/docs/git-rm" target="_blank" rel="external">rm</a></p>
<p>原文地址：<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">Github</a><br>译文地址：<a href="http://www.jointforce.com/jfperiodical/article/show/796?m=d03" target="_blank" rel="external">http://www.jointforce.com/jfperiodical/article/show/796?m=d03</a></p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章非常详细的介绍了GIT中撤销提交的相关知识]]>
    
    </summary>
    
      <category term="GIT" scheme="http://sunxiang0918.github.io/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[zookeeper 集群部署]]></title>
    <link href="http://sunxiang0918.github.io/2014/09/20/zookeeper-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2014/09/20/zookeeper-集群部署/</id>
    <published>2014-09-20T11:55:15.000Z</published>
    <updated>2015-07-29T12:44:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="zookeeper_集群部署">zookeeper 集群部署</h1><p>在现在的软件系统中,通常都会搭建集群或者分布式环境了.而在这种情况下,通常都需要一个分布式程序协调者的服务.这最常用的就是zookeeper了.<br>在我们的系统中,会使用zookeeper来做<code>统一的配置管理</code>,集群<code>节点状态管理</code>,以及<code>分布式锁</code>的功能.<br>为了保证zookeeper本身的高可用性,那么这就需要对ZK进行集群.</p>
<h2 id="安装环境">安装环境</h2><p>操作系统:Ubuntu 12.04 64位<br>JDK:1.7.0_55 64位<br>机器: <code>192.168.1.100</code> <code>192.168.1.101</code>  <code>192.168.1.101</code></p>
<h2 id="安装步骤">安装步骤</h2><a id="more"></a>
<h3 id="1-_下载Zookeeper">1. 下载Zookeeper</h3><p>直接到他的官网上下载最新的zookeeper软件: <a href="http://zookeeper.apache.org/releases.html#download" target="_blank" rel="external">http://zookeeper.apache.org/releases.html#download</a></p>
<p><img src="/img/2014/09/20/1.png" alt=""></p>
<h3 id="2-_上传Zookeeper安装包到服务器">2. 上传Zookeeper安装包到服务器</h3><p>这个随便使用什么东西上传都可以, <code>sft</code> <code>scp</code> 等等</p>
<h3 id="3-_为Zookeeper创建目录-">3. 为Zookeeper创建目录.</h3><p>在bash中创建文件夹. 我把目录建到 /usr/local/下的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /usr/<span class="built_in">local</span>/zookeeper</span><br></pre></td></tr></table></figure>
<h3 id="4-_解压安装包到zk的目录">4. 解压安装包到zk的目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar –xzvf zookeeper-<span class="number">3.4</span>.<span class="number">6</span>.tar.gz /usr/<span class="built_in">local</span>/zookeeper</span><br></pre></td></tr></table></figure>
<h3 id="5-_再创建几个ZK必要的文件夹">5. 再创建几个ZK必要的文件夹</h3><p>ZK还需要创建几个运行时必要的文件夹: 一个用来存放数据<code>data</code>,一个用来存放数据日志的<code>datalog</code>,以及一个存放ZK运行时日志的目录<code>logs</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /usr/<span class="built_in">local</span>/zookeeper/data</span><br><span class="line">$ mkdir /usr/<span class="built_in">local</span>/zookeeper/datalog</span><br><span class="line">$ mkdir /usr/<span class="built_in">local</span>/zookeeper/logs</span><br></pre></td></tr></table></figure>
<h3 id="6-_在data目录中创建一个myid文件">6. 在data目录中创建一个myid文件</h3><p>这个文件主要是用于标示自己是哪一个服务器的.文件的内容很简单,里面就是一个数字.<br>比如自己的server1,那么里面就写一个<code>1</code>.如果是server2,那么里面就写一个<code>2</code>.</p>
<h3 id="7-_配置ZK的配置文件zoo-cfg">7. 配置ZK的配置文件zoo.cfg</h3><p>接下来进入zk的conf目录.这个目录中应该有一个<code>zoo_sample.cfg</code>的文件.拷贝这个文件,并重命名为<code>zoo.cfg</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<h3 id="8-_修改zoo-cfg文件的内容">8. 修改zoo.cfg文件的内容</h3><p>配置的内容如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line">initLimit=<span class="number">10</span></span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line">syncLimit=<span class="number">5</span></span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line">dataDir=/usr/<span class="built_in">local</span>/zookeeper/data</span><br><span class="line">dataLogDir=/usr/<span class="built_in">local</span>/zookeeper/datalog</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line">clientPort=<span class="number">2181</span></span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to "0" to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"></span><br><span class="line">minSessionTimeout=<span class="number">1000</span></span><br><span class="line">maxSessionTimeout=<span class="number">1500</span></span><br><span class="line"></span><br><span class="line">server.<span class="number">1</span>=<span class="number">192.168</span>.<span class="number">1.100</span>:<span class="number">2888</span>:<span class="number">3888</span>  </span><br><span class="line">server.<span class="number">2</span>=<span class="number">192.168</span>.<span class="number">1.101</span>:<span class="number">2888</span>:<span class="number">3888</span>  </span><br><span class="line">server.<span class="number">3</span>=<span class="number">192.168</span>.<span class="number">1.102</span>:<span class="number">2888</span>:<span class="number">3888</span></span><br></pre></td></tr></table></figure>
<p><strong>参数说明:</strong><br><code>tickTime</code>：zookeeper中使用的基本时间单位, 毫秒值.</p>
<p><code>initLimit</code>: zookeeper集群中的包含多台server, 其中一台为leader, 集群中其余的server为follower。 initLimit参数配置初始化连接时, follower和leader之间的最长心跳时间. 此时该参数设置为5, 说明时间限制为5倍tickTime, 即5*2000=10000ms=10s.</p>
<p><code>syncLimit</code>: 该参数配置leader和follower之间发送消息, 请求和应答的最大时间长度. 此时该参数设置为2, 说明时间限制为2倍tickTime, 即4000ms.</p>
<p><code>dataDir</code>: 数据存放目录. 可以是任意目录.但是我喜欢这么干</p>
<p><code>dataLogDir</code>: log目录, 同样可以是任意目录. 如果没有设置该参数, 将使用和dataDir相同的设置</p>
<p><code>clientPort</code>: 监听client连接的端口号.</p>
<p><code>server.X=A:B:C</code>: 其中X是一个数字, 表示这是第几号server. A是该server所在的IP地址. B配置该server和集群中的leader交换消息所使用的端口. C配置选举leader时所使用的端口.</p>
<p><code>minSessionTimeout</code>: 最小的会话超时时间,这两个参数可以适当的调低一点,否则如果一个临时状态节点挂掉以后,会有很长时间才会在ZK中体现出来.</p>
<p><code>maxSessionTimeout</code>: 最大的会话超时时间</p>
<h3 id="9-_启动Zookeeper">9. 启动Zookeeper</h3><p>配置到这里就完了.其实ZK的集群配置非常的简单.<br>启动也非常的简单.直接在命令行中调用:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./zkServer.sh start</span><br></pre></td></tr></table></figure>
<p>第一台机器启动的时候可能会报异常,这是正常的.他启动后会尝试连接其他的两台机器.但是由于其他两台还没启动起来,所以会报错. 启动了就好了.</p>
<p>PS: 需要注意的是,ZK集群提供了过半存活的能力.也就是说2n+1台机器环境下的ZK集群.最多允许n个节点挂掉.超过了就无法选举出leader了.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="zookeeper_集群部署">zookeeper 集群部署</h1><p>在现在的软件系统中,通常都会搭建集群或者分布式环境了.而在这种情况下,通常都需要一个分布式程序协调者的服务.这最常用的就是zookeeper了.<br>在我们的系统中,会使用zookeeper来做<code>统一的配置管理</code>,集群<code>节点状态管理</code>,以及<code>分布式锁</code>的功能.<br>为了保证zookeeper本身的高可用性,那么这就需要对ZK进行集群.</p>
<h2 id="安装环境">安装环境</h2><p>操作系统:Ubuntu 12.04 64位<br>JDK:1.7.0_55 64位<br>机器: <code>192.168.1.100</code> <code>192.168.1.101</code>  <code>192.168.1.101</code></p>
<h2 id="安装步骤">安装步骤</h2>]]>
    
    </summary>
    
      <category term="Zookeeper" scheme="http://sunxiang0918.github.io/tags/Zookeeper/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析]]></title>
    <link href="http://sunxiang0918.github.io/2014/07/28/DB2%E4%B8%8B%E4%BD%BF%E7%94%A8Hibernate%E8%87%AA%E5%8A%A8%E9%87%8D%E5%BB%BA%E8%A1%A8%E5%AF%BC%E8%87%B4%E6%95%B4%E4%B8%AADB2%E5%8D%A1%E4%BD%8F%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://sunxiang0918.github.io/2014/07/28/DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析/</id>
    <published>2014-07-28T01:51:28.000Z</published>
    <updated>2015-07-28T02:29:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析">DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析</h1><h2 id="问题现象:">问题现象:</h2><p>今天在做高级检索的时候,当用户在界面配置了高级检索的字段后,需要程序自动的把AI3_ADVANCEDSEARCH表删除后,重建.本来这个功能在XDA和xSpace上是能正常工作的.<br>这两个系统所使用的数据库是 MYSQL和ORACLE.一切正常.  现在TVBS使用的是DB2. 在做测试的时候发现.<strong>每当重建表的时候,整个重建的线程都卡住了</strong>.同时,<strong>使用DB2的SQL管理工具,对任意的表进行修改/删除/新建,都会卡住</strong>.这肯定是有问题的.</p>
<h2 id="原因分析过程:">原因分析过程:</h2><ol>
<li>最开始就怀疑是hibernate和DB2的配合的问题,于是打断点.一路跟踪到它卡住的地方.<br><img src="/img/2014/07/28/1.png" alt=""><br>就是这里,调用JDBC的statement.executeUpdate就会卡住. 这句是标准的JDBC的代码.其中statement的实例是DB2的驱动中的对象,于是<span style="background:yellow">怀疑是DB2的驱动问题</span>.于是从网上重新找驱动.<a id="more"></a></li>
<li><p>DB2的驱动是个锤子,官网上根本下不到.需要验证码,验证码IBM又不发给我们.于是只能大海捞针的到处找.终于找到了DB2 9.5的驱动.<span style="background:red">于是换上新的驱动,继续测试. 结果依旧.</span>问题没有解决.看来不是驱动的问题.</p>
</li>
<li><p>换一种思路.写了一段小的JDBC程序来执行创建表的操作:<br><img src="/img/2014/07/28/2.png" alt=""><br>这样操作又能成功. 于是对比分析两次执行的差别.<span style="background:yellow">发现  statement对象的类型不同</span>.<br> 简单的JDBC使用的是 db2驱动中的类<code>com.ibm.db2.jcc.am.tm.</code>而MAMSpace中使用的是JBOSS封装过的类<code>org.jboss.resource.adapter.jdbc.WrappedStatement</code><br> 于是<span style="background:yellow">怀疑是JBOSS的JNDI数据库连接池的问题.</span></p>
</li>
<li><p>马上<span style="background:yellow">更换我们dcmp使用的连接池.</span>不是用JBOSS的JNDI数据库连接池.然后再次进行测试.<br> <span style="background:red">结果……问题依旧…..</span></p>
</li>
<li><p>重启DB2….再次把小程序和MAMSpace都断点到同一位置.然后<span style="background:yellow">开始怀疑是否是事务等问题.</span>于是分析两个statment对象中属性的不同. 但是….一个驱动.居然混淆了的.<br><img src="/img/2014/07/28/3.png" alt=""><br>它所有的字段,属性全部都是 a b c d 的命名.<span style="background:red">大致对比了一下.还是没发现问题.</span></p>
</li>
<li><p>无耐.只有重新再来.经过五六次的不断断点,不断重启DB2. <strong>发现一个很怪异的现象</strong>.<br> 就是 每次卡住以后,只有重启DB2才能恢复 DB2对数据表的DDL功能.<br>并且,<span style="background:yellow">重启后,会发现其实这个时候DB2已经把 AI3_ADVANCEDSEARCH表建出来了. 但是缺少一个字段.</span><br> 建表语句:</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"AI3_ADVANCESEARCH"</span> (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),rEvtl <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID))</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>卡住重启后,建出来的表:   
![](/img/2014/07/28/4.png)  
注意,与建表语句相比,差了 rEvtl字段.  于是<span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"background:yellow"</span>&gt;</span>开始怀疑是否是这个字段有问题.<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><p>7.再一次重启DB2和DCMP,并断点到执行建表语句的位置. 这次直接把内存中的SQL语句给更改了.改成:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"AI3_ADVANCESEARCH"</span> (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID))</span></span><br></pre></td></tr></table></figure>
<p>也就是去掉rEvtl字段,只建4个基本字段.<br><span style="background:green">果然这次程序没有被卡住.</span><br>于是,马上回跳程序.<span style="background:yellow">在不重启服务器和DB2的情况下</span>,执行有rEvtl字段的建表语句.也就是会被卡住的DDL. <span style="background:green">结果执行成功.并没有被卡住…..</span>  无语了.只能<span style="background:yellow">怀疑是DB2的内部处理中有甚么特殊的地方.</span></p>
<ol>
<li>再一次重启DB2和DCMP.这次直接把内存中SQL语句给更改成:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"AI3_ADVANCESEARCH"</span> (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),NHNXL <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID))</span></span><br></pre></td></tr></table></figure>
<p>也就是第5个字段改成大写.<span style="background:red">测试结果还是失败</span>…看来<span style="background:yellow">不是字段大小写的问题.</span></p>
<ol>
<li>再一次重启DB2和DCMP.这次直接把内存中SQL语句中第五个字段的字段类型改成bigint.:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">"AI3_ADVANCESEARCH"</span> (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),OSEBi <span class="built_in">bigint</span>,<span class="keyword">primary</span> <span class="keyword">key</span> (ID))</span></span><br></pre></td></tr></table></figure>
<p><span style="background:red">测试结果再次失败</span>….看来<span style="background:yellow">不是字段类型的问题.</span></p>
<ol>
<li>再一次重启DB2和DCMP.这次直接把内存中SQL语句改成:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> AI3_ADVANCESEARCH (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,ENTITYTYPE <span class="built_in">varchar</span>(<span class="number">255</span>),ENldl <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID)) <span class="keyword">IN</span> TBL_SMAM <span class="keyword">INDEX</span> <span class="keyword">IN</span> IDX_SMAM</span></span><br></pre></td></tr></table></figure>
<p>也就是把表名的双引号去掉.增加上表空间. <span style="background:red">测试结果依然失败</span>…..看来<span style="background:yellow">不是表名和表空间的问题.</span></p>
<ol>
<li>再一次重启DB2和DCMP.这次直接把内存中SQL语句改成:</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> AI3_ADVANCESEARCH (ID <span class="built_in">bigint</span> <span class="keyword">not</span> <span class="literal">null</span>,ENTITYCONTENTID <span class="built_in">varchar</span>(<span class="number">255</span>),ENTITYID <span class="built_in">bigint</span>,QMwQH <span class="built_in">varchar</span>(<span class="number">255</span>),<span class="keyword">primary</span> <span class="keyword">key</span> (ID)) <span class="keyword">IN</span> TBL_SMAM <span class="keyword">INDEX</span> <span class="keyword">IN</span> IDX_SMAM</span></span><br></pre></td></tr></table></figure>
<p>也就是把ENTITYTYPE这个字段删掉,<span style="background:red">测试结果还是不行</span>….</p>
<ol>
<li><p>转变一下思路, 先在SQL管理器中把表删除了. 然后再在程序里面创建表.<span style="background:green">就OK了.</span><br>转变一下,由此可见,<span style="background:yellow">问题并不在于Create表的地方.应该是drop表出的问题.</span></p>
</li>
<li><p>既然出在drop表的地方.那么我在这个地方是不是可以不调用drop表喃?于是写了一段存储过程.</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> <span class="string">"MAMDBA"</span>.<span class="string">"DROPADVANCESEARCH"</span>()</span><br><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line">SPECIFIC DROPADAVANCESEARCH</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">IF</span> <span class="keyword">EXISTS</span> (<span class="keyword">select</span> * <span class="keyword">from</span> sysibm.systables <span class="keyword">where</span> TID &lt;&gt; <span class="number">0</span> <span class="keyword">and</span> name = <span class="string">'AI3_ADVANCESEARCH'</span> ) <span class="keyword">then</span></span><br><span class="line">		<span class="keyword">drop</span> <span class="keyword">table</span> AI3_ADVANCESEARCH;</span></span><br><span class="line">	<span class="operator"><span class="keyword">END</span> <span class="keyword">IF</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">END</span></span></span><br></pre></td></tr></table></figure>
<p>然后在调用删除的地方直接调用存储过程来进行删除: “call dropadvancesearch()”.    <span style="background:red">测试结果还是不得行.</span></p>
<ol>
<li>再一次的对比了一下成功的情况. 发现<span style="background:yellow">如果drop表的语句是通过hibernate执行的,那么,虽然在SQL管理器中看到表确实是删除了,日志中事务确实是提交了.但是再次建表的时候如果新建的表结构与被删除的表表结构不同,DB2就会被卡住.</span> 重启DB2后,被删除的表又冒出来了.<span style="background:yellow">这可能和DB2的某个执行有关.但是网上DB2的资料太少了.找不出问题的原因</span>.因此,<span style="background:blue">最后.只能在删除表的地方判断下是否是DB2,如果是,那么就直接使用JDBC来删除表而不使用hibernate来执行删除</span>. 重启后,<span style="background:green">问题解决.</span><br><img src="/img/2014/07/28/5.png" alt=""> </li>
</ol>
<hr>
<h2 id="总结:">总结:</h2><p>这个问题相当的奇怪,到最后都没找出真正的问题原因.在MYSQL和Oracle中不存在这个问题.因此可以确定应该是DB2中的某些处理相当奇怪,造成了在Hibernate管理事务的情况下.会造成DB2删除表在DB2内部发生死锁.于是乎,导致整个DB2停止响应.当重启后,真正的表并没有删除,因此,如果又建立一张和以前被删除的表的名字一样的表的话,是有问题的.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析">DB2下使用Hibernate自动重建表导致整个DB2卡住的问题分析</h1><h2 id="问题现象:">问题现象:</h2><p>今天在做高级检索的时候,当用户在界面配置了高级检索的字段后,需要程序自动的把AI3_ADVANCEDSEARCH表删除后,重建.本来这个功能在XDA和xSpace上是能正常工作的.<br>这两个系统所使用的数据库是 MYSQL和ORACLE.一切正常.  现在TVBS使用的是DB2. 在做测试的时候发现.<strong>每当重建表的时候,整个重建的线程都卡住了</strong>.同时,<strong>使用DB2的SQL管理工具,对任意的表进行修改/删除/新建,都会卡住</strong>.这肯定是有问题的.</p>
<h2 id="原因分析过程:">原因分析过程:</h2><ol>
<li>最开始就怀疑是hibernate和DB2的配合的问题,于是打断点.一路跟踪到它卡住的地方.<br><img src="/img/2014/07/28/1.png" alt=""><br>就是这里,调用JDBC的statement.executeUpdate就会卡住. 这句是标准的JDBC的代码.其中statement的实例是DB2的驱动中的对象,于是<span style="background:yellow">怀疑是DB2的驱动问题</span>.于是从网上重新找驱动.]]>
    
    </summary>
    
      <category term="DB2" scheme="http://sunxiang0918.github.io/tags/DB2/"/>
    
      <category term="Hibernate" scheme="http://sunxiang0918.github.io/tags/Hibernate/"/>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Lucene进行索引部分更新缓慢原因分析]]></title>
    <link href="http://sunxiang0918.github.io/2014/07/25/%E4%BD%BF%E7%94%A8Lucene%E8%BF%9B%E8%A1%8C%E7%B4%A2%E5%BC%95%E9%83%A8%E5%88%86%E6%9B%B4%E6%96%B0%E7%BC%93%E6%85%A2%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    <id>http://sunxiang0918.github.io/2014/07/25/使用Lucene进行索引部分更新缓慢原因分析/</id>
    <published>2014-07-25T10:23:55.000Z</published>
    <updated>2015-07-27T11:05:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用Lucene进行索引部分更新缓慢原因分析">使用Lucene进行索引部分更新缓慢原因分析</h1><h2 id="问题的引出">问题的引出</h2><p>在我们的系统中,使用了<code>Lucene</code>作为全文检索引擎用作NRT近实时检索.这就牵涉到一个更新的问题.<br>在Lucene当中,其实是<strong>不存在部分更新</strong>的说法的,它仅仅支持全更新.因此,为了应用端的调用方便.在我们的FTEngine全文检索引擎中是提供了部分更新的功能的,其逻辑大体上来说,就是根据传入的<code>uniqueID</code>,在索引中找到对应的<code>Document</code>.然后再恢复它的<code>Term</code>.而后再<strong>构造全更新的Document</strong>,交由Lucene进行全更新.<br>但是,在北京台项目中,突然发现全文检索更新的很慢,往往页面都对素材修改了2个小时了,索引都还没有更新. 从而引出了这个问题.</p>
<h2 id="解决思路">解决思路</h2><p>经过最初步的分析, 发现发生这种现象多集中于有大量的归档与回迁的操作.这两个操作对索引的影响就是会一次性的大量的进行索引的部分更新. 因此就把原因怀疑到了部分更新上.</p>
<a id="more"></a>
<h2 id="分析过程">分析过程</h2><ol>
<li>修改FTEngine的源代码.在项目中,加入大量的日志,全部显示使用时间.<br><img src="/img/2014/07/25/1.png" alt=""><br><img src="/img/2014/07/25/2.png" alt="">  </li>
<li><p>发现程序在恢复<strong>没有Store</strong>的字段的Term的时候非常的慢.经过分析以及网上找问题,发现是由于我们对于Index的字段没有使用Lucene提供的<strong>TermVector</strong>功能,也就是Term的位置向量.它是以空间来换取时间,当使用了位置向量后,就相当于为每一个Term都编了号,记录了位置.这样在恢复的时候大大的提高了查询Term的性能.这样就能很快的恢复Document了.</p>
</li>
<li><p>经过修改后,再进行测试,发现有些Document的恢复还是很慢. 对比恢复的快的与慢得Document.发现他们的区别在于恢复字段的时候,如果每一个字段都是有值的,那么由于有termVector那么会非常的快.但是如果这个字段是没有值的,那么恢复Term就相当的慢.<br><img src="/img/2014/07/25/3.png" alt=""><br><img src="/img/2014/07/25/4.png" alt=""> </p>
</li>
<li><p>进一步分析,没有<strong>digitalbarcode</strong>字段,那么他恢复这个的时候是如何处理的呢?<br>代码先去找这条记录的这个字段是否有<strong>Vector</strong>向量.<br><img src="/img/2014/07/25/5.png" alt=""><br>因为该条Documnet根本就没有这个字段,所以肯定没有这个向量.所以他走到<code>else</code>中去了.<br><img src="/img/2014/07/25/6.png" alt=""><br>else中的处理是先读到该字段的所有<code>term</code>. digitalTapeBarcode大概有2万个term.然后把这些term都取出来.遍历所有的term.然后判断这个term是否是属于这个document的.<br><img src="/img/2014/07/25/7.png" alt="">  </p>
</li>
<li><p>程序的结果也符合预期:<br><img src="/img/2014/07/25/8.png" alt="">  </p>
</li>
<li><p>找到问题原因后,就着手进行修改. 由于Lucene本身没有提供根据document来查询这条记录是否有这个字段.所以我们才会进行遍历.这也是无法修改的.</p>
</li>
<li><p>但是,在这我使用了一个取巧的办法.<br><img src="/img/2014/07/25/9.png" alt=""><br>也就是认为如果在使用TermVector的情况下(现在的索引,在北京台之后的都是使用了TermVector的).<br><strong>如果在TermVector中没有找到,就认为该Document中没有这个字段,不需要恢复.</strong>也就没必要去遍历这几万次.<br><img src="/img/2014/07/25/10.png" alt=""><br><img src="/img/2014/07/25/11.png" alt="">  </p>
</li>
</ol>
<p>相同的90条记录,进行部分更新.   修改前用时 <strong>38778</strong>毫秒 ,修改后  <strong>4475</strong>毫秒. 基本认为问题解决.<br>在不修改底层到<code>Lucene</code>的情况下,只能这样了</p>
<ol>
<li>做1W条记录的批量部分更新测试:</li>
</ol>
<p>修改前: 开始时间: 2014-07-25 11:57:35,666      结束时间:2014-07-25 13:12:39,811 共用时:<strong>4504</strong>秒<br><img src="/img/2014/07/25/12.png" alt="">    </p>
<p>修改后:开始时间:2014-07-25 17:20:23,382      结束时间:2014-07-25 17:25:57,946 共用时:<strong>334</strong>秒<br><img src="/img/2014/07/25/13.png" alt=""> </p>
<ol>
<li>到此,问题基本解决</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章是记录了在我们系统中使用Lucene作为全文检索的时候,进行大量的部分更新时非常缓慢的原因分析排查过程.]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="Lucene" scheme="http://sunxiang0918.github.io/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义hibernate方言 支持正则表达式查询]]></title>
    <link href="http://sunxiang0918.github.io/2014/07/21/%E8%87%AA%E5%AE%9A%E4%B9%89hibernate%E6%96%B9%E8%A8%80-%E6%94%AF%E6%8C%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2/"/>
    <id>http://sunxiang0918.github.io/2014/07/21/自定义hibernate方言-支持正则表达式查询/</id>
    <published>2014-07-21T12:00:18.000Z</published>
    <updated>2015-07-30T13:18:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="自定义hibernate方言_支持正则表达式查询">自定义hibernate方言 支持正则表达式查询</h1><h2 id="问题的引出">问题的引出</h2><p>最近收到一个新的需求,在基于数据库查询中,需要支持更高级的正则表达式的查询.但是这个在Hibernate的HQL中是不支持的.那么就需要想办法支持这个功能.</p>
<h2 id="解决过程">解决过程</h2><ul>
<li>首先需要明确的是查询数据库是否支持正则表达式的查询. 经过网上的查询.发现我们系统支持的<code>Mysql5.5</code>以及<code>Oracle10g</code>都是支持正则表达式查询的,但是两个的语法稍微有点不一样.</li>
</ul>
<p><strong>通用正则表达式语法</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">表示匹配任意一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[ ]</code></td>
<td style="text-align:center">匹配任何单一字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[0-9]</code></td>
<td style="text-align:center">表示一个字符的范围</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">否定一个字符集合，将匹配除指定字符外的任何东西</td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">匹配特殊字符转义</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">0个或多个匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">1个或多个匹配（等于 {1, }）</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">0个或1个匹配（等于 {0, 1}）</td>
</tr>
<tr>
<td style="text-align:center"><code>{n}</code></td>
<td style="text-align:center">指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>{n, }</code></td>
<td style="text-align:center">不少于指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>{n ,m}</code></td>
<td style="text-align:center">匹配数目的范围</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p><strong>标准类别:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[:alnum:]</td>
<td style="text-align:center">文字数字字符</td>
</tr>
<tr>
<td style="text-align:center">[:alpha:]</td>
<td style="text-align:center">文字字符</td>
</tr>
<tr>
<td style="text-align:center">[:blank:]</td>
<td style="text-align:center">空白字符</td>
</tr>
<tr>
<td style="text-align:center">[:cntrl:]</td>
<td style="text-align:center">控制字符</td>
</tr>
<tr>
<td style="text-align:center">[:digit:]</td>
<td style="text-align:center">数字字符</td>
</tr>
<tr>
<td style="text-align:center">[:graph:]</td>
<td style="text-align:center">图形字符</td>
</tr>
<tr>
<td style="text-align:center">[:lower:]</td>
<td style="text-align:center">小写文字字符</td>
</tr>
<tr>
<td style="text-align:center">[:print:]</td>
<td style="text-align:center">图形或空格字符</td>
</tr>
<tr>
<td style="text-align:center">[:punct:]</td>
<td style="text-align:center">标点字符</td>
</tr>
<tr>
<td style="text-align:center">[:space:]</td>
<td style="text-align:center">空格、制表符、新行、和回车</td>
</tr>
<tr>
<td style="text-align:center">[:upper:]</td>
<td style="text-align:center">大写文字字符</td>
</tr>
<tr>
<td style="text-align:center">[:xdigit:]</td>
<td style="text-align:center">十六进制数字字符</td>
</tr>
</tbody>
</table>
<p><strong>Mysql</strong>: mysql的正则表达式查询是以关键字<code>REGEXP</code>和<code>NOT REGEXP</code>做标识的.后面的语法和一般的正则表达式是一样的.</p>
<p>它们的用法是:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'Monty!'</span> <span class="keyword">REGEXP</span> <span class="string">'.*'</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'new*\n*line'</span> <span class="keyword">REGEXP</span> <span class="string">'new\\*.\\*line'</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'a'</span> <span class="keyword">REGEXP</span> <span class="string">'^[a-d]'</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'justalnums'</span> <span class="keyword">REGEXP</span> <span class="string">'[[:alnum:]]+'</span>;</span></span><br><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="string">'!!'</span> <span class="keyword">REGEXP</span> <span class="string">'[[:alnum:]]+'</span>;</span></span><br></pre></td></tr></table></figure>
<p>具体更多信息可以参见:<a href="https://dev.mysql.com/doc/refman/5.1/en/regexp.html" target="_blank" rel="external">Regular Expressions</a></p>
<p><strong>Oracle</strong>:oracle的正则表达式查询是以关键字<code>REGEXP_LIKE</code>和<code>NOT REGEXP_LIKE</code>做标识的.</p>
<p>它们的用法是:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> TestTable <span class="keyword">where</span> REGEXP_LIKE ( name, <span class="string">'^\(\d&#123;3&#125;\) \d&#123;3&#125;-\d&#123;4&#125;$'</span> )</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TestTable <span class="keyword">where</span> REGEXP_LIKE ( name, <span class="string">'new\\*.\\*line'</span> )</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> TestTable <span class="keyword">where</span> REGEXP_LIKE ( name, <span class="string">'[[:alnum:]]+'</span> )</span></span><br></pre></td></tr></table></figure>
<p>具体更多信息可以参见:<a href="http://docs.oracle.com/cd/B19306_01/appdev.102/b14251/adfns_regexp.htm" target="_blank" rel="external">Using Regular Expressions in Oracle Database</a></p>
<ul>
<li>分析Hibernate解析HQL的地方.通过断点可以发现,HQL转换成SQL的时候,Hibernate的Dialect方言是起了关键的作用的.它注册了HQL的各种<code>字段类型``内置函数</code>以及它们转换成对应数据库SQL的方法.</li>
<li><code>org.hibernate.dialect.Dialect</code> 这个类主要有 <code>register*</code>开头的几个方法.用于注册各种<code>字段类型``内置函数``关键字</code>等等.</li>
<li>我们需要的就是继承某一数据库的Dialect.然后在构造函数中加上我们需要的自定义的<code>字段类型``内置函数``关键字</code></li>
<li>比如在<strong>Mysql</strong>中增加正者表达式,就需要继承<code>MySQL5Dialect</code>.然后在构造函数中进行注册:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomMySQL5Dialect</span> <span class="keyword">extends</span> <span class="title">MySQL5Dialect</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomMySQL5Dialect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">/*通过自定义MYSQL的方言. 增加函数的支持</span><br><span class="line">        * 这个的意思就是 当遇到 regexp(name,'rain')的时候,自动的转换成  name REGEXP 'rain'  这句SQL</span><br><span class="line">         * 再比如  regexp(name,'[[:alnum:]]+rain[[:alnum:]]+|[[:alnum:]]+rain|rain[[:alnum:]]+').就转换成</span><br><span class="line">         *  name REGEXP '[[:alnum:]]+rain[[:alnum:]]+|[[:alnum:]]+rain|rain[[:alnum:]]+' 这句SQL.然后返回是一个布尔值</span><br><span class="line">         *  又因为hibernate不支持自定义的检索函数无返回值. 所以 写的时候 必须 写成 where regexp(name,'rain')=true</span><br><span class="line">         *  否则解析会报错</span><br><span class="line">         *  */</span></span><br><span class="line">        registerFunction(<span class="string">"regexp"</span>, <span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN, <span class="string">"?1 REGEXP '?2'"</span>));</span><br><span class="line"></span><br><span class="line">        registerFunction(<span class="string">"noregexp"</span>, <span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN, <span class="string">"?1 NOT REGEXP '?2'"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*这个地方替换成了自定义的SQLFunction.详见@see com.sobey.database.hibernate.CustomExactSearchSQLFunction*/</span></span><br><span class="line">        <span class="comment">/*精确查询*/</span></span><br><span class="line">        registerFunction(<span class="string">"exactsearch"</span>,<span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN,<span class="string">"( ?1 REGEXP '?2' AND ?1 NOT REGEXP '[[:alnum:][:punct:]]+?2[[:alnum:][:punct:]]+|[[:alnum:][:punct:]]+?2|?2[[:alnum:][:punct:]]+' )"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在<strong>Oracle</strong>中增加正则表达式,需要继承<code>Oracle10gDialect</code>:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomOracleDialect</span>  <span class="keyword">extends</span> <span class="title">Oracle10gDialect</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomOracleDialect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*2014-10-20 14:54:28 由于默认情况下 hibernate会把 text映射成为Oracle中的 long型.而不是text类型.</span><br><span class="line">         * 而long是oracle废弃了的,一个表只能有一个long字段.因此,就造成了表表不起的问题.因此就需要我们手动的映射到clob上 */</span></span><br><span class="line">        registerColumnType(-<span class="number">1</span>, <span class="string">"clob"</span>);         <span class="comment">//Types.LONGVARCHAR</span></span><br><span class="line">        registerColumnType(-<span class="number">16</span>, <span class="string">"clob"</span>);        <span class="comment">//Types.LONGNVARCHAR</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*通过自定义Oracle的方言. 增加函数的支持</span><br><span class="line">        * 这个的意思就是 当遇到 regexp(name,'rain')的时候,自动的转换成   REGEXP_LIKE (name,'rain')  这句SQL</span><br><span class="line">         * 再比如  regexp(name,'[[:alnum:]]+rain[[:alnum:]]+|[[:alnum:]]+rain|rain[[:alnum:]]+').就转换成</span><br><span class="line">         *  name REGEXP '[[:alnum:]]+rain[[:alnum:]]+|[[:alnum:]]+rain|rain[[:alnum:]]+' 这句SQL.然后返回是一个布尔值</span><br><span class="line">         *  又因为hibernate不支持自定义的检索函数无返回值. 所以 写的时候 必须 写成 where regexp(name,'rain')=true</span><br><span class="line">         *  否则解析会报错</span><br><span class="line">         *  */</span></span><br><span class="line">        registerFunction(<span class="string">"regexp"</span>, <span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN, <span class="string">"REGEXP_LIKE(?1,'?2')"</span>));</span><br><span class="line"></span><br><span class="line">        registerFunction(<span class="string">"noregexp"</span>, <span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN, <span class="string">"NOT REGEXP_LIKE(?1,'?2')"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*精确查询*/</span></span><br><span class="line">        registerFunction(<span class="string">"exactsearch"</span>,<span class="keyword">new</span> StandardSQLFunction(StandardBasicTypes.BOOLEAN,<span class="string">"(REGEXP_LIKE(?1,'?2') AND NOT REGEXP_LIKE(?1,'[[:alnum:][:punct:]]+?2[[:alnum:][:punct:]]+|[[:alnum:][:punct:]]+?2|?2[[:alnum:][:punct:]]+'))"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在上述的表达式中 <code>?1</code> <code>?2</code> 分别表示的是 第一个入参和第二个入参.因为我们定义了<strong>REGEXP</strong>操作是一个<strong>二元操作符</strong>.需要传入字段名以及正则表达式规则.</p>
</li>
<li><p>这样自定义后.在配置Hibernate的时候直接指定方言为我们自定义的Dialect:</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 引入dataSource --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernateProperties"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="title">props</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.dialect"</span>&gt;</span>xxx.CustomOracleDialect<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.format_sql"</span>&gt;</span>false<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">				...</span><br><span class="line">			<span class="tag">&lt;/<span class="title">props</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这样就可以在HQL中使用我们新定义的函数了.比如:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from Test where exactsearch(name,'new\\*.\\*line')=true;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>这里调用自定义函数由于是<code>StandardBasicTypes.BOOLEAN</code>.因此返回值需要和一个布尔值进行对比.这样才不会解析报错.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="自定义hibernate方言_支持正则表达式查询">自定义hibernate方言 支持正则表达式查询</h1><h2 id="问题的引出">问题的引出</h2><p>最近收到一个新的需求,在基于数据库查询中,需要支持更高级的正则表达式的查询.但是这个在Hibernate的HQL中是不支持的.那么就需要想办法支持这个功能.</p>
<h2 id="解决过程">解决过程</h2><ul>
<li>首先需要明确的是查询数据库是否支持正则表达式的查询. 经过网上的查询.发现我们系统支持的<code>Mysql5.5</code>以及<code>Oracle10g</code>都是支持正则表达式查询的,但是两个的语法稍微有点不一样.</li>
</ul>
<p><strong>通用正则表达式语法</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">表示匹配任意一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[ ]</code></td>
<td style="text-align:center">匹配任何单一字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[0-9]</code></td>
<td style="text-align:center">表示一个字符的范围</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">否定一个字符集合，将匹配除指定字符外的任何东西</td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">匹配特殊字符转义</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">0个或多个匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">1个或多个匹配（等于 {1, }）</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">0个或1个匹配（等于 {0, 1}）</td>
</tr>
<tr>
<td style="text-align:center"><code>{n}</code></td>
<td style="text-align:center">指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>{n, }</code></td>
<td style="text-align:center">不少于指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>{n ,m}</code></td>
<td style="text-align:center">匹配数目的范围</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="Hibernate" scheme="http://sunxiang0918.github.io/tags/Hibernate/"/>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记一次JVM优化过程]]></title>
    <link href="http://sunxiang0918.github.io/2014/06/27/%E8%AE%B0%E4%B8%80%E6%AC%A1JVM%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>http://sunxiang0918.github.io/2014/06/27/记一次JVM优化过程/</id>
    <published>2014-06-27T02:29:56.000Z</published>
    <updated>2015-07-27T10:12:20.000Z</updated>
    <content type="html"><![CDATA[<h1 id="记一次JVM优化过程">记一次JVM优化过程</h1><h2 id="问题的引出">问题的引出</h2><p>在多个系统环境中都出现了我们的DCMP在运行过程中突然停止响应,并且时间长达几分钟至几十分钟之久.期间DCMP任何功能都无法运行.严重的影响了系统的运行.因此需要分析排查问题的原因</p>
<h2 id="解决思路">解决思路</h2><p>经过最初步的分析,发现是DCMP在运行一段时间后,会执行<code>FullGC</code>. 在FullGC的过程中整个系统会停止一切响应.因此,解决该问题的思路,就是分析出DCMP平凡进行<code>FullGC</code>的原因.然后进行优化</p>
<h2 id="分析过程">分析过程</h2><ol>
<li><p>在DCMP运行的过程中,通过windows任务管理器找到进程的<code>PID</code>.然后调用JDK自带的命令: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat –gcutil PID 重复次数 间隔时间</span><br></pre></td></tr></table></figure>
<p> 获取当前JVM的内存信息:<br> <img src="/img/2014/06/27/1.png" alt=""><br> 他上面标识了JVM中每一个区的说占用百分比.</p>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>通过一段时间的观察,发现DCMP每一次<code>FullGC</code>都是由于<code>Perm</code>区内存空间占满造成的,而不是<code>Old</code>区.  在JVM定义中Perm区是<strong>持久区</strong>.用于<strong>存放ClassLoader和Class的类信息以及常量</strong>的.理论上是不会大量的增长的.因此在分段式的GC中是不会被GC的.只有在FullGC中会被GC.而我们的系统中,1G的<code>perm</code>区,仅仅需要10分钟就会被填满.这肯定是有问题的.</p>
</li>
<li><p>经过系统最小化的测试原则.也就是把能去掉的模块都去掉,仅仅保留DCMP运行的最少模块.发现<code>Perm</code>区的增长和<code>CDPLB</code><em>(我们系统中的一个组件与任务调度的服务)</em>的轮询时间高度一直.有理由相信和<code>CDPLB</code>有关.于是排查代码.发现对于一个<code>CDPLB</code>的任务,他在每一次轮询的时候都要调用ITaskRedirector的实现类进行分析获取该任务需要交由哪个执行器来处理.于是修改CDPLB的逻辑,让每一个任务在添加的时候就调用一次ITaskRedirector去获取执行器的名字.上线后,再次调用<code>jstat</code>命令发现<code>perm</code>区的增长后明显的好转.但是对于一般的情况,增速还是过快.特别是进行保存元数据的时候,会进行明显的增长.</p>
</li>
<li><p>再次分析<code>ITaskRedirector</code>实现类与保存元数据的逻辑的共性.发现都有<strong>xml</strong>转换对象的步骤.初步猜测与这个有关.于是编写测试类:<br> <img src="/img/2014/06/27/2.png" alt=""><br> 该断代码的逻辑在于读取一个临时实体的XML字符串. 然后不断的循环,一次采用<code>XStream</code>来反序列化生成临时实体对象,一次采用<code>Dom4j</code>来生成临时实体对象.两种方式交替执行.每次执行停顿<em>5000</em>毫秒.该代码执行后,通过<code>jstat</code>分析得出,每当使用<code>XStream</code>生成临时实体的时候<code>Perm</code>区都会增长<strong>0.5%</strong>左右.而使用<code>Dom4j</code>不会(<em>如果使用Dom4j的XPATH功能,会增长0.1左右</em>).由此可以断定应该是<code>Xstream</code>在反序列化XML生成对象的过程中产生了<strong>动态的代理Class</strong>.造成了<code>perm</code>区的增加.</p>
</li>
<li><p>根据网上查到的说法,<code>Xstream</code>是线程安全的,因此修改代码.把以前每调用一次序列化/反序列化 就要注册一次<code>Xstream</code>改为了<strong>缓存常量</strong>.经过这次修改,<code>Perm</code>区增长的问题基本解决.每一次的<code>FullGC</code>都不是由于<code>Perm</code>区满了引起的了.</p>
</li>
<li><p>继续使用<code>jstat</code>分析,发现系统虽然<code>FullGC</code>的<strong>频率降低</strong>了,但是每一次<code>FullGC</code>的<strong>持续时间还是很久</strong>.经过进一步的查资料,我们现在使用的是<code>Parallel GC</code>,也就是<strong>并行GC</strong>.该GC的特点是<strong>并行</strong>处理<code>Minor GC</code>.系统吞吐量优先,也就是说,它会尽量减少GC的次数,等到内存满后再进行一次FullGC.所以FullGC的时间相当的长.因此,<strong>更换GC方式为CMS GC</strong>.</p>
</li>
<li><p><code>CMS GC</code>全称<code>Concurrent Mark-Sweep GC</code>.它是一种并行的<strong>标记GC</strong>.当有部分内存需要被GC的时候,它会标记这部分内存.然后系统就不再使用这部分内存.同一时间,它开始并行的开始释放被标记的这部分内存.从而达到高响应的.它是一种高响应式的GC,它为了能减少GC的时间,通过不断的标记和交换内存来达到目的.因此对于系统的吞吐量是有一定的影响的.</p>
</li>
<li><p>决定选用CMS GC方式后,还需要决定的就是整个系统的堆大小以及每一个区的大小.<br> <img src="/img/2014/06/27/3.png" alt="">  </p>
</li>
<li><p>判断JVM是否调优有三个标准:<strong>吞吐量</strong>,<strong>延迟及响应性</strong>,<strong>内存占用</strong>.</p>
<ul>
<li><code>吞吐量</code>是对<strong>单位时间内处理工作量的度量</strong>,设计吞吐量需求时,一般不考虑它对延迟或响应时间的影响.通常情况下,增加吞吐量的代价是延迟的增加或内存使用的增加.吞吐量性能的需求的一个典型例子是:应用程序每秒需要完成2500次事务.</li>
<li><code>延迟及响应性</code>是<strong>对引用程序收到指令开始工作直到完成该工作所消耗时间的度量</strong>.通常情况下,提高响应性的代价是更低的吞吐量,或者更多的内存消耗.延迟需求的一个典型例子是应用程序应该在60ms内完成请求的处理工作</li>
<li><code>内存占用</code>是指在<strong>同等程度的吞吐量,延迟,可用性等前提下,运行应用程序所需要的内存大小</strong>.内存占用通常以运行应用程序需要的JAVA堆大小或运行应用程序所需要的总大小来表述.一般情况下可以通过增大JAVA堆的方式增加内存能够提高吞吐量,降低延迟.</li>
</ul>
</li>
<li><p>我们的DCMP系统目前暂时没有一个硬性的吞吐量或响应的要求,但是要求尽量在等量内存下达到最大吞吐量或最低响应时间.要达到这个要求有三个原则:</p>
<ol>
<li>每一次MinorGC都尽可能多的收集垃圾对象.遵守这一原则可以减少应用程序发生FullGC的频率.FullGC的持续时间总是最长的.是应用程序无法达到其延迟或吞吐量要求的罪魁祸首.</li>
<li>处理吞吐量和延迟问题时,垃圾处理器能使用的内存越大,即JAVA堆空间越大,垃圾收集效果越好.</li>
<li>在这三个性能指标(吞吐量,延迟,内存占用)中任意选择两个进行JVM调优.</li>
</ol>
</li>
<li><p>开始优化内存之前,需要理解JVM中堆的布局非常重要,它直接可以从理论上帮助我们确定应用程序使用JAVA堆的大小,微调影响垃圾收集器性能的空间大小.<br><img src="/img/2014/06/27/4.png" alt=""><br>JVM主要有三个空间,分别是:<strong>新生代</strong>,<strong>老年代</strong>以及<strong>永久区</strong>.<br>JAVA应用程序分类JAVA对象的时候,首先在新生代空间(<code>Eden</code>)中分配对象.经过一次<code>MinorGC</code>后,存活下来的对象会放入<code>S0</code>区.然后<code>S0</code>和<code>S1</code>交换.当再一次<code>MinorGC</code>后,把存活下来的对象再放入当前的<code>S0</code>区.经过几次<code>MinorGC</code>之后还保持活跃的对象会被晋升到老年代中.永久代中空间存放的是VM和JAVA类的元数据已经驻留的Strings和类静态变量.</p>
<ul>
<li>整个JVM堆大小可以使用 <code>–Xmx</code>和<code>-Xms</code>指定</li>
<li>新生代可以使用<code>-XX:NewSize</code>  <code>-XX:MaxNewSize</code>  或者 <code>–Xmn</code>指定</li>
<li>老年代空间大小会根据新生代的大小隐式的指定.即 <strong>老年代=堆大小-新生代</strong></li>
<li>持久代空间大小通过: <code>-XX:PermSize</code>   <code>-XX:MaxPerSize</code> 来指定<br>新生代,老年代,永久代这三个空间中的任何一个不能满足内存分配请求时,就会发生垃圾回收,理解这一点非常重要.</li>
</ul>
</li>
<li><p>有了理论的知识后,接下来就是根据我们系统具体的进行分析了.首选需要的就是选择JVM运行模式.毫无疑问,我们系统肯定是使用的<code>Server</code>模式.Server模式提供了更复杂的生成码优化功能,这个功能对于服务器的应用而言尤其重要</p>
</li>
<li><p>接下来就是确定内存占用.程序的内存并不是越多越好,这需要考虑成本等问题.初始堆大小通常应该是老年代活跃数据的<strong>3-4</strong>倍.永久代大小应该比永久代活跃数据大<strong>1.5-2</strong>倍.新生代大小通常应该是老年代活跃数据的<strong>1-1.5</strong>倍.</p>
</li>
<li><p>所谓的活跃数据,即<strong>应用程序运行于稳定态时,长期存活的对象在JAVA堆中占用的空间大小</strong>.换句话说,活跃数据大小是引用程序运行于稳定后,FullGC之后JAVA堆中老年代和永久代占用的空间大小.</p>
</li>
<li><p>经过在107机器上大规模的跑hotfolder入库(<em>文件分析-保存元数据</em>).我们老年代的活跃数据大概为<strong>1个G</strong>.因此调整初始化堆大小为<strong>4G</strong>,永久代<strong>346m</strong>,新生代<strong>1.5G</strong><br><img src="/img/2014/06/27/5.png" alt="">  </p>
</li>
<li><p>接下来微调新生代的大小.<br>通常情况下,<strong>新生代空间越小,MinorGC持续时间越短</strong>,不考虑这对于MinorGC持续时间的影响,减少新生代空间又会增加MinorGC的频率.因此需要取<strong>它们的中间点</strong>.分析GC数据的时候,如果发现MinorGC的间隔时间过长,修正的方法是减少新生代空间.如果Minor频率太高,修正的方法是增加新生代空间.经过GC日志的分析,新生代1.5G的空间比较合适我们的系统,每次MinorGC的平均时间为0.04秒左右.<br><img src="/img/2014/06/27/6.png" alt="">   </p>
</li>
<li><p>微调老年代的大小.<br>这一步的目标是评估FullGC引入的<code>最差停滞时间</code>以及<code>FullGC的频率</code>.<br>同年轻代一样,老年代的优化也需要采集垃圾手机的统计数据.我们关注的是FullGC的持续时间和频率.经过采样,发现了一个问题.在当前的配置情况下,当系统运行了一段时间后,会进行大量的FullGC.而不进行MinorGC. FullGC占到了所有GC的90%以上.虽然每一次FullGC的持续时间都不长,但这是不正常的,经过GC日志的分析.发现,当系统进行大量的FullGC的时候,老年区与持久区并没有被占满,也就是说FullGC不是这两个区被占满造成的.每次出发FullGC的时机都是年轻代占满,进行GC的时候.报concurrent mode failure<br><img src="/img/2014/06/27/7.png" alt=""><br>经过oracle等论坛的查询和源码的分析,发现出现这种现象有一种情况就是当<code>年轻代GC</code>的时候,他需要向<strong>老年代晋升对象</strong>,而老年代的空间如果不够年轻代晋升的对象时(<strong>这里有一个误区,也是让我疑惑了很久的地方,就是明明老年代的空间大于年轻代,为什么还会不够.原因在于CMS方式的GC是不会整理内存的,内存空间是一个一个的片段.当老年区的最大连续内存片段小于年轻代晋升的对象大小时,JVM就会认为空间不足</strong>),就会发生MinorGC失败,从而JVM尝试进行FullGC.因此,可以得出一个结论就是年轻代和老年代空间大小比过小了.在不增加堆空间大小的情况下,就只能减少年轻代的空间.因此,重新修改年轻代大小为1G.</p>
</li>
<li><p>Survivor空间调优<br><code>Survivor</code>空间也就是图上的 <code>S0</code> <code>S1</code>空间. 两个空间的大小虽然很小,但是作用很大.整个Survivor空间分成了两个部分,即<strong>S0</strong>和<strong>S1</strong>,也叫<strong>From</strong>区和<strong>To</strong>区.它相当于是一个缓存区,能提高年轻代晋升到老年代的对象的命中率.一旦完成MinorGC,Eden空间会被清空,From空间也会被清空.而To空间中保留了还是活跃的对象,之后Survivor空间交换标记为下一次MinorGC作准备.现在被清空的From区被标记成了To区,而To区被标记成From区.因此MinorGC结束时,Eden空间和一块Survivor空间被清空,另一块Survivor空间中保留经历了上一次MinorGC存货下来的活跃对象.如果MinorGC时.To区空间不足以容纳所有从Eden区和From区中复制过来的活跃对象,超出的部分就会直接晋升至老年区.这会加速FullGC的频率.调整Survivor空间的大小,让其有足够的空间容纳存活对象足够长的时间,直到几个周期之后对象老化.就能避免Survivor空间的溢出.<br>调整Survivor空间大小可以通过: <code>-XX:SurvivorRation=&lt;ratio&gt;</code> 进行调整.<br>计算公式为: <code>Survivor空间大小=-Xmn/(+XX:SurvivorRation=&lt;ration&gt;+2)</code><br>要调优Survivor空间,需要监控晋升阀值.晋升阀值决定了对象在新生代Survivor空间中保留的次数.通过在GC日志中增加<code>-XX:+PrintTenuringDistribution</code>.来监控晋升阀值.<br>增加该参数后,每一个MinorGC都会打印Survivor区中的对象大小以及保留次数:<br>比如:  </p>
<blockquote>
<p>age 1: 6115072bytes, 6115072 total<br>age 2:  286672bytes, 6401774 total<br>age 3:  115704 bytes, 6517448 total<br>age 4:   95932 bytes,  6613380 total<br>age 5:   89465 bytes,  6702845 total<br>age 6:   88322 bytes,  6791167 total<br>age 7    88201bytes,  6879368 total  </p>
</blockquote>
<p>从上表来看,年龄为<code>1</code> <code>2</code> <code>3</code>的对象非常的多,而年龄<code>4</code>开始就很少了.也就是说系统的Survivor的晋升阀值就是3.即<code>-XX:MaxTenuringThreshold=3</code>.整个年龄为3的对象为65兆.所以就配置Survivor区大小为<strong>130m</strong>.即<strong>-XX:SurvivorRatio=6</strong></p>
</li>
<li><p>CMS收集周期调优<br>确定完JVM堆以及每一个区的大小后,还需要的就是根据CMS收集策略来调整一些参数.比如:  </p>
<ul>
<li>Perm区满后是采用FullGC还是直接抛异常终止系统运行的<code>-XX:+CMSPermGenSweepingEnabled</code>参数.  </li>
<li>CMS老年代开始标记的进入周期,如果CMS周期开的太晚,就会发生失速.如果它无法以足够快的速度回收对象,就无法避免老年化空间用尽.但是如果CMS周期开始得过早,又会引起无用的消耗,影响应用程序的吞吐量.经过GC日志的分析,当老年代占用大于1.6G的时候,就会发生concurrent mode failure.因此决定CMS进入时机为老年代的60%,即: <code>-XX:CMSInitiatingOccupancyFraction=60</code></li>
<li>CMS回收不会整理内存,这就会造成老年区的内存碎片越来越多,影响效率.因此就需要指定进行几次FullGC后,整理老年区的内存.这会增加一个FullGC的时间,但是可以整体的增加系统的吞吐量.经过分析我们的系统很久才会触发一次FullGC,于是配置每一个FullGC前都进行内存整理: <code>-XX:CMSFullGCsBeforeCompaction=1</code></li>
</ul>
</li>
<li><p>到此,GC的配置已完成,然后就是进行大量的测试.现在的配置如下:</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> JAVA_OPTS=%JAVA_OPTS% -Xms4096m -Xmx4096m -XX:PermSize=<span class="number">346</span>m -XX:MaxPermSize=<span class="number">346</span>m -Xmn1024m  -Xss128k -server -XX:MaxTenuringThreshold=<span class="number">5</span></span><br><span class="line"><span class="built_in">set</span> JAVA_OPTS=%JAVA_OPTS% -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+CMSPermGenSweepingEnabled -XX:+UseCMSInitiatingOccupancyOnly -XX:+CMSClassUnloadingEnabled -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:SurvivorRatio=<span class="number">6</span> -XX:CMSFullGCsBeforeCompaction=<span class="number">1</span> -XX:CMSInitiatingOccupancyFraction=<span class="number">60</span> -XX:ParallelGCThreads=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> JAVA_OPTS=%JAVA_OPTS% -XX:+DisableExplicitGC</span><br></pre></td></tr></table></figure>
<p>经过3台AT导入同时导入的压力测试:<br><img src="/img/2014/06/27/8.png" alt="">  </p>
<p>系统运行<strong>52937</strong>秒,整个GC暂停时间<strong>231.71</strong>秒. 系统可用时间 <strong>99.56%</strong>.平均GC时间<strong>0.039</strong>秒,最大停顿时间<strong>2.7</strong>秒.达到系统要求.</p>
<ol>
<li><p>把同样的配置发到旺旺现场,发现系统还是响应很慢,收集GC日志后发现.他们的元数据太大.造成新生代被占满的速度太快.平凡的进行MinorGC. 平均每<strong>0.2秒</strong>就进行一个MinorGC,系统停顿<strong>0.04秒</strong>. 整个系统的可用时间只有<strong>75%</strong>.没达到吞吐量的需求.日志显示<strong>0.2秒</strong>新生代的<strong>900M</strong>空间就会被占满.但是不会平凡的进行FullGC.证明<strong>整体的GC策略是正确的</strong>,但是确实由于量的原因,<strong>4G空间不能满足要求了</strong>.所以一方面增加现场的内存配置到8G.另一方面,分析流程,发现由于AT导入速度大于我们保存元数据的速度.所以保存元数据的流程越来越多,而保存元数据没有使用CDPLB调度,所有的任务都驻留在内存中,造成了新生代增速过快.因此,修改程序让CDPLB也来调度保存元数据,同一时间只有300个任务驻留在内存中.再次观察日志.问题解决.</p>
</li>
<li><p>至此,整个DCMP的内存调优结束.</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章是记录了一次在我们的项目中遇到CG时间过长的问题排查过程.]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="JVM" scheme="http://sunxiang0918.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JBOSS4关闭时不断开数据库连接问题分析]]></title>
    <link href="http://sunxiang0918.github.io/2013/04/21/JBOSS4%E5%85%B3%E9%97%AD%E6%97%B6%E4%B8%8D%E6%96%AD%E5%BC%80%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://sunxiang0918.github.io/2013/04/21/JBOSS4关闭时不断开数据库连接问题分析/</id>
    <published>2013-04-21T01:43:10.000Z</published>
    <updated>2015-07-29T03:05:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JBOSS4作为windows服务关闭时不断开数据库连接问题分析">JBOSS4作为windows服务关闭时不断开数据库连接问题分析</h1><h2 id="问题现象:">问题现象:</h2><p>现场发现,每次重启媒资服务,Oracle的数据库连接会增加约20个的JDBC连接.这样就会导致数据库连接越来越多.</p>
<h2 id="问题分析">问题分析</h2><p>接到这个问题, 使用<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> program,i.* <span class="keyword">from</span> v$<span class="keyword">session</span> i <span class="keyword">where</span> program = <span class="string">'JDBC Thin Client’</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个SQL语句查询到 确实每次重启都有 大约20个 名为<code>&#39;JDBC Thin Client’</code> 的数据库连接没有释放. </p>
<ol>
<li>于是,想办法给JDBC的连接加上了名字. 具体办法是:修改<code>Oracle-DS.xml</code> 增加一行配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">connection-property</span> <span class="attribute">name</span>=<span class="value">"v$session.program"</span>&gt;</span>DCMP DB Connection<span class="tag">&lt;/<span class="title">connection-property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样就可以给我们的服务的数据库连接增加名字.</p>
<a id="more"></a>
<ol>
<li><p>通过给<code>DCMP</code>与<code>统计服务</code>增加名字. 并不断的重启服务器发现.这个问题是概率性的,并且大概率发生在<strong>统计服务</strong>上.</p>
</li>
<li><p>通过分析启动的日志,发现当我们<strong>停止</strong>服务器的时候,日志中并没有出现停止服务应该有的一些<strong>shutdown的日志</strong>.而是硬生生的就停止服务了. 通过对比 使用<strong>Windows服务</strong>启停统计与使用<strong>run.bat批处理</strong>启停统计. 发现, 问题的根源在于我们注册的Windows服务上.使用run.bat命令行启停统计,一切正常, 在日志中会出现一系列的shutdown日志.</p>
</li>
<li><p>既然是JBoss Windows服务出现的问题,那么分析 相关的几个配置. <code>service.bat</code>   修改这个配置,让shutdown事件打印出日志.发现当windows服务调用<strong>JBOSS的shutdown</strong>的时候,会报错:   <code>&quot;Shutting down MAMSpace_DCMP_Service [2015-04-10 19:27:10] 系统找不到指定的路径&quot;</code>  </p>
</li>
<li><p>那么问题就肯定在于JBOSS的 shutdown命令的问题了. 分析 JBOSS <code>shutdown.bat</code>  发现其中的JAVA_HOME <strong>没有修改过</strong> 指向的是默认的: <code>“C:\Program Files (x86)\Java\jdk1.5.0_17”</code>   我们的java并没有安装在那个地方.修改为正确的<code>”..\jre”</code>. 再次启停.</p>
</li>
<li><p>停止日志报错: </p>
<blockquote>
<p>“java.lang.NoClassDefFoundError: org/jboss/system/server/ServerImplMBean at org.jboss.Shutdown.main(Shutdown.java:116)”   </p>
</blockquote>
<p>经过网上的查询分析.发现是JBOSS4的一个<strong>BUG</strong>.<a href="https://issues.jboss.org/browse/JBAS-3894" target="_blank" rel="external">https://issues.jboss.org/browse/JBAS-3894</a> 这个问题在JBOSS5中被修正. </p>
</li>
<li><p>但是由于我们不能更新JBOSS版本,只有想其他的办法,经过分析JBOSS的相关源码.他缺少的是一个<code>jbossall-client.jar</code>的依赖.于是从网上找到一个这个jar包.放入 <code>JBOSS/client/jbossall-client.jar</code>.  然后再次启停.</p>
</li>
<li><p>发现报错:   <code>Failed to connect to server localhost:1099</code>    基本上能发现问题了. 是因为统计服务的默认<code>1099</code>端口被改成了<code>21099</code>.<br>因此需要修改<strong>shutdown.bat</strong>调用的时候的 <strong>默认端口</strong>.   经过分析,发现调用shutdown.bat的地方是在<strong>service.bat</strong>中. 默认传参是 <code>shutdown -S</code>    修改成   <code>shutdown -s 127.0.0.1:21099</code>   后. 再次实现. 问题解决</p>
</li>
</ol>
<h2 id="问题总结">问题总结</h2><p>要解决这个问题,主要需要有以下的几个步骤:</p>
<ol>
<li><p>修改 <code>&quot;JBOSS\bin\shutdown.bat&quot;</code> 文件,把 JAVA_HOME 修改为<code>&quot;..\jre&quot;</code><br>  “set JAVA_HOME=..\jre”</p>
</li>
<li><p>拷贝<code>jbossall-client.jar</code>到<code>JBOSS/client/jbossall-client.jar</code></p>
</li>
<li><p>修改<code>service.bat</code>中的命令为默认端口. 这个端口号在 <code>&quot;JBOSS/server/default/conf/jboss-service.xml&quot;</code>文件中的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">mbean</span> <span class="attribute">code</span>=<span class="value">"org.jboss.naming.NamingService"</span></span><br><span class="line">      <span class="attribute">name</span>=<span class="value">"jboss:service=Naming"</span></span><br><span class="line">      <span class="attribute">xmbean-dd</span>=<span class="value">"resource:xmdesc/NamingService-xmbean.xml"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>节点下.<br><code>call shutdown -s 127.0.0.1:21099</code></p>
<p><strong>问题解决</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="JBOSS4作为windows服务关闭时不断开数据库连接问题分析">JBOSS4作为windows服务关闭时不断开数据库连接问题分析</h1><h2 id="问题现象:">问题现象:</h2><p>现场发现,每次重启媒资服务,Oracle的数据库连接会增加约20个的JDBC连接.这样就会导致数据库连接越来越多.</p>
<h2 id="问题分析">问题分析</h2><p>接到这个问题, 使用<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> program,i.* <span class="keyword">from</span> v$<span class="keyword">session</span> i <span class="keyword">where</span> program = <span class="string">'JDBC Thin Client’</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个SQL语句查询到 确实每次重启都有 大约20个 名为<code>&#39;JDBC Thin Client’</code> 的数据库连接没有释放. </p>
<ol>
<li>于是,想办法给JDBC的连接加上了名字. 具体办法是:修改<code>Oracle-DS.xml</code> 增加一行配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">connection-property</span> <span class="attribute">name</span>=<span class="value">"v$session.program"</span>&gt;</span>DCMP DB Connection<span class="tag">&lt;/<span class="title">connection-property</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样就可以给我们的服务的数据库连接增加名字.</p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="JBOSS" scheme="http://sunxiang0918.github.io/tags/JBOSS/"/>
    
  </entry>
  
</feed>