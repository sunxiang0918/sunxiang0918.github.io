<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[翔妖除魔的个人博客]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://sunxiang0918.github.io//"/>
  <updated>2015-10-11T15:55:55.000Z</updated>
  <id>http://sunxiang0918.github.io//</id>
  
  <author>
    <name><![CDATA[翔妖除魔]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[MacOS下JAVA开发使用经验(二)]]></title>
    <link href="http://sunxiang0918.github.io/2015/10/11/MacOS%E4%B8%8BJAVA%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C-%E4%BA%8C/"/>
    <id>http://sunxiang0918.github.io/2015/10/11/MacOS下JAVA开发使用经验-二/</id>
    <published>2015-10-11T13:39:59.000Z</published>
    <updated>2015-10-11T15:55:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MacOS下JAVA开发使用经验(二)">MacOS下JAVA开发使用经验(二)</h1><p><a href="http://sunxiang0918.cn/2015/09/21/MacOS下JAVA开发使用经验(一" target="_blank" rel="external">上一篇文章</a>)写了最常用的一些工具,接下来再介绍一下提高开发生产力的工具.</p>
<h2 id="软件">软件</h2><h3 id="BetterZip">BetterZip</h3><p>这个是MAC下很常用的压缩/解压的软件.它对于Windows下的中文支持的比较好.<br>基本上没有遇到在Windows下压缩的中文字符,到Mac下就无法打开的问题了.<br>同时他也支持rar格式. 对于我们JAVA的各种<code>ear</code>,<code>war</code>,<code>jar</code>等 都是可以直接打开,然后编辑的.当双击某个jar中的xml文件后会自动打开关联的文件编辑器,然后保存文本编辑器也会自动的更新jar包.</p>
<p><img src="/img/2015/10/11/1.png" alt=""></p>
<h3 id="Beyond_Compare">Beyond Compare</h3><p>这个是我们搞IT的大杀器.以前只有在Windows上有,当时为了这一个软件,我不得不装上了虚拟机.<br>不得不说,用过这么多文件比较工具,这个始终是神话般的存在.什么<code>DiffMerge</code> <code>FileMerge</code> <code>Araxis Merge</code> <code>Kaleidoscope</code> 都弱爆了.<br>这个工具可以配合你的<code>sourceTree</code>等代码管理工具使用,直接清晰地对比和合并代码.同时也可以和<code>JD</code>反编译工具配合直接对比<code>class</code>文件的差异(这个可以参考我的<a href="http://sunxiang0918.cn/2014/09/20/在MAC下使用beyondcompare比较JAVA-Class文件/" target="_blank" rel="external">另一篇文章</a>).</p>
<p><img src="/img/2015/10/11/2.png" alt=""></p>
<a id="more"></a>
<h3 id="Dash">Dash</h3><p>这个又是<code>Mac Only</code>的一个福利,是一款功能单一却精准的API文档浏览器,以及代码片段管理工具.它采用了单窗口的模式,最方便的提供了API查询的需求.我们平时写东西的时候,最常用的就是查看源码和API了,IDE提供了源码的查看,而<code>Dash</code>则提供了<code>API查询</code>的功能. 它可以和绝大多数的IDE合作,包括我们JAVA最常用的<code>Intellij</code> <code>eclipse</code>.只需要在需要查看API的代码上按住<code>Command+Shift+左键</code>(这个可以自己设置),那么就会自动的跳转到它的界面上并显示这段代码的API.不需要我们到处去翻了.<br>它基本上集成了绝大多数的API文档,包括<code>JDK</code> <code>Spring</code> <code>Hibernate</code>等等,同时也支持三方的推送,只要是符合标准的url地址,都可以添加到它里面进行管理.</p>
<p><img src="/img/2015/10/11/3.png" alt=""></p>
<h3 id="JD-GUI">JD-GUI</h3><p>这个是Mac下的可视化的<code>Java</code>反编译工具.使用很简单,直接双击打开界面后,把<code>class</code>文件或者文件夹直接拖入他的窗口就可以了.然后就会自动的反编译好,如果是一个文件夹的话,他还支持代码间的跳转.这对有些时候来说有奇效.</p>
<p><img src="/img/2015/10/11/4.png" alt=""></p>
<h3 id="MongoHub">MongoHub</h3><p>这个是在Mac下非常好用的<code>Mongo</code>可视化客户端.它基本上提供了<code>Mongo</code>的所有操作,并且支持Mongo的集群连接,同时,它是免费<a href="https://github.com/jeromelebel/MongoHub-Mac" target="_blank" rel="external">开源的</a>.如果在开发中需要使用<code>Mongo</code>数据库.那么这个基本上是不二的选择.</p>
<p><img src="/img/2015/10/11/5.png" alt=""></p>
<h3 id="Navicat_Premium">Navicat Premium</h3><p>这个是多平台下的多数据库管理工具,能支持<code>Oracle</code>,<code>Mysql</code>,<code>Sqlite</code>,<code>PostgreSQL</code>.不过我主要是拿它来管理<code>Oracle</code>和<code>Sqlite</code>.它也提供了很全面的数据库管理功能.比如导入导出,执行函数,事件,任务等等.但是这个工具使用起来有点慢,而且容易崩溃(我也不知道为什么,已经遇到很多次了),所以不怎么常用.不过用来临时操作下<code>Oracle</code>或<code>Sqlite</code>还是推荐.</p>
<p><img src="/img/2015/10/11/6.png" alt=""></p>
<h3 id="OmniDiskSweeper">OmniDiskSweeper</h3><p>这个工具也是平时使用Mac必不可少的,主要是用来查看磁盘空间被什么文件使用的.通过这个软件可以很容易的看到你的磁盘到底是被什么占用了这么多.自从又一次无意间发现企鹅聊天占用了我系统盘10个G空间存放莫名其妙的东西后,我就养成了定时执行一次这个软件的习惯,谁叫我们是屌丝只买得起256G的SSD喃..空间还是要节约到用..</p>
<p><img src="/img/2015/10/11/7.png" alt=""></p>
<h3 id="OmniGraffle&amp;OmniPlan">OmniGraffle&amp;OmniPlan</h3><p>这两个工具是用来画UML和项目甘特图的,也是在Mac上算是比较好用的了.它们对应了Windows上的<code>Visio</code>和<code>Project</code>.如果你们是一个传统点的软件开发公司,相信采用瀑布开发模型的肯定是需要这两个软件的.</p>
<p><img src="/img/2015/10/11/8.png" alt=""></p>
<p><img src="/img/2015/10/11/9.png" alt=""></p>
<h3 id="Sequel_Pro">Sequel Pro</h3><p>这个是在Mac环境下的Mysql的管理软件.完全免费的,并且是原生的Mac软件,使用速度比<code>Navicat</code>快.功能也和<code>Navicat</code>是一样的.因此,我平时更倾向于使用这个工具来管理<code>Mysql</code>.<br>它的开源地址是:<a href="https://github.com/sequelpro/sequelpro" target="_blank" rel="external">https://github.com/sequelpro/sequelpro</a></p>
<p><img src="/img/2015/10/11/10.jpg" alt=""></p>
<h3 id="Microsoft_Remote_Desktop">Microsoft Remote Desktop</h3><p>这个工具也是在工作中基本上跑不掉的.它是用来远程Windows系统的,相当于Windows上的远程桌面.没有办法,我们的环境中还是有一半的Windows机器作为媒体处理的执行器.平时需要远程上去调试些东西.不过还算微软厚道,这个工具还是比较好用的,能支持同时打开几个文件.并且能直接粘贴复制远程桌面的东西到本地.</p>
<p><img src="/img/2015/10/11/11.png" alt=""></p>
<h3 id="Transmit">Transmit</h3><p>非常好用的sftp工具,他提供了<code>FTP</code> <code>SFTP</code> <code>S3</code> 的文件访问.并且支持标签组的操作,以及直接双击打开关联的工具修改文件并自动上传.还支持各种姿势的拖拽操作.总之非常方便,强烈地推荐.</p>
<p><img src="/img/2015/10/11/12.png" alt=""></p>
<h3 id="Brew">Brew</h3><p>brew 又叫Homebrew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 只需要一个命令， 非常方便.类似于Ubuntu上的<code>apt-get</code>.他能方便的管理我们的各种软件的依赖,这些工具通常都是些比较专业的命令行工具,安装不是需要编译一大堆就是需要下载各种依赖包,总之不简单.用了这个之后,一句话而已,就搞定了.<br>要安装Brew也很简单,在终端中输入 <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code>即可.<br>安装后 就可以在终端中输入<code>brew</code> 来进行各种操作了.<br>比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">brew install wget</span><br><span class="line">brew search /*get/</span><br><span class="line">brew list</span><br><span class="line">brew update</span><br></pre></td></tr></table></figure>
<h3 id="zsh">zsh</h3><p>Linux/Unix提供了很多种Shell,除了大家最常用的bash以外,<code>Macos</code>还预装了一个<code>zsh</code>.这个可是一个大杀器,被称为终极Shell,但是由于配置过于复杂,用的人始终不多.直到有一天,有个外国友人搞了一个<code>oh my zsh</code>的项目,可以让你很容易的使用上<code>zsh</code>.</p>
<ol>
<li>切换到zsh<br> 直接在终端中输入 <code>chsh -s /bin/zsh</code> 即可.</li>
<li>安装oh my zsh<br> 这个也直接在终端中输入 <code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code> 即可.它会自动的下载源码并编译然后安装配置一条龙搞完.安装完成后重新打开一个终端窗口,你就可以看到一个彩色的提示了<br><img src="/img/2015/10/11/13.png" alt=""></li>
<li><p>修改 ~/.zshrc配置<br> 这个配置文件里面就是zsh的自定义配置项了,可以在这里配置zsh的主题,插件,命令行别名等等.<br> 比如以下就是我常用的别名:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">		<span class="built_in">alias</span> hexog=<span class="string">'hexo generate'</span></span><br><span class="line"><span class="built_in">alias</span> hexod=<span class="string">'hexo deploy'</span></span><br><span class="line"><span class="built_in">alias</span> hexon=<span class="string">'hexo new'</span></span><br><span class="line"><span class="built_in">alias</span> cls=<span class="string">'clear'</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l'</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ls -a'</span></span><br><span class="line"><span class="built_in">alias</span> vi=<span class="string">'vim'</span></span><br><span class="line"><span class="built_in">alias</span> javac=<span class="string">"javac -J-Dfile.encoding=utf8"</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">"grep --color=auto"</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> html=st   <span class="comment"># 在命令行直接输入后缀为 html 的文件名，会在 sublimeText 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> rb=st     <span class="comment"># 在命令行直接输入 ruby 文件，会在 sublimeText 中打开</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> py=st       <span class="comment"># 在命令行直接输入 python 文件，会用 sublimeText 中打开，以下类似</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> js=st</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> c=st</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> java=st</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> txt=st</span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> gz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> tgz=<span class="string">'tar -xzvf'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> zip=<span class="string">'unzip'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="operator">-s</span> bz2=<span class="string">'tar -xjvf'</span></span><br></pre></td></tr></table></figure>
<p> 主题的话,推荐使用<code>agnoster</code>,颜色比较好看,并且能以标签的形式展示Git的分支等等,就像上面的截图一样.不过这个主题需要安装<code>Menlo-Powerline.otf</code>字体.并且使用<code>d6a36b1</code>提交上的<code>agnoster</code>主题文件,否则是会有乱码的.</p>
</li>
<li><p>使用zsh</p>
<ul>
<li>zsh完全兼容bash,原来怎么使用bash的就可以怎么使用zsh,命令完全一样.</li>
<li>提供了强大的历史记录功能,上下箭头可以翻阅所有你执行过的命令,并且还可以加限制条件,比如先输入一个<code>cd</code>,然后上下箭头显示的就是 你所有执行过的<code>cd</code> 命令.</li>
<li>各种补全功能,它的Tab补全功能不像bash是严格区分大小写的,他可以自动识别大小写,这样就再也不用不停的大小写切换了.路径补全如果遇到相同开头的路径了,多按几次tab键是可以直接选择的,而不像以前只能再不断的输入字母直到路径唯一.命令补全功能也很强大,它可以理解大多数的命令参数.比如你想杀掉java的进程,以前需要先输入<code>ps</code>命令找到<code>java</code>进程的<code>PID</code>.然后执行<code>kill PID</code>来杀掉进程.使用zsh可以直接输入<code>kill java</code>+tab键,他会列出现在所有的java进程,一个回车,zsh会自动的替换为进程的pid.</li>
<li>目录浏览和跳转,在命令行中输入d会列出你再这个会话里面访问过的目录列表,并且前面还有序号.接下来你只需要输入序号,就可以直接跳转到当前目录了.这样就可以直达很多地方,非常的方便.以前需要一步一步的<code>cd</code>.</li>
<li>支持直接输入<code>..</code>或<code>...</code>,或者直接输入当前目录的名字,基本上再也不需要cd命令了.以前经常不小心在<code>cd ..</code>中间没有加上空格.命令不起作用.这个就再也不会出现这种情况了.</li>
<li>智能跳转,在安装了autojump之后,配合zsh,会自动记录你访问过的目录.然后它自动的构建一个遍历树结构.以后你直接通过 j+目录名 就可以直接进行目录的跳转了.大多数情况下还是比较靠谱的.比如你访问过<code>/Application/tomcat/bin</code>.  那么你直接输入<code>j tbin</code>它就能自动的跳转到那去,非常的方便.</li>
<li><code>ctrl+r</code>可以搜索你以前输入过的命令,并重新执行. 比如你以前输入过<code>nano ~/.zshrc</code>.那么现在你只要点击<code>ctrl+r</code>后,输入<code>zsh</code> 就可以直接显示出<code>nano ~/.zshrc</code>,一个回车就重复执行了.</li>
</ul>
</li>
</ol>
<h2 id="总结">总结</h2><p>其实基于Unix的<code>MacOs</code> 真的非常适合我们程序猿的使用(dotNet的除外).它不光提供了方便好用的GUI环境,还提供了强大的类<code>Unix</code>的命令行操作.很多Linux上的操作或命令或经验,基本上可以直接在Macos上使用.对于我们Java开发来说,什么<code>activemq</code> <code>elasticsearch</code> <code>flume</code> <code>hadoop</code> <code>JBOSS</code> <code>kafka</code> <code>mongodb</code> <code>neo4j</code> <code>redis</code> <code>tomcat</code> <code>zookeeper</code>些,基本上都可以直接下载下来然后运行<code>sh</code>就可以了.像<code>redis</code>这些需要编译的,在你安装过<code>xcode</code>的情况下,基本上一个<code>make</code>命令就搞定了.<br>如果没有试过,建议大家可以先装一个黑苹果试一试.我相信用过一段时间后,会喜欢上在Mac上做开发的.<br>MacOS绝不不仅仅是一个装逼的花瓶!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MacOS下JAVA开发使用经验(二)">MacOS下JAVA开发使用经验(二)</h1><p><a href="http://sunxiang0918.cn/2015/09/21/MacOS下JAVA开发使用经验(一">上一篇文章</a>)写了最常用的一些工具,接下来再介绍一下提高开发生产力的工具.</p>
<h2 id="软件">软件</h2><h3 id="BetterZip">BetterZip</h3><p>这个是MAC下很常用的压缩/解压的软件.它对于Windows下的中文支持的比较好.<br>基本上没有遇到在Windows下压缩的中文字符,到Mac下就无法打开的问题了.<br>同时他也支持rar格式. 对于我们JAVA的各种<code>ear</code>,<code>war</code>,<code>jar</code>等 都是可以直接打开,然后编辑的.当双击某个jar中的xml文件后会自动打开关联的文件编辑器,然后保存文本编辑器也会自动的更新jar包.</p>
<p><img src="/img/2015/10/11/1.png" alt=""></p>
<h3 id="Beyond_Compare">Beyond Compare</h3><p>这个是我们搞IT的大杀器.以前只有在Windows上有,当时为了这一个软件,我不得不装上了虚拟机.<br>不得不说,用过这么多文件比较工具,这个始终是神话般的存在.什么<code>DiffMerge</code> <code>FileMerge</code> <code>Araxis Merge</code> <code>Kaleidoscope</code> 都弱爆了.<br>这个工具可以配合你的<code>sourceTree</code>等代码管理工具使用,直接清晰地对比和合并代码.同时也可以和<code>JD</code>反编译工具配合直接对比<code>class</code>文件的差异(这个可以参考我的<a href="http://sunxiang0918.cn/2014/09/20/在MAC下使用beyondcompare比较JAVA-Class文件/">另一篇文章</a>).</p>
<p><img src="/img/2015/10/11/2.png" alt=""></p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="MAC" scheme="http://sunxiang0918.github.io/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Redis集群部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/10/03/Redis%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/10/03/Redis集群部署/</id>
    <published>2015-10-03T06:24:35.000Z</published>
    <updated>2015-10-12T14:25:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Redis集群部署">Redis集群部署</h1><p>Redis作为目前最常用的内存NOSQL数据库,使用的场景非常的广泛.但是在3.0以前官方一直都是没有集群的方案的.相当于是一个单机内存数据库.为了其高可用,集群的部署是非常有必要的.因此,各种第三方厂商都推出了自己的集群方案.使用的最多的就是<code>豌豆荚</code>开源的<code>Codis</code>,<code>Twitter</code>开源的<code>Twemproxy</code>,<code>Netflix</code>的<code>Dynamo</code>.</p>
<p>目前Redis是<code>3.0.4</code>版本,其中已经自带了<code>Redis Cluster</code>.但是官方的方案有一些架构上的问题.</p>
<ul>
<li>首先,官方方案是完全的去中心化的,依靠自己Server的网络通信来进行同步.那么,在节点比较多的情况下,性能上是有影响的.</li>
<li>其二,一个redis进程既负责读写数据又负责集群交互，虽然设计者已经尽可能简化了代码和逻辑，但还是让redis从一个内存NoSQL变成了一个分布式NoSQL.</li>
<li>其三,官方方案没有采用一致性哈希,而是预分配slot的形式来进行分片.新节点的加入不是自动的,依赖于外部的ruby脚本.</li>
<li>其四,集群版本和单机版本数据不兼容,客户端不兼容.它的集群分发依赖于客户端的驱动. 目前只有JAVA的<code>Jedis Driver</code>支持了<code>Redis Cluster</code>的连接.而<code>spring-data-redis</code>目前也还没有支持官方方案.因此我们不能直接调用.</li>
<li>其五,集群至少要分三片,加上主从备份.也就是说至少需要6个节点才能组建<code>Redis</code>集群.</li>
</ul>
<p>从上面可以看出,目前官方的方案.并不适合我们.它现在还不稳定,开源社区的支持也比较少.<br>从其他三方的方案中进行对比,最后选择<code>Codis</code>作为我们<code>Redis</code>集群部署的方案.</p>
<a id="more"></a>
<h2 id="官方集群方案的部署">官方集群方案的部署</h2><p>虽然目前我们不会使用官方的方案,但是不排除以后会使用.毕竟是官方的东西,应该要靠谱些.</p>
<ol>
<li><p>下载 并编译最新的Redis. 由于Redis是C写的.并且网上只有源码.因此,最好是直接下载源码到<code>类unix</code>机器上,然后调用 <code>sudo make</code> 命令自动的编译出可运行的版本.</p>
</li>
<li><p>最少集群6个节点,因此在我的磁盘上建立一个<code>redis-test</code>文件夹.然后建立6个子文件夹,作为6个节点.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir redis-test</span><br><span class="line"><span class="built_in">cd</span> redis-test</span><br><span class="line">mkdir <span class="number">7000</span> <span class="number">7001</span> <span class="number">7002</span> <span class="number">7003</span> <span class="number">7004</span> <span class="number">7005</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后拷贝6分编译好的redis到各个目录中去.</p>
</li>
<li><p>修改redis.conf文件.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port <span class="number">7005</span> </span><br><span class="line">pidfile /Volumes/EXCHANGE/redis-test/<span class="number">7000</span>/redis.pid </span><br><span class="line">cluster-enabled yes  </span><br><span class="line"><span class="comment"># 和端口对应  </span></span><br><span class="line">cluster-config-file nodes.conf  </span><br><span class="line">cluster-node-timeout <span class="number">5000</span>  </span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改好后,进入每一个的src文件夹,执行<code>./redis-server ../redis.conf</code> 启动6个服务.</p>
</li>
<li><p>随便找一个节点的src目录,找到<code>redis-trib.rb</code>文件.然后执行:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas <span class="number">1</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span></span><br></pre></td></tr></table></figure>
<p> 其中的<code>--replicas 1</code>指的是从服务的数量.</p>
<p> 执行了这句后,会显示出集群的分布情况.</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span>: OK</span><br><span class="line">Connecting to node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span>: OK</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on <span class="number">6</span> nodes...</span><br><span class="line">Using <span class="number">3</span> masters:</span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span></span><br><span class="line"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span></span><br><span class="line">Adding replica <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span> to <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span></span><br><span class="line">Adding replica <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span> to <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span></span><br><span class="line">Adding replica <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span> to <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span></span><br><span class="line">M: d450eaf8b29ccc57c5ab851868a0e23b41d0f50c <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span></span><br><span class="line">   slots:<span class="number">0</span>-<span class="number">5460</span> (<span class="number">5461</span> slots) master</span><br><span class="line">M: b4f505a8bfbc58dcd65c0a106f284ae1fe3efe1b <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span></span><br><span class="line">   slots:<span class="number">5461</span>-<span class="number">10922</span> (<span class="number">5462</span> slots) master</span><br><span class="line">M: e81eea0243d2976daca5b349ec0bc2d109ac81d0 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span></span><br><span class="line">   slots:<span class="number">10923</span>-<span class="number">16383</span> (<span class="number">5461</span> slots) master</span><br><span class="line">S: <span class="number">52</span>a634c534ca5db005dbc31494676e08454ebfa4 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span></span><br><span class="line">   replicates d450eaf8b29ccc57c5ab851868a0e23b41d0f50c</span><br><span class="line">S: <span class="number">270</span>c10d1f3b85438b74b8fd5c9d91a3e0ce8a0da <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span></span><br><span class="line">   replicates b4f505a8bfbc58dcd65c0a106f284ae1fe3efe1b</span><br><span class="line">S: e6eae15e4883<span class="built_in">cd</span>408fe889e85565a38f6e030de7 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span></span><br><span class="line">   replicates e81eea0243d2976daca5b349ec0bc2d109ac81d0</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span>)</span><br><span class="line">M: d450eaf8b29ccc57c5ab851868a0e23b41d0f50c <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7000</span></span><br><span class="line">   slots:<span class="number">0</span>-<span class="number">5460</span> (<span class="number">5461</span> slots) master</span><br><span class="line">M: b4f505a8bfbc58dcd65c0a106f284ae1fe3efe1b <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7001</span></span><br><span class="line">   slots:<span class="number">5461</span>-<span class="number">10922</span> (<span class="number">5462</span> slots) master</span><br><span class="line">M: e81eea0243d2976daca5b349ec0bc2d109ac81d0 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7002</span></span><br><span class="line">   slots:<span class="number">10923</span>-<span class="number">16383</span> (<span class="number">5461</span> slots) master</span><br><span class="line">M: <span class="number">52</span>a634c534ca5db005dbc31494676e08454ebfa4 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7003</span></span><br><span class="line">   slots: (<span class="number">0</span> slots) master</span><br><span class="line">   replicates d450eaf8b29ccc57c5ab851868a0e23b41d0f50c</span><br><span class="line">M: <span class="number">270</span>c10d1f3b85438b74b8fd5c9d91a3e0ce8a0da <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7004</span></span><br><span class="line">   slots: (<span class="number">0</span> slots) master</span><br><span class="line">   replicates b4f505a8bfbc58dcd65c0a106f284ae1fe3efe1b</span><br><span class="line">M: e6eae15e4883<span class="built_in">cd</span>408fe889e85565a38f6e030de7 <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7005</span></span><br><span class="line">   slots: (<span class="number">0</span> slots) master</span><br><span class="line">   replicates e81eea0243d2976daca5b349ec0bc2d109ac81d0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All <span class="number">16384</span> slots covered.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当出现:<code>Can I set the above configuration? (type &#39;yes&#39; to accept):</code>的时候,输入<code>yes</code>.然后他就会自动的通知各个节点,自发组成集群.</p>
<p>到此,redis集群的官方方案就部署好了.<br>如果安装过程中出现:<code>/System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/rubygems/core_ext/kernel_require.rb:55:in</code>require’: cannot load such file — redis (LoadError)<code>.那是ruby缺少</code>redis<code>的依赖.
在控制台输入</code>gem install redis`即可.</p>
<h2 id="codis集群方案的部署">codis集群方案的部署</h2><p>Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有明显的区别.上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务.</p>
<p>Codis 由四部分组成:</p>
<ul>
<li>Codis Proxy (codis-proxy)</li>
<li>Codis Manager (codis-config)</li>
<li>Codis Redis (codis-server)</li>
<li>ZooKeeper</li>
</ul>
<p>codis-proxy 是客户端连接的 Redis 代理服务, codis-proxy 本身实现了 Redis 协议, 表现得和一个原生的 Redis 没什么区别 (就像 Twemproxy), 对于一个业务来说, 可以部署多个 codis-proxy, codis-proxy 本身是无状态的.</p>
<p>codis-config 是 Codis 的管理工具, 支持包括, 添加/删除 Redis 节点, 添加/删除 Proxy 节点, 发起数据迁移等操作. codis-config 本身还自带了一个 http server, 会启动一个 dashboard, 用户可以直接在浏览器上观察 Codis 集群的运行状态.</p>
<p>codis-server 是 Codis 项目维护的一个 Redis 分支, 基于 2.8.21 开发, 加入了 slot 的支持和原子的数据迁移指令. Codis 上层的 codis-proxy 和 codis-config 只能和这个版本的 Redis 交互才能正常运行.</p>
<p>Codis 依赖 ZooKeeper 来存放数据路由表和 codis-proxy 节点的元信息, codis-config 发起的命令都会通过 ZooKeeper 同步到各个存活的 codis-proxy.</p>
<p>需要注意的是,codis的proxy是无状态的,当一个分片的master挂掉的时候,codis不会自动的将某个slave升级成master.不过他提供了一个解决方案:<a href="https://github.com/ngaut/codis-ha" target="_blank" rel="external">codis-ha</a>.这是一个通过codis开放的api实现自动切换主从的工具。该工具会在检测到master挂掉的时候将其下线并选择其中一个slave提升为master继续提供服务。但是只是在每一个分片是一主一从两台的情况下才有效.否则,该分片内其他slave实例是不会自动改变状态的，这些slave仍将试图从旧的master上同步数据，因而会导致分片内新的master和其他slave之间的数据不一致。因为redis的slave of命令切换master时会丢弃slave上的全部数据，从新master完整同步，会消耗master资源。因此建议在知情的情况下手动操作。使用 codis-config server add <group_id> <redis_addr> slave 命令刷新这些节点的状态即可。codis-ha不会自动刷新其他slave的状态。</redis_addr></group_id></p>
<hr>
<ol>
<li><p>由于codis是由GO语言写的,因此,要运行codis首先需要的就是安装<code>go</code>语言环境.</p>
<p> 在类<code>unix</code>机器上都有现成的安装包可以安装.<br> 比如<code>Macos</code> 在终端中输入<code>brew install go</code> 即可. (安装过程中需要访问<code>https://go.googlesource.com/tools.git</code>,方法你懂的)</p>
</li>
<li><p>设置GO的workspace路径.在<code>~/.bash_profiler</code>下增加<code>export GOPATH=&quot;/Volumes/WORKSPACE/openSourceWorkspace/GoWorkspace&quot;</code> 注意$GOPATH是本机所有go项目（包括项目依赖的第三方库）的所在目录，而非单纯codis的所在目录。</p>
</li>
<li>执行下面的命令下载codis源码并编译.它会自动的下载源码以及依赖包.</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go get -u <span class="operator">-d</span> github.com/wandoulabs/codis</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/wandoulabs/codis</span><br><span class="line">./bootstrap.sh</span><br><span class="line">make gotest</span><br></pre></td></tr></table></figure>
<ol>
<li><p>执行完命令后,会在codis/bin下生成三个文件<code>codis-config</code> <code>codis-proxy</code> <code>codis-server</code>. <code>assets</code>文件夹里面存放的是<code>dashboard</code>服务所需要的静态文件.</p>
</li>
<li><p>默认情况下 这些命令都会读取<code>config.ini</code>里面的配置.配置很简单,按照里面的注释改就可以了.</p>
</li>
<li>启动ZK.</li>
<li>启动<code>dashboard</code>,执行 <code>./bin/codis-config dashboard</code>,就会启动dashboard</li>
<li>初始化 slots , 执行 <code>./bin/codis-config slot init</code>，该命令会在zookeeper上创建slot相关信息.</li>
<li>开始启动<code>Codis Redis</code>.执行<code>./bin/codis-server</code>,就启动的.这个就和官网的一样. 配置文件也可以跟在后面.比如:<code>./bin/codis-server redis.config</code></li>
<li><p>添加 <strong>Redis Server Group</strong> , 每一个 <strong>Server Group</strong> 作为一个 Redis 服务器组存在, 只允许有一个 <strong>master</strong>, 可以有<strong>多个 slave</strong>, <strong>group id</strong> 仅<strong>支持大于等于1的整数</strong>.这个步骤可以通过<code>dashboard</code>来增加,也可以使用命令行.比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/codis-config server add <span class="number">1</span> localhost:<span class="number">6379</span> master</span><br><span class="line">bin/codis-config server add <span class="number">1</span> localhost:<span class="number">6380</span> slave</span><br><span class="line">bin/codis-config server add <span class="number">2</span> localhost:<span class="number">6479</span> master</span><br><span class="line">bin/codis-config server add <span class="number">2</span> localhost:<span class="number">6480</span> slave</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样就增加了4个节点,并且分成两片,每片一主一从.</p>
<ol>
<li><p>设置 server group 服务的 slot 范围 Codis 采用 Pre-sharding 的技术来实现数据的分片, 默认分成 1024 个 slots (0-1023), 对于每个key来说, 通过以下公式确定所属的 Slot Id : SlotId = crc32(key) % 1024 每一个 slot 都会有一个且必须有一个特定的 server group id 来表示这个 slot 的数据由哪个 server group 来提供.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ bin/codis-config slot range-set <span class="number">0</span> <span class="number">511</span> <span class="number">1</span> online</span><br><span class="line">$ bin/codis-config slot range-set <span class="number">512</span> <span class="number">1023</span> <span class="number">2</span> online</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>同样,可以在界面上进行操作</p>
<ol>
<li><p>启动 codis-proxy (注意,如果zk的session时间设置太短的话,proxy可能启动不起来.)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/codis-proxy -c config.ini -L ./<span class="built_in">log</span>/proxy.log  --cpu=<span class="number">8</span> --addr=<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">19000</span> --http-addr=<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">11000</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>到此就集群完毕.</p>
<hr>
<p>接下来就是客户端的调用了.<br>由于codis依赖了zk作为服务的发现方.因此,整个集群的节点状态都是在zk中有的.</p>
<p>它自身也提供了一个JAVA的实现,叫<a href="https://github.com/wandoulabs/codis/tree/master/extern/jodis" target="_blank" rel="external">jodis</a>.通过这个,就可以关联<code>jedis Driver</code>.并且获取当前可用的<code>codis-server</code>.<br>不过目前这个jodis还没有提供与spring的集成.这个需要我们自己来开发.    </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Redis集群部署">Redis集群部署</h1><p>Redis作为目前最常用的内存NOSQL数据库,使用的场景非常的广泛.但是在3.0以前官方一直都是没有集群的方案的.相当于是一个单机内存数据库.为了其高可用,集群的部署是非常有必要的.因此,各种第三方厂商都推出了自己的集群方案.使用的最多的就是<code>豌豆荚</code>开源的<code>Codis</code>,<code>Twitter</code>开源的<code>Twemproxy</code>,<code>Netflix</code>的<code>Dynamo</code>.</p>
<p>目前Redis是<code>3.0.4</code>版本,其中已经自带了<code>Redis Cluster</code>.但是官方的方案有一些架构上的问题.</p>
<ul>
<li>首先,官方方案是完全的去中心化的,依靠自己Server的网络通信来进行同步.那么,在节点比较多的情况下,性能上是有影响的.</li>
<li>其二,一个redis进程既负责读写数据又负责集群交互，虽然设计者已经尽可能简化了代码和逻辑，但还是让redis从一个内存NoSQL变成了一个分布式NoSQL.</li>
<li>其三,官方方案没有采用一致性哈希,而是预分配slot的形式来进行分片.新节点的加入不是自动的,依赖于外部的ruby脚本.</li>
<li>其四,集群版本和单机版本数据不兼容,客户端不兼容.它的集群分发依赖于客户端的驱动. 目前只有JAVA的<code>Jedis Driver</code>支持了<code>Redis Cluster</code>的连接.而<code>spring-data-redis</code>目前也还没有支持官方方案.因此我们不能直接调用.</li>
<li>其五,集群至少要分三片,加上主从备份.也就是说至少需要6个节点才能组建<code>Redis</code>集群.</li>
</ul>
<p>从上面可以看出,目前官方的方案.并不适合我们.它现在还不稳定,开源社区的支持也比较少.<br>从其他三方的方案中进行对比,最后选择<code>Codis</code>作为我们<code>Redis</code>集群部署的方案.</p>]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://sunxiang0918.github.io/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kafka集群部署]]></title>
    <link href="http://sunxiang0918.github.io/2015/09/28/Kafka%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>http://sunxiang0918.github.io/2015/09/28/Kafka集群部署/</id>
    <published>2015-09-28T14:12:16.000Z</published>
    <updated>2015-10-12T14:21:17.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Kafka集群">Kafka集群</h1><p>Kafka作为新一代的消息系统,最初是由LinkedIn公司开发,之后开源成为Apache的顶级项目.<br>它与传统的消息系统相比,有以下不同:</p>
<ul>
<li>它被设计为一个分布式系统，易于向外扩展；</li>
<li>它同时为发布和订阅提供高吞吐量；</li>
<li>它支持多订阅者，当失败时能自动平衡消费者；</li>
<li>它将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。</li>
</ul>
<p>同时.Kafka提供了多种客户端的Driver.这点比阿里的<code>RocketMQ</code>要好.而阿里的RocketMQ在性能和使用方面优于Kafka,不过只提供JAVA的客户端.</p>
<p>而我们系统中不光只有JAVA应用,因此,在我们的系统中,决定使用kafka作为我们的消息服务.</p>
<a id="more"></a>
<h2 id="集群部署">集群部署</h2><ol>
<li>启动Zookeeper服务<br>　　集群部署也是需要启用Zookeeper。
　　</li>
<li><p>启动Kafka broker服务<br> 在不同的机器上拷贝kafka.然后修改它的<code>$KAFKA_HOME/config/server.properties</code>文件.<br> 主要是修改以下几个地方:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务的序号,这个需要在集群中保证唯一</span></span><br><span class="line">brokerid = <span class="number">0</span></span><br><span class="line"><span class="comment">#服务的端口,如果是一台机器上只启动一个kafka,可以不修改</span></span><br><span class="line">port = <span class="number">1234</span></span><br><span class="line"><span class="comment">#服务的数据存放位置,默认可以不修改</span></span><br><span class="line">log.dir = /tmp/kafka_<span class="built_in">log</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>然后调用 <span class="escape">`.</span>/bin/kafka-server-start.sh conf/server.properties<span class="escape">` </span>即可启动
</code></pre><ol>
<li><p>然后就可以创建<code>Topic</code>了. </p>
<p> <code>bin/kafka-topics.sh --create --zookeeper 127.0.0.1:2181 --replication-factor 2 --partitions 2 --topic testTopic</code></p>
<p> 其中<code>replication-factor</code>表示要在几个节点上存放数据.一般有几个节点就配置成几个就可以了.<br> <code>partitions</code>就表示分片.一般配置成1就可以了.</p>
</li>
<li><p>到此,kafka的集群就搭建完成了.然后就可以使用我们的代码来进行试验了.</p>
<p> Spring配置:</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">	<span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"jmsTemplate"</span> <span class="attribute">class</span>=<span class="value">"com.sobey.jcg.kafka.util.KafkaTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"127.0.0.1:8092,127.0.0.1:8093"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"defaultThreadPool"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 核心线程数，默认为1 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"corePoolSize"</span> <span class="attribute">value</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大线程数，默认为Integer.MAX_VALUE --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxPoolSize"</span> <span class="attribute">value</span>=<span class="value">"900"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 队列最大长度，一般需要设置值&gt;=notifyScheduledMainExecutor.maxNum；默认为Integer.MAX_VALUE --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"queueCapacity"</span> <span class="attribute">value</span>=<span class="value">"50"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 线程池维护线程所允许的空闲时间，默认为60s --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"keepAliveSeconds"</span> <span class="attribute">value</span>=<span class="value">"60"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者     --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"rejectedExecutionHandler"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- AbortPolicy:直接抛出java.util.concurrent.RejectedExecutionException异常 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- CallerRunsPolicy:主线程直接执行该任务，执行完之后尝试添加下一个任务到线程池中，可以有效降低向线程池内添加任务的速度 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DiscardOldestPolicy:抛弃旧的任务、暂不支持；会导致被丢弃的任务无法再次被执行 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DiscardPolicy:抛弃当前任务、暂不支持；会导致被丢弃的任务无法再次被执行        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"customConsumerMessageListener"</span> <span class="attribute">class</span>=<span class="value">"com.xxx.jcg.kafka.util.KafkaMessageListenerAdapter"</span> <span class="attribute">scope</span>=<span class="value">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.xxx.jcg.kafka.test.CustomConsumer"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--ZK的链接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"zookeeperConnect"</span> <span class="attribute">class</span>=<span class="value">"com.sobey.jcg.kafka.util.ZookeeperConnect"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"zkConnect"</span> <span class="attribute">value</span>=<span class="value">"127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"zkConnectionTimeout"</span> <span class="attribute">value</span>=<span class="value">"6000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"zkSessionTimeout"</span> <span class="attribute">value</span>=<span class="value">"400"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"zkSyncTime"</span> <span class="attribute">value</span>=<span class="value">"200"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.sobey.jcg.kafka.util.KafkaMessageListenerContainer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"zookeeperConnect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"defaultThreadPool"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"listener"</span> <span class="attribute">ref</span>=<span class="value">"customConsumerMessageListener"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"topic"</span> <span class="attribute">value</span>=<span class="value">"kafkatopic"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.sobey.jcg.kafka.util.KafkaMessageListenerContainer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"zookeeperConnect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"defaultThreadPool"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"listener"</span> <span class="attribute">ref</span>=<span class="value">"customConsumerMessageListener"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"topic"</span> <span class="attribute">value</span>=<span class="value">"clusterTest"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br><span class="line">	```	</span><br><span class="line">	</span><br><span class="line">	测试代码:</span><br><span class="line">	</span><br><span class="line">	```java</span><br><span class="line">	public class JMSSenderTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        CustomSpringContextUtil.getContext("applicationContext.xml").getBean("jmsTemplate");</span><br><span class="line"></span><br><span class="line">        UserInfo userInfo = new UserInfo("aaa",17,true);</span><br><span class="line">        </span><br><span class="line">        JMSSender.getInstance().sendMessage(userInfo,"clusterTest");</span><br><span class="line"></span><br><span class="line">        JMSSender.getInstance().sendMessage("这个是String","clusterTest");</span><br><span class="line"></span><br><span class="line">        HashMap<span class="tag">&lt;<span class="title">Object,Object</span>&gt;</span> objectObjectMap = new HashMap<span class="tag">&lt;<span class="title">Object,</span> <span class="attribute">Object</span>&gt;</span>();</span><br><span class="line">        objectObjectMap.put("name","bbbb");</span><br><span class="line">        objectObjectMap.put("age",20);</span><br><span class="line">        objectObjectMap.put("gender",true);</span><br><span class="line">        JMSSender.getInstance().sendMessage(objectObjectMap,"clusterTest");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>如果正常的话,就会发送消息到kafka中. 并且程序能有消费的记录.
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Kafka集群">Kafka集群</h1><p>Kafka作为新一代的消息系统,最初是由LinkedIn公司开发,之后开源成为Apache的顶级项目.<br>它与传统的消息系统相比,有以下不同:</p>
<ul>
<li>它被设计为一个分布式系统，易于向外扩展；</li>
<li>它同时为发布和订阅提供高吞吐量；</li>
<li>它支持多订阅者，当失败时能自动平衡消费者；</li>
<li>它将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。</li>
</ul>
<p>同时.Kafka提供了多种客户端的Driver.这点比阿里的<code>RocketMQ</code>要好.而阿里的RocketMQ在性能和使用方面优于Kafka,不过只提供JAVA的客户端.</p>
<p>而我们系统中不光只有JAVA应用,因此,在我们的系统中,决定使用kafka作为我们的消息服务.</p>]]>
    
    </summary>
    
      <category term="Kafka" scheme="http://sunxiang0918.github.io/tags/Kafka/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacOS下JAVA开发使用经验(一)]]></title>
    <link href="http://sunxiang0918.github.io/2015/09/21/MacOS%E4%B8%8BJAVA%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C(%E4%B8%80)/"/>
    <id>http://sunxiang0918.github.io/2015/09/21/MacOS下JAVA开发使用经验(一)/</id>
    <published>2015-09-21T13:38:36.000Z</published>
    <updated>2015-10-11T15:46:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MacOS下JAVA开发使用经验(一)">MacOS下JAVA开发使用经验(一)</h1><p>我是大概在2007年左右接触到MACOS的.当时先是折腾了半年的<code>Ubuntu</code>,然后在一个偶然的机会发现了<code>MacOS 10.4.6</code>,看到界面截图,简直是惊为天人.刚好那个时候苹果开始使用Intel的CPU.让我们有机会品尝了一下黑苹果的滋味.虽然在我的<code>HP DV2621</code>笔记本上装黑苹果又卡又热,但是还是让我深深的喜欢上了这个系统.到2009年,实在是憋不住了,买了我人生中的第一台macbook <code>mb990</code>.然后毕业后到公司上班也申请一直使用苹果系统.反正我是搞JAVA的,到是和操作系统关系不大,反而我到是觉得搞JAVA开发,Mac比Win还好用些,这么多年来也是越用越顺手.这里分享下我平时使用的一些经验或软件吧~</p>
<h2 id="硬件">硬件</h2><p>这部分没啥好说的,苹果的电脑就这么几个型号.不过对于我们上班的来说,还是推荐使用rMBP+24寸以上的显示器的组合. 苹果的视网膜屏确实相当牛逼,看代码完全是种享受.<br>配置的话,只要不是macmini和air以及现在新出的macbook的话,应该都还OK.我个人是使用的<code>2014年rMBP 15寸低配</code>那款.编译和运行的速度秒杀大多数的机器.<br>而对于键盘和鼠标的话,没有什么特殊的要求.机械键盘我还没用过,不好评价的.鼠标的话,我用的是苹果的<code>Magic Mouse</code>,有人说那鼠标完全是反人类的,其实我觉得还好,现在平均每天要用10个小时以上,也没觉得特别的不适.使用这个鼠标最大的好处肯定就是它的多点触控了.几个工具全屏再加上几个多桌面,使用那个鼠标很容易的就可以做切换.</p>
<a id="more"></a>
<h2 id="系统">系统</h2><p>系统的话就不断的保持最新的正式版即可.升级一般来说都可以放心,我从以前的<code>10.5</code>升级到<code>10.10</code>都没遇到过什么问题.<br>然后就是一些系统的设置了.</p>
<h3 id="Docker自动放大">Docker自动放大</h3><p>由于使用的程序比较多,所以Docker上有一堆的图标,自然每一个图标就比较小,因此需要把自动放大的功能给打开.而且也不能放到屏幕的左右两边,否则就会小的没法看…<br><img src="/img/2015/09/21/1.png" alt=""></p>
<h3 id="屏幕四个角触发操作">屏幕四个角触发操作</h3><p>这个是MacOS的一个比较实用的功能,就是把鼠标移动到屏幕的四个角上就可以触发一些特定的操作.比如显示桌面啊,launchpad啊等等.<br>我一般都是把左下角设置为<code>显示桌面</code>,左上角设置为<code>MissionControl</code>,右上角设置为<code>Launchpad</code><br><img src="/img/2015/09/21/2.png" alt=""></p>
<h3 id="将F1_F2等作为标准按钮">将F1 F2等作为标准按钮</h3><p>不知道是出于什么原因,MacOS系统刚装上的时候,键盘最上面的一排F1,F2的按钮是音量键这些.这完全就没法用嘛.所以必须设置成为标准的F1 F2功能. 这个只需要在<code>设置-键盘</code> 里面设置即可.<br><img src="/img/2015/09/21/3.png" alt=""></p>
<h3 id="设置浏览器的刷新快捷键">设置浏览器的刷新快捷键</h3><p>在默认的情况下,Safari和Chrome都没有提供<code>F5</code>刷新页面的功能.这让我们在浏览网页或修改页面的时候很难受,因此需要增加上这些快捷键. 这在<code>设置-键盘-快捷键</code>中设置.<br><img src="/img/2015/09/21/4.png" alt=""></p>
<h3 id="鼠标和触控板的轻触和滚动方向">鼠标和触控板的轻触和滚动方向</h3><p>自从Macos10.8以后,苹果把鼠标和触控板的滑动方向给反向了,也就是鼠标向下滑动,页面是往上走的.这和<code>Ipad</code>这些操作是一样的,但是我总觉得在电脑上有点奇怪.所以需要修改下. 同时还有就是鼠标和触控板的多点控制,比如两个指头是切换屏幕啊,轻触是右键啊等等 都是在 <code>设置-鼠标</code>和<code>设置-触控板</code>里面设置.<br><img src="/img/2015/09/21/5.png" alt=""></p>
<p><img src="/img/2015/09/21/6.png" alt=""></p>
<h3 id="增加状态栏直接锁定屏幕">增加状态栏直接锁定屏幕</h3><p>在公司上班,谁都有离开位置的时候,为了防止电脑可能被其他人随便操作,一定的安全措施还是需要的.最简单的方法就是直接把电脑屏幕给合上,那么再次打开的时候就要求输入密码.但是这样电脑就会休眠,而且如果外接了显示器的,有可能本来笔记本就是合上的(在mbp接上电源,外接键盘和鼠标的情况下.如果合并笔记本屏幕,那么就会单输出图像到外接显示器,这个时候系统是不会休眠的).那么还有一个方法就是使用<code>钥匙串</code>的功能,一键锁定计算机,并且关闭屏幕显示. 这个就是在<code>应用程序-实用工具-钥匙串访问</code>中.<br><img src="/img/2015/09/21/7.png" alt=""></p>
<p><img src="/img/2015/09/21/8.png" alt=""></p>
<h2 id="软件">软件</h2><p>软件即是工具,所谓工欲善其事，必先利其器.好的工具能让你的工作更得心应手.这里就推荐一下我平时所使用的一些工具.</p>
<p>先来看一下我的Docker,我最常用的软件基本上就在这了.<br><img src="/img/2015/09/21/9.png" alt=""></p>
<h3 id="XtraFinder">XtraFinder</h3><p>这个是Finder的增强工具.免费的,提供了很多有用的工具,基本上属于必装.</p>
<ul>
<li>提供了类似于Chrome一样的多标签操作</li>
<li>双击某一个标签,提供了两个标签的联合操作.</li>
<li>支持<code>Command+x</code>的剪切操作</li>
<li>增加了右键<code>新建文件</code>的功能</li>
<li>增加了在当前文件夹直接打开终端的功能</li>
<li>增加了快捷键显示和隐藏系统<code>隐藏文件</code>的功能.</li>
<li>提供了文件夹和文件分开排序的功能<br><img src="/img/2015/09/21/10.png" alt=""></li>
</ul>
<h3 id="1Password">1Password</h3><p>这个又是一个神器,他可以帮你保存所有的密码.这样你只需要记住一个密码就可以了,其他的密码都交由它来保存.它同时有safari和chrome的插件,以及IOS端的程序.通过加密了的文件使用iCloud进行同步,没有中心的服务器.自从CSDN被拖库而被泄露了一堆密码以后,我就开始使用这个软件,把我所有的账号都通过它设置成14位的不同的随机密码,这样减少了一个密码泄露,全部玩完的情况.要说这个软件的缺点,那就是卖的有点贵,300多一个好像.不过我觉得还是值了.(网上到是有这个的破解软件,但是如果真想使用这个软件,我建议还是买正版吧.一个用来保存密码的软件使用破解的,我怕里面的密码也一起被”破解”了..)<br><img src="/img/2015/09/21/11.png" alt=""></p>
<p><img src="/img/2015/09/21/12.png" alt=""></p>
<h3 id="Doit-im">Doit.im</h3><p>这个是国内的一个厂商推出的GTD软件.可以和IOS以及Web页面同步.我试用了很多的GTD软件,最后对比下来觉得这个软件做的比较好.提供了很完善的功能,比如<code>收集箱</code> <code>下一步行动</code> <code>明日代办</code> <code>日程</code> <code>项目</code> <code>情景</code> <code>标签</code> <code>子任务</code> <code>优先级</code> 等等.能让我很轻松的管理各种任务,有什么想法了就马上记录到收集箱中.然后再进行进一步的细分,这样就可以始终保持工作有条不紊的进行. BTW,这个软件是收取服务费的,一年100块.</p>
<p><img src="/img/2015/09/21/13.png" alt=""></p>
<h3 id="Teambition">Teambition</h3><p>这个是团队协作的工具,它提供的Mac客户端,其实就是一个Webkit的网页.这点做的就没有Doit.im好,太偷懒了.具体的用法可以参考我另外的一篇博文 <a href="http://sunxiang0918.cn/2015/09/07/使用TeamBition进行敏捷开发/" target="_blank" rel="external">使用TeamBition进行敏捷开发</a></p>
<h3 id="邮件">邮件</h3><p>这个是Macos自带的程序,前段时间还使用过腾讯的FoxMail,也还可以.两个的功能都差不多,随便选择一个就可以了.我是不想再安装一个软件,所以选择了自带的Mail程序.<br>需要注意的是,最好在Mail程序中设置一个你的签名.并且在签名中增加一个Unicode的字符.这样在发送邮件的时候,Mail会把你的邮件使用UTF-8的格式来传送,这样Win端的一些工具收到后就不会有乱码的问题.<br><img src="/img/2015/09/21/14.png" alt=""></p>
<h3 id="Reeder">Reeder</h3><p>这个是目前最好用的RSS阅读软件了.他可以订阅各种的来源,自从google的死了后,现在我使用的是Feedly提供的服务.还算稳定可靠.同样提供了IOS端的程序,两个间可以进行同步.虽然现在都在说RSS已经过时了,但是我觉得RSS还能活跃很久,毕竟这种订阅的信息收集其实是很高效和有用的.<br><img src="/img/2015/09/21/15.png" alt=""></p>
<h3 id="Safari">Safari</h3><p>没啥好说的,系统自带的游览器.速度快,稳定.配合iCloud和handoff功能,在IOS设备和笔记本间无缝的切换,体验相当的舒服.然后我把搜索引擎设置成为了百度.这意味着平时的生活和娱乐就使用的safari.</p>
<h3 id="Chrome">Chrome</h3><p>对比Safari,我更倾向于把Chrome当成一个工作相关的工具.首先就是把搜索引擎设置为google,然后安装上<code>PostMan</code>,<code>JSON-handle</code>,<code>OneTab</code>,<code>红杏</code>等扩展插件,然后再配合自带的<code>审查元素</code>功能.基本上我遇得到的一些界面分析,Rest调用,JSON格式化等等都能应付了.</p>
<h3 id="QQ和微信">QQ和微信</h3><p>这个没啥说的,国内基本上是必装的软件了.</p>
<h3 id="EverNote">EverNote</h3><p>我是把EverNote当做知识库来使用,配合它的标签和强大的搜索功能.基本上能很快的找到我以前记录的东西.这东西也是有IOS端的.平时看知乎或网页等等,看到感兴趣需要记录的了,可以直接发送到everNote中去. 而且我觉得这货在MAC上比在Win上用的顺手.不管是界面还是操作,而且没得广告.<br><img src="/img/2015/09/21/16.png" alt=""></p>
<h3 id="iTunes和网易音乐">iTunes和网易音乐</h3><p>一个是用来听本地音乐的,一个是用来听在线音乐的.现在是没有音乐作为背景,就写不出来代码… T.Tb</p>
<h3 id="IntelliJ_IDEA">IntelliJ IDEA</h3><p>Intellij是我认为最智能的JAVA IDE,推荐所有的Javaer们都尝试尝试.可以最开始从eclipse转过来的时候比较痛苦,但是一旦上手后,就会觉得以前像在使用记事本写代码一样.. IDEA提供了很强大的上下文推导以及Spring等框架的上下文管理,强大的Maven支持,再加上完备的插件支持,自己再多设置几个<code>Live Template</code> 写起代码来那叫一个顺手啊.<br>插件除了自带的,我还安装了<code>Docker Integration</code> <code>FindBugs</code> <code>JProfiler</code> <code>Mybatis plugin</code> <code>RegexpTester</code> <code>Scala</code> <code>ZooKeeper</code>.<br>总之,保证你不后悔使用<code>IntelliJ IDEA</code><br><img src="/img/2015/09/21/17.png" alt=""></p>
<h3 id="XCode">XCode</h3><p>要玩儿IOS编程,当然还是要使用官方的XCode了.当然,说实话,我觉得没有<code>IDEA</code>出的<code>AppCode</code>用起顺手,功能也没有别人的多.不过胜在官方支持,对各个功能,特别是storyboard支持的最好.XCode同样也可以安装插件,首先必装的就是<code>Alcatraz</code>-用来管理插件的插件.可以通过在终端中执行下面的代码来安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh</span><br></pre></td></tr></table></figure>
<p>而后就直接在<code>Windows-Package Manager</code>里面选择需要的插件即可.我使用了这些插件:<br><code>ClangFormat</code> <code>FuzzyAutocomplete</code> <code>HighlightSelectedString</code> <code>LinkedLog</code> <code>OMColorSense</code> <code>OMQuickHelp</code> <code>SFJumpToLine</code> <code>VVDocumenter-Xcode</code> <code>XToDo</code></p>
<p><img src="/img/2015/09/21/18.png" alt=""></p>
<h3 id="Cornerstone">Cornerstone</h3><p>可以说是MacOS下最好用的SVN工具了.他集中式的管理了SVN项目.界面的布局和操作也非常的合理.支持几乎所有的SVN功能.这个工具基本上陪伴了我5年.最多的时候管理了一百多个项目而性能不减.可以说是完爆Win上的同类软件.不过这个软件是付费的,大概60美刀左右.<br><img src="/img/2015/09/21/19.png" alt=""></p>
<h3 id="SourceTree">SourceTree</h3><p>这个软件又是一个神器,用来管理Git的.同Cornerstone一样,也是一个集中式的管理工具.界面布局和操作非常的方便.支持创建,克隆,提交,push,pull,分支,合并等等Git的功能.大大的简化了开发者与代码库之间的操作.同时在Mac的体验也比Win上的相同软件要好的多.最重要的是它是一个免费的软件,堪称业界良心啊.<br><img src="/img/2015/09/21/20.png" alt=""></p>
<h3 id="Pages_Numbers_Keynote">Pages Numbers Keynote</h3><p>苹果办公软件三剑客.我平时写东西都是使用这个软件的.觉得简洁,写出来的效果也很好.特别是Keynote,做出来的演讲稿效果相当的舒服.如果要发给别个交互,发布成为PDF就可以了.</p>
<h3 id="Word_Excel_PowerPoint">Word Excel PowerPoint</h3><p>毕竟公司里面不全都是用的Macos系统,别人写的DOC文件,你还是要打开看的,或者老总发给你的Excel教你填,你也不好意思发个PDF给人家..所以这个软件还是需要保留的.</p>
<h3 id="Fraise_SublimeText">Fraise SublimeText</h3><p>这两个都是文本编辑器,第一个支持最完整的编码格式,以及能很方便的转换各种文本的编码格式,基本上被我用来转换文档格式用了.<br>而SublimeText可以说是一个最强大的文本编辑器.平时看日志,临时改些代码,格式化XML,记录会议纪要等等都是靠它了.<br><img src="/img/2015/09/21/21.png" alt=""></p>
<h3 id="MacDown">MacDown</h3><p>用来书写MarkDown格式的文本的.这个软件是我试用了一堆MAC上的MarkDown软件后选出来的.支持的MarkDown语法算是很完整的了,非在线的编辑器,允许自定义样式和代码高亮的格式,支持各种快捷键操作.总之,非常的好用.我现在基本上所有的文本都是使用MarkDown来记录了.<br><img src="/img/2015/09/21/22.png" alt=""></p>
<h3 id="Parallels_Desktop">Parallels Desktop</h3><p>MacOS上的虚拟机软件,我对比过VMware.觉得这个软件无论是在速度还是系统占用上都有优势.<br>现在虚拟机其实很少使用了,主要就是打开一些非要用IE打开的奇葩网页.然后就是虚拟机上安装一些Linux系统或Oracle数据库来瞎折腾.这样不会影响到实体机.<br><img src="/img/2015/09/21/23.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MacOS下JAVA开发使用经验(一)">MacOS下JAVA开发使用经验(一)</h1><p>我是大概在2007年左右接触到MACOS的.当时先是折腾了半年的<code>Ubuntu</code>,然后在一个偶然的机会发现了<code>MacOS 10.4.6</code>,看到界面截图,简直是惊为天人.刚好那个时候苹果开始使用Intel的CPU.让我们有机会品尝了一下黑苹果的滋味.虽然在我的<code>HP DV2621</code>笔记本上装黑苹果又卡又热,但是还是让我深深的喜欢上了这个系统.到2009年,实在是憋不住了,买了我人生中的第一台macbook <code>mb990</code>.然后毕业后到公司上班也申请一直使用苹果系统.反正我是搞JAVA的,到是和操作系统关系不大,反而我到是觉得搞JAVA开发,Mac比Win还好用些,这么多年来也是越用越顺手.这里分享下我平时使用的一些经验或软件吧~</p>
<h2 id="硬件">硬件</h2><p>这部分没啥好说的,苹果的电脑就这么几个型号.不过对于我们上班的来说,还是推荐使用rMBP+24寸以上的显示器的组合. 苹果的视网膜屏确实相当牛逼,看代码完全是种享受.<br>配置的话,只要不是macmini和air以及现在新出的macbook的话,应该都还OK.我个人是使用的<code>2014年rMBP 15寸低配</code>那款.编译和运行的速度秒杀大多数的机器.<br>而对于键盘和鼠标的话,没有什么特殊的要求.机械键盘我还没用过,不好评价的.鼠标的话,我用的是苹果的<code>Magic Mouse</code>,有人说那鼠标完全是反人类的,其实我觉得还好,现在平均每天要用10个小时以上,也没觉得特别的不适.使用这个鼠标最大的好处肯定就是它的多点触控了.几个工具全屏再加上几个多桌面,使用那个鼠标很容易的就可以做切换.</p>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="MAC" scheme="http://sunxiang0918.github.io/tags/MAC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<翻译>基于内容地址的Docker Registry2.0]]></title>
    <link href="http://sunxiang0918.github.io/2015/09/20/%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AE%B9%E5%9C%B0%E5%9D%80%E7%9A%84Docker-Registry2-0/"/>
    <id>http://sunxiang0918.github.io/2015/09/20/基于内容地址的Docker-Registry2-0/</id>
    <published>2015-09-20T14:18:58.000Z</published>
    <updated>2015-09-20T15:48:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="基于内容地址的Docker_Registry2-0">基于内容地址的Docker Registry2.0</h1><p>由于最近在项目中需要使用<code>Docker</code>,并且需要持续集成,因此就研究了一下Docker的<code>Registry</code>.突然发现<code>V1</code>版本的<a href="https://github.com/docker/docker-registry" target="_blank" rel="external">Registry</a>已经被官方打为<strong>废弃</strong>了.新的第二个版本的<a href="https://github.com/docker/distribution" target="_blank" rel="external">Registry</a>已经开始提供服务.因此就着重的研究了一下这个,无奈现在相关的文档还非常的少.找到一篇日文的文章感觉还不错,因此就翻译了一下.先申明下我日语也就是玩票的性质,肯定有很多不正确的地方,还望海涵.</p>
<hr>
<h2 id="Content_Addressable_DockerイメージとRegistry2-0"><a href="http://deeeet.com/writing/2015/04/20/docker-1_6_distribution/" target="_blank" rel="external">Content Addressable DockerイメージとRegistry2.0</a></h2><p>Docker1.6已经出了.它增加了很多新的功能,比如:容器与镜像的标记(具体更多的信息可以看RancherOS的<a href="http://rancher.com/docker-labels/" target="_blank" rel="external">“Adding Label Support to Docker 1.6”</a>),日志记录的多种驱动等等.这次的Release更新中,我最感兴趣的就是Docker的Image开始基于内容进行寻址(Content-addressable) (<a href="https://github.com/docker/docker/pull/11109" target="_blank" rel="external">#11109</a>)</p>
<p>到目前为止,Docker Registry通过镜像的名字与Tag与Image进行交互(比如:<code>tcnksm/golang:1.2</code>).而Tag是由镜像的作者自己定义的.这就不能保证在相同的Tag下的镜像内容是完全相同的(在GIG中由于使用了commit的哈希值,因此标签不会出现这种情况.)</p>
<p>与<code>Docker1.6</code>同时发布的<code>Registry2.0</code>(<a href="https://github.com/docker/distribution" target="_blank" rel="external">docker/distribution</a>)为镜像使用了一种不重复的ID(<code>digest</code>)来确保同一ID值所引用的镜像的内容始终是相同的(immutable image references)</p>
<a id="more"></a>
<h3 id="尝试">尝试</h3><p>DockerHub已经开始支持<code>Registry2.0</code>,因此可以马上使用这个功能.但是,这次是尝试自己搭建一个私有的注册环境来尝试它的新功能(环境是在OSX上使用 boot2docker)</p>
<p>首先需要安装Registry.与V1相同,Docker已经提供了相应的镜像.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p <span class="number">5000</span>:<span class="number">5000</span> registry:<span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>准备一个简单的<code>Dockerfile</code>文件来构建我们的<code>tcnksm/test-digest</code>镜像.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t $(boot2docker ip):<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest:latest .</span><br></pre></td></tr></table></figure>
<p>然后通过<code>images</code>命令来验证是否正确.使用<code>--digests</code>参数会在结果中显示<code>digest</code>信息.与Git的不同,<code>build</code>的过程是不会生成<code>digest</code>的值的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --digests</span><br><span class="line">REPOSITORY                               TAG                 DIGEST              IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line"><span class="number">192.168</span>.<span class="number">59.103</span>:<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest   latest              &lt;none&gt;              <span class="number">8</span>c2e06607696        <span class="number">3</span> days ago          <span class="number">2.433</span> MB</span><br></pre></td></tr></table></figure>
<p>通过<code>push</code>向<code>Registry</code>进行推送.<code>push</code>的过程会生成<code>digest</code>值.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker push $(boot2docker ip):<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest:latest</span><br><span class="line">...</span><br><span class="line">Digest: sha256:e4c425e28a3cfe41efdfceda7ccce6be4efd6<span class="built_in">fc</span>775b24d5ae26477c96fb5eaa4</span><br></pre></td></tr></table></figure>
<p>为了替换本地生成的不带<code>digest</code>的镜像.我们可以在<code>pull</code>的时候,使用<code>NAME@DIGEST</code>的方式来代替原来<code>NAME:TAG</code>的方式.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(boot2docker ip):<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest:latest</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull $(boot2docker ip):<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest@sha256:e4c425e28a3cfe41efdfceda7ccce6be4efd6<span class="built_in">fc</span>775b24d5ae26477c96fb5eaa4</span><br></pre></td></tr></table></figure>
<p>这个时候再使用<code>images</code>命令来确认一下.这次的镜像信息中就带有<code>digest</code>信息了.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --digests</span><br><span class="line">REPOSITORY                               TAG                 DIGEST                                                                    IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line"><span class="number">192.168</span>.<span class="number">59.103</span>:<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest   &lt;none&gt;              sha256:e4c425e28a3cfe41efdfceda7ccce6be4efd6<span class="built_in">fc</span>775b24d5ae26477c96fb5eaa4   <span class="number">8</span>c2e06607696        <span class="number">3</span> days ago          <span class="number">2.433</span> MB</span><br></pre></td></tr></table></figure>
<h3 id="Dockerfile">Dockerfile</h3><p><code>Dockerfile</code>的<code>FROM</code>语句现在也可以使用<code>digest</code>来指定镜像的名字.如果发现通过原来的镜像捕捉任何的东西就更新成为新的镜像,那么这样的操作可以被避免(気がついたら元のイメージ更新されていて完成イメージが意図しないものになっていたということが避けられる．)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM <span class="number">192.168</span>.<span class="number">59.103</span>:<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest@sha256:e4c425e28a3cfe41efdfceda7ccce6be4efd6<span class="built_in">fc</span>775b24d5ae26477c96fb5eaa4</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line">Step <span class="number">0</span> : FROM <span class="number">192.168</span>.<span class="number">59.103</span>:<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest@sha256:e4c425e28a3cfe41efdfceda7ccce6be4efd6<span class="built_in">fc</span>775b24d5ae26477c96fb5eaa4</span><br><span class="line">---&gt; <span class="number">8</span>c2e06607696</span><br><span class="line">Successfully built <span class="number">8</span>c2e06607696</span><br></pre></td></tr></table></figure>
<h3 id="镜像的更新">镜像的更新</h3><p>可以通过编辑<code>Dockerfile</code>文件然后通过<code>build</code>命令来构建新的镜像.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">MAINTAINER tcnksm</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t $(boot2docker ip):<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest:latest .</span><br></pre></td></tr></table></figure>
<p>然后执行<code>Registry</code>的<code>push</code>操作,于是现在的<code>digest</code>会被改变.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker push $(boot2docker ip):<span class="number">5000</span>/tcnksm/<span class="built_in">test</span>-digest:latest</span><br><span class="line">...</span><br><span class="line">Digest: sha256:<span class="number">4675</span>f7a9d45932e3043058ef032680d76e8aacccda94b74374efe156e2940ee5</span><br></pre></td></tr></table></figure>
<h3 id="机制">机制</h3><p>简单的说明一下机制.<code>digest</code>不是本地生成的,而是通过<code>push</code>操作,在<code>Registry</code>一方生成的.</p>
<p>当客户端推送镜像到<code>Registry</code>时会同时附带<code>Image Manifest</code>(也就是签名).<code>Image Manifest</code>也就是Docker镜像内容的一些JSON话的定义.在Golang中的结构就如下所示,包含了镜像的名字,FSLayer的信息等等(manifest的具体定义参见<a href="https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-1.md" target="_blank" rel="external">这里</a>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ManifestData <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name          <span class="typename">string</span>             <span class="string">`json:"name"`</span></span><br><span class="line">    Tag           <span class="typename">string</span>             <span class="string">`json:"tag"`</span></span><br><span class="line">    Architecture  <span class="typename">string</span>             <span class="string">`json:"architecture"`</span></span><br><span class="line">    FSLayers      []*FSLayer         <span class="string">`json:"fsLayers"`</span></span><br><span class="line">    History       []*ManifestHistory <span class="string">`json:"history"`</span></span><br><span class="line">    SchemaVersion <span class="typename">int</span>                <span class="string">`json:"schemaVersion"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以调用他的API来查看<code>Manifest</code>中的内容.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl $(boot2docker ip):<span class="number">5000</span>/v2/tcnksm/<span class="built_in">test</span>-digest/manifests/latest</span><br></pre></td></tr></table></figure>
<p>因此,<code>Registry</code>是通过下面的函数来根据<code>Manifest</code>的元数据来生成<code>digest</code>的(<a href="https://github.com/docker/distribution/blob/master/registry/handlers/images.go" target="_blank" rel="external">registry/handlers/images.go</a>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PutImageManifest validates and stores and image in the registry.</span></span><br><span class="line"><span class="keyword">func</span> (imh *imageManifestHandler) PutImageManifest(w http.ResponseWriter, r *http.Request)</span><br></pre></td></tr></table></figure>
<p>在客户端调用的时候通过消息头<code>Docker-Content-Digest</code>发送给对方(<a href="https://github.com/docker/distribution/blob/master/docs/spec/api.md#put-manifest" target="_blank" rel="external">API doc</a>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">202</span> Accepted</span><br><span class="line">Location: &lt;url&gt;</span><br><span class="line">Content-Length: <span class="number">0</span></span><br><span class="line">Docker-Content-Digest: &lt;digest&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Registry不同的话?">Registry不同的话?</h3><p>如果发送的<code>Manifest</code>内容是相同的话,那么推送到不同的Registry其实是会生成相同的<code>digest</code>的.<code>digest</code>对于<code>Registry</code>来说是全局唯一的.</p>
<p>所以通过上面的方式制作的镜像,如果推送到<code>DockerHub</code>中的话,是会得到相同的<code>digest</code>的.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t tcnksm/<span class="built_in">test</span>-digest:latest .</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker push tcnksm/<span class="built_in">test</span>-digest:latest</span><br><span class="line">...</span><br><span class="line">Digest: sha256:e4c425e28a3cfe41efdfceda7ccce6be4efd6<span class="built_in">fc</span>775b24d5ae26477c96fb5eaa4</span><br></pre></td></tr></table></figure>
<h3 id="Registry2-0">Registry2.0</h3><p><a href="http://blog.docker.com/2015/04/faster-and-better-image-distribution-with-registry-2-0-and-engine-1-6/" target="_blank" rel="external">Faster and Better Image Distribution with Registry 2.0 and Engine 1.6 | Docker Blog</a></p>
<p><a href="https://github.com/docker/distribution" target="_blank" rel="external">docker/distribution</a>是一个新的Registr的实现.尝试用来解决现在版本的一些API或安全性的问题.现在的V1版本是使用<code>Pythone</code>来实现的,而新的<code>V2</code>版本则是使用Go语言来实现的.</p>
<p>新的特征有:</p>
<ul>
<li>重新定义了镜像的<code>Manifest</code>(<a href="https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-1.md" target="_blank" rel="external">Image Manifest Version 2, Schema 1</a>) - 可以参阅 <a href="https://github.com/docker/docker/issues/8093" target="_blank" rel="external">#8093</a>,主要是改善了安全方面的问题</li>
<li>新的API(<a href="https://github.com/docker/distribution/blob/master/docs/spec/api.md" target="_blank" rel="external">Docker Registry HTTP API V2</a>,<a href="https://github.com/docker/distribution/blob/master/docs/spec/api.md#detail" target="_blank" rel="external">#Detail</a>) - 使用<code>Manifest V2</code>来改善URI,如果在<code>Push/Pull</code>的过程中程序死掉或异常终止,那么当再开启的时候,会继续执行.(详细的实现的话,目前我还没有看到由Go语言接口实现的客户端实现到底是怎么做的).</li>
<li>后端的存储插件化(<a href="https://github.com/docker/distribution/blob/master/docs/storagedrivers.md" target="_blank" rel="external">Docker-Registry Storage Driver</a>) - 在新版本中,可以选择内存,文件系统,S3,Azure Blob Storage来作为镜像的存储.重新定义了一套Go语言的接口,允许你自己实现不同的存储.</li>
<li>webhook的实现(<a href="https://github.com/docker/distribution/blob/master/docs/notifications.md" target="_blank" rel="external">Notifications</a>) - <code>Push/Pull</code>到某个endpoint的时候,可以发送相应的事件通知.</li>
</ul>
<p>目前<code>dist</code>命令还只有一些基本框架而已(<a href="https://github.com/docker/distribution/tree/master/cmd/dist" target="_blank" rel="external">dist</a>).这对Docker镜像的pull/push操作只能使用命令行.作为Docker镜像的下载与运行来说,现在不是分离的了,这点有点讨厌.它试图全部都在这里进行解决.</p>
<h3 id="References">References</h3><ul>
<li><a href="https://docs.docker.com/registry/overview/" target="_blank" rel="external">Docker Registry 2.0</a></li>
<li><a href="https://github.com/docker/distribution/blob/master/docs/spec/auth/token.md" target="_blank" rel="external">Docker Registry v2 authentication via central service</a></li>
<li><a href="https://github.com/docker/distribution/blob/master/docs/deploying.md" target="_blank" rel="external">Deploying a registry service</a></li>
<li><a href="https://github.com/kelseyhightower/docker-registry-osx-setup-guide" target="_blank" rel="external">kelseyhightower/docker-registry-osx-setup-guide</a></li>
</ul>
<hr>
<p>原文链接: <a href="http://deeeet.com/writing/2015/04/20/docker-1_6_distribution/" target="_blank" rel="external">http://deeeet.com/writing/2015/04/20/docker-1_6_distribution/</a><br>翻译: <a href="sunxiang0918.cn">翔妖除魔</a></p>
<hr>
<p>补充一点我自己的看法.</p>
<p>对于V1的问题主要有:</p>
<ul>
<li>性能:<ul>
<li>随机ID重复Push  (docker的id是 客户端随机生成的.)</li>
<li>metadata,layer,metadata,layer (链表结构,不能随机读取)</li>
<li>python实现</li>
</ul>
</li>
<li>安全        <ul>
<li>随机image id</li>
<li>无法对内容进行校验</li>
<li>无法确定layer来源</li>
</ul>
</li>
<li>其他<ul>
<li>相同TAG两次下载 镜像可能是不一样的    </li>
</ul>
</li>
</ul>
<p>而V2的好处就在于 ID是更具内容使用SHA256算出来的.</p>
<ul>
<li><p>Digest(V2中的image Id):</p>
<ul>
<li>内容可校验</li>
<li>算法可插拔</li>
<li>cache友好</li>
<li>服务器端计算,加强安全</li>
<li>统一了存储</li>
</ul>
</li>
<li><p>Manifest:</p>
<ul>
<li>包含所有layer信息</li>
<li>signature强化校验</li>
<li>V1兼容</li>
</ul>
</li>
<li><p>性能:</p>
<ul>
<li>Go实现</li>
<li>并行pull</li>
<li>减少了auth流程</li>
</ul>
</li>
<li><p>其他:</p>
<ul>
<li>Notification机制</li>
<li>后端存储插件化</li>
<li>全新API</li>
<li>更复杂的鉴权方式</li>
</ul>
</li>
<li><p>存在问题:</p>
<ul>
<li>API缺失:   delete, search,list 没有</li>
<li>push/pull 速度有待优化 (gzip解压压缩)</li>
<li>镜像格式和V1 <strong>不兼容</strong></li>
</ul>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="基于内容地址的Docker_Registry2-0">基于内容地址的Docker Registry2.0</h1><p>由于最近在项目中需要使用<code>Docker</code>,并且需要持续集成,因此就研究了一下Docker的<code>Registry</code>.突然发现<code>V1</code>版本的<a href="https://github.com/docker/docker-registry">Registry</a>已经被官方打为<strong>废弃</strong>了.新的第二个版本的<a href="https://github.com/docker/distribution">Registry</a>已经开始提供服务.因此就着重的研究了一下这个,无奈现在相关的文档还非常的少.找到一篇日文的文章感觉还不错,因此就翻译了一下.先申明下我日语也就是玩票的性质,肯定有很多不正确的地方,还望海涵.</p>
<hr>
<h2 id="Content_Addressable_DockerイメージとRegistry2-0"><a href="http://deeeet.com/writing/2015/04/20/docker-1_6_distribution/">Content Addressable DockerイメージとRegistry2.0</a></h2><p>Docker1.6已经出了.它增加了很多新的功能,比如:容器与镜像的标记(具体更多的信息可以看RancherOS的<a href="http://rancher.com/docker-labels/">“Adding Label Support to Docker 1.6”</a>),日志记录的多种驱动等等.这次的Release更新中,我最感兴趣的就是Docker的Image开始基于内容进行寻址(Content-addressable) (<a href="https://github.com/docker/docker/pull/11109">#11109</a>)</p>
<p>到目前为止,Docker Registry通过镜像的名字与Tag与Image进行交互(比如:<code>tcnksm/golang:1.2</code>).而Tag是由镜像的作者自己定义的.这就不能保证在相同的Tag下的镜像内容是完全相同的(在GIG中由于使用了commit的哈希值,因此标签不会出现这种情况.)</p>
<p>与<code>Docker1.6</code>同时发布的<code>Registry2.0</code>(<a href="https://github.com/docker/distribution">docker/distribution</a>)为镜像使用了一种不重复的ID(<code>digest</code>)来确保同一ID值所引用的镜像的内容始终是相同的(immutable image references)</p>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://sunxiang0918.github.io/tags/Docker/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Zookeeper 数据清理]]></title>
    <link href="http://sunxiang0918.github.io/2015/09/16/Zookeeper-%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86/"/>
    <id>http://sunxiang0918.github.io/2015/09/16/Zookeeper-数据清理/</id>
    <published>2015-09-16T15:31:16.000Z</published>
    <updated>2015-09-16T16:18:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Zookeeper_数据清理">Zookeeper 数据清理</h1><h2 id="问题现象:">问题现象:</h2><p>情况是这样的,我在自己的笔记本上安装了<code>Zookeeper</code>,并使用了默认的配置作为开发的时候使用.<br>因为平时会关机等等,所以重启<code>zookeeper</code>的次数也是比较频繁的.突然最近发现系统磁盘空间就不够用了.<br>这不查不知道,一查吓一跳,<code>zookeeper</code>的data数据文件夹占了大概<strong>5个G</strong>的空间,而我zookeeper里面其实也没有什么东西,怎么会这么大呢?于是有了这篇文章的诞生.</p>
<h2 id="问题分析:">问题分析:</h2><p>首先我就在网上找了一圈,都说使用<code>zk/bin</code>里面的<code>zkClean.sh</code>就可以了.<br>其调用语法是:<code>./zkClean.sh -n 3</code> 这样就可以保留最近的三个Log文件.<br>但是我执行了后,发现然并卵.点反应都没有.一个文件都没有删除掉..<br>然后又找了一篇文章:<a href="http://nileader.blog.51cto.com/1381108/932156" target="_blank" rel="external">ZooKeepr日志清理</a>.按照里面说的第一种方法,直接删除data文件夹里面的数据.只保留最近的3个.结果删除以后,数据都没了…说明这个方法里面肯定有什么猫腻是没有发现的.</p>
<a id="more"></a>
<p>于是,仔细的分析<code>zkClean.sh</code>这个脚本. 发现它其实是调用的<code>org.apache.zookeeper.server.PurgeTxnLog</code>这个类中的方法来执行清理工作的.于是找到这个类的源文件.分析其中的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">purge</span><span class="params">(File dataDir, File snapDir, <span class="keyword">int</span> num)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count should be greater than 3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FileTxnSnapLog txnLog = <span class="keyword">new</span> FileTxnSnapLog(dataDir, snapDir);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// found any valid recent snapshots?</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// files to exclude from deletion</span></span><br><span class="line">        Set&lt;File&gt; exc=<span class="keyword">new</span> HashSet&lt;File&gt;();</span><br><span class="line">        List&lt;File&gt; snaps = txnLog.findNRecentSnapshots(num);</span><br><span class="line">        <span class="keyword">if</span> (snaps.size() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        File snapShot = snaps.get(snaps.size() -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (File f: snaps) &#123;</span><br><span class="line">            exc.add(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> zxid = Util.getZxidFromName(snapShot.getName(),<span class="string">"snapshot"</span>);</span><br><span class="line">        exc.addAll(Arrays.asList(txnLog.getSnapshotLogs(zxid)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Set&lt;File&gt; exclude=exc;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyFileFilter</span> <span class="keyword">implements</span> <span class="title">FileFilter</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line">            MyFileFilter(String prefix)&#123;</span><br><span class="line">                <span class="keyword">this</span>.prefix=prefix;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File f)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!f.getName().startsWith(prefix) || exclude.contains(f))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add all non-excluded log files</span></span><br><span class="line">        List&lt;File&gt; files=<span class="keyword">new</span> ArrayList&lt;File&gt;(</span><br><span class="line">                Arrays.asList(txnLog.getDataDir().listFiles(<span class="keyword">new</span> MyFileFilter(<span class="string">"log."</span>))));</span><br><span class="line">        <span class="comment">// add all non-excluded snapshot files to the deletion list</span></span><br><span class="line">        files.addAll(Arrays.asList(txnLog.getSnapDir().listFiles(<span class="keyword">new</span> MyFileFilter(<span class="string">"snapshot."</span>))));</span><br><span class="line">        <span class="comment">// remove the old files</span></span><br><span class="line">        <span class="keyword">for</span>(File f: files)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Removing file: "</span>+</span><br><span class="line">                DateFormat.getDateTimeInstance().format(f.lastModified())+</span><br><span class="line">                <span class="string">"\t"</span>+f.getPath());</span><br><span class="line">            <span class="keyword">if</span>(!f.delete())&#123;</span><br><span class="line">                System.err.println(<span class="string">"Failed to remove "</span>+f.getPath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过断点发现,在我这的环境中执行到<code>Util.getZxidFromName(snapShot.getName(),&quot;snapshot&quot;);</code>这句的时候,返回的<code>zxid</code>为<code>-1</code>.也就是没有找到<code>snapshot</code>的文件.所以剩下的所有文件都被加入到了<code>exclude</code>这个排除删除的变量中.因此,最后需要删除的队列<code>files</code>里面的东西其实是空的,也就是什么文件都不删除.</p>
<p>为什么没有找到<code>snapshot</code>的文件呢?仔细看了下我这的<code>zookeeper/data</code>文件夹.其中确实没有名为<code>snapshot.*</code>的文件,全是<code>log.*</code>的文件.</p>
<p>翻看<code>zookeeper</code>的官方文档.里面其实写的很清楚了.<br>在<code>zookeeper</code>中, <code>dataDir</code>里面存储的是<code>snapshot</code>文件,也就是快照文件,作用就类似于我们数据库的<code>dump</code>文件.里面存放了所有的<code>zk</code>数据.<br>而<code>dataLogDir</code>文件夹里面存储的是<code>log</code>文件.也就是事务日志文件.每对zk中的数据做一次修改并保存.都会往这个文件中记录一条数据.<br>也就是说,当<code>zookeeper</code>启动的时候,它其实是通过一个<code>snapshot</code>快照文件加上一堆的<code>log</code>事务日志文件的叠加来还原zk中的数据的.</p>
<p>那么,<code>snapshot</code>文件是从哪儿来得呢?为什么我的机器上没有<code>snapshot</code>文件呢?<br><code>zookeeper</code>的<a href="http://zookeeper.apache.org/doc/r3.3.3/zookeeperAdmin.html" target="_blank" rel="external">官方文档</a>中说的比较清楚,它有一个配置项叫做<code>snapCount</code>这个是用来控制生成快照文件的,默认值是<code>100000</code>.它的意思是当有<code>snapCount/2+rand.nextInt(snapCount/2)</code>条事务日志记入到<code>log</code>文件中的时候,那么就做一次快照.也就是在默认情况下五万至十万条事务的时候会做一次快照,之所以用随机数是为了避免在集群中,所有服务器在同一时间做快照的操作.<br>分析到这,原因就显而易见了.由于我是自己机器上做测试用的,量都比较小.半年了都还没有提交到五万次事务.所以它就一直不会生成快照文件,所以也就在清理日志文件的时候不会清理任何的<code>log</code>了.</p>
<p>除了这个问题,还有一个问题就是为什么会生成这么多的<code>log.*</code>文件.而且每一个文件都是64MB大小.<br>其实这个是因为<code>zookeeper</code>在开始写事务日志的时候,server每次都会新生成一个指定大小的<code>log</code>文件,本意是预分配空间,使磁盘空间更连续,最小化磁盘寻道的次数.<br>默认配置大小就是<code>64M</code>.因此,当系统每次重启的时候都会新生成一个<code>64M</code>大小的<code>log.*</code>文件了.完全没有写满就重启<code>zookeeper</code>.大大的浪费了空间.因此,我们需要调整这个大小.<br>控制这个大小的配置是<code>preAllocSize</code>,单位是<code>KB</code>.我们可以粗略的计算一下所需要的空间.比如我们五万次事务提交一次镜像.而每一次的事务大概是150个字节.那么总大小就应该是:<code>150*50000/1024/1024=7</code>,也就是7MB左右.</p>
<p>这样修改了这两个参数后,重新启动<code>zookeeper</code>.写一个简易的程序不断的对<code>zk</code>做写入的测试.结果证明了上面的分析.<code>data</code>文件夹中开始出现<code>snapshot</code>文件了.而且在不重启的情况下,<code>log</code>文件的数量也是在可控的范围内.这个时候再通过<code>zkClean.sh</code>就可以清除掉多余的日志文件了.</p>
<p>到此,问题解决.</p>
<h2 id="其他补充:">其他补充:</h2><p>除了使用<code>zkClean.sh</code>文件手工的删除外.还可以在<code>zoo.cfg</code>文件中配置<code>autopurge.snapRetainCount</code>和<code>autopurge.purgeInterval</code>两个参数.<br>第一个参数指明了需要保留的快照数量,默认值和最小值是<code>3</code>.<br>第二个参数是两次清楚数据的时间间隔,单位是小时.如果设置为<code>0</code>,那么就不开启自动清理.</p>
<p>除此之外,建议把<code>data</code>和<code>dataLog</code>两个文件夹分开.不要存放到一起,因为<code>data</code>文件存放的其实是快照,对磁盘的性能要求不高.而<code>dataLog</code>文件夹里面存放的是事务日志文件,每执行一次事务,都会写数据到这个文件夹中去.因此对磁盘的要求是非常高的. 再者,他<code>org.apache.zookeeper.server.PurgeTxnLog</code>这个类的处理逻辑其实有一定的问题.首先它会把MacOS系统里面的<code>.DS_Store</code>文件计算进去,这个获取最新的文件的时候有可能是会出问题的.其二就是他在查找最新的几个文件的时候是没有单独的过滤<code>snapshot</code>文件的.如果没有区分<code>data</code>和<code>dataLog</code>文件夹,<code>snapshot</code>和<code>log</code>文件都混在一起,那么最后获取的处理就会找不到<code>snapshot</code>文件.那么又会照成什么都不能删除的情况.</p>
<h2 id="问题总结:">问题总结:</h2><ol>
<li>修改配置中的<code>snapCount</code>,根据自己业务的需要,适当的修改这个数值.比如我们系统修改成<code>5000</code>比较合适.</li>
<li>修改配置中的<code>preAllocSize</code>,根据自己业务的需要,适当的修改这个数值.比如我们系统修改成<code>1000</code>比较合适.</li>
<li>修改配置中的<code>dataDir</code>和<code>dataLogDir</code>.分开存放事务日志和快照文件</li>
<li>修改配置中的<code>autopurge.snapRetainCount</code>和<code>autopurge.purgeInterval</code>.增加自动删除多余日志的检测.</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Zookeeper_数据清理">Zookeeper 数据清理</h1><h2 id="问题现象:">问题现象:</h2><p>情况是这样的,我在自己的笔记本上安装了<code>Zookeeper</code>,并使用了默认的配置作为开发的时候使用.<br>因为平时会关机等等,所以重启<code>zookeeper</code>的次数也是比较频繁的.突然最近发现系统磁盘空间就不够用了.<br>这不查不知道,一查吓一跳,<code>zookeeper</code>的data数据文件夹占了大概<strong>5个G</strong>的空间,而我zookeeper里面其实也没有什么东西,怎么会这么大呢?于是有了这篇文章的诞生.</p>
<h2 id="问题分析:">问题分析:</h2><p>首先我就在网上找了一圈,都说使用<code>zk/bin</code>里面的<code>zkClean.sh</code>就可以了.<br>其调用语法是:<code>./zkClean.sh -n 3</code> 这样就可以保留最近的三个Log文件.<br>但是我执行了后,发现然并卵.点反应都没有.一个文件都没有删除掉..<br>然后又找了一篇文章:<a href="http://nileader.blog.51cto.com/1381108/932156">ZooKeepr日志清理</a>.按照里面说的第一种方法,直接删除data文件夹里面的数据.只保留最近的3个.结果删除以后,数据都没了…说明这个方法里面肯定有什么猫腻是没有发现的.</p>]]>
    
    </summary>
    
      <category term="Zookeeper" scheme="http://sunxiang0918.github.io/tags/Zookeeper/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="集群" scheme="http://sunxiang0918.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift2.0 beta5 后异常处理的一些补充]]></title>
    <link href="http://sunxiang0918.github.io/2015/09/13/Swift2-0-beta6-%E5%90%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A1%A5%E5%85%85/"/>
    <id>http://sunxiang0918.github.io/2015/09/13/Swift2-0-beta6-后异常处理的一些补充/</id>
    <published>2015-09-13T14:10:42.000Z</published>
    <updated>2015-09-14T01:12:46.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift2-0_beta5_后异常处理的一些补充">Swift2.0 beta5 后异常处理的一些补充</h1><p>随着<code>XCode7 GM</code>在9月9号的推出,Swift2.0也要进入了GM了.随后的语法应该会逐渐的稳定下来了.其实在Swfit2.0 beta6后,Swift2对异常的处理又发生了一些变化,比如增加了一个<code>try?</code>关键字.<br>因此,这篇文章就再罗列一下现在Swift2.0异常处理的各种场景与方式.</p>
<h2 id="首先是定义一个异常-">首先是定义一个异常.</h2><p>Swift2.0中 所有的异常类都是遵循<code>ErrorType</code>这个协议的.因此定义一个异常的最简单的方式就是使用枚举来实现一个这个协议:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AppException</span> : <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">IllegalArgumentException</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">IllegalFormatException</span>(coinsNeeded: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中我使用枚举定义了一个<code>AppException</code>的异常类,有两个case,并且借助于swift中强大的枚举类,<code>IllegalFormatException</code>case拥有一个<code>Int</code>类型的变量为<code>coinsNeeded</code>.</p>
<a id="more"></a>
<p>当然,你也可以像<code>JAVA</code>中那样,从异常的基类上继承一个自定义的异常类.<br>在JAVA中是这样写的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String code;</span><br><span class="line">	<span class="keyword">private</span> String message;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServerException</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.code = code;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	setter/getter</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相同的逻辑在swift2中是这样的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ServerException</span> : <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> code:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> message:<span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(code:<span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.code = code</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(code:<span class="type">String</span>,message:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.code = code</span><br><span class="line">        <span class="keyword">self</span>.message = message</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是,在Swift2.0 beta5之前 直接用结构体来实现<code>ErrorType</code>是会出错的.<br>必须在实现的结构体中增加<code>_domian:String</code> <code>_code:Int</code> 这两个计算属性才可以.这不知道是它内部实现有什么魔法了. 但是在<code>beta5</code>以后就不存在这个问题了,我们可以任意的实现<code>ErrorType</code>用来自定义异常类.</p>
<h2 id="接着就是要使用异常了">接着就是要使用异常了</h2><p>定义完异常后,接下来肯定就是在我们的程序中使用异常了.<br>swift2.0中提供了 <code>try</code> <code>try!</code> <code>try?</code> <code>do</code> <code>catch</code> <code>throws</code> <code>throw</code> 这几个关键字来处理异常.我们一个一个的来说.</p>
<h3 id="1-throw/throws">1.throw/throws</h3><p><code>throw</code>和<code>throws</code>这两个关键字 其实和JAVA中的语义是一样的. 在JAVA面试中 它们两个的区别 基本上算是必考的题.<br><code>throw</code>表示的是 在程序语句中抛出一个异常.而<code>throws</code>用于定义在方法的签名上,表示这个方法可能会抛出异常.</p>
<p><code>siwft2</code>中的<code>throws</code>语法与<code>JAVA</code>中的稍有不同, 差别就在于它的位置,以及类型标示.<br>在<code>JAVA</code>中,<code>throws</code>是位于方法签名的最后的:<code>访问限定符 返回类型 方法名(入参列表) throws 异常类型</code>.<br>而在swift中<code>throws</code>更多的就只是一个标示,它并不写明要抛出的异常类型是什么,只是告诉调用者,我是要抛出异常的.因此,它的位置更靠前,是在返回参数类型之前: <code>func 方法名(入参列表) throws -&gt;返回类型</code></p>
<p>在程序语句中使用<code>throw</code>抛出异常的时候,同JAVA一样,抛出的应该是一个异常类型的实例.<br>如果是枚举类型,并且是没有参数的.那么就可以直接写上枚举值,比如:<code>throw AppException.IllegalArgumentException</code>,如果是有参数的枚举类型或者是结构体,那么在throw后就需要传入实例的值.比如:<code>throw ServerException(code: &quot;E0001&quot;)</code> <code>throw AppException.IllegalFormatException(coinsNeeded: 5)</code></p>
<h3 id="2-do/catch">2.do/catch</h3><p>这个就是swift中的异常捕捉的语法.<br><code>do</code>代码块用于包裹一个代码块,其中可能会有要抛出异常的方法.<code>catch</code>代码块用于捕捉异常,并在它自身的代码块中处理异常</p>
<p>比如常规的用法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">exceptionTest</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"123"</span>)</span><br><span class="line">	   throw <span class="type">AppException</span>.<span class="type">IllegalFormatException</span>(coinsNeeded: <span class="number">5</span>)</span><br><span class="line">	&#125;catch <span class="keyword">let</span> e &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"exception: <span class="subst">\(e)</span>"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就演示了 如果使用 do-catch 代码块来捕捉一个异常,以及顺带演示了如何抛出一个带有参数的枚举类型的异常. 上面的代码 捕捉了任意类型的异常,并且使用了一个 e 变量来表示它.这样在catch块中就可以使用这个异常了.</p>
<p>当然,你也可以定义多个catch块,每一个catch块都指定一个要处理的异常类型,这样的用法也是很常见的.<br>在swift2中当然也是支持的,例如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">exceptionTest</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"123"</span>)</span><br><span class="line">        throw <span class="type">AppException</span>.<span class="type">IllegalFormatException</span>(coinsNeeded: <span class="number">5</span>)</span><br><span class="line">    &#125;catch <span class="type">AppException</span>.<span class="type">IllegalArgumentException</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"IllegalArgumentException"</span>)</span><br><span class="line">    &#125;catch <span class="type">AppException</span>.<span class="type">IllegalFormatException</span>(<span class="keyword">let</span> coinsNeeded)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"aaaa:<span class="subst">\(coinsNeeded)</span>"</span>)</span><br><span class="line">    &#125;catch <span class="keyword">let</span> e &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"exceptions: <span class="subst">\(e)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是catch代码块的顺序是从上到下匹配的.所以,通常我们会把越广泛的catch异常处理块定义到越后面. 上面的例子就很好的表现了这一点. 并且也演示了 如何接收带有参数的枚举类型的异常的值.</p>
<p>当然,还有一种情况就是捕捉自定义的异常结构体.它和捕捉枚举类型的异常其实是一样的.只是多了一个异常类型转换的过程:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">exceptionTest3</span><span class="params">(cass:Bool)</span></span> throws &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cass &#123;</span><br><span class="line">            throw <span class="type">ServerException</span>(code: <span class="string">"E0001"</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">AppException</span>.<span class="type">IllegalArgumentException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch <span class="keyword">let</span> er <span class="keyword">as</span> <span class="type">ServerException</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"err:<span class="subst">\(er.code)</span>"</span>)</span><br><span class="line">    &#125;catch <span class="keyword">let</span> e &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"exceptions:<span class="subst">\(e)</span>"</span>)</span><br><span class="line">        throw <span class="type">ServerException</span>(code: <span class="string">"E0001"</span>)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上面的代码所示, 当<code>cass</code>为<code>true</code>的时候,方法会抛出一个自定义的<code>ServerException</code>异常. 而捕获这个异常的代码为<code>catch let er as ServerException</code>,也就是 它定义了一个变量<code>er</code>并且转换为<code>ServerException</code>类型,来接收这个异常. 因此异常体中就可以直接使用结构体中的成员和方法了.<br>同样,catch代码块的顺序是从上到下匹配的.<br>另外一个值得注意的地方在于,我可以在catch块中继续的抛出异常,只要有地方继续的do-catch这个异常或者是方法签名可以抛出异常即可.</p>
<p>因此,这又说明了一个问题,就是 如果一个方法可以抛出异常,那么它就可以直接调用其他的可能会抛出异常的方法,而不需一定要使用do-catch来捕获异常.<br>这样就可以一层一层的把异常传递出去.比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">exceptionTest2</span><span class="params">()</span></span> throws -&gt;<span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">//可以不用do-catch 而直接调用exceptionTest 从而把异常抛出去</span></span><br><span class="line">    exceptionTest()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="try/try!/try?">try/try!/try?</h3><p>剩下的就是这对三胞胎兄弟了. 他们的语义都是说明 他们后面的方法是可能要抛出异常的,我要尝试执行.<br>其中, <code>try</code>必须在<code>do-catch</code>语句中. 用于在<code>do-catch</code>语句中标识哪句话可能会抛出异常.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = try exceptionTest2()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"result:<span class="subst">\(result)</span>"</span>)</span><br><span class="line">        <span class="keyword">if</span> cass &#123;</span><br><span class="line">            throw <span class="type">ServerException</span>(code: <span class="string">"E0001"</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">AppException</span>.<span class="type">IllegalArgumentException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch <span class="keyword">let</span> er <span class="keyword">as</span> <span class="type">ServerException</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"err:<span class="subst">\(er.code)</span>"</span>)</span><br><span class="line">    &#125;catch <span class="keyword">let</span> e &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"exceptions:<span class="subst">\(e)</span>"</span>)</span><br><span class="line">        throw <span class="type">ServerException</span>(code: <span class="string">"E0001"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这句话就很清楚的表明,<code>exceptionTest2()</code>在调用的时候可能会抛出异常,我要尝试的执行这句方法.如果执行成功没有问题,那么就赋值给result.如果有问题,那么就抛出异常,由异常捕获块来处理异常.</p>
<p>但是,有时某个方法虽然它定义了可能抛出异常,但是在我们的使用场景中非常的确定这个方法里面是不会抛出异常的.那么我们就可以不使用 <code>do-catch</code>块来多此一举的捕获异常. 直接使用<code>try!</code>就可以了.<br>它就说明这个方法里面是不可能抛出异常的,我很肯定.比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">exceptionTest4</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> try! exceptionTest2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面这个例子中的方法签名上并没有标示<code>throws</code>可能抛出异常. 但是在调用<code>exceptionTest2()</code>方法的时候非常的确定是不会抛出异常的,因此就直接使用了<code>try!</code>即可.<br>在这种情况下,如果一旦调用的方法抛出了异常,那么整个程序就会直接崩溃,这一点需要特别的注意.</p>
<p>还剩下一个就是<code>try?</code> 这个是<code>Swift2.0 beta6</code>中新增加的语法.<br>它会尝试执行一个可能抛出异常的操作,如果操作执行成功,执行的结果就会包裹在一个可选值里面,如果操作执行失败(比如某个错误被抛出了),那么执行的结果就是nil,而<code>error</code>的内容会被抛弃.</p>
<p>这样做的好处是在结合<code>if let</code>,<code>guard</code> 或者<code>map</code>等链式处理的时候 非常的方便.<br>因为有些时候我们并不关心异常的原因,只需要知道结果是异常的就可以了.那么在这个情况下.在异常的时候,需要非常繁琐的<code>do-catch</code>语句来不断的包裹和处理异常,可能整个业务的处理逻辑都被异常处理而打乱了.比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">Foundation</span></span><br><span class="line"><span class="comment">// get the currently logged in user</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">loggedInUser</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>? &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">// get his name</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getUserName</span> <span class="params">(userId: Int)</span></span> throws -&gt; <span class="type">String</span> &#123; <span class="keyword">return</span> <span class="string">"Claus"</span> &#125;</span><br><span class="line"><span class="comment">// create a new image post with this username. Returns the post data</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imagePostForUserName</span><span class="params">(name: String, imageURL: NSURL?)</span></span> -&gt; <span class="type">NSData</span>? &#123; <span class="keyword">return</span> <span class="type">NSData</span>() &#125;</span><br><span class="line"><span class="comment">// post the data to a server</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">postImage</span><span class="params">(data: NSData)</span></span> throws -&gt; <span class="type">Bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> uid = loggedInUser() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> username = try getUserName(uid)</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> data = imagePostForUserName(username, imageURL: <span class="literal">nil</span>) &#123;</span><br><span class="line">	    <span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> success = try postImage(data)</span><br><span class="line">		<span class="keyword">if</span> success &#123;</span><br><span class="line">		    <span class="built_in">print</span> (<span class="string">"Submitted"</span>)</span><br><span class="line">		&#125;  </span><br><span class="line">	    &#125; catch &#123;</span><br><span class="line">		<span class="comment">// more error handling</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">	<span class="comment">// todo: error handling</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果使用了<code>try?</code>,那么代码就被简化成了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> uid = loggedInUser(),</span><br><span class="line">	username = try? getUserName(uid),</span><br><span class="line">	data = imagePostForUserName(username, imageURL: <span class="literal">nil</span>),</span><br><span class="line">	success = try? postImage(data)</span><br><span class="line">   <span class="keyword">where</span> success == <span class="literal">true</span> &#123;</span><br><span class="line">      <span class="built_in">print</span> (<span class="string">"Submitted"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一句话就搞定了.简化了不少. 当然,按照上面的写法我们就无法知道他错误的信息了.</p>
<h3 id="defer">defer</h3><p>除了上面所说的那些专门处理异常的关键字. 还有一个关键字<code>defer</code>可以配合<code>do-catch</code>语句来实现JAVA中<code>try-catch-finally</code>的逻辑. 也就是一段代码,无论成功执行还是异常捕获甚至是<code>try-finally</code>,它都要在最后执行. 这个在swift中 就是使用<code>defer</code>关键字来实现的.</p>
<p>比如上面的<code>test3</code>的例子,稍微改一下即可:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">exceptionTest3</span><span class="params">(cass:Bool)</span></span> throws &#123;</span><br><span class="line">    </span><br><span class="line">    defer&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"finally!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = try exceptionTest2()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"result:<span class="subst">\(result)</span>"</span>)</span><br><span class="line">        <span class="keyword">if</span> cass &#123;</span><br><span class="line">            throw <span class="type">ServerException</span>(code: <span class="string">"E0001"</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            throw <span class="type">AppException</span>.<span class="type">IllegalArgumentException</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;catch <span class="keyword">let</span> er <span class="keyword">as</span> <span class="type">ServerException</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"err:<span class="subst">\(er.code)</span>"</span>)</span><br><span class="line">    &#125;catch <span class="keyword">let</span> e &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"exceptions:<span class="subst">\(e)</span>"</span>)</span><br><span class="line">        throw <span class="type">ServerException</span>(code: <span class="string">"E0001"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他就会在方法的执行最后打印一句<code>finally!</code>. 需要注意的是,如果你把<code>defer{}</code>放在了<code>do{}</code>块里面.那么它的执行顺序是先于<code>catch</code>代码块的.</p>
<p>具体更多关于<code>defer</code>的用法,可以参考我另外的一篇博客:<a href="http://sunxiang0918.cn/2015/08/04/Swift-2-0-新特性/#4-defer关键字" target="_blank" rel="external">Swift 2.0 新特性</a></p>
<h2 id="总结">总结</h2><p>以上就是<code>Swift2.0</code>中异常处理的一些方面.用熟悉以后,确实很大大的方便我们的编程,写出更优雅的程序.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift2-0_beta5_后异常处理的一些补充">Swift2.0 beta5 后异常处理的一些补充</h1><p>随着<code>XCode7 GM</code>在9月9号的推出,Swift2.0也要进入了GM了.随后的语法应该会逐渐的稳定下来了.其实在Swfit2.0 beta6后,Swift2对异常的处理又发生了一些变化,比如增加了一个<code>try?</code>关键字.<br>因此,这篇文章就再罗列一下现在Swift2.0异常处理的各种场景与方式.</p>
<h2 id="首先是定义一个异常-">首先是定义一个异常.</h2><p>Swift2.0中 所有的异常类都是遵循<code>ErrorType</code>这个协议的.因此定义一个异常的最简单的方式就是使用枚举来实现一个这个协议:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AppException</span> : <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">IllegalArgumentException</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">IllegalFormatException</span>(coinsNeeded: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中我使用枚举定义了一个<code>AppException</code>的异常类,有两个case,并且借助于swift中强大的枚举类,<code>IllegalFormatException</code>case拥有一个<code>Int</code>类型的变量为<code>coinsNeeded</code>.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用TeamBition进行敏捷开发]]></title>
    <link href="http://sunxiang0918.github.io/2015/09/07/%E4%BD%BF%E7%94%A8TeamBition%E8%BF%9B%E8%A1%8C%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>http://sunxiang0918.github.io/2015/09/07/使用TeamBition进行敏捷开发/</id>
    <published>2015-09-07T13:30:27.000Z</published>
    <updated>2015-09-07T14:44:45.000Z</updated>
    <content type="html"><![CDATA[<h1 id="使用TeamBition进行敏捷开发">使用TeamBition进行敏捷开发</h1><p>最近开始新的项目,由于人数也不多,需求也比较模糊,因此觉得可以试一试采用敏捷开发的模式来进行过程管理.于是研究了一下如何方便的进行这方面的管理.</p>
<h2 id="SCRUM">SCRUM</h2><h3 id="基本概念">基本概念</h3><p>Scrum就是敏捷开发中的一种模型.它主要有三个基本的概念:</p>
<ol>
<li>角色</li>
<li>工件</li>
<li>活动</li>
</ol>
<h4 id="1-_角色">1. 角色</h4><ul>
<li><strong>Product Owner(产品负责人)</strong>:负责维护产品订单的人，代表利益相关者的利益。</li>
<li><strong>Scrum Master(Scrum管理者)</strong>:为Scrum过程负责的人，确保scrum的正确使用并使得Scrum的收益最大化。</li>
<li><strong>Team(研发团队)</strong>:由负责自我管理开发产品的人组成的跨职能团队。</li>
</ul>
<p>他们的职责分别是:</p>
<h5 id="Product_Owner">Product Owner</h5><ul>
<li><strong>建立愿景</strong>:确认产品的项目愿景</li>
<li><strong>定义产品路标</strong>:确定大得功能以及客户的期望</li>
<li><strong>确定需求</strong>:生成故事描述</li>
<li><strong>维护Product Backlog</strong>:确定功能优先级,确保对即将开始的迭代故事进行了足够的细化</li>
<li><strong>客户验收</strong>:能让客户使用产品提供反馈</li>
<li><strong>计划</strong>:确定交付时间,跟踪进度</li>
<li><strong>协调</strong>:协调团队需要的资源</li>
</ul>
<h5 id="Scrum_Master">Scrum Master</h5><ul>
<li><strong>确保流程的贯彻执行</strong>:对如何执行上达成一致,保证团队一致的执行流程</li>
<li><strong>找到并去除障碍</strong>:找到任何妨碍目标达成的障碍,并设法调动资源去除障碍</li>
<li><strong>保证内部沟通的顺畅</strong>:保证团队沟通顺利,高效</li>
<li><strong>维持工作环境</strong>:确保整个项目中团队的工作节奏和工作进度.</li>
<li><strong>团队提高</strong>:确保团队的人员是合适的,在团队中组织技能培训,通过激发创造性与推动授权来提升团队成员</li>
</ul>
<h5 id="Team">Team</h5><ul>
<li><strong>协作</strong>:具有不同特长的团队成员,形成高度的自我管理能力,保持节奏的实现每一次Sprint目标</li>
<li><strong>维护架构</strong>:保证架构的稳定性和持续性</li>
<li><strong>掌握需求</strong>:团队有这人明白具体需求是什么,如何实现.</li>
<li><strong>保证质量</strong>:通过代码标准,持续集成,配置管理,内外测试等保证产品的质量</li>
<li><strong>设计方案</strong>:决定如何编写代码实现需求,包括单元测试和自动化测试</li>
</ul>
<a id="more"></a>
<h4 id="2-_工件">2. 工件</h4><h5 id="Product_Backlog_(产品订单):">Product Backlog (产品订单):</h5><ul>
<li>面向客户的需求</li>
<li>需求可评估,可实现,可测试</li>
<li>待完成的工作列表</li>
<li>Product Owner需要对列表进行优先级排序</li>
<li>每个迭代开始前需要持续修正</li>
</ul>
<h5 id="Sprint_Backlog(冲刺订单,迭代周期)">Sprint Backlog(冲刺订单,迭代周期)</h5><ul>
<li>细化需求</li>
<li>可执行的任务</li>
<li>团队中任何人都可以增加删除更改</li>
<li>对于面对困难不清楚的,可以逐步细化</li>
<li>每日更新</li>
</ul>
<h5 id="燃尽图">燃尽图</h5><p>迭代中任务的总体完成情况</p>
<h4 id="3-_活动">3. 活动</h4><h5 id="Sprint_Planning_Meeting(计划会)">Sprint Planning Meeting(计划会)</h5><ul>
<li>分析和评估产品Backlog各项目</li>
<li>选择一些作为迭代的目标</li>
<li>决定如何实现迭代目标</li>
<li>以小时为单位评估迭代任务工作量</li>
</ul>
<h5 id="Daily_Standup_Meeting(每日立会)">Daily Standup Meeting(每日立会)</h5><ul>
<li>每天都要开</li>
<li>15分钟左右</li>
<li>早上或晚上都可</li>
<li>不是为了解决问题</li>
<li>所有相关人员都被邀请</li>
<li>每个人都要发言</li>
<li>只说三个东西:1.已经做了什么 2.将要做什么 3.遇到的困难</li>
</ul>
<h5 id="Review_Meeting(评审会)">Review Meeting(评审会)</h5><ul>
<li>演示所完成的迭代工作</li>
<li>非正式的,不需要正式演示文档等</li>
<li>整个团队都要邀请</li>
<li>讨论有问题的地方</li>
</ul>
<h5 id="Retrospective_Meeting(回顾会)">Retrospective Meeting(回顾会)</h5><ul>
<li>周期性的</li>
<li>总结工作中的经验和教训</li>
<li>讨论本次迭代中的不足</li>
<li>整个团队都要参加</li>
</ul>
<h3 id="开发过程">开发过程</h3><ol>
<li>首先明确产品的功能确定Product Backlog,由Product Owner负责.这个允许持续变化和增加</li>
<li>Product Owner对产品订单进行筛选,提炼最核心的需求.</li>
<li>Scrum Team根据Product Backlog列表,做工作量的预估以及业务逻辑,功能流程的梳理</li>
<li>通过Sprint Planning Metting会议,从中挑选一个Story作为本次迭代完成的目标,一般迭代的周期是2-4周.</li>
<li>然后把这个Story进行细化,形成一个Sprint Backlog.</li>
<li>每一个团队成员根据Sprint Backlog再细化成更小的任务(尽量每个任务的工作量在2天内能完成).(每一个任务至少需要两人来评工作量,扑克游戏方法评估)</li>
<li>每天需要进行 Daily Stand Meeting,每次会议控制在15分钟左右,每个人必须发言,并且向所有成员当面汇报1.你完成了什么,2.承诺将要完成什么,3.遇到不能解决的问题也可以提出.</li>
<li>做到能随时集成,使用GIT+MAVEN+Jenkin持续化集成.</li>
<li>当一个Sprint Backlog完成,也就表示一次迭代完成,需要进行Srpint Review Metting,产品负责人和客户都要参加.用于演示完成迭代的软件产品.然后客户提出意见和建议,收集起来作为后续迭代的需求.</li>
<li>最后进行Sprint  Retrospective Meeting,总结并讨论本次迭代中的问题和还需要改进的地方,放入后续迭代的需求中.</li>
</ol>
<h2 id="TeamBition">TeamBition</h2><p>Teambition 强大、简洁的任务版功能，快速提升整个团队的工作效率。<br>经过试用觉得还可以,能方便我们完成整个敏捷的流程.</p>
<h3 id="界面">界面</h3><p><img src="/img/2015/09/07/1.png" alt=""><br>这个是他的主界面,上面有各种项目</p>
<p><img src="/img/2015/09/07/2.png" alt=""><br>这个是它用户的主页,上面记录了整个团队的各种变动,以及今天的任务等等</p>
<p><img src="/img/2015/09/07/3.png" alt=""><br>这个就是它最核心的任务看板了,对应了Scrum中的白板功能,能把某一个迭代周期的任务按照阶段分出来.</p>
<p><img src="/img/2015/09/07/4.png" alt=""><br>这个是分享墙的功能,也就是可以作为一个在线的WIKI来使用的.他支持普通的文档以及markdown文档.我们可以把自己的各种API文档,开发文档等等都放到这里共享出来.</p>
<p><img src="/img/2015/09/07/5.png" alt=""><br>这个是文件库功能,也就是一个在线的网盘,单个文件最大200MB,不限制文件个数.因此可以把各种原型,素材,资料,工具等等都放入到这个里面.</p>
<p><img src="/img/2015/09/07/6.png" alt=""><br>接下来就是日程功能了,这个就和<code>iCal</code> <code>outlook</code>里面的日程是一样的.同样可以增加参与者等等,然后到时间后可以通知大家</p>
<p><img src="/img/2015/09/07/7.png" alt=""><br>回顾功能用于查看大家一个周期内做了什么事还是比较有用的.但是我觉得还缺少了周报的功能,这点的话 <a href="http://team.oschina.net" target="_blank" rel="external">team.oschina.net</a> 做的就要好些.毕竟有些时候公司上面是要看周报说话的,没有这东西不得行啊…</p>
<p><img src="/img/2015/09/07/8.png" alt=""><br>标签功能是提供了一种把任务分组的方式.我个人是比较喜欢标签的方式来整理任务的.因此这也是我选择teambition而没有选择worklite等等的原因.它对Tags的支持是最完整的.可以自定任意个标签,一个任务可以绑定任意个标签.</p>
<h3 id="Scrum过程">Scrum过程</h3><p>这里开始介绍下如何套用teambition来实行Scrum</p>
<h4 id="产品的需求收集">产品的需求收集</h4><p>首先,我们会增加一个任务分组,名字叫:<code>Product Backlog</code><br><img src="/img/2015/09/07/9.png" alt=""> </p>
<p>它有五栏:</p>
<ul>
<li><strong>收集需求</strong>:就是原始的客户需求,需要我们完成的</li>
<li><strong>确认需求</strong>:经过一定整理有优先级的确认必须要实现的需求拖入这里.Scrum Planning Metting需要关注这里的需求.然后在备注或者标签上指明状态,以及迭代的版本</li>
<li><strong>开始研发</strong>:当这个需求进入开发的时候,拖入到这里.</li>
<li><strong>进入测试</strong>:开发完成,拖入需求到进入测试.这里的测试只的不是QA的测试,应该是用户或产品人员的DC</li>
<li><strong>完成</strong>:如果需求开发并完成测试,能发布了,就拖入到这里</li>
</ul>
<h4 id="Sprint_Planning_Meeting">Sprint Planning Meeting</h4><p>有了产品需求之后,接下来的就是开迭代计划会议了,这里可以使用日程表的功能来安排会议.然后通过会议的结果来制定迭代的开发排期:<br><img src="/img/2015/09/07/10.png" alt=""><br>这里面就安排了几个迭代的周期,每一个周期的时间是什么.并且也是燃尽图的功能.蓝色表示近期的任务,绿色表示完成的任务,红色表示逾期的任务.通过这个就能很直观的看到整个迭代周期任务的完成情况.</p>
<h4 id="Sprint_Backlog">Sprint Backlog</h4><p>通过计划会议把Product Backlog中的东西拆分了放入到迭代周期中.对于最近的迭代周期,进行详细的任务拆分和工作量的评估:<br><img src="/img/2015/09/07/11.png" alt=""> </p>
<p>有五栏:</p>
<ul>
<li><strong>需要做</strong>:本次迭代需要完成的需求,与产品不同,这里更关心的是技术层面,需要标号</li>
<li><strong>如何做</strong>:细分到两天以内的任务.需要标上子号</li>
<li><strong>正在做</strong>:正在完成的任务拖入到这里,并且允许再次细化</li>
<li><strong>做测试</strong>:完成开发的拖入到这里,这里指的就是软件的测试,如果是子号,由开发自己测试.如果是大号,由测试人员测试.</li>
<li><strong>完成</strong>:如果需求开发并完成测试,能发布了,就拖入到这里.如果是子号,由开发拖入,如果是大号,由测试人员拖入</li>
</ul>
<p>当任务需要进行到下一个阶段的时候,相关人员通过拖动任务卡片,将其移动到下一阶段.同时可以通过修改执行者来告知对方进行下一步的工作了.同时会给每一个任务设置截止时间,这样当时间到的时候会在<code>我的今日</code>视图中非常明了的看到需要做什么,而且如果超过时间了,会以红色标识.但是这里我认为最好在加上一个开始时间,因为一个任务有可能会有两天的时间,那么当在开始做的时候,可能并不是截止日期当天.这样他就不能很直观的提醒我今天需要做什么了.按照GTD的方式其实都有个<code>日程</code>和<code>今日代办</code>两类的,都是可以设置任务的开始时间的.</p>
<h4 id="问题支持">问题支持</h4><p>是软件都是有问题的.那么缺陷的管理也是非常重要的.因此我增加了一个任务分组名叫<code>问题支持</code>,这个其实是在<code>scrum</code>中是没有的.<br><img src="/img/2015/09/07/12.png" alt=""> </p>
<p>有四栏:</p>
<ul>
<li><strong>系统问题</strong>:发现的BUG或Issue放入这里,打上标签</li>
<li><strong>解决中</strong>:开发认领问题后,把问题拖入到这里,然后在子任务中可以增加一些开发的Task.并完成</li>
<li><strong>验证中</strong>:问题修复后,拖入到这里.测试关注其中的问题,然后一一进行验证.如果有问题,打回到解决中.并修改Tag.如果没有问题,拖入问题解决</li>
<li><strong>问题解决</strong>:解决了的问题放入到这里.</li>
</ul>
<p>由于teambition是由任务为导向的,目前还不知道到底用来管理缺陷靠谱不.只有试一试再说了.如果不得行,可能还是会换成<code>redmine</code>来进行管理.但是这就又多了一套体系.</p>
<h4 id="其他">其他</h4><p>整个teambition中到处都是可以增加评论和收藏的.我觉得这个也是比较有用的东西.一个任务发布出来,团队成员可以针对这个任务做一些讨论或意见,然后全部保存下来,真正做这个任务的人可能就会得到很多的帮助.<br>但是目前整个teambition中创建讨论还是比较麻烦.没找到直接创建讨论的地方,只能先建立一个任务当做一个话题.然后在里面发表评论作为讨论的发言.teambition这个团队的另外一个产品<code>简聊</code>到是是完成这个功能的东西,但是又需要开一个另外的工具,都觉得比较麻烦.于是也就罢了.</p>
<h2 id="总结">总结</h2><p>这个算是我们团队的一个新的尝试,使用新的工具,使用新的过程模型来完成新的目标.目前试用了一周,感觉还是可以的.具体的成效就等到这个项目完了以后再来补充吧.</p>
<p><strong>PS:</strong>TeamBition的界面我个人觉得单调了点,随便比<code>Tower.im</code>好看些.但是我觉得比不上<code>WorkLite</code>.还有就是所谓的桌面客户端,简直是太偷懒了!!直接就是一个<code>node-webkit</code>浏览器,这个和我直接打开safari有啥区别….而且在接收通知的时候有可能CPU还要狂飙.. 你看人家<code>doit.im</code> 客户端就是客户端,网页就是网页,多好~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="使用TeamBition进行敏捷开发">使用TeamBition进行敏捷开发</h1><p>最近开始新的项目,由于人数也不多,需求也比较模糊,因此觉得可以试一试采用敏捷开发的模式来进行过程管理.于是研究了一下如何方便的进行这方面的管理.</p>
<h2 id="SCRUM">SCRUM</h2><h3 id="基本概念">基本概念</h3><p>Scrum就是敏捷开发中的一种模型.它主要有三个基本的概念:</p>
<ol>
<li>角色</li>
<li>工件</li>
<li>活动</li>
</ol>
<h4 id="1-_角色">1. 角色</h4><ul>
<li><strong>Product Owner(产品负责人)</strong>:负责维护产品订单的人，代表利益相关者的利益。</li>
<li><strong>Scrum Master(Scrum管理者)</strong>:为Scrum过程负责的人，确保scrum的正确使用并使得Scrum的收益最大化。</li>
<li><strong>Team(研发团队)</strong>:由负责自我管理开发产品的人组成的跨职能团队。</li>
</ul>
<p>他们的职责分别是:</p>
<h5 id="Product_Owner">Product Owner</h5><ul>
<li><strong>建立愿景</strong>:确认产品的项目愿景</li>
<li><strong>定义产品路标</strong>:确定大得功能以及客户的期望</li>
<li><strong>确定需求</strong>:生成故事描述</li>
<li><strong>维护Product Backlog</strong>:确定功能优先级,确保对即将开始的迭代故事进行了足够的细化</li>
<li><strong>客户验收</strong>:能让客户使用产品提供反馈</li>
<li><strong>计划</strong>:确定交付时间,跟踪进度</li>
<li><strong>协调</strong>:协调团队需要的资源</li>
</ul>
<h5 id="Scrum_Master">Scrum Master</h5><ul>
<li><strong>确保流程的贯彻执行</strong>:对如何执行上达成一致,保证团队一致的执行流程</li>
<li><strong>找到并去除障碍</strong>:找到任何妨碍目标达成的障碍,并设法调动资源去除障碍</li>
<li><strong>保证内部沟通的顺畅</strong>:保证团队沟通顺利,高效</li>
<li><strong>维持工作环境</strong>:确保整个项目中团队的工作节奏和工作进度.</li>
<li><strong>团队提高</strong>:确保团队的人员是合适的,在团队中组织技能培训,通过激发创造性与推动授权来提升团队成员</li>
</ul>
<h5 id="Team">Team</h5><ul>
<li><strong>协作</strong>:具有不同特长的团队成员,形成高度的自我管理能力,保持节奏的实现每一次Sprint目标</li>
<li><strong>维护架构</strong>:保证架构的稳定性和持续性</li>
<li><strong>掌握需求</strong>:团队有这人明白具体需求是什么,如何实现.</li>
<li><strong>保证质量</strong>:通过代码标准,持续集成,配置管理,内外测试等保证产品的质量</li>
<li><strong>设计方案</strong>:决定如何编写代码实现需求,包括单元测试和自动化测试</li>
</ul>]]>
    
    </summary>
    
      <category term="团队管理" scheme="http://sunxiang0918.github.io/tags/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/"/>
    
      <category term="敏捷开发" scheme="http://sunxiang0918.github.io/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>Java HashMap工作原理]]></title>
    <link href="http://sunxiang0918.github.io/2015/09/02/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://sunxiang0918.github.io/2015/09/02/Java-HashMap工作原理/</id>
    <published>2015-09-02T15:00:38.000Z</published>
    <updated>2015-09-07T15:17:25.000Z</updated>
    <content type="html"><![CDATA[<p>Java中HashMap的工作原理其实以前就看过很多次了,也仔细的分析过它的源码.但是一直没有写一篇文章来记录一下,这篇文章写的非常的清楚,非常的透彻.是我见过讲的最详细的.值得保存下来.</p>
<h1 id="Java_HashMap工作原理">Java HashMap工作原理</h1><p>大部分Java开发者都在使用Map，特别是HashMap。HashMap是一种简单但强大的方式去存储和获取数据。但有多少开发者知道HashMap内部如何工作呢？几天前，我阅读了java.util.HashMap的大量源代码（包括Java 7 和Java 8），来深入理解这个基础的数据结构。在这篇文章中，我会解释java.util.HashMap的实现，描述Java 8实现中添加的新特性，并讨论性能、内存以及使用HashMap时的一些已知问题。</p>
<h2 id="内部存储">内部存储</h2><p>Java HashMap类实现了Map<k, v="">接口。这个接口中的主要方法包括：</k,></p>
<ul>
<li>V put(K key, V value)</li>
<li>V get(Object key)</li>
<li>V remove(Object key)</li>
<li>Boolean containsKey(Object key)</li>
</ul>
<p>HashMap使用了一个内部类Entry<k, v="">来存储数据。这个内部类是一个简单的键值对，并带有额外两个数据：</k,></p>
<ul>
<li>一个指向其他入口（译者注：引用对象）的引用，这样HashMap可以存储类似链接列表这样的对象。</li>
<li>一个用来代表键的哈希值，存储这个值可以避免HashMap在每次需要时都重新生成键所对应的哈希值。</li>
</ul>
<a id="more"></a>
<p>下面是Entry<k, v="">在Java 7下的一部分代码：</k,></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap将数据存储到多个单向Entry链表中（有时也被称为桶bucket或者容器orbins）。所有的列表都被注册到一个Entry数组中（Entry<k, v="">[]数组），这个内部数组的默认长度是16。</k,></p>
<p>下面这幅图描述了一个HashMap实例的内部存储，它包含一个nullable对象组成的数组。每个对象都连接到另外一个对象，这样就构成了一个链表。</p>
<p><img src="/img/2015/09/02/1.jpg" alt=""> </p>
<p>所有具有相同哈希值的键都会被放到同一个链表（桶）中。具有不同哈希值的键最终可能会在相同的桶中。</p>
<p>当用户调用 put(K key， V value) 或者 get(Object key) 时，程序会计算对象应该在的桶的索引。然后，程序会迭代遍历对应的列表，来寻找具有相同键的Entry对象（使用键的equals()方法）。</p>
<p>对于调用get()的情况，程序会返回值所对应的Entry对象（如果Entry对象存在）。</p>
<p>对于调用put(K key, V value)的情况，如果Entry对象已经存在，那么程序会将值替换为新值，否则，程序会在单向链表的表头创建一个新的Entry（从参数中的键和值）。</p>
<p>桶（链表）的索引，是通过map的3个步骤生成的：</p>
<ul>
<li>首先获取键的<strong>散列码</strong>。</li>
<li>程序<strong>重复</strong>散列码，来阻止针对键的糟糕的哈希函数，因为这有可能会将所有的数据都放到内部数组的相同的索引（桶）上。</li>
<li>程序拿到重复后的散列码，并对其使用数组长度（最小是1）的<strong>位掩码（bit-mask）</strong>。这个操作可以保证索引不会大于数组的大小。你可以将其看做是一个经过计算的优化取模函数。</li>
</ul>
<p>下面是生成索引的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the "rehash" function in JAVA 7 that takes the hashcode of the key</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// the "rehash" function in JAVA 8 that directly takes the key</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// the function that returns the index from the rehashed hash</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了更有效地工作，内部数组的大小必须是2的幂值。让我们看一下为什么：</p>
<p>假设数组的长度是17，那么掩码的值就是16（数组长度-1）。16的二进制表示是0…010000，这样对于任何值H来说，“H &amp; 16”的结果就是16或者0。这意味着长度为17的数组只能应用到两个桶上：一个是0，另外一个是16，这样不是很有效率。但是如果你将数组的长度设置为2的幂值，例如16，那么按位索引的工作变成“H &amp; 15”。15的二进制表示是0…001111，索引公式输出的值可以从0到15，这样长度为16的数组就可以被充分使用了。例如：</p>
<ul>
<li>如果H = 952，它的二进制表示是0..01110111000，对应的索引是0…01000 = 8</li>
<li>如果H = 1576，它的二进制表示是0..011000101000，对应的索引是0…01000 = 8</li>
<li>如果H = 12356146，它的二进制表示是0..0101111001000101000110010，对应的索引是0…00010 = 2</li>
<li>如果H = 59843，它的二进制表示是0..01110100111000011，它对应的索引是0…00011 = 3</li>
</ul>
<p>这种机制对于开发者来说是透明的：如果他选择一个长度为37的HashMap，Map会自动选择下一个大于37的2的幂值（64）作为内部数组的长度。</p>
<h2 id="自动调整大小">自动调整大小</h2><p>在获取索引后，get()、put()或者remove()方法会访问对应的链表，来查看针对指定键的Entry对象是否已经存在。在不做修改的情况下，这个机制可能会导致性能问题，因为这个方法需要迭代整个列表来查看Entry对象是否存在。假设内部数组的长度采用默认值16，而你需要存储2，000,000条记录。在最好的情况下，每个链表会有125,000个Entry对象（2,000,000/16）。get()、remove()和put()方法在每一次执行时，都需要进行125,000次迭代。为了避免这种情况，HashMap可以增加内部数组的长度，从而保证链表中只保留很少的Entry对象。</p>
<p>当你创建一个HashMap时，你可以通过以下构造函数指定一个初始长度，以及一个loadFactor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span></span><br></pre></td></tr></table></figure>
<p>如果你不指定参数，那么默认的initialCapacity的值是16， loadFactor的默认值是0.75。initialCapacity代表内部数组的链表的长度。</p>
<p>当你每次使用put(…)方法向Map中添加一个新的键值对时，该方法会检查是否需要增加内部数组的长度。为了实现这一点，Map存储了2个数据：</p>
<ul>
<li>Map的大小：它代表HashMap中记录的条数。我们在向HashMap中插入或者删除值时更新它。</li>
<li>阀值：它等于内部数组的长度*loadFactor，在每次调整内部数组的长度时，该阀值也会同时更新。</li>
</ul>
<p>在添加新的Entry对象之前，put(…)方法会检查当前Map的大小是否大于阀值。如果大于阀值，它会创建一个新的数组，数组长度是当前内部数组的两倍。因为新数组的大小已经发生改变，所以索引函数（就是返回“键的哈希值 &amp; (数组长度-1)”的位运算结果）也随之改变。调整数组的大小会创建两个新的桶（链表），并且将所有现存Entry对象重新分配到桶上。调整数组大小的目标在于降低链表的大小，从而降低put()、remove()和get()方法的执行时间。对于具有相同哈希值的键所对应的所有Entry对象来说，它们会在调整大小后分配到相同的桶中。但是，如果两个Entry对象的键的哈希值不一样，但它们之前在同一个桶上，那么在调整以后，并不能保证它们依然在同一个桶上。</p>
<p><img src="/img/2015/09/02/2.jpg" alt=""> </p>
<p>这幅图片描述了调整前和调整后的内部数组的情况。在调整数组长度之前，为了得到Entry对象E，Map需要迭代遍历一个包含5个元素的链表。在调整数组长度之后，同样的get()方法则只需要遍历一个包含2个元素的链表，这样get()方法在调整数组长度后的运行速度提高了2倍。</p>
<h2 id="线程安全">线程安全</h2><p>如果你已经非常熟悉HashMap，那么你肯定知道它不是线程安全的，但是为什么呢？例如假设你有一个Writer线程，它只会向Map中插入已经存在的数据，一个Reader线程，它会从Map中读取数据，那么它为什么不工作呢？</p>
<p>因为在自动调整大小的机制下，如果线程试着去添加或者获取一个对象，Map可能会使用旧的索引值，这样就不会找到Entry对象所在的新桶。</p>
<p>在最糟糕的情况下，当2个线程同时插入数据，而2次put()调用会同时出发数组自动调整大小。既然两个线程在同时修改链表，那么Map有可能在一个链表的内部循环中退出。如果你试着去获取一个带有内部循环的列表中的数据，那么get()方法永远不会结束。</p>
<p><strong>HashTable</strong>提供了一个线程安全的实现，可以阻止上述情况发生。但是，既然所有的同步的CRUD操作都非常慢。例如，如果线程1调用get(key1)，然后线程2调用get(key2)，线程2调用get(key3)，那么在指定时间，只能有1个线程可以得到它的值，但是3个线程都可以同时访问这些数据。</p>
<p>从Java 5开始，我们就拥有一个更好的、保证线程安全的HashMap实现：<strong>ConcurrentHashMap</strong>。对于ConcurrentMap来说，只有桶是同步的，这样如果多个线程不使用同一个桶或者调整内部数组的大小，它们可以同时调用get()、remove()或者put()方法。<strong>在一个多线程应用程序中，这种方式是更好的选择</strong>。</p>
<h2 id="键的不变性">键的不变性</h2><p>为什么将字符串和整数作为HashMap的键是一种很好的实现？主要是因为它们是不可变的！如果你选择自己创建一个类作为键，但不能保证这个类是不可变的，那么你可能会在HashMap内部丢失数据。</p>
<p>我们来看下面的用例：</p>
<ul>
<li>你有一个键，它的内部值是“1”。</li>
<li>你向HashMap中插入一个对象，它的键就是“1”。</li>
<li>HashMap从键（即“1”）的散列码中生成哈希值。</li>
<li>Map在新创建的记录中存储这个哈希值。</li>
<li>你改动键的内部值，将其变为“2”。</li>
<li>键的哈希值发生了改变，但是HashMap并不知道这一点（因为存储的是旧的哈希值）。</li>
<li>你试着通过修改后的键获取相应的对象。</li>
<li>Map会计算新的键（即“2”）的哈希值，从而找到Entry对象所在的链表（桶）。<ul>
<li>情况1： 既然你已经修改了键，Map会试着在错误的桶中寻找Entry对象，没有找到。</li>
<li>情况2： 你很幸运，修改后的键生成的桶和旧键生成的桶是同一个。Map这时会在链表中进行遍历，已找到具有相同键的Entry对象。但是为了寻找键，Map首先会通过调用equals()方法来<strong>比较键的哈希值</strong>。因为修改后的键会生成不同的哈希值（旧的哈希值被存储在记录中），那么Map没有办法在链表中找到对应的Entry对象。</li>
<li>下面是一个Java示例，我们向Map中插入两个键值对，然后我修改第一个键，并试着去获取这两个对象。你会发现从Map中返回的只有第二个对象，第一个对象已经“丢失”在HashMap中：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableKeyTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyKey</span> </span>&#123;</span><br><span class="line">            Integer i;</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.i = i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">MyKey</span><span class="params">(Integer i)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.i = i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> MyKey) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i.equals(((MyKey) obj).i);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Map&lt;MyKey, String&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        MyKey key1 = <span class="keyword">new</span> MyKey(<span class="number">1</span>);</span><br><span class="line">        MyKey key2 = <span class="keyword">new</span> MyKey(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        myMap.put(key1, <span class="string">"test "</span> + <span class="number">1</span>);</span><br><span class="line">        myMap.put(key2, <span class="string">"test "</span> + <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// modifying key1</span></span><br><span class="line">        key1.setI(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">        String test1 = myMap.get(key1);</span><br><span class="line">        String test2 = myMap.get(key2);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"test1= "</span> + test1 + <span class="string">" test2="</span> + test2);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的输出是“test1=null test2=test 2”。如我们期望的那样，Map没有能力获取经过修改的键 1所对应的字符串1。</p>
<h2 id="Java_8_中的改进">Java 8 中的改进</h2><p>在Java 8中，HashMap中的内部实现进行了很多修改。的确如此，Java 7使用了1000行代码来实现，而Java 8中使用了2000行代码。我在前面描述的大部分内容在Java 8中依然是对的，除了使用链表来保存Entry对象。在Java 8中，我们仍然使用数组，但它会被保存在Node中，Node中包含了和之前Entry对象一样的信息，并且也会使用链表：</p>
<p>下面是在Java 8中Node实现的一部分代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">     <span class="keyword">final</span> K key;</span><br><span class="line">     V value;</span><br><span class="line">     Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>
<p>那么和Java 7相比，到底有什么大的区别呢？好吧，Node可以被扩展成TreeNode。TreeNode是一个红黑树的数据结构，它可以存储更多的信息，这样我们可以在O(log(n))的复杂度下添加、删除或者获取一个元素。下面的示例描述了TreeNode保存的所有信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// inherited from Node&lt;K,V&gt;</span></span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">// inherited from Node&lt;K,V&gt;</span></span><br><span class="line">    V value; <span class="comment">// inherited from Node&lt;K,V&gt;</span></span><br><span class="line">    Node&lt;K,V&gt; next; <span class="comment">// inherited from Node&lt;K,V&gt;</span></span><br><span class="line">    Entry&lt;K,V&gt; before, after;<span class="comment">// inherited from LinkedHashMap.Entry&lt;K,V&gt;</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;</span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;</span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br></pre></td></tr></table></figure>
<p>红黑树是自平衡的二叉搜索树。它的内部机制可以保证它的长度总是log(n)，不管我们是添加还是删除节点。使用这种类型的树，最主要的好处是针对内部表中许多数据都具有相同索引（桶）的情况，这时对树进行搜索的复杂度是O(log(n))，而对于链表来说，执行相同的操作，复杂度是O(n)。</p>
<p>如你所见，我们在树中确实存储了比链表更多的数据。根据继承原则，<strong>内部表中可以包含Node</strong>（链表）或者<strong>TreeNode（红黑树）</strong>。Oracle决定根据下面的规则来使用这两种数据结构：</p>
<ul>
<li><p>对于内部表中的指定索引（桶），如果node的数目多于8个，那么链表就会被转换成红黑树。</p>
</li>
<li><p>对于内部表中的指定索引（桶），如果node的数目小于6个，那么红黑树就会被转换成链表。</p>
</li>
</ul>
<p><img src="/img/2015/09/02/3.jpg" alt=""> </p>
<p>这张图片描述了在Java 8 HashMap中的内部数组，它既包含树（桶0），也包含链表（桶1，2和3）。桶0是一个树结构是因为它包含的节点大于8个。</p>
<h2 id="内存开销">内存开销</h2><h3 id="JAVA_7">JAVA 7</h3><p>使用HashMap会消耗一些内存。在Java 7中，HashMap将键值对封装成Entry对象，一个Entry对象包含以下信息：</p>
<ul>
<li>指向下一个记录的引用</li>
<li>一个预先计算的哈希值（整数）</li>
<li>一个指向键的引用</li>
<li>一个指向值的引用</li>
</ul>
<p>此外，Java 7中的HashMap使用了Entry对象的内部数组。假设一个Java 7 HashMap包含N个元素，它的内部数组的容量是CAPACITY，那么额外的内存消耗大约是：</p>
<p><code>sizeOf(integer)* N + sizeOf(reference)* (3*N+C)</code></p>
<p>其中：</p>
<ul>
<li>整数的大小是4个字节</li>
<li>引用的大小依赖于JVM、操作系统以及处理器，但通常都是4个字节。</li>
</ul>
<p>这就意味着内存总开销通常是16 <em> N + 4 </em> CAPACITY字节。</p>
<p>注意：在Map自动调整大小后，CAPACITY的值是下一个大于N的最小的2的幂值。</p>
<p>注意：从Java 7开始，HashMap采用了延迟加载的机制。这意味着即使你为HashMap指定了大小，在我们第一次使用put()方法之前，记录使用的内部数组（耗费4*CAPACITY字节）也不会在内存中分配空间。</p>
<h3 id="JAVA_8">JAVA 8</h3><p>在Java 8实现中，计算内存使用情况变得复杂一些，因为Node可能会和Entry存储相同的数据，或者在此基础上再增加6个引用和一个Boolean属性（指定是否是TreeNode）。</p>
<p>如果所有的节点都只是Node，那么Java 8 HashMap消耗的内存和Java 7 HashMap消耗的内存是一样的。</p>
<p>如果所有的节点都是TreeNode，那么Java 8 HashMap消耗的内存就变成：</p>
<p><code>N * sizeOf(integer) + N * sizeOf(boolean) + sizeOf(reference)* (9*N+CAPACITY )</code></p>
<p>在大部分标准JVM中，上述公式的结果是44 <em> N + 4 </em> CAPACITY 字节。</p>
<h2 id="性能问题">性能问题</h2><h3 id="非对称HashMap_vs_均衡HashMap">非对称HashMap vs 均衡HashMap</h3><p>在最好的情况下，get()和put()方法都只有O(1)的复杂度。但是，如果你不去关心键的哈希函数，那么你的put()和get()方法可能会执行非常慢。put()和get()方法的高效执行，取决于数据被分配到内部数组（桶）的不同的索引上。如果键的哈希函数设计不合理，你会得到一个非对称的分区（不管内部数据的是多大）。所有的put()和get()方法会使用最大的链表，这样就会执行很慢，因为它需要迭代链表中的全部记录。在最坏的情况下（如果大部分数据都在同一个桶上），那么你的时间复杂度就会变为O(n)。</p>
<p>下面是一个可视化的示例。第一张图描述了一个非对称HashMap，第二张图描述了一个均衡HashMap。</p>
<p><img src="/img/2015/09/02/4.jpg" alt=""> </p>
<p>在这个非对称HashMap中，在桶0上运行get()和put()方法会很花费时间。获取记录K需要花费6次迭代。</p>
<p><img src="/img/2015/09/02/5.jpg" alt=""> </p>
<p>在这个均衡HashMap中，获取记录K只需要花费3次迭代。这两个HashMap存储了相同数量的数据，并且内部数组的大小一样。唯一的区别是键的哈希函数，这个函数用来将记录分布到不同的桶上。</p>
<p>下面是一个使用Java编写的极端示例，在这个示例中，我使用哈希函数将所有的数据放到相同的链表（桶），然后我添加了2,000,000条数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyKey</span> </span>&#123;</span><br><span class="line">            Integer i;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">MyKey</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.i =i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            …</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        Date begin = <span class="keyword">new</span> Date();</span><br><span class="line">        Map &lt;MyKey,String&gt; myMap= <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2_500_000</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2_000_000</span>;i++)&#123;</span><br><span class="line">            myMap.put( <span class="keyword">new</span> MyKey(i), <span class="string">"test "</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Date end = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"Duration (ms) "</span>+ (end.getTime()-begin.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的机器配置是core i5-2500k @ 3.6G，在java 8u40下需要花费超过<strong>45分钟</strong>的时间来运行（我在45分钟后停止了进程）。如果我运行同样的代码， 但是我使用如下的hash函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> key = <span class="number">2097152</span>-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> key+<span class="number">2097152</span>*i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行它需要花费<strong>46秒</strong>，和之前比，这种方式好很多了！新的hash函数比旧的hash函数在处理哈希分区时更合理，因此调用put()方法会更快一些。如果你现在运行相同的代码，但是使用下面的hash函数，它提供了更好的哈希分区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只需要花费<strong>2秒</strong>！</p>
<p>我希望你能够意识到哈希函数有多重要。如果在Java 7上面运行同样的测试，第一个和第二个的情况会更糟（因为Java 7中的put()方法复杂度是O(n)，而Java 8中的复杂度是O(log(n))。</p>
<p>在使用HashMap时，你需要针对键找到一种哈希函数，可以<strong>将键扩散到最可能的桶上</strong>。为此，你需要<strong>避免哈希冲突</strong>。String对象是一个非常好的键，因为它有很好的哈希函数。Integer也很好，因为它的哈希值就是它自身的值。</p>
<h3 id="调整大小的开销">调整大小的开销</h3><p>如果你需要存储大量数据，你应该在创建HashMap时指定一个初始的容量，这个容量应该接近你期望的大小。</p>
<p>如果你不这样做，Map会使用默认的大小，即16，factorLoad的值是0.75。前11次调用put()方法会非常快，但是第12次（16<em>0.75）调用时会创建一个新的长度为32的内部数组（以及对应的链表/树），第13次到第22次调用put()方法会很快，但是第23次（32</em>0.75）调用时会重新创建（再一次）一个新的内部数组，数组的长度翻倍。然后内部调整大小的操作会在第48次、96次、192次…..调用put()方法时触发。如果数据量不大，重建内部数组的操作会很快，但是数据量很大时，花费的时间可能会从秒级到分钟级。通过初始化时指定Map期望的大小，你可以<strong>避免调整大小操作带来的消耗</strong>。</p>
<p>但这里也有一个<strong>缺点</strong>：如果你将数组设置的非常大，例如2^28，但你只是用了数组中的2^26个桶，那么你将会浪费大量的内存（在这个示例中大约是2^30字节）。</p>
<h2 id="结论">结论</h2><p>对于简单的用例，你没有必要知道HashMap是如何工作的，因为你不会看到O(1)、O(n)以及O(log(n))之间的区别。但是如果能够理解这一经常使用的数据结构背后的机制，总是有好处的。另外，对于Java开发者职位来说，这是一道典型的面试问题。</p>
<p>对于大数据量的情况，了解HashMap如何工作以及理解键的哈希函数的重要性就变得非常重要。</p>
<p>我希望这篇文章可以帮助你对HashMap的实现有一个深入的理解。</p>
<hr>
<p>原文链接： <a href="http://coding-geek.com/how-does-a-hashmap-work-in-java/" target="_blank" rel="external">coding-geek</a> 翻译： <a href="http://www.importnew.com/" target="_blank" rel="external">ImportNew.com</a> - <a href="http://www.importnew.com/author/wing011203" target="_blank" rel="external">Wing</a><br>译文链接： <a href="http://www.importnew.com/16599.html" target="_blank" rel="external">http://www.importnew.com/16599.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Java中HashMap的工作原理其实以前就看过很多次了,也仔细的分析过它的源码.但是一直没有写一篇文章来记录一下,这篇文章写的非常的清楚,非常的透彻.是我见过讲的最详细的.值得保存下来.</p>
<h1 id="Java_HashMap工作原理">Java HashMap工作原理</h1><p>大部分Java开发者都在使用Map，特别是HashMap。HashMap是一种简单但强大的方式去存储和获取数据。但有多少开发者知道HashMap内部如何工作呢？几天前，我阅读了java.util.HashMap的大量源代码（包括Java 7 和Java 8），来深入理解这个基础的数据结构。在这篇文章中，我会解释java.util.HashMap的实现，描述Java 8实现中添加的新特性，并讨论性能、内存以及使用HashMap时的一些已知问题。</p>
<h2 id="内部存储">内部存储</h2><p>Java HashMap类实现了Map<K, V>接口。这个接口中的主要方法包括：</p>
<ul>
<li>V put(K key, V value)</li>
<li>V get(Object key)</li>
<li>V remove(Object key)</li>
<li>Boolean containsKey(Object key)</li>
</ul>
<p>HashMap使用了一个内部类Entry<K, V>来存储数据。这个内部类是一个简单的键值对，并带有额外两个数据：</p>
<ul>
<li>一个指向其他入口（译者注：引用对象）的引用，这样HashMap可以存储类似链接列表这样的对象。</li>
<li>一个用来代表键的哈希值，存储这个值可以避免HashMap在每次需要时都重新生成键所对应的哈希值。</li>
</ul>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker入门]]></title>
    <link href="http://sunxiang0918.github.io/2015/08/27/Docker%E5%85%A5%E9%97%A8/"/>
    <id>http://sunxiang0918.github.io/2015/08/27/Docker入门/</id>
    <published>2015-08-27T13:29:31.000Z</published>
    <updated>2015-08-27T15:27:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Docker入门">Docker入门</h1><p>Docker是一种新型的虚拟化技术,他释放了虚拟化的性能,极大的降低了云计算资源供应的成本,同时让应用的分发,测试,部署都变得非常的高效的容易!</p>
<h2 id="Docker简介">Docker简介</h2><p>Docker是一个开源项目,诞生于2013年初.使用的是Google的Go语言实现,遵循了Apache2.0协议.代码放在了<a href="https://github.com/docker/docker" target="_blank" rel="external">GitHub</a>上.<br>它使用了Linux的LXC等技术,实现了轻量级的操作系统虚拟化.</p>
<h2 id="使用Docker的好处">使用Docker的好处</h2><ol>
<li>更快速的交付和部署<br> 开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。</li>
<li>更高效的虚拟化<br> Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。</li>
<li>更轻松的迁移和扩展<br> Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</li>
<li>更简单的管理<br> 所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</li>
</ol>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">Docker</th>
<th style="text-align:center">虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">启动</td>
<td style="text-align:center">秒级</td>
<td style="text-align:center">分钟级</td>
</tr>
<tr>
<td style="text-align:center">硬盘使用</td>
<td style="text-align:center">一般为 MB</td>
<td style="text-align:center">一般为 GB</td>
</tr>
<tr>
<td style="text-align:center">性能</td>
<td style="text-align:center">接近原生</td>
<td style="text-align:center">弱于原生</td>
</tr>
<tr>
<td style="text-align:center">系统支持量</td>
<td style="text-align:center">单机支持上千个容器</td>
<td style="text-align:center">一般几十个</td>
</tr>
</tbody>
</table>
<h2 id="基本概念">基本概念</h2><p>Docker包含了三个基本的概念:</p>
<ul>
<li>镜像(Image)</li>
<li>容器(Container)</li>
<li>仓库(Repository)</li>
</ul>
<p>理解了这三个概念,就理解了Docker的整个生命周期</p>
<h3 id="镜像">镜像</h3><ol>
<li>Docker镜像就是一个创建的只读模板</li>
<li>里面仅安装了最小化的操作系统和用户需要的应用程序。</li>
<li>镜像可以用来创建 Docker 容器。</li>
</ol>
<h3 id="容器">容器</h3><ol>
<li>容器是从镜像创建的运行实例。</li>
<li>每个容器都是相互隔离的、保证安全的平台。</li>
<li>可以把镜像看成是一个类,而容器就是这个类的实例.</li>
</ol>
<h3 id="仓库">仓库</h3><ol>
<li>仓库是集中存放镜像文件的场所。</li>
<li>仓库有公有仓库和私有仓库之分</li>
<li>我们可以把自己创建的镜像注册到仓库中,提供给他人使用</li>
<li>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</li>
</ol>
<h2 id="安装">安装</h2><p>由于Linux内核的限制,Docker只能安装在kernel3.8以上<br>最新的ubuntu14.10和centos7都已经包含了docker最新的安装源.</p>
<h3 id="CentOS">CentOS</h3><p>直接在终端输入: <code>sudo yum install docker</code> 即可<br>然后可以输入以下命令启动并注册Docker到系统中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service docker start</span><br><span class="line">sudo chkconfig docker on</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu">Ubuntu</h3><p>在终端中输入以下命令安装:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install apt-transport-https</span><br><span class="line">$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:<span class="number">80</span> --recv-keys <span class="number">36</span>A1D7869245C8950F966E92D8576A8BA88D21E9</span><br><span class="line">$ sudo bash -c <span class="string">"echo deb https://get.docker.io/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list"</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install lxc-docker</span><br></pre></td></tr></table></figure>
<h2 id="最简例子">最简例子</h2><p>这里演示一个最简单的docker的使用例子.就是运行一个tomcat8</p>
<ol>
<li>在命令行中输入:<code>docker search tomcat</code><br> <img src="/img/2015/08/27/1.png" alt=""><br> 它显示了在中央库中存在的tomcat镜像</li>
<li>从中央仓库中下载tomcat8的镜像:<br> 在终端中输入:<code>docker pull tomcat:8.0</code><br> <img src="/img/2015/08/27/2.png" alt=""><br> 这显示的就是完成从中央仓库下载镜像</li>
<li>查看当前本地docker有哪些镜像<br> <img src="/img/2015/08/27/3.png" alt=""><br> 它显示了当前有两个镜像,分别是什么,从哪下载的,镜像GUID是什么,大小是什么等等  </li>
<li>从镜像中启动一个新的tomcat容器<br> <img src="/img/2015/08/27/4.png" alt=""><br> 命令是 <code>docker run -d -p 8888:8080 tomcat:8.0</code><br> <code>-d</code>表示后台运行, <code>-p</code>表示实体机上的端口与docker容器内的端口映射 <code>tomcat:8.0</code>表示镜像的名字</li>
<li>使用 docker ps -a 查看容器的状态<br> <img src="/img/2015/08/27/5.png" alt=""><br> 表示了容器的GUID,镜像名字,执行命令,创建时间,状态,端口映射,容器名字等等</li>
<li>这个时候就已经可以在浏览器中通过宿主机IP和端口8888来访问tomcat8的容器了.这样在一个什么都没有安装的新机器上,其实很简单的就完成了tomcat的安装.这就是docker的优势<br> <img src="/img/2015/08/27/6.png" alt=""></li>
</ol>
<h2 id="常用命令">常用命令</h2><p>以下就是Docker的一些常用的命令.便于我们平时的操作</p>
<ul>
<li><p><strong>RUN</strong>:这个命令是最常用的命令.用于使用镜像创建一个新容器，并在其中运行给定命令.当其中的命令执行完后,关闭容器.<br>  它的语法是:<code>docker run 参数 镜像名:版本号</code><br>  当执行这个命令后,docker会根据镜像,重新生成一个<em>新的容器</em>,并执行</p>
<ul>
<li><strong>-d</strong>:后台模式启动,这样就不会侵占当前当前的控制台</li>
<li><strong>-rm</strong>:容器执行完毕后删除容器.这功能在调试的时候非常的有用,Docker的容器开销非常的小,以至于可以随用随删除</li>
<li><strong>-ti</strong>:分配一个伪终端绑定到容器的标准输入上,并一直打开.这样就可以在实体机上操作容器的终端了.通常都是这样用的:docker run -ti tomcat:8.0 /bin/bash    这句话的意思就是启动一个新的tomcat容器,并进入它的终端</li>
<li><strong>-p</strong>:绑定容器对外访问的端口,因为默认情况下容器在docker的虚拟环境下会有自己的一个随机的虚拟IP.外面是不能直接访问的.那么如果要访问容器的应用,就需要把外面的端口和容器内的端口映射起来.这样调用实体机的某一个端口相当于是在访问docker容器中的某个端口.比如:  -p 8888:8080   表示实体机的8888端口映射到容器中的8080端口.</li>
<li><strong>-name</strong>:给容器指定一个名称,如果不指定,那么就是一个随机的名字.</li>
</ul>
</li>
<li><p><strong>STOP</strong>:该命令是用来关闭容器的,使用非常的简单.<br>  它的语法是:<code>docker stop 容器GUID/容器名</code><br>  当执行这个命令后,docker会结束此容器.当然,如果这个容器不是后台执行的.那么直接在容器的终端中输入exit也是可以结束容器的</p>
</li>
<li><p><strong>START</strong>:与Stop相反,start命令是用来启动容器的.与run命令不同的是,start命令不会从镜像中创建一个新的容器.它只会把现有的处于停止或暂停状态的容器重新启动起来.<br>  它的语法是: <code>docker start 参数 容器GUID/容器名</code></p>
</li>
<li><p><strong>EXEC</strong>:这个命令是在某个正在运行的容器中执行某个命令.我们可以把这个命令作为进入容器环环境的一个方法.<br>  它的语法是:<code>docker exec 参数 容器GUID/容器名 执行的命令</code>.<br>  比如:<code>docker exec -ti c13 /bin/bash</code>.这个就是直接进入了容器的终端中,请注意用户那,已经是tomcat容器的上下文终端了.这个时候就可以做一系列的修改.</p>
</li>
<li><p><strong>EXPORT/IMPORT</strong>:这两个命令用于把当前执行的容器导出为快照,以及恢复快照为镜像.通过这两个命令就可以很方便的把自己对容器的修改分发给其他的人.<br>  它们的语法是:<code>docker export 容器GUID &gt; 文件名.tar</code>和<code>cat tar文件 | docker import 文件路径 镜像名字:版本</code></p>
</li>
<li><p><strong>RM</strong>:这个指令是删除一个容器.当容器执行完毕后,如果在启动的时候没有配置-rm 那么它默认是不会删除的.这样有可能容器会越来越多.这时可以使用<code>docker rm 容器guid</code>的方式来删除不要的容器.<br>  注意:只能删除已停止了的容器.如果没有配置数据卷,那么删除容器后,数据就会被清除</p>
</li>
<li><p><strong>PS</strong>:它可以查看当前docker中容器的情况.包括了容器的各种信息.<br>  它的语法是: <code>docker ps -a</code><br>  可以显示所有的容器,包括已停止了的.</p>
</li>
<li><p><strong>TOP</strong>:这个命令用于显示某个docker容器中所有进程的情况.方便我们分析.<br>  它的语法是:<code>docker top 容器guid</code><br>  <img src="/img/2015/08/27/7.png" alt=""></p>
</li>
<li><p><strong>SEARCH</strong>:这个命令是用来从仓库中搜寻镜像的.默认情况下,它会从中央仓库中去搜寻镜像文件.当然,你也可以指定从某个私服中去搜寻.<br>  它的语法是: <code>docker search 镜像关键字</code></p>
</li>
<li><p><strong>PULL</strong>:使用这个命令可以从仓库中下载镜像到本地.也是很常用的一个命令.<br>  它的语法是:<code>docker pull 镜像名:版本号</code><br>  注意:如果是从私服中下载,那么需要再镜像名前面加上私服的<code>url/</code>.</p>
</li>
<li><p><strong>PUSH</strong>:与PULL命令相反,你可以把你自己做好的镜像注册到仓库中提供给他人使用.<br>  它的语法是: <code>docker push 镜像名字</code><br>  同样,如果你要push到私服里.需要在镜像名字前使用<code>tags</code>命令增加私服的<code>url/</code></p>
</li>
<li><p><strong>IMAGES</strong>:使用这个命令可以列出你现在本地有哪一些的镜像文件可以使用.<br>  它的语法是:<code>docker images</code></p>
</li>
<li><p><strong>COMMIT</strong>:当我们对某个容器做修改之后.如果需要保留这些修改到镜像中.那么就可以是commit命令,提交修改到镜像.需要注意的是这个命令只会在原来的镜像基础上新创建一个镜像.镜像是只读的!<br>  它的语法是:<code>docker commit -m “提交的内容” 容器GUID 镜像名:版本</code><br>  如果成功它会返回镜像的guid.</p>
</li>
<li><p><strong>SAVE/LOAD</strong>:其实这个命令和import/export是一样的.区别就在于export/import操作的对象是容器.而save/load操作的对象是镜像.<br>  它们的语法是:<code>docker save -o 快照名.tar 镜像名:版本</code> <code>docker load &lt; 快照名.tar</code></p>
</li>
<li><p><strong>RMI</strong>:rmi命令和rm命令差不多.区别在于是用来删除无用的镜像的.<br>  它的语法是:<code>docker rmi 镜像名:版本</code></p>
</li>
</ul>
<p>这些命令可以用下图来表示:<br><img src="/img/2015/08/27/8.png" alt=""></p>
<h2 id="创建镜像">创建镜像</h2><p>我们平时使用的时候肯定不可能只会用到现成的镜像,这就涉及到我们需要自定义镜像了.而docker提供了两种创建镜像的方法.</p>
<ol>
<li>使用commit命令来提交对容器的修改,从而创建一个新的镜像.</li>
<li>使用dockerfile文件来自动化的创建一个新的镜像,这个dockerfile文件就像是Maven中的pom.xml文件一样.是用来构建镜像的脚本语言</li>
</ol>
<h3 id="Commit">Commit</h3><p>这种方式非常简单,就是从镜像中先启动一个容器.然后进入容器,对这个容器做一些修改.而后就可以执行 <code>docker commit</code>命令把这个容器保存成一个新的镜像.<br>但是这种方式不适合自动化构建.比如在研发过程中编译新的版本的应用程序后,每次都启动容器,进入容器,做修改,然后保存.非常的麻烦.</p>
<h3 id="Dockerfile">Dockerfile</h3><p>Dockerfile用于描述如何构建一个镜像.可以使用<code>docker build</code> 来使用dockerfile文件.<br>dockerfile的每一条指令都是docker的镜像的一层操作.我们可以把docker镜像想想成是一个固定镜像上不断叠加变化的层次结构.这就是docker存储所使用AUFS.并且一个镜像不能超过127层.<br>dockerfile的基本语法是:</p>
<ul>
<li>使用#来注释</li>
<li>以FROM指令开头,告诉Docker使用哪一镜像作为基础.</li>
<li>然后是MAINTAINER指令,表示维护者的信息</li>
<li>RUN 开头的指令会在创建镜像的过程中在容器中执行.run的结果会作为下一条指令的输入.比如安装一个什么软件:<code>RUN yum install xxxx</code></li>
<li>ENTRYPOINT指令用于设置在容器启动时执行的命令.每一个dockerfile中最多只能有一条这个指令.</li>
<li>EXPOSE命令:设置一个端口在运行的镜像中暴露出来.这样就可以在容器外看到这个端口并与其通信.</li>
<li>ENV指令:用于设置环境变量,这里设置的环境变量在以后运行的容器中都可见</li>
<li>ADD指令:从src路径拷贝到容器的dest路径.注意的是src是相对于构建的源目录的相对路径.而dest是容器中的绝对路径.</li>
<li>VOLUME指令:创建一个挂载点用于共享目录</li>
<li>WORKDIR指令:配置RUN,CMD,ENTRYPOINT指定当前工作路径.可以设置多次,如果是相对路径,则是相对上一个WORKDIR指令的路径.</li>
<li>CMD指令:同ENTRYPOINT指令差不多,用于容器启动时指定运行的命令.同样每一个dockerfile中只能有一个.它与ENTRYPOINT区别在于,执行”docker run 镜像名 命令”.的时候会替换掉CMD指令中指定的命令,而ENTRYPOINT不会.CMD可以为ENTRYPOINT提供参数，ENTRYPOINT本身也可以包含参数，但是你可以把那些可能需要变动的参数写到CMD里而把那些不需要变动的参数写到ENTRYPOINT里面.</li>
</ul>
<p>这里提供一个案例.在一个标准的centos镜像的基础上安装tomcat.然后部署我们的一个测试的war包进去.</p>
<ol>
<li>先创建一个dockertest的文件夹.在里面创建一个Dockerfile文件,注意大小写.然后写上:<br><img src="/img/2015/08/27/9.png" alt=""></li>
<li>而后在dockertest文件夹下执行: <code>docker build -t 镜像名字:版本 .</code></li>
<li>不要忘了最后的点号.那表示是在当前目录构建镜像.</li>
<li>剩下的就是等待了.<br><img src="/img/2015/08/27/10.png" alt=""></li>
</ol>
<h2 id="私有仓库">私有仓库</h2><p>docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库.<br>使用命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run <span class="operator">-e</span> GUNICORN_OPTS=[<span class="string">"--preload"</span>] <span class="operator">-d</span> -p <span class="number">5000</span>:<span class="number">5000</span> -v /opt/data/registry:/tmp/registry registry</span><br></pre></td></tr></table></figure>
<p>来启动私有注册中心.并指定仓库存放到实体机的<code>/opt/data/registry</code>目录</p>
<h3 id="可视化界面">可视化界面</h3><p>如果觉得命令行不直观,这里还提供了一个简单的UI界面.直接使用docker下载镜像:<br><code>docker pull atcol/docker-registry-ui</code><br>然后运行:<code>docker run -d -p 8081:8080 -link registry容器的名字 atcol/docker-registry-ui</code> 就可以了.注意它依赖registry容器.</p>
<h2 id="数据管理">数据管理</h2><p>容器既然是非常轻量的,推崇用后即删除.那么数据存放就必然不能存放到容器内部.否则一删除容器,数据就丢失了.<br>Docker内部为了维护容器以及容器之间的数据.使用了数据卷和数据卷容器两种方式</p>
<h3 id="数据卷">数据卷</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li>数据卷可以在容器之间共享和重用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>卷会一直存在，直到没有容器使用</li>
</ul>
<p>要创建一个数据卷很简单,在使用<code>docker run</code>命令的时候 使用<code>-v</code>参数即可.在一个run命令中可以有<strong>多个</strong>-v参数,用来指定多个数据卷.<br>比如:<code>sudo docker run -d -P --name web -v /webapp training/webapp python app.py</code><br>也可以直接指定实体机的某个目录作为容器中的某个数据卷:<br>比如:<code>sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py</code><br>默认数据卷是 读写权限</p>
<h3 id="数据卷容器">数据卷容器</h3><p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。<br>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。<br>然后使用run命令创建数据卷容器:<code>sudo docker run -d -v /dbdata --name dbdata 镜像名字 echo Data-only container for it</code><br>而后启动其他容器的时候 使用<code>—volumes-from</code>来挂载数据卷容器:<br><code>sudo docker run -d --volumes-from dbdata --name t1 sun/tomcat</code><br>如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器。</p>
<h4 id="数据卷备份">数据卷备份</h4><p>使用 <code>--volumes-from</code> 标记来创建一个加载 dbdata 容器卷的容器，并从宿主机挂载当前到容器的 /backup 目录。命令如下：<br><code>sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</code><br>容器启动后，使用了 tar 命令来将 dbdata 卷备份为本地的 /backup/backup.tar。</p>
<h4 id="数据卷恢复">数据卷恢复</h4><p>如果要恢复数据到一个容器，首先创建一个带有数据卷的容器 dbdata2。<br><code>sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</code><br>然后创建另一个容器，挂载 dbdata2 的容器，并使用 untar 解压备份文件到挂载的容器卷中。<br><code>sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</code></p>
<h2 id="网络">网络</h2><p>在安装好docker以后,你操作系统的网卡中会增加一个名叫 <code>dcoker0</code>的 <strong>虚拟网卡</strong>.它通常都有一个<code>172.17.xx.xx</code>的IP地址.这个就是整个docker网络的桥接地址.docker容器都是通过这个桥接网卡来上网的.<br>每一个docker容器启动后都会随机的分配一个和docker0同网段的虚拟ip作为容器的ip.注意是<strong>每一次启动后IP地址都会改变</strong><br>docker容器之间可以通过各自的虚拟ip进行互联.<br>docker容器外的机器除安装的宿主机外默认是不能访问容器内的ip地址的.</p>
<h3 id="外部访问">外部访问</h3><p>如果要外部的机器访问容器内部.最简单的方式就是使用端口映射.把docker实体机的某个端口映射到docker容器内的某个端口上.这样直接访问实体机的ip:映射端口. 即可访问进容器.</p>
<ul>
<li><strong>-P</strong>: Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</li>
<li><strong>-p</strong>: 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。<br>比如: <code>sudo docker run -d -p 5000:5000 training/webapp python app.py</code><br><code>sudo docker run -d -p 127.0.0.1::5000 training/webapp python app.py</code><br><code>sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code><br>可以通过 <code>docker port 容器GUID 端口</code> 来查看容器的某个端口被映射成的实体机的哪个端口<br>-p命令可以在一个run命令中 多次使用,从而绑定多个内部端口.</li>
</ul>
<h3 id="垮物理机组网">垮物理机组网</h3><p>外部访问的另外一种方式就是直接把容器的IP暴露到真实的网络中.不通过nat转发.<br><img src="/img/2015/08/27/11.png" alt=""></p>
<ol>
<li>创建自己的网桥:<br>编辑 <code>/etc/network/interface</code> 文件<br><img src="/img/2015/08/27/12.png" alt=""><br>将Docker的默认网桥绑定到这个新建的br0上,这样就将这台机器上容器绑定到em1这个网卡所对应的物理网络上了.</li>
</ol>
<p>修改 <code>/etc/default/docker</code>文件.最后添加一行:<br><img src="/img/2015/08/27/13.png" alt=""></p>
<p>在启动Docker的时候,使用-b参数将容器绑定到物理网络上,重启Docker服务后,再进入容器就可以看到它已经绑定到你的物理网络上了.<br>这样多台物理宿主机的容器之间也可以互联了.但是需要注意的是,这样就需要自己来保证容器的网络安全.</p>
<h3 id="容器互联">容器互联</h3><p>除了端口映射和暴露容器到物理网络上外.容器之间的交互还有一种方式,就是使用容器的连接系统.该系统会在源和接收容器之间建立一个通信隧道,接收容器可以看到源容器指定的信息.<br>连接系统依赖容器的名字来执行,因此,首先需要在run的时候使用—name参数给容器起一个名字.<br>然后使用 —link参数让容器之间安全的进行交互.<br><code>sudo docker run -d -P --name web --link db:db training/webapp python app.py</code><br>这样在启动db:db容器的时候不需要指定-P或-p. docker会自动的处理两个容器间的网络互连.你在webapp中ping db容器,是可以获取到db容器的IP的.也就可以访问db容器expose出来的端口了.<br>这样处理的好处就是避免了安全问题,缺点就是docker容器之外是不能访问的.通常可以把数据库等底层的容器作为link源,不暴露出对外端口. web容器通过link使用db容器.然后发布对外的访问端口映射.</p>
<h3 id="容器固定IP">容器固定IP</h3><p>默认情况下启动一个container，其会自动获取一个跟docker0同网段的IP，而且重启container其IP一般会发生变化，但有时候我们会需要固定的IP(比如FT就需要固定的IP,否则每一次启动ZK中都会增加IP信息)。<br>要实现这个需要在docker run的时候使用<strong>—net=none</strong>的方式关闭docker默认的桥接方式连接网络.而是手动的配置网络</p>
<p>输入以下命令创建并进入一个tomcat容器<br><code>docker run -d -P --net=&#39;none&#39; tomcat:8.0</code><br>这个时候容器没有网卡</p>
<p>然后安装pipework.这个是docker开发人员提供的一个网络配置工具.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line">wget https://github.com/jpetazzo/pipework/archive/master.zip</span><br><span class="line">unzip master.zip </span><br><span class="line">cp pipework-master/pipework  /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">chmod <span class="number">777</span> /usr/<span class="built_in">local</span>/bin/pipework</span><br></pre></td></tr></table></figure>
<p>接下来使用 docker ps -a命令找到容器的名字.比如是nostalgic_almeida.<br>而后在实体机的终端上输入:<br><code>pipework docker0 nostalgic_almeida 172.17.42.111/24</code><br>这样就给这个容器指定了172.17.42.111这个固定IP.<br>Pipework有个缺陷，容器重启后IP设置会自动消失，需要重新设置。这个可以写一个脚本来处理.具体的参见:<a href="http://www.aixchina.net/club/thread-123383-1-1.html" target="_blank" rel="external">http://www.aixchina.net/club/thread-123383-1-1.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Docker入门">Docker入门</h1><p>Docker是一种新型的虚拟化技术,他释放了虚拟化的性能,极大的降低了云计算资源供应的成本,同时让应用的分发,测试,部署都变得非常的高效的容易!</p>
<h2 id="Docker简介">Docker简介</h2><p>Docker是一个开源项目,诞生于2013年初.使用的是Google的Go语言实现,遵循了Apache2.0协议.代码放在了<a href="https://github.com/docker/docker">GitHub</a>上.<br>它使用了Linux的LXC等技术,实现了轻量级的操作系统虚拟化.</p>
<h2 id="使用Docker的好处">使用Docker的好处</h2><ol>
<li>更快速的交付和部署<br> 开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。</li>
<li>更高效的虚拟化<br> Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。</li>
<li>更轻松的迁移和扩展<br> Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</li>
<li>更简单的管理<br> 所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</li>
</ol>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://sunxiang0918.github.io/tags/Docker/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<翻译>Solr 数据导入Handler]]></title>
    <link href="http://sunxiang0918.github.io/2015/08/09/Solr%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5Handler/"/>
    <id>http://sunxiang0918.github.io/2015/08/09/Solr数据导入Handler/</id>
    <published>2015-08-08T16:00:00.000Z</published>
    <updated>2015-08-27T15:57:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Solr_数据导入Handler">Solr 数据导入Handler</h2><p>由于在我们新的全文检索引擎中使用了Solr作为底层,因此当时是想直接使用Solr提供的DataImportHandler来进行数据的导入,于是就有在它的官网上看了相关的内容,并且试着进行了翻译.虽然最后我们还是自己实现了一套数据导入,但是它的这篇文章写的确实非常的好.</p>
<h2 id="Data_Import_Request_Handler">Data Import Request Handler</h2><p>大多数系统都会把他们的数据存储在关系型数据库或者XML文件中,并且还要对这些数据进行检索.<code>DataImportHandler</code>就是Solr提供的一个工具:可以通过配置的方式驱动工具全量(<code>full builds</code>)或增量的把数据导入到Solr中.</p>
<p>除了这篇文章外,还可以参见<a href="https://wiki.apache.org/solr/DataImportHandlerFaq" target="_blank" rel="external">DataImportHandlerFaq</a>.如果想快速开始,可以浏览<a href="https://wiki.apache.org/solr/DIHQuickStart" target="_blank" rel="external">DIHQuickStart</a></p>
<h1 id="概况">概况</h1><h2 id="目标">目标</h2><ul>
<li>能从关系型数据库中读取数据</li>
<li>能通过配置从多个表以及列数据中构造Solr的文档(<code>Document</code>)</li>
<li>能更新上述的Solr文档</li>
<li>能根据配置提供全导入的功能</li>
<li>能检测增量的数据新增与更新,并做增量导入(我们假设存在一个最后更新时间的时间戳字段来保证增量的工作)</li>
<li>能自动的计划与调度全更新与增量更新</li>
<li>能通过配置从xml/http/file 中读取数据并创建索引</li>
<li>能提供插件机制来保证用户可以选择任何的数据源(ftp,scp等等)和格式(JSON,csv等等)进行索引工作.</li>
</ul>
<a id="more"></a>
<h1 id="设计概况">设计概况</h1><p>要使用这个<code>Handler</code>,就必须在<code>solrconfig.xml</code>文件中做如下的注册:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">requestHandler</span> <span class="attribute">name</span>=<span class="value">"/dataimport"</span> <span class="attribute">class</span>=<span class="value">"org.apache.solr.handler.dataimport.DataImportHandler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">lst</span> <span class="attribute">name</span>=<span class="value">"defaults"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">str</span> <span class="attribute">name</span>=<span class="value">"config"</span>&gt;</span>/home/username/data-config.xml<span class="tag">&lt;/<span class="title">str</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">lst</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">requestHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>顾名思义,它是一个<a href="https://wiki.apache.org/solr/SolrRequestHandler" target="_blank" rel="external">SolrRequestHandler</a>的实现.它可以从两个地方进行配置:</p>
<ul>
<li><code>solrconfig.xml</code>.可以在这里增加数据配置文件的位置</li>
<li>数据源也可以配置在这里,或者直接配置在<code>data-config.xml</code>文件中</li>
<li><code>data-config.xml</code><ul>
<li>如何获取数据(查询,Url等等)</li>
<li>读取什么数据(结果集(<code>resultset</code>)列,<code>xml</code>的字段等等)</li>
<li>如果处理数据(修改/新增/删除 字段)</li>
</ul>
</li>
</ul>
<h1 id="从关系型数据库导入的用法">从关系型数据库导入的用法</h1><p>为了使用这个Handler,需要参照以下几个步骤:</p>
<ul>
<li>定义一个<code>data-config.xml</code>文件,并且在<code>solrconfig.xml</code>文件的<code>DataImportHandler</code>小节指定它的存放位置</li>
<li>定义数据源连接信息</li>
<li>打开<code>http://localhost:8983/solr/dataimport</code>网址以验证<code>DataImportHandler</code>的所有东西都正常工作</li>
<li>使用全导入命令(<code>full-import</code>)执行从数据库到Solr索引的全导入操作</li>
<li>使用增量导入命令(<code>delta-import</code>)执行Solr索引的增量导入(获取新的 插入与更新)</li>
</ul>
<h2 id="配置数据源">配置数据源</h2><p>在<code>dataConfig</code>标签下直接增加<code>dataSource</code>标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">type</span>=<span class="value">"JdbcDataSource"</span> <span class="attribute">driver</span>=<span class="value">"com.mysql.jdbc.Driver"</span> <span class="attribute">url</span>=<span class="value">"jdbc:mysql://localhost/dbname"</span> <span class="attribute">user</span>=<span class="value">"db_username"</span> <span class="attribute">password</span>=<span class="value">"db_password"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数据源的配置也可以直接在<code>solrConfig.xml</code>中配置,这个可以参照<a href="#solrconfigdatasource">#solrconfigdatasource</a></li>
<li><code>type</code>属性是用于定义数据源实现类的,是选填值,默认实现是<code>JdbcDataSource</code></li>
<li>当有多个数据源的时候,<code>name</code>属性可以用来当数据源的标识.</li>
<li>剩下的其他属性全是特定的数据源实现所特有的.</li>
<li>如果你要自己实现数据源插件,可以看<a href="https://wiki.apache.org/solr/DataImportHandler#datasource" target="_blank" rel="external">这里</a></li>
</ul>
<h3 id="Oracle数据库实例">Oracle数据库实例</h3><p>首先你需要下载并安装<a href="http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html" target="_blank" rel="external">Oralce JDBC驱动</a>到Solr安装目录的<code>lib</code>文件夹下.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">name</span>=<span class="value">"jdbc"</span> <span class="attribute">driver</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span> <span class="attribute">url</span>=<span class="value">"jdbc:oracle:thin:@//hostname:port/SID"</span> <span class="attribute">user</span>=<span class="value">"db_username"</span> <span class="attribute">password</span>=<span class="value">"db_password"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多数据源">多数据源</h3><p>在实现中有一种可能就是需要不止一个数据源.为了配置多个数据源,需要再配置多个<code>dataSource</code>标签.这时数据源的<code>name</code>属性就有意义了.当有多个数据源的时候,每一个数据源的<code>name</code>属性都不能重复,是唯一的.比如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">type</span>=<span class="value">"JdbcDataSource"</span> <span class="attribute">name</span>=<span class="value">"ds-1"</span> <span class="attribute">driver</span>=<span class="value">"com.mysql.jdbc.Driver"</span> <span class="attribute">url</span>=<span class="value">"jdbc:mysql://db1-host/dbname"</span> <span class="attribute">user</span>=<span class="value">"db_username"</span> <span class="attribute">password</span>=<span class="value">"db_password"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">type</span>=<span class="value">"JdbcDataSource"</span> <span class="attribute">name</span>=<span class="value">"ds-2"</span> <span class="attribute">driver</span>=<span class="value">"com.mysql.jdbc.Driver"</span> <span class="attribute">url</span>=<span class="value">"jdbc:mysql://db2-host/dbname"</span> <span class="attribute">user</span>=<span class="value">"db_username"</span> <span class="attribute">password</span>=<span class="value">"db_password"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在你的实体(<code>entityies</code>)中这样引用:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">..</span><br><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"one"</span> <span class="attribute">dataSource</span>=<span class="value">"ds-1"</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">   ..</span><br><span class="line"><span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"two"</span> <span class="attribute">dataSource</span>=<span class="value">"ds-2"</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">   ..</span><br><span class="line"><span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">..</span><br></pre></td></tr></table></figure>
<h2 id="配置JDBC数据源">配置JDBC数据源</h2><p><code>JdbcDataSource</code> 允许有以下属性:</p>
<ul>
<li><strong>driver</strong>(必填):Jdbc驱动的类名</li>
<li><strong>url</strong>(必填):jdbc链接的url地址.(当使用jndi连接的时候,不是必填的.)</li>
<li><strong>user</strong>:用户名</li>
<li><strong>password</strong>:用户密码</li>
<li><strong>jndiName</strong>:当使用jndi连接数据库的时候的jndi名称</li>
<li><strong>batchSize</strong>:jdbc连接的批量提交大小.使用<code>-1</code>可以防止<code>setFetchSize()</code>方法抛出异常</li>
<li><strong>convertType</strong>:(true/false)自动读取目标Solr中的数据类型,默认是<code>false</code></li>
<li><strong>autoCommit</strong>:自动提交,如果设置为<code>false</code>,那么它会调用<code>setAutoCommit(false)</code>. 详细参见<a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a></li>
<li><strong>readOnly</strong>:如果设置这个为<code>true</code>,那么它在连接的时候会调用<code>setReadOnly(true)</code>,<code>setAutoCommit(true)</code>,<code>setTransactionIsolation(TRANSACTION_READ_UNCOMMITTED)</code>,<code>setHoldability(CLOSE_CURSORS_AT_COMMIT)</code>.详细参见<a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a></li>
<li><strong>transactionIsolation</strong>:事务级别,可以有以下几个值:[<code>TRANSACTION_READ_UNCOMMITTED</code>, <code>TRANSACTION_READ_COMMITTED</code>, <code>TRANSACTION_REPEATABLE_READ</code>,<code>TRANSACTION_SERIALIZABLE</code>,<code>TRANSACTION_NONE</code>].详细参见<a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a></li>
</ul>
<p>直接放入<code>dataSource</code>标签的其他标签会直接被传入到JDBC驱动</p>
<h2 id="在data-config-xml中进行配置">在data-config.xml中进行配置</h2><p>一个Solr的文档可以被认为是一个去标准化的、拥有多个字段、其值来自不同表的<code>schema</code>.</p>
<p><code>data-config.xml</code>首先定义了一个<code>Document</code>元素.一个<code>document</code>代表了一种文档.一个文档包含了一个或多个根实体(<code>root entity</code>).一个根实体又可以包含多个子实体,这些子实体反过来又可以再包含其他的实体.一个实体就是关系数据库中的一个表或试图.每一个实体都可以包含多个字段.每一个字段相当于关系型数据库查询语句的结果中的返回字段.对于每一个字段,都是查询结果集中的列名.如果结果集的列名与Solr的字段名不相同,那么就需要填写<code>name</code>属性.而其他的必要属性比如<code>type</code>可以直接从<code>SolrSchema.xml</code>中继承(当然,也可以被重写)</p>
<p>为了从数据库中获取数据,我们的设计理念围绕着为每一个实体都提供给用户<strong>模板化的SQL</strong>(<code>templatized sql</code>).它能当用户需要时,提供给用户完整的<code>SQL</code>功能.而根实体就是其字段能被其他子实体所关联的中心表.</p>
<h3 id="data-config的Schema定义">data-config的Schema定义</h3><p><code>dataconfig</code>并没有严格的schema定义.实体与字段的属性取决于它们依赖的<code>processeor</code>处理器和<code>transformer</code>转换器</p>
<p>一个实体默认的属性都有:</p>
<ul>
<li><strong>name</strong>(必填):用于标识一个实体的唯一名字</li>
<li><strong>processor</strong>:当数据源不是关系型数据库时必填.默认值是<code>SqlEntityProcessor</code></li>
<li><strong>transformer</strong>:被实体引用的转换器(详细见转换器章节)</li>
<li><strong>dataSource</strong>:实体所使用的数据源名称(当有多个数据源的时候使用)</li>
<li><strong>threads</strong>:设置是否使用多线程来进行实体的提取,这个值必须被设置在根实体上.详细可以参见<a href="https://wiki.apache.org/solr/Solr3.1" target="_blank" rel="external">Solr3.1</a><ul>
<li>注意:并不是所有的DataImportHandler组件都是线程安全的.如果要使用这个特性,那么请确保测试完全!</li>
<li>与多线程相关的显著BUG已经在<a href="https://wiki.apache.org/solr/Solr3.6" target="_blank" rel="external">Solr3.6</a>中被修复.如果在旧的版本上使用这个特性,建议升级版本.请看Solr3.6.0的<a href="https://issues.apache.org/jira/browse/SOLR-3011" target="_blank" rel="external">SOLR-3011</a>.你也需要从<a href="https://issues.apache.org/jira/browse/SOLR-3360" target="_blank" rel="external">SOLR-3360</a>开始修复</li>
<li><code>threads</code>属性已经在<a href="https://wiki.apache.org/solr/Solr3.6" target="_blank" rel="external">Solr3.6</a>中被废弃,并且会在<a href="https://wiki.apache.org/solr/Solr4.0" target="_blank" rel="external">Solr4.0</a>中被删除.详细可以参见<a href="https://issues.apache.org/jira/browse/SOLR-3262" target="_blank" rel="external">SOLR-3262</a></li>
<li><strong>pk</strong>:实体的主键字段.这个属性是<strong>可选</strong>的,并且只有在增量更新中才有用.它并没有与<code>schema.xml</code>中定义的<code>uniqueKey</code>字段相关联,虽然他们两个可以是相同的.</li>
<li><strong>rootEntity</strong>:在默认情况下,所有在<code>document</code>下的实体都是根实体.如果这个值被设置为<code>false</code>,只有直接在<code>document</code>下的实体才会被认为是实体.根实体所有返回的列都会被Solr创建成一个文档.</li>
<li><strong>onError</strong>:(abort|skip|continue).默认值是<code>abort</code>.<code>skip</code>会跳过当前的文档.<code>continue</code>会继续处理,就当错误没有发生.<a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a></li>
<li><strong>preImportDeleteQuery</strong>:当全导入执行前会使用这个属性的值来清理索引,而不是使用<code>*:*</code>来清除原有的索引.这个属性只能赋值给<code>document</code>节点下的直接根实体.</li>
<li><strong>postImportDeleteQuery</strong>:当全导入执行完成后会使用这个属性的值来再执行一次.同样,这个属性只能赋值给<code>document</code>节点下的直接根实体.</li>
</ul>
</li>
</ul>
<p><code>SqlEntityProcessor</code>这个实体节点的属性有:</p>
<ul>
<li><strong>query</strong>(必填):查询数据库所执行的SQL字符串</li>
<li><strong>deltaQuery</strong>:当增量导入时所使用的查询语句</li>
<li><strong>parentDeltaQuery</strong>:当增量导入时所使用的查询语句</li>
<li><strong>deletedPkQuery</strong>:当增量导入时所使用的查询语句</li>
<li><strong>deltaImportQuery</strong>:(当增量导入时所使用的查询语句).如果不提供这个语句,DIH会在识别增量后尝试构建查询语句(这是非常容易出错的).命名空间<code>${dih.delta.&lt;column-name&gt;}</code>可以在这个查询语句中使用,比如:<code>select * from tbl where id=${dih.delta.id}</code>. <a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a></li>
</ul>
<h2 id="操作命令">操作命令</h2><p>DIH提供了基于HTTP请求的API.这些就是他能执行的操作:</p>
<ul>
<li>full-import:当请求<code>http://&lt;host&gt;:&lt;port&gt;/solr/dataimport?command=full-import</code>地址的时候,全导入操作会开始执行.<ul>
<li>这个操作会在一个新的线程中被执行.并且相应中的<code>status</code>属性会显示为<code>busy</code>.</li>
<li>这个操作所执行的时间取决于数据的大小.</li>
<li>当全导入命令被执行时,它会在<code>conf/dataimpoort.properties</code>文件(<a href="https://wiki.apache.org/solr/DataImportHandler#Configuring_The_Property_Writer" target="_blank" rel="external">这个文件可以进行配置</a>)中记录操作开始的时间</li>
<li>存储下来的时间戳会在增量导入执行的时候被使用</li>
<li>在全导入的过程中,Solr的查询不会被锁定</li>
<li>它拥有几个扩展的参数:<ul>
<li>entity:直接定义在<code>document</code>节点下的实体的名字.使用这个参数可以有选择性的执行一个或多个实体的导入,设置多个<code>entity</code>参数可以一次性的执行多个实体的导入.如果没有这个参数,所有的实体都会被导入.</li>
<li>clean:(默认是true).在执行全导入前,先清理一次索引.</li>
<li>commit:(默认是true).当操作之后,提交文档</li>
<li>optimize:(在Solr3.6之前是true,以后是false).当全导入之后,执行整理的操作.请注意:这是一个非常昂贵的操作.并且通常在增量导入时是无意义的.</li>
<li>debug:(默认是false).使用调试模式执行,它在开发模式下可以被使用(<a href="https://wiki.apache.org/solr/DataImportHandler#interactive" target="_blank" rel="external">参见这里</a>)<ul>
<li>请注意,在调试模式下,文档不会被自动的提交.如果你想在调试模式下提交结果.那么需要显式的在请求中增加<code>commit=true</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>delta-import: 为了增量的导入并且检测数据变化.可以执行<code>http://&lt;host&gt;:&lt;port&gt;/solr/dataimport?command=delta-import</code>命令.它同样的支持<code>clean</code> <code>commit</code> <code>optimize</code>和<code>debug</code>参数</li>
<li>status: 执行<code>http://&lt;host&gt;:&lt;port&gt;/solr/dataimport</code>这个命令用来返回当前的执行状态.它会提供一份详细的统计数据,记录了<code>创建</code>、<code>删除</code> <code>查询数</code> <code>结果集</code> <code>状态</code>等等数据.</li>
<li>reload-config:当<code>data-config</code>文件被改变了,并且你想不重启Solr而重新加载这个文件的时候,执行<code>http://&lt;host&gt;:&lt;port&gt;/solr/dataimport?command=reload-config</code></li>
<li>abort:使用<code>http://&lt;host&gt;:&lt;port&gt;/solr/dataimport?command=abort</code>这个来中止数据的导入</li>
</ul>
<h2 id="全导入实例">全导入实例</h2><p>让我们来看一个例子,假如在数据库中我们有如下的定义:<br><img src="https://wiki.apache.org/solr/DataImportHandler?action=AttachFile&amp;do=get&amp;target=example-schema.png" alt=""><br>这是一个可以满足Solr Schema定义的关系模型.我们会使用这个例子来给<code>DataImportHandler</code>创建一个<code>data-config.xml</code>.我们使用<a href="http://hsqldb.org/" target="_blank" rel="external">HSQLDB</a>数据库来创建这个Schema.要运行它,请执行以下的步骤:</p>
<ol>
<li>找到solr下载文件夹中的<code>example/example-DIH</code>目录.它包含了一个完整的配置好了的RSS操作例子(稍后会说明)的Solr实例</li>
<li>使用<code>example-DIH/solr</code>目录作为你的Solr主目录.在<code>/examples</code>目录下执行<code>java -Dsolr.solr.home=&quot;./example-DIH/solr/&quot; -jar start.jar</code>来启动你的Solr</li>
<li>访问<a href="http://localhost:8983/solr/db/dataimport" target="_blank" rel="external">http://localhost:8983/solr/db/dataimport</a>来验证配置是否正确</li>
<li>访问<a href="http://localhost:8983/solr/db/dataimport?command=full-import" target="_blank" rel="external">http://localhost:8983/solr/db/dataimport?command=full-import</a>开始执行全导入</li>
</ol>
<p>这个Solr的目录是一个多核(<a href="https://wiki.apache.org/solr/MultiCore" target="_blank" rel="external">MultiCore</a>)的Solr.它包含了两个核心,一个是这个例子所示的数据库例子,另一个是一个RSS导入的例子(新特性)</p>
<ul>
<li><p>这个例子中的<code>data-config.xml</code>配置如下:</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">driver</span>=<span class="value">"org.hsqldb.jdbcDriver"</span> <span class="attribute">url</span>=<span class="value">"jdbc:hsqldb:/temp/example/ex"</span> <span class="attribute">user</span>=<span class="value">"sa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">document</span> <span class="attribute">name</span>=<span class="value">"products"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"item"</span> <span class="attribute">query</span>=<span class="value">"select * from item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"ID"</span> <span class="attribute">name</span>=<span class="value">"id"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"NAME"</span> <span class="attribute">name</span>=<span class="value">"name"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"MANU"</span> <span class="attribute">name</span>=<span class="value">"manu"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"WEIGHT"</span> <span class="attribute">name</span>=<span class="value">"weight"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"PRICE"</span> <span class="attribute">name</span>=<span class="value">"price"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"POPULARITY"</span> <span class="attribute">name</span>=<span class="value">"popularity"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"INSTOCK"</span> <span class="attribute">name</span>=<span class="value">"inStock"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"INCLUDES"</span> <span class="attribute">name</span>=<span class="value">"includes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"feature"</span> <span class="attribute">query</span>=<span class="value">"select description from feature where item_id='$&#123;item.ID&#125;'"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"features"</span> <span class="attribute">column</span>=<span class="value">"description"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"item_category"</span> <span class="attribute">query</span>=<span class="value">"select CATEGORY_ID from item_category where item_id='$&#123;item.ID&#125;'"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"category"</span> <span class="attribute">query</span>=<span class="value">"select description from category where id = '$&#123;item_category.CATEGORY_ID&#125;'"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"description"</span> <span class="attribute">name</span>=<span class="value">"cat"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在这里,根实体是一个名叫<code>item</code>的表,它的主键字段名为<code>id</code>.数据可以通过<code>select * from item</code>这个语句查询.每一个实体拥有多个<code>features</code>,这些值是从表<code>feature</code>中的<code>description</code>字段来的.<code>feature</code>实体的查询语句是:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"feature"</span> <span class="attribute">query</span>=<span class="value">"select description from feature where item_id='$&#123;item.id&#125;'"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"feature"</span> <span class="attribute">column</span>=<span class="value">"description"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在表<code>feature</code>中的外键<code>item_id</code>字段关联了<code>item</code>表的主键<code>id</code>字段为<em>item</em>的每一行数据获取多行<em>feature</em>数据.按照类似的方式,我们可以关联<code>item</code>和<code>category</code>(这是一个多对多关系).需要注意,我们是如何使用模板SQL来通过中间表<code>item_category</code>来关联两张表记录的:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"item_category"</span> <span class="attribute">query</span>=<span class="value">"select category_id from item_category where item_id='$&#123;item.id&#125;'"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"category"</span> <span class="attribute">query</span>=<span class="value">"select description from category where id = '$&#123;item_category.category_id&#125;'"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"description"</span> <span class="attribute">name</span>=<span class="value">"cat"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="一个更短的dataConfig配置">一个更短的dataConfig配置</h3><p>在上一个例子中,它映射了多个数据库字段到Solr的字段中.而还有一种可能是我们会映射所有的数据库字段到Solr字段中,并且它们字段的名字都是相同的(忽略大小写).也许当任何内置的转换器被使用的时候(见 转换器章节),你才需要添加一个字段.<br>一个更短的版本例子如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">driver</span>=<span class="value">"org.hsqldb.jdbcDriver"</span> <span class="attribute">url</span>=<span class="value">"jdbc:hsqldb:/temp/example/ex"</span> <span class="attribute">user</span>=<span class="value">"sa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"item"</span> <span class="attribute">query</span>=<span class="value">"select * from item"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"feature"</span> <span class="attribute">query</span>=<span class="value">"select description as features from feature where item_id='$&#123;item.ID&#125;'"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"item_category"</span> <span class="attribute">query</span>=<span class="value">"select CATEGORY_ID from item_category where item_id='$&#123;item.ID&#125;'"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"category"</span> <span class="attribute">query</span>=<span class="value">"select description as cat from category where id = '$&#123;item_category.CATEGORY_ID&#125;'"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用增量导入命令">使用增量导入命令</h2><p>当访问<a href="http://localhost:8983/solr/dataimport?command=delta-import" target="_blank" rel="external">http://localhost:8983/solr/dataimport?command=delta-import</a>地址的时候,增量导入操作会被执行.这个操作会在一个新的线程开始执行,并且相应中的<code>status</code>属性会显示<code>busy</code>.取决于你数据的大小,这个操作会花费一些时间.在任何时候,你都可以访问<a href="http://localhost:8983/solr/dataimport" target="_blank" rel="external">http://localhost:8983/solr/dataimport</a>来查看当前的状态.</p>
<p>当增量导入命令被执行的时候,它会从<code>conf/dataimport.properties</code>文件中读取开始的时间.这个时间会被用于执行增量查询,并且当完成增量导入后,会更新<code>conf/dataimport.properties</code>文件中的时间戳.</p>
<p><strong>提示</strong>:在Solr中,增量导入是一种比全导入跟有效率的方式,但是它需要一些少量的配置:<a href="https://wiki.apache.org/solr/DataImportHandlerDeltaQueryViaFullImport" target="_blank" rel="external">DataImportHandlerDeltaQueryViaFullImport</a></p>
<h3 id="增量导入的实例">增量导入的实例</h3><p>我们会使用与全导入相同的数据库例子.请注意,这个例子中的数据库schema已经被更新了,在每一个表中现在都包含了一个<code>last_modified</code>的时间戳字段.你可能需要重新下载数据库,因为它最近已经更新了.我们使用这个时间戳字段来决定每一个表中的哪些记录自从上一次被索引后有所变动.</p>
<p>请看一下一下的data-config.xml配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">driver</span>=<span class="value">"org.hsqldb.jdbcDriver"</span> <span class="attribute">url</span>=<span class="value">"jdbc:hsqldb:/temp/example/ex"</span> <span class="attribute">user</span>=<span class="value">"sa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">document</span> <span class="attribute">name</span>=<span class="value">"products"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"item"</span> <span class="attribute">pk</span>=<span class="value">"ID"</span></span><br><span class="line">                <span class="attribute">query</span>=<span class="value">"select * from item"</span></span><br><span class="line">                <span class="attribute">deltaImportQuery</span>=<span class="value">"select * from item where ID='$&#123;dih.delta.id&#125;'"</span></span><br><span class="line">                <span class="attribute">deltaQuery</span>=<span class="value">"select id from item where last_modified &amp;gt; '$&#123;dih.last_index_time&#125;'"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"feature"</span> <span class="attribute">pk</span>=<span class="value">"ITEM_ID"</span></span><br><span class="line">                    <span class="attribute">query</span>=<span class="value">"select description as features from feature where item_id='$&#123;item.ID&#125;'"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"item_category"</span> <span class="attribute">pk</span>=<span class="value">"ITEM_ID, CATEGORY_ID"</span></span><br><span class="line">                    <span class="attribute">query</span>=<span class="value">"select CATEGORY_ID from item_category where ITEM_ID='$&#123;item.ID&#125;'"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"category"</span> <span class="attribute">pk</span>=<span class="value">"ID"</span></span><br><span class="line">                       <span class="attribute">query</span>=<span class="value">"select description as cat from category where id = '$&#123;item_category.CATEGORY_ID&#125;'"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意<code>deltaQuery</code>属性,这个属性拥有一个能够判定<em>item</em>表变化的SQL语句.同时注意变量<code>${dataimporter.last_index_time}</code>,这是一个<code>DataImportHandler</code>提供的变量,用于表示上一次全更新或增量更新运行的时间戳.你可以在<code>data-config.xml</code>文件中的任意SQL中使用这个变量,它会在执行中被替换成真正的<code>last_index_time</code>时间.</p>
<p><strong>注意</strong>:</p>
<ul>
<li><p>上一个例子中的<code>deltaQuery</code>语句只用来监听了<em>item</em>表的变化,而没有监听其他表.你其实可以监听通过下面的一条SQL查询来监听所有关联的子表的变化.搞清楚它们的细节是留给各位的一个练习:</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> id <span class="keyword">from</span> item <span class="keyword">where</span> id <span class="keyword">in</span></span><br><span class="line">                                (<span class="keyword">select</span> item_id <span class="keyword">as</span> id <span class="keyword">from</span> feature <span class="keyword">where</span> last_modified &gt; <span class="string">'$&#123;dih.last_index_time&#125;'</span>)</span><br><span class="line">                                <span class="keyword">or</span> id <span class="keyword">in</span></span><br><span class="line">                                (<span class="keyword">select</span> item_id <span class="keyword">as</span> id <span class="keyword">from</span> item_category <span class="keyword">where</span> item_id <span class="keyword">in</span></span><br><span class="line">                                    (<span class="keyword">select</span> id <span class="keyword">as</span> item_id <span class="keyword">from</span> category <span class="keyword">where</span> last_modified &gt; <span class="string">'$&#123;dih.last_index_time&#125;'</span>)</span><br><span class="line">                                <span class="keyword">or</span> last_modified &amp;gt;</span> '$&#123;dih.last_index_time&#125;')</span><br><span class="line">                                or last_modified &amp;gt; '$&#123;dih.last_index_time&#125;'</span><br></pre></td></tr></table></figure>
</li>
<li><p>书写一个如上面那样复杂的<code>deltaQuery</code>查询语句并不是一个愉快的任务,所以我们提供了一套其他的方法来完成相同的目标.</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">driver</span>=<span class="value">"org.hsqldb.jdbcDriver"</span> <span class="attribute">url</span>=<span class="value">"jdbc:hsqldb:/temp/example/ex"</span> <span class="attribute">user</span>=<span class="value">"sa"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"item"</span> <span class="attribute">pk</span>=<span class="value">"ID"</span> <span class="attribute">query</span>=<span class="value">"select * from item"</span></span><br><span class="line">                <span class="attribute">deltaImportQuery</span>=<span class="value">"select * from item where ID=='$&#123;dih.delta.id&#125;'"</span></span><br><span class="line">                <span class="attribute">deltaQuery</span>=<span class="value">"select id from item where last_modified &amp;gt; '$&#123;dih.last_index_time&#125;'"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"feature"</span> <span class="attribute">pk</span>=<span class="value">"ITEM_ID"</span></span><br><span class="line">                    <span class="attribute">query</span>=<span class="value">"select DESCRIPTION as features from FEATURE where ITEM_ID='$&#123;item.ID&#125;'"</span></span><br><span class="line">                    <span class="attribute">deltaQuery</span>=<span class="value">"select ITEM_ID from FEATURE where last_modified &gt; '$&#123;dih.last_index_time&#125;'"</span></span><br><span class="line">                    <span class="attribute">parentDeltaQuery</span>=<span class="value">"select ID from item where ID=$&#123;feature.ITEM_ID&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"item_category"</span> <span class="attribute">pk</span>=<span class="value">"ITEM_ID, CATEGORY_ID"</span></span><br><span class="line">                    <span class="attribute">query</span>=<span class="value">"select CATEGORY_ID from item_category where ITEM_ID='$&#123;item.ID&#125;'"</span></span><br><span class="line">                    <span class="attribute">deltaQuery</span>=<span class="value">"select ITEM_ID, CATEGORY_ID from item_category where last_modified &gt; '$&#123;dih.last_index_time&#125;'"</span></span><br><span class="line">                    <span class="attribute">parentDeltaQuery</span>=<span class="value">"select ID from item where ID=$&#123;item_category.ITEM_ID&#125;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"category"</span> <span class="attribute">pk</span>=<span class="value">"ID"</span></span><br><span class="line">                        <span class="attribute">query</span>=<span class="value">"select DESCRIPTION as cat from category where ID = '$&#123;item_category.CATEGORY_ID&#125;'"</span></span><br><span class="line">                        <span class="attribute">deltaQuery</span>=<span class="value">"select ID from category where last_modified &amp;gt; '$&#123;dih.last_index_time&#125;'"</span></span><br><span class="line">                        <span class="attribute">parentDeltaQuery</span>=<span class="value">"select ITEM_ID, CATEGORY_ID from item_category where CATEGORY_ID=$&#123;category.ID&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在这里我们为除了根的每一个实体(其实就只有两个)指定了三个查询语句.</p>
<ul>
<li><code>query</code>属性为Solr文档的全导入提供了所需要的字段.</li>
<li><code>deltaImportQuery</code>属性为增量导入提供了所需要的字段.</li>
<li><code>deltaQuery</code>属性提供了从上一次索引以来变化了的实体的主键</li>
<li><code>parentDeltaQuery</code>属性使用当前变化了的表中的记录(依赖<code>deltaQuery</code>查询)来提供给父表的变化的记录中.这个属性是必须的,因为当一个子表中的记录被变化的时候,我们需要重新生成包含这个字段的文档的索引</li>
</ul>
<p>让我们再重申一下结论:</p>
<ul>
<li>通过<code>query</code>提供的每一行数据,这个查询语句是每一个子实体都会被调用一次的.</li>
<li>通过<code>deltaQuery</code>提供的每一行数据,<code>parentDeltaQuery</code>会被执行</li>
<li>如果根实体或子实体中任何一个数据被改变,我们都会重新生成包含这些记录的Solr的文档</li>
</ul>
<p>注意:<code>deltaImportQuery</code>是Solr1.4才有的特性.最初这个语句会根据<code>query</code>属性自动的生成,但是错误率很高.并且有可能会使用全导入的命令去做增量导入. 详细请见<a href="http://wiki.apache.org/solr/DataImportHandlerFaq#fullimportdelta" target="_blank" rel="external">这里</a></p>
<p>在<a href="https://wiki.apache.org/solr/Solr3.1" target="_blank" rel="external">Solr3.1</a>中,这个Handler会检测以确认在所有的查询中,你提供的主键字段是在结果集中.在一种情况下,要求在从1.4升级到3.1的时候给主键字段一个SQL的别名<code>did</code>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(did) <span class="keyword">FROM</span> $&#123;dataimporter.request.dataView&#125;</span></span><br></pre></td></tr></table></figure>
<p>需要被改成:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(did) <span class="keyword">AS</span> did <span class="keyword">FROM</span> $&#123;dataimporter.request.dataView&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="配置属性写入器">配置属性写入器</h1><p><a href="https://wiki.apache.org/solr/Solr4.1" target="_blank" rel="external">Solr4.1</a>中,在<code>dataConfig</code>节点下新增加了一个<code>propertyWriter</code>节点.属性<code>last_index_time</code>的值会被这个处理器转换成文本并且保存到<code>properties</code>文件中.并且会在下一次的导入时被当做<code>${dih.last_index_time}</code>变量被使用.这一个节点就是用来描述如何控制属性值写入<code>properties</code>文件的. </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">propertyWriter</span> <span class="attribute">dateFormat</span>=<span class="value">"yyyy-MM-dd HH:mm:ss"</span> <span class="attribute">type</span>=<span class="value">"SimplePropertiesWriter"</span> <span class="attribute">directory</span>=<span class="value">"data"</span> <span class="attribute">filename</span>=<span class="value">"my_dih.properties"</span> <span class="attribute">locale</span>=<span class="value">"en_US"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>首先,这个节点是可选的,它拥有默认的语言环境、目录和文件名.<code>type</code>属性在单机情况下默认为<a href="https://wiki.apache.org/solr/SimplePropertiesWriter" target="_blank" rel="external">SimplePropertiesWriter</a>.而在<a href="https://wiki.apache.org/solr/SolrCloud" target="_blank" rel="external">SolrCloud</a>情况下,默认是<code>ZKPropertiesWriter</code></li>
<li><code>type</code>:这个节点是表示写入器的实现类,除非整个<code>&lt;propertyWriter/&gt;</code>都被忽略,否则它是必填的.</li>
<li><code>filename</code>:(<code>SimplePropertiesWriter</code>)默认的名字就是DIH请求处理器的名字然后加上<code>.properties</code>后缀,比如:<code>dataimport.properties</code></li>
<li><code>directory</code>:(<code>SimplePropertiesWriter</code>) 它的默认值是<code>conf</code>目录</li>
<li><code>dateFormat</code>:(<code>SimplePropertiesWriter</code>/<code>ZKPropertiesWriter</code>)使用<code>java.text.SimpleDateFormat</code>的正则表达式来把日期转换为文本.默认值是<code>yyyy-MM-dd HH:mm:ss</code>.而对于JDBC的转义语法,需要使用<code>{&#39;ts&#39; yyyy-MM-dd HH:mm:ss}</code></li>
<li><code>locale</code>:(<code>SimplePropertiesWriter</code>/<code>ZKPropertiesWriter</code>)在Solr4.1中,默认的语言环境是根语言环境.这一点与Solr4.0以及之前都不同.之前的版本始终使用的是机器的默认语言环境</li>
</ul>
<h1 id="使用XML/HTTP数据源">使用XML/HTTP数据源</h1><p><code>DataImportHandler</code>同样能使用基于HTTP的数据源来创建索引.包括从<code>REST/XML</code>的API和<code>RSS/ATOM</code>的订阅来创建索引.</p>
<h2 id="配置URLDataSource或HttpDataSource数据源">配置URLDataSource或HttpDataSource数据源</h2><p>在<a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a>开始,<code>HttpDataSource</code>已经由<code>URLDataSource</code>所替代而被废弃.</p>
<p>一个简单的配置在<code>dataConfig.xml</code>中的<code>URLDataSource</code>和<code>HttpDataSource</code>的配置样例如下所示:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">name</span>=<span class="value">"b"</span> <span class="attribute">type</span>=<span class="value">"!HttpDataSource"</span> <span class="attribute">baseUrl</span>=<span class="value">"http://host:port/"</span> <span class="attribute">encoding</span>=<span class="value">"UTF-8"</span> <span class="attribute">connectionTimeout</span>=<span class="value">"5000"</span> <span class="attribute">readTimeout</span>=<span class="value">"10000"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- or in Solr 1.4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">name</span>=<span class="value">"a"</span> <span class="attribute">type</span>=<span class="value">"URLDataSource"</span> <span class="attribute">baseUrl</span>=<span class="value">"http://host:port/"</span> <span class="attribute">encoding</span>=<span class="value">"UTF-8"</span> <span class="attribute">connectionTimeout</span>=<span class="value">"5000"</span> <span class="attribute">readTimeout</span>=<span class="value">"10000"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>它们所拥有的扩展属性有这些:</p>
<ul>
<li><strong>baseUrl</strong>(可选):当在开发、测试或者生产环境下有不同的IP地址和端口的时候你需要使用这个属性来把变化隔离在<code>solrconfig.xml</code>文件中.</li>
<li><strong>encoding</strong>(可选):在默认情况下编码的值同响应头上的编码是相同的,但是你可以使用这个属性来覆盖它.</li>
<li><strong>connectionTimeout</strong>(可选):默认的超时时间为5000毫秒</li>
<li><strong>readTimeout</strong>(可选):默认的读取超时时间为10000毫秒</li>
</ul>
<h2 id="在data-config-xml文件中进行配置">在data-config.xml文件中进行配置</h2><p>一个由<code>xml/http</code>数据源提供的实体除了上面所说的默认属性外,还有以下这些属性:</p>
<ul>
<li>processor(必须):并且其值必须是<code>XPathEntityProcessor</code></li>
<li>url(必须):这个url地址会被用来调用REST API.(可以模板化).如果这个数据源是一个文件,那么这个属性就必须是文件的路径.</li>
<li>stream(可选):当xml非常大的时候,可以设置这个为<code>true</code></li>
<li>forEach(必须):它是一个用来圈定一条记录范围的<code>XPATH</code>表达式,如果存在多种记录的类型,那么使用<code>/</code>来分隔.当<code>useSolrAddSchema</code>被设置为<code>true</code>的时候,这个属性可以被忽略</li>
<li>xsl(可选):提供一个XSL文件的全路径或者url用来在生成索引前使用XSL来转换来源数据.</li>
<li>useSolrAddSchema(可选):如果数据源提供的数据与solr要增加的数据具有相同的schema结构,那么久没必要再指定任何字段了,只需要把它设置成true就可以了.</li>
<li>flatten(可选):当这个值被设置为<code>true</code>的时候,所有xml节点下的值都会被抽取到一个字段中,而不会考虑它们节点的名字.</li>
</ul>
<p>而实体的每一个字段除了上文提到的标准属性外,还有以下的属性:</p>
<ul>
<li><strong>xpath</strong>(可选):这个一个xpath表达式,用于描述在记录中的每一个字段是如何被映射到索引的字段上的.如果该字段不是来自xml中的某个节点值(有可能是通过<code>transformer</code>转换器生成的),那么这个属性是可以被忽略的.如果索引的一个字段在<code>schema</code>中被标记为<code>multivalued</code>,并且提供的xpath表达式也能返回多个值的话.那么,不需要任何额外的配置,它就能够被<code>XPathEntityProcessor</code>自动的处理.</li>
<li><strong>commonField</strong>:可以是<code>true</code>/<code>false</code>.如果它为<code>true</code>,那么当这个字段在创建SolrDocument时如果没有值,它仍然可以拷贝上一个记录的相同字段的值作为自己的值.</li>
</ul>
<p>如果一个API支持分块多次调用来获取完整的数据(当数据太大时可能会发生).<code>XPathEntityprocessor</code>也能通过一个<code>transformer</code>支持的.当这个<code>transformer</code>返回的记录中包含有<code>$hasMore</code>并且值为<code>true</code>的时候.这个处理器会使用相同的URL模板再发送一次请求(模板中的实际值会在调用前重新计算).这个转换器同样支持在返回的结果中包含下一次请求的url地址.这要求返回的结果中包含<code>$nextUrl</code>属性,其值是完整的下一次请求的URL地址.</p>
<p><code>XPathEnityProcessor</code>实现了一个支持Xpath表达式子集的流式解析器.它不支持完整的XPATH语法,但是如下所示的常用的语法是支持的:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">xpath=<span class="value"><span class="string">"/a/b/subject[@qualifier='fullTitle']"</span></span></span></span><br><span class="line"><span class="setting">xpath=<span class="value"><span class="string">"/a/b/subject/@qualifier"</span></span></span></span><br><span class="line"><span class="setting">xpath=<span class="value"><span class="string">"/a/b/c"</span></span></span></span><br><span class="line"><span class="setting">xpath=<span class="value"><span class="string">"//a/..."</span></span></span></span><br><span class="line"><span class="setting">xpath=<span class="value"><span class="string">"/a//b..."</span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="HttpDataSource的例子">HttpDataSource的例子</h2><p>在<a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a>开始,<code>HttpDataSource</code>已经由<code>URLDataSource</code>所替代而被废弃.</p>
<p>下载在数据库章节提供的完整的导入例子,然后我们会尝试在这个例子中索引<a href="http://rss.slashdot.org/Slashdot/slashdot" target="_blank" rel="external">Slashdot RSS feed</a>.</p>
<p>它的<code>data-config.xml</code>文件如下所示:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">type</span>=<span class="value">"HttpDataSource"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"slashdot"</span></span><br><span class="line">                        <span class="attribute">pk</span>=<span class="value">"link"</span></span><br><span class="line">                        <span class="attribute">url</span>=<span class="value">"http://rss.slashdot.org/Slashdot/slashdot"</span></span><br><span class="line">                        <span class="attribute">processor</span>=<span class="value">"XPathEntityProcessor"</span></span><br><span class="line">                        <span class="attribute">forEach</span>=<span class="value">"/RDF/channel | /RDF/item"</span></span><br><span class="line">                        <span class="attribute">transformer</span>=<span class="value">"DateFormatTransformer"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"source"</span>       <span class="attribute">xpath</span>=<span class="value">"/RDF/channel/title"</span>   <span class="attribute">commonField</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"source-link"</span>  <span class="attribute">xpath</span>=<span class="value">"/RDF/channel/link"</span>    <span class="attribute">commonField</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"subject"</span>      <span class="attribute">xpath</span>=<span class="value">"/RDF/channel/subject"</span> <span class="attribute">commonField</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"title"</span>        <span class="attribute">xpath</span>=<span class="value">"/RDF/item/title"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"link"</span>         <span class="attribute">xpath</span>=<span class="value">"/RDF/item/link"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"description"</span>  <span class="attribute">xpath</span>=<span class="value">"/RDF/item/description"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"creator"</span>      <span class="attribute">xpath</span>=<span class="value">"/RDF/item/creator"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"item-subject"</span> <span class="attribute">xpath</span>=<span class="value">"/RDF/item/subject"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"slash-department"</span> <span class="attribute">xpath</span>=<span class="value">"/RDF/item/department"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"slash-section"</span>    <span class="attribute">xpath</span>=<span class="value">"/RDF/item/section"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"slash-comments"</span>   <span class="attribute">xpath</span>=<span class="value">"/RDF/item/comments"</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"date"</span> <span class="attribute">xpath</span>=<span class="value">"/RDF/item/date"</span> <span class="attribute">dateTimeFormat</span>=<span class="value">"yyyy-MM-dd'T'hh:mm:ss"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个就是它的数据配置.如果你看过<code>Slashdot RSS</code>的结构,它有一些头结点,比如标题、连接、主题等等.这些会通过<code>Xpath</code>表达式被映射成为Solr的来源、来源链接和主题字段.这一个摘要(<code>feed</code>)会包含多个<code>item</code>元素,每一个元素都包含了一个新闻.因此,我们期望的是对每一个<code>item</code>都创建一个Solr的文档.</p>
<p><code>XPathEntityprocessor</code>被设计成为流式的、逐行的读取xml,它使用<code>forEach</code>属性来标记<em>一行</em>.在这个例子中,<code>forEach</code>属性被赋值为<code>/RDF/channel | /RDF/item</code>.这意味着在这个XML中会有两种类型的行记录(它使用了Xpath语法来表示<code>或者</code>,以便能表示多种类型).当它读取到一行记录后,它会尝试尽可能多的在记录中读取定义中存在的字段.因此,在这种情况下,当它读取到<code>/RDF/channel</code>这种记录的时候,它会获取<code>source</code>、<code>source-link</code>、<code>source-subject</code>三个字段.经过处理,它会发现这个记录并不具备创建索引所必须的<code>pk</code>字段,所以它并不会真正的创建Solr的文档,但是由于这三个字段都被标识为<code>commonField=true</code>.因此,它会继续持有这几个值以方便后续行的处理.<br>当它继续一行一行向后解析XML并遇到<code>/RDF/item</code>记录的时候,它会获取到所有除了在头上那3个值以外的所有值.但是由于那三个字被标记为共有字段,所以处理器会把先前获取到的三个字段的值放入当前创建的文档当中.</p>
<p>那么当一个实体中的<code>transformer</code>属性为<code>DateFormatTransformer</code>的时候会发生什么呢?具体可以参见<a href="#DateFormatTransformer">DateFormatTransformer</a>章节.</p>
<p>你可以使用同<code>RSS/ATOM</code>、<code>XML</code>数据源、其他Solr服务器甚至是具有良好结构的XHTML文档索引一样的方法从<code>REST</code>API中建立索引.当然,我们对XPATH的支持也是有限制的(不支持通配符,只支持全路径等等).但是我们已经尝试了保证常用的通用用例能被覆盖到.并且它还是一个流式的解析器,它非常的快并且在超大的XML文档解析时也能保持比较低的内存消耗.它并不支持命名空间,但是它可以处理xmls的命名空间.当你提供XPATH的时候,只需要丢掉命名空间不管即可(比如要映射<code>&lt;dc:subject&gt;</code>节点只需要提供的XPATH包含<code>subject</code>即可).这非常的简单,并不需要你写一行的代码!</p>
<p>注意:并不像数据库,你并不能在使用<code>XPathEntityProcessor</code>的时候省略字段的定义声明.它依赖于在定义中声明的字段的XPATH,才能从xml中提取出来值.</p>
<h2 id="从维基百科提取索引的例子">从维基百科提取索引的例子</h2><p>下面的<code>data-config.xml</code>被用于提取维基百科dump全部的索引(只有最近的英文的文章).这个文件从维基百科网站下载下来的时候是<code>pages-articles.xml.bz2</code>,解压后有将近40GB的大小.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">type</span>=<span class="value">"FileDataSource"</span> <span class="attribute">encoding</span>=<span class="value">"UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"page"</span></span><br><span class="line">                <span class="attribute">processor</span>=<span class="value">"XPathEntityProcessor"</span></span><br><span class="line">                <span class="attribute">stream</span>=<span class="value">"true"</span></span><br><span class="line">                <span class="attribute">forEach</span>=<span class="value">"/mediawiki/page/"</span></span><br><span class="line">                <span class="attribute">url</span>=<span class="value">"/data/enwiki-20130102-pages-articles.xml"</span></span><br><span class="line">                <span class="attribute">transformer</span>=<span class="value">"RegexTransformer,DateFormatTransformer"</span></span><br><span class="line">                &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"id"</span>        <span class="attribute">xpath</span>=<span class="value">"/mediawiki/page/id"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"title"</span>     <span class="attribute">xpath</span>=<span class="value">"/mediawiki/page/title"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"revision"</span>  <span class="attribute">xpath</span>=<span class="value">"/mediawiki/page/revision/id"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"user"</span>      <span class="attribute">xpath</span>=<span class="value">"/mediawiki/page/revision/contributor/username"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"userId"</span>    <span class="attribute">xpath</span>=<span class="value">"/mediawiki/page/revision/contributor/id"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"text"</span>      <span class="attribute">xpath</span>=<span class="value">"/mediawiki/page/revision/text"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"timestamp"</span> <span class="attribute">xpath</span>=<span class="value">"/mediawiki/page/revision/timestamp"</span> <span class="attribute">dateTimeFormat</span>=<span class="value">"yyyy-MM-dd'T'hh:mm:ss'Z'"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"$skipDoc"</span>  <span class="attribute">regex</span>=<span class="value">"^#REDIRECT .*"</span> <span class="attribute">replaceWith</span>=<span class="value">"true"</span> <span class="attribute">sourceColName</span>=<span class="value">"text"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>schema.xml</code>文件中相关的部分如下所示:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"id"</span>        <span class="attribute">type</span>=<span class="value">"string"</span>  <span class="attribute">indexed</span>=<span class="value">"true"</span> <span class="attribute">stored</span>=<span class="value">"true"</span> <span class="attribute">required</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"title"</span>     <span class="attribute">type</span>=<span class="value">"string"</span>  <span class="attribute">indexed</span>=<span class="value">"true"</span> <span class="attribute">stored</span>=<span class="value">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"revision"</span>  <span class="attribute">type</span>=<span class="value">"int"</span>    <span class="attribute">indexed</span>=<span class="value">"true"</span> <span class="attribute">stored</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"user"</span>      <span class="attribute">type</span>=<span class="value">"string"</span>  <span class="attribute">indexed</span>=<span class="value">"true"</span> <span class="attribute">stored</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"userId"</span>    <span class="attribute">type</span>=<span class="value">"int"</span>     <span class="attribute">indexed</span>=<span class="value">"true"</span> <span class="attribute">stored</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"text"</span>      <span class="attribute">type</span>=<span class="value">"text_en"</span>    <span class="attribute">indexed</span>=<span class="value">"true"</span> <span class="attribute">stored</span>=<span class="value">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"timestamp"</span> <span class="attribute">type</span>=<span class="value">"date"</span>    <span class="attribute">indexed</span>=<span class="value">"true"</span> <span class="attribute">stored</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">name</span>=<span class="value">"titleText"</span> <span class="attribute">type</span>=<span class="value">"text_en"</span>    <span class="attribute">indexed</span>=<span class="value">"true"</span> <span class="attribute">stored</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="title">uniqueKey</span>&gt;</span>id<span class="tag">&lt;/<span class="title">uniqueKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">copyField</span> <span class="attribute">source</span>=<span class="value">"title"</span> <span class="attribute">dest</span>=<span class="value">"titleText"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在50分钟内提取了8338182篇文章,所消耗的内存峰值是4GB.该测试是在Solr4.3.1中测试的,<code>ramBufferSizeMB</code>设置为<code>256MB</code>.整个维基百科的dump文件存放在7200转速的希捷机械硬盘中,而Solr的索引存放在海盗船的SSD中.</p>
<p>请注意:有许多维基百科的文章是被重定向到其他的文章中,在Solr1.4后使用<code>$skipDoc</code>可以忽略这些文章.同样的,<code>$skipDoc</code>只有在正则表达式匹配的情况下被返回.</p>
<h2 id="使用增量导入命令-1">使用增量导入命令</h2><p>仅仅只有<code>SqlEntityProcessor</code>的实体处理器支持增量操作.<code>XPathEntityProcessor</code>处理器目前还没有实现增量的操作.因此,不幸的是,目前还没有方法来支持XML的增量导入.如果你想在<code>XPathEntityProcessor</code>中实现这些方法:这些方法在<code>EntityProcessor.java</code>中有解释.</p>
<h1 id="从邮件中创建索引">从邮件中创建索引</h1><p>请参见<a href="https://wiki.apache.org/solr/MailEntityProcessor" target="_blank" rel="external">MailEntityProcessor</a></p>
<h1 id="Tika的集成">Tika的集成</h1><p>请参见<a href="https://wiki.apache.org/solr/TikaEntityProcessor" target="_blank" rel="external">TikaEntityProcessor</a></p>
<h1 id="扩展功能的API工具">扩展功能的API工具</h1><p>我们目前展示过的例子都是非常简单的.不可能将用户的所有需求都通过一个xml配置文件就满足的.所以我们提供了一些抽象的类让用户自己来实现,从而实现更高级的功能.</p>
<h2 id="Transformer">Transformer</h2><p>每一个被实体所使用的字段值都可以直接被索引处理器所使用或者是通过<code>Transformer</code>转换器加工一下再使用,甚至有可能完全的生成新的字段值也是可能的.<code>transformer</code>转换器必须被配置在实体的属性中:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"foo"</span> <span class="attribute">transformer</span>=<span class="value">"com.foo.Foo"</span> <span class="attribute">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意:转换器的值必须是一个完整的类路径.如果路径是<code>org.apache.solr.handler.dataimport</code>那么包名可以被省略. 如果一个类是在<code>solr</code>的包范围类,那么<code>solr.&lt;classname&gt;</code>同样可以工作.这个规则适用于所有的扩展类,比如<code>DataSource</code>、<code>EntityProcessor</code>和<code>Evaluator</code></p>
<p>类<code>Foo</code>必须继承自抽象类<code>org.apache.solr.hander.dataimport.Transformer</code>,这个类只有一个抽象的方法.</p>
<p>实体的<code>transformer</code>属性同时可以使用<code>,</code>配置多个转换器.在这种情况下转换器会按照他们定义是时的顺序链式的进行处理.这意味着当字段从数据源中被读取出来后,这些字段会按照实体定义的字段以及顺序被配置的第一个转换器筛选一次.如果转换器处理出了结果.那么所有被筛选过的实体的字段都会被用作下一个转换器的输入进行处理.</p>
<p>一个转换器可以被用于修改一个从数据源中获取的字段的值.也可以用于创建一个新的未定义的字段.如果转换器的操作执行失败,或者正则匹配失败,那么字段会保持原样,已存在的字段不会被修改,未定义的字段也不会被生成.上述的链式处理允许一个字段的值一次又一次不断的被转换器所改变.并且一个转换器还允许使用其他实体的字段用于处理字段的值.</p>
<h3 id="RegexTransformer">RegexTransformer</h3><p>有一个名为由DIH提供的内置的名为<code>RegexTransformer</code>的转换器.它能帮助我们使用正则表达式来提取和操作字段的值.它真正的实现类是<code>org.apache.solr.handler.dataimport.RegexTransformer</code>,但是在使用的时候我们可以省略它的包名.</p>
<p><strong>属性</strong><br><code>RegexTransformer</code>只有<code>regex</code>和<code>splitBy</code>可被使用,其他的属性会被它所忽略.</p>
<ul>
<li><strong>regex</strong>:这是一个用来匹配字段或者sourceColName值的正则表达式.如果没有<code>replaceWith</code>属性,那么每一个正则表达式组(‘regex group’)会被提取为一个值,并且返回值的集合.</li>
<li><strong>sourceColName</strong>:需要使用正则表达式提取值的来源字段名,如果没有这个字段,那么来源和目标字段的名字是相同的.</li>
<li><strong>splitBy</strong>:被用来标识分隔字符串的,它会把分隔后的多个值使用集合返回出去</li>
<li><strong>groupName</strong>:用逗号分隔的字段列名,被用来标识正则表达式组,每一组的匹配结果都会被存储到另外一个不同的字段中去.如果一些组并没有被命名,那么在两个逗号之间留一个空格.</li>
<li><strong>replaceWith</strong>:跟随着<code>regex</code>属性一起使用,其效果等同于调用方法<code>new String(&lt;sourceColVal&gt;).replaceAll(&lt;regex&gt;, &lt;replaceWith&gt;)</code></li>
</ul>
<p>例子:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"foo"</span> <span class="attribute">transformer</span>=<span class="value">"RegexTransformer"</span></span><br><span class="line"><span class="attribute">query</span>=<span class="value">"select full_name , emailids from foo"</span>/&gt;</span></span><br><span class="line">... /&gt;</span><br><span class="line">   <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"full_name"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"firstName"</span> <span class="attribute">regex</span>=<span class="value">"Mr(\w*)\b.*"</span> <span class="attribute">sourceColName</span>=<span class="value">"full_name"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"lastName"</span> <span class="attribute">regex</span>=<span class="value">"Mr.*?\b(\w*)"</span> <span class="attribute">sourceColName</span>=<span class="value">"full_name"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- another way of doing the same --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"fullName"</span> <span class="attribute">regex</span>=<span class="value">"Mr(\w*)\b(.*)"</span> <span class="attribute">groupNames</span>=<span class="value">"firstName,lastName"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"mailId"</span> <span class="attribute">splitBy</span>=<span class="value">","</span> <span class="attribute">sourceColName</span>=<span class="value">"emailids"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中,<code>regex</code>属性以及<code>sourceColName</code>属性就是由转换器来使用的.它从查询结果集中读取<code>full_name</code>字段的值并且提供给<code>firstName</code>和<code>lastName</code>这两个新的字段使用.因此,即使在查询结果中只有一个<code>full_name</code>字段.但是在Solr文档中还是能获取到两个衍生的扩展字段:<code>firstName</code>和<code>lastName</code>.这些新的字段,只有在正则匹配时才会被创建.</p>
<p>而表中的<code>emailids</code>字段又是由逗号分隔的.因此,最终它提供了一个或多个email的id.并且我们把它提取到了Solr的一个多值(<code>multivalued</code>)字段:<code>mailId</code>中.</p>
<p>正则表达式的匹配默认是区分大小写的.可以使用<code>(?i)</code>以及<code>(?u)</code>标志(<code>u</code>可以在Unicode编码中使用, <code>i</code>只能是US-ASCII)来告诉表达式全部或者有一部分匹配是忽略大小写的.另外的一些标志和操作可以参考Java的正则表达式类<code>java.util.regex</code>,比照到它来设置.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- matches Apples and apples --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"just_apples"</span> <span class="attribute">regex</span>=<span class="value">"(?iu)(apples)"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意:这个转换器可以被用于使用<code>splitBy</code>属性来分隔字符串,或者使用<code>replaceWith</code>属性来替换字符串中的每一个值,又或者使用<code>groupNames</code>来表示一组正则表达式组.到底是用来做什么这取决于它定义时<code>splitBy</code>、<code>replaceWith</code>和<code>groupNames</code>这几个属性到底哪一个最前面.当它匹配到第一个动作后,后面的属性标签会被忽略.</p>
<h3 id="ScriptTransformer">ScriptTransformer</h3><p>这个转换器能让你书写<code>Javascript</code>或者其他JAVA支持的脚本语言.你必须在<code>JAVA6</code>中才能使用此功能.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="xml"><span class="cdata">&lt;![CDATA[</span><br><span class="line">                function f1(row)        &#123;</span><br><span class="line">                    row.put('message', 'Hello World!');</span><br><span class="line">                    return row;</span><br><span class="line">                &#125;</span><br><span class="line">        ]]&gt;</span></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"e"</span> <span class="attribute">pk</span>=<span class="value">"id"</span> <span class="attribute">transformer</span>=<span class="value">"script:f1"</span> <span class="attribute">query</span>=<span class="value">"select * from X"</span>&gt;</span></span><br><span class="line">                ....</span><br><span class="line">                <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外一个复杂点的例子:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript">&lt;![CDATA[</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">CategoryPieces</span><span class="params">(row)</span>    </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> pieces = row.<span class="keyword">get</span>(<span class="string">'category'</span>).split(<span class="string">'/'</span>);</span><br><span class="line">                    <span class="keyword">var</span> arr = <span class="keyword">new</span> java.util.ArrayList();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;pieces.length; i++) &#123;</span><br><span class="line">                       arr.add(pieces[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    row.put(<span class="string">'categorypieces'</span>, arr);</span><br><span class="line">                    row.remove(<span class="string">'category'</span>);</span><br><span class="line">                    <span class="keyword">return</span> row;</span><br><span class="line">                &#125;</span><br><span class="line">        ]]&gt;</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"e"</span> <span class="attribute">pk</span>=<span class="value">"id"</span> <span class="attribute">transformer</span>=<span class="value">"script:CategoryPieces"</span> <span class="attribute">query</span>=<span class="value">"select * from X"</span>&gt;</span></span><br><span class="line">                ....</span><br><span class="line">                <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>你可以把在<code>dataConfig</code>节点下放入一个<code>script</code>节点.在默认情况下假定是<code>Javascript</code>.但是当你如果要使用其他的语言,那么在<code>script</code>节点上增加一个<code>language=&quot;MyLanguage&quot;</code>的属性即可(必须是java 6 支持的语言)</li>
<li>你可以在转换器中写任意多个的函数.每一个函数都必须能使用<code>Map&lt;String,Object&gt;</code>来接收每一行的数据,并且返回一行记录(在应用转换后)</li>
<li>可以使用<code>row.remove(keyname)</code>来从一行记录中删除项目</li>
<li>要给一个字段增加多个项目值,请<code>var arr = new java.util.ArrayList()</code>.你不能直接使用<code>JavaScript</code>中的数组</li>
<li><code>JAVA</code>中的<code>Map</code>对象能被变成文档</li>
<li><code>JAVA</code>中的<code>ArrayList</code>对象能被变成文档</li>
<li>要在实体中使用一个函数,可以在<code>entity</code>节点中写成<code>transformer=&quot;script:&lt;function-name&gt;&quot;</code>.</li>
<li>在上面的例子中,<code>f1</code>这个<code>javascript</code>函数会在实体e返回的每一行记录上执行一次.</li>
<li>它会被当成一个java的转换器来执行.抽象类<code>Transformer</code>的<code>transformRow(Map&lt;String,Object&gt; , Context context)</code>方法有两个入参.但由于它是一个<code>javascript</code>脚本,因此第二个参数有可能被忽略,并且还能正常工作.</li>
</ul>
<h3 id="DateFormatTransformer">DateFormatTransformer</h3><p>DIH内置了一个名为<code>DateFormatTransformer</code>的转换器.这个转换器对于把<code>java.util.Date</code>实例转换成日期/时间字符串非常的有用.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"date"</span> <span class="attribute">xpath</span>=<span class="value">"/RDF/item/date"</span> <span class="attribute">dateTimeFormat</span>=<span class="value">"yyyy-MM-dd'T'HH:mm:ss"</span> <span class="attribute">locale</span>=<span class="value">"en"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>属性</strong><br><code>DateFormatTransformer</code>转换器仅有一个特有的<code>dateTimeFormat</code>属性.其他属性和它无关.</p>
<ul>
<li><strong>dateTimeFormat</strong>:字段要被格式化的格式.它必须遵循java<a href="http://java.sun.com/j2se/1.4.2/docs/api/java/text/SimpleDateFormat.html" target="_blank" rel="external">SimpleDateFormat</a>的语法.</li>
<li><strong>sourceColName</strong>:指明哪一个列的数据会被日期格式化处理.如果不填这个属性,那么来源和目的字段都是相同的.</li>
<li><strong>locale</strong>:日期转换器所使用的语言环境(可选).如果没有设置语言环境,在Solr4.1以及之后的版本默认是<code>ROOT</code>语言环境(在Solr4.1之前使用的是机器默认的语言环境)</li>
</ul>
<p>上述的字段被定义在<code>RSS</code>的例子中用来解析RSS摘要中的发布时间.</p>
<h3 id="NumberFormatTransformer">NumberFormatTransformer</h3><p>它可以用来把一个字符串解析成一个数字.它使用了JAVA中的<code>NumberFormat</code>类:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"price"</span> <span class="attribute">formatStyle</span>=<span class="value">"number"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下,<code>NumberFormat</code>使用系统默认的语言环境来解析给定的字符串.可选的,你可以如下那样指定语言环境(请参阅<code>java.util.Locale</code>的javadoc来获取更多的信息):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"price"</span> <span class="attribute">formatStyle</span>=<span class="value">"number"</span> <span class="attribute">locale</span>=<span class="value">"de-DE"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>属性</strong><br><code>NumberFormatTransformer</code>仅使用<code>formatStyle</code>这一个属性.</p>
<ul>
<li><strong>formatStyle</strong>:用于指定某一个字段被转换成的格式,这个属性的值只能是<code>number</code>|<code>percent</code>|<code>integer</code>|<code>currency</code>中的一个.它会使用java<code>NumberFormat</code>的语法.</li>
<li><strong>sourceColName</strong>:指明哪一列的数据会被NumberFormat处理.如果不提供这个属性,那么源和目标字段相同</li>
<li><strong>locale</strong>:解析字符串时所使用的语言环境(可选).如果没有设置语言环境,在Solr4.1以及之后的版本默认是<code>ROOT</code>语言环境(在Solr4.1之前使用的是机器默认的语言环境)</li>
</ul>
<h3 id="TemplateTransformer">TemplateTransformer</h3><p>可用于覆盖或修改已经存在的任意Solr字段或者创建一个新的Solr字段.分配给该属性的值是一个基于静态模板的可使用DIH变量的字符串.如果模板字符串包含占位符或变量,那么在转换器开始执行前必须定义它们.一个未定义的变量会导致整个模板的转换会被忽略.比如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"e"</span> <span class="attribute">transformer</span>=<span class="value">"TemplateTransformer"</span> <span class="attribute">..</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"namedesc"</span> <span class="attribute">template</span>=<span class="value">"hello$&#123;e.name&#125;,$&#123;eparent.surname&#125;"</span> /&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>模板的这个规则同样适用于<code>query</code>,<code>url</code>等等.它可以帮助我们连接多个值或者为一个字段插入一些另外的字符.仅当字段上有<code>template</code>属性时它才会被执行.</p>
<p><strong>属性</strong></p>
<ul>
<li>template:模板字符串.在上面的例子中有<code>${e.name}</code>和<code>$eparent.surname</code>两个占位符.他们必须在被执行前提供值.</li>
</ul>
<h3 id="HTMLStripTransformer">HTMLStripTransformer</h3><p><a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a><br>可以在一个字符串字段中去掉HTML标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"e"</span> <span class="attribute">transformer</span>=<span class="value">"HTMLStripTransformer"</span> <span class="attribute">..</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"htmlText"</span> <span class="attribute">stripHTML</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它会使用<code>org.apache.solr.analysis.HTMLStripReader</code>类来去掉一个字段值中的HTML标签.</p>
<p><strong>属性</strong></p>
<ul>
<li><strong>stripHTML</strong>:一个用于标记是否在这个字段上执行<code>HTMLStripTransformer</code>的布尔值</li>
</ul>
<h3 id="ClobTransformer">ClobTransformer</h3><p><a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a><br>它可以用来从数据库的<code>Clob</code>类型字段中获取一个字符串.比如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"e"</span> <span class="attribute">transformer</span>=<span class="value">"ClobTransformer"</span> <span class="attribute">..</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"hugeTextField"</span> <span class="attribute">clob</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>属性</strong></p>
<ul>
<li><strong>clob</strong>:用于标记是否在这个字段上执行<code>ClobTransformer</code>转换的布尔值</li>
<li><strong>sourceColName</strong>:标记数据来源字段是哪一个.如果不设置这个属性,那么来源和目标字段相同.</li>
</ul>
<h3 id="LogTransformer">LogTransformer</h3><p><a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a><br>它可以用来处理控制台或日志文件中的日志数据,比如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">...</span></span><br><span class="line"><span class="attribute">transformer</span>=<span class="value">"LogTransformer"</span></span><br><span class="line"><span class="attribute">logTemplate</span>=<span class="value">"The name is $&#123;e.name&#125;"</span> <span class="attribute">logLevel</span>=<span class="value">"debug"</span> &gt;</span></span><br><span class="line">....</span><br><span class="line"><span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>与其他的转换器不同,它不会给实体中的任何一个字段增加属性,仅仅会在<code>entity</code>节点上增加.<br>有效的<code>logLevels</code>是:</p>
<ol>
<li>trace</li>
<li>debug</li>
<li>info</li>
<li>warn</li>
<li>error<br>这些值是区分大小写的(要求全小写)</li>
</ol>
<h3 id="转换器的例子">转换器的例子</h3><p><a href="https://wiki.apache.org/solr/Solr1.4" target="_blank" rel="external">Solr1.4</a><br>下面的例子展示了使用转换器链来大量重复的处理变量.<br>我们保持<code>solrconfig.xml</code>不变并且重用一些转换器.两个实体的列名同样会在转换器中使用.</p>
<p>假设我们现在有一些XML文档,其中每一个都描述了一组图片.这些图片储存在XML文档的image子文件夹中.有一个性存储了图片文件名的属性关联了一段简介和一个描述这这图片详情的文档.最后,提供了一个稍小的png格式的图标文件,这个文件的名字就是在图片的名称前加一个<code>s</code>.<br>我们期望Solr能索引图片的绝对路径、它的图标以及详细的描述.下面就展示一下如何配置<code>solrconfig.xml</code>和DIH的<code>data-config.xml</code>文件来索引这些数据:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">requestHandler</span> <span class="attribute">name</span>=<span class="value">"/dataimport"</span> <span class="attribute">class</span>=<span class="value">"org.apache.solr.handler.dataimport.DataImportHandler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">lst</span> <span class="attribute">name</span>=<span class="value">"defaults"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">str</span> <span class="attribute">name</span>=<span class="value">"config"</span>&gt;</span>data-config.xml<span class="tag">&lt;/<span class="title">str</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">lst</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">lst</span> <span class="attribute">name</span>=<span class="value">"invariants"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- Pass through the prefix which needs stripped from</span><br><span class="line">            an absolute disk path to give an absolute web path  --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">str</span> <span class="attribute">name</span>=<span class="value">"img_installdir"</span>&gt;</span>/usr/local/apache2/htdocs<span class="tag">&lt;/<span class="title">str</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">lst</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">requestHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">name</span>=<span class="value">"myfilereader"</span> <span class="attribute">type</span>=<span class="value">"FileDataSource"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"jc"</span> <span class="attribute">rootEntity</span>=<span class="value">"false"</span> <span class="attribute">dataSource</span>=<span class="value">"null"</span></span><br><span class="line">            <span class="attribute">processor</span>=<span class="value">"FileListEntityProcessor"</span></span><br><span class="line">            <span class="attribute">fileName</span>=<span class="value">"^.*\.xml$"</span> <span class="attribute">recursive</span>=<span class="value">"true"</span></span><br><span class="line">            <span class="attribute">baseDir</span>=<span class="value">"/usr/local/apache2/htdocs/imagery"</span></span><br><span class="line">            &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"x"</span><span class="value">rootEntity="true"</span></span><br><span class="line">              <span class="attribute">dataSource</span>=<span class="value">"myfilereader"</span></span><br><span class="line">              <span class="attribute">processor</span>=<span class="value">"XPathEntityProcessor"</span></span><br><span class="line">              <span class="attribute">url</span>=<span class="value">"$&#123;jc.fileAbsolutePath&#125;"</span></span><br><span class="line">              <span class="attribute">stream</span>=<span class="value">"false"</span> <span class="attribute">forEach</span>=<span class="value">"/mediaBlock"</span></span><br><span class="line">              <span class="attribute">transformer</span>=<span class="value">"DateFormatTransformer,TemplateTransformer,RegexTransformer,LogTransformer"</span></span><br><span class="line">              <span class="attribute">logTemplate</span>=<span class="value">"      processing $&#123;jc.fileAbsolutePath&#125;"</span></span><br><span class="line">              <span class="attribute">logLevel</span>=<span class="value">"info"</span></span><br><span class="line">              &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"fileAbsPath"</span>     <span class="attribute">template</span>=<span class="value">"$&#123;jc.fileAbsolutePath&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"fileWebPath"</span>     <span class="attribute">template</span>=<span class="value">"$&#123;x.fileAbsolutePath&#125;"</span></span><br><span class="line">                                        <span class="attribute">regex</span>=<span class="value">"$&#123;dataimporter.request.img_installdir&#125;(.*)"</span> <span class="attribute">replaceWith</span>=<span class="value">"$1"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"fileWebDir"</span>      <span class="attribute">regex</span>=<span class="value">"^(.*)/.*"</span> <span class="attribute">replaceWith</span>=<span class="value">"$1"</span> <span class="attribute">sourceColName</span>=<span class="value">"fileWebPath"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"imgFilename"</span>     <span class="attribute">xpath</span>=<span class="value">"/mediaBlock/@url"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"imgCaption"</span>      <span class="attribute">xpath</span>=<span class="value">"/mediaBlock/caption"</span>  /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"imgSrcArticle"</span>   <span class="attribute">xpath</span>=<span class="value">"/mediaBlock/source"</span></span><br><span class="line">                                        <span class="attribute">template</span>=<span class="value">"$&#123;x.fileWebDir&#125;/$&#123;x.imgSrcArticle&#125;/"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"uid"</span>             <span class="attribute">regex</span>=<span class="value">"^(.*)$"</span> <span class="attribute">replaceWith</span>=<span class="value">"$1#$&#123;x.imgFilename&#125;"</span> <span class="attribute">sourceColName</span>=<span class="value">"fileWebPath"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- if imgFilename is not defined all the following will also not be defined --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"imgWebPathFULL"</span>  <span class="attribute">template</span>=<span class="value">"$&#123;x.fileWebDir&#125;/images/$&#123;x.imgFilename&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"imgWebPathICON"</span>  <span class="attribute">regex</span>=<span class="value">"^(.*)\.\w+$"</span> <span class="attribute">replaceWith</span>=<span class="value">"$&#123;x.fileWebDir&#125;/images/s$1.png"</span></span><br><span class="line">                                        <span class="attribute">sourceColName</span>=<span class="value">"imgFilename"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="实现自定义的转换器">实现自定义的转换器</h3><p>你可以非常简单的实现一个你自己的转换器,具体的文档请参阅<a href="https://wiki.apache.org/solr/DIHCustomTransformer" target="_blank" rel="external">DIHCustomTransformer</a></p>
<h2 id="EntityProcessor">EntityProcessor</h2><p>每一个的实体都会被一个名叫<code>SqlEntityProcessor</code>的默认实体处理器处理.它非常适合处理使用关系型数据库作为数据源的系统.而对于其他种类的数据源,比如REST或者NOSQL数据库,你可以选择扩展<code>org.apache.solr.handler.dataimport.Entityprocessor</code>这个抽象类.它被设计为流式逐行的处理实体.一个最简单的实现自己的实体处理类的方式就是继承自<code>EntityProcessorBase</code>类并且重写它的<code>public Map&lt;String,Object&gt; nextRow()</code>方法.<code>EntityProcessor</code>依赖于数据源来获取数据.数据源的返回类型对于<code>EntityProcessor</code>非常的重要.</p>
<h3 id="SqlEntityProcessor">SqlEntityProcessor</h3><p>它是默认处理器.它的数据源必须是<code>DataSource&lt;Iterator&lt;Map&lt;String, Object&gt;&gt;&gt;</code>种类的.<code>JdbcDataSource</code>就可以被它使用.</p>
<h3 id="XPathEntityProcessor">XPathEntityProcessor</h3><p>它用于索引XML类型的数据.它的数据源必须是<code>DataSource&lt;Reader&gt;</code>类型的.<code>URLDataSource</code>或者<code>FileDataSource</code>都可以提供给<code>XPathEntityProcessor</code>使用.</p>
<h3 id="FileListEntityProcessor">FileListEntityProcessor</h3><p>这是一个简单的实体处理器.它可以被用来基于某些条件枚举文件系统上的一系列文件.它不需要使用数据源.它的实体的属性有:</p>
<ul>
<li>fileName:(必须)标示文件的一个正则表达式</li>
<li>baseDir:(必须)基础目录(绝对路径)</li>
<li>recursive:是否递归扫描文件,默认是<code>false</code></li>
<li>excludes:一个标示需要排除的文件的正则表达式</li>
<li>newerThan:一个日期参数.使用<code>yyyy-MM-dd HH:mm:ss</code>的格式.它也可以是一个日期计算字符串(<code>&#39;NOW-3DAYS&#39;</code>).这个单引号是必须的.或者也可以是一种有效的<code>VariableResolver</code>格式,比如(<code>${var.name}</code>)</li>
<li>olderThan:一个日期参数,规则同上</li>
<li>biggerThan:一个整形参数</li>
<li>smallerThan:一个整形参数</li>
<li>rootEntity:除非你只希望索引文件名,否则必须在<code>document</code>节点的直接<code>entity</code>节点上设置为<code>false</code>.这意味着,对于从根实体中获取的每一行记录都会被创建成为一个Solr/Lucene的文档.但可能在这种情况下,我们并不想把每一个文件都创建成一个document.我们希望由实体<code>x</code>生成的每一行数据成为一个文档.由于实体<code>f</code>是<code>rootEntity=false</code>的,直接在它下面的实体会自动的成为一个根实体.并且每一行都会变成一个文档.</li>
<li>dataSource:如果是使用的Solr1.3,那么这个值必须被设置成<code>null</code>.因为它不使用任何的数据源.在Solr1.4中已经不需要设置这个属性了.它仅仅表示我们不会创建一个数据源实例(在大多数情况下,只会使用一个数据源(<code>JdbcDataSource</code>)并且所有的实体都使用它.在<code>FileListEntityProcessor</code>中,并不需要使用数据源)</li>
</ul>
<p>例子:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">type</span>=<span class="value">"FileDataSource"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"f"</span> <span class="attribute">processor</span>=<span class="value">"FileListEntityProcessor"</span> <span class="attribute">baseDir</span>=<span class="value">"/some/path/to/files"</span> <span class="attribute">fileName</span>=<span class="value">".*xml"</span> <span class="attribute">newerThan</span>=<span class="value">"'NOW-3DAYS'"</span> <span class="attribute">recursive</span>=<span class="value">"true"</span> <span class="attribute">rootEntity</span>=<span class="value">"false"</span> <span class="attribute">dataSource</span>=<span class="value">"null"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"x"</span> <span class="attribute">processor</span>=<span class="value">"XPathEntityProcessor"</span> <span class="attribute">forEach</span>=<span class="value">"/the/record/xpath"</span> <span class="attribute">url</span>=<span class="value">"$&#123;f.fileAbsolutePath&#125;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"full_name"</span> <span class="attribute">xpath</span>=<span class="value">"/field/xpath"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不要忘了<code>rootEntity</code>属性.如上所示,<code>FileListEntityProcessor</code>会隐式的在实体<code>X</code>中生成<code>fileDir</code>、<code>file</code>、<code>fileAbsolutePath</code>、<code>fileSize</code>、<code>fileLastModified</code>字段.需要特别指出的是<code>FileListEntityProcessor</code>返回的路径列表和随后的实体必须使用<code>FileDataSource</code>来获取文件的内容.</p>
<h3 id="CachedSqlEntityProcessor">CachedSqlEntityProcessor</h3><p>这个处理器是<code>SqlEntityProcessor</code>的一个扩展.这个实体处理器可以通过命中缓存来减少真正执行数据库的查询.对于只有一个SQL执行的根实体,在大多数情况下是不起作用的.</p>
<p>例1:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"x"</span> <span class="attribute">query</span>=<span class="value">"select * from x"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"y"</span> <span class="attribute">query</span>=<span class="value">"select * from y where xid=$&#123;x.id&#125;"</span> <span class="attribute">processor</span>=<span class="value">"CachedSqlEntityProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子和其他的例子一样.当一个查询被执行,那么它的查询结果会被缓存起来,再当遇到相同的查询时,它会直接从缓存中获取数据并返回.</p>
<p>例2:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"x"</span> <span class="attribute">query</span>=<span class="value">"select * from x"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"y"</span> <span class="attribute">query</span>=<span class="value">"select * from y"</span> <span class="attribute">processor</span>=<span class="value">"CachedSqlEntityProcessor"</span>  <span class="attribute">where</span>=<span class="value">"xid=x.id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子和上面的例子在<code>where</code>属性上稍微有一点不一样.在这个例子中查询条件从数据库表中命中了所有的记录,并且把这些记录都放入了缓存.而神奇的地方在于<code>where</code>的值.缓存会在实体<code>y</code>中定义一个<code>xid</code>的键.在之后的每一次执行查询实体的时候,都会直接从缓存中命中,并且把<code>x.id</code>的值赋予<code>xid</code>,然后返回整行的数据.</p>
<p>表达式左边是<code>y</code>中的列,表达式右边的值会从缓存中获取并赋值.</p>
<p>上面例2的另外一种写法是使用<code>cacheKey</code>和<code>cacheLookup</code>参数:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"x"</span> <span class="attribute">query</span>=<span class="value">"select * from x"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"y"</span> <span class="attribute">query</span>=<span class="value">"select * from y"</span> <span class="attribute">processor</span>=<span class="value">"CachedSqlEntityProcessor"</span> <span class="attribute">cacheKey</span>=<span class="value">"xid"</span> <span class="attribute">cacheLookup</span>=<span class="value">"x.id"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意:在Solr 3.6, 3.6.1, 4.0-Alpha &amp; 4.0-Beta版本中<code>cacheKey</code>属性被重命名为<code>cachePk</code>.它从4.0和3.6.2又变了回来.参阅:<a href="https://issues.apache.org/jira/browse/SOLR-3850" target="_blank" rel="external">SOLR-3850</a></p>
<p>关于DIH的更多缓存的选项可以看<a href="https://issues.apache.org/jira/browse/SOLR-2382" target="_blank" rel="external">SOLR-2382</a>.这些额外的选项包括:在NOSQL的实体中使用缓存,扩展缓存的实现,持久化缓存,把DIH的输出写入缓存而不是Solr,使用已经创建了的缓存作为DIH实体的输入以及增量更新缓存数据.其中的一些特性会在<code>Solr3.6</code> <code>Solr4.0</code> 中提供.</p>
<h3 id="PlainTextEntityProcessor">PlainTextEntityProcessor</h3><p>这个实体处理器会从数据源中读取所有的内容,并且写入到一个被称为<code>plainText</code>的隐藏字段中.文本的内容不会做任何的解析,但是你可以根据需要,自己增加转换器来处理<code>plainText</code>中的数据,甚至是增加一些字段出来.<br>例子:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">processor</span>=<span class="value">"PlainTextEntityProcessor"</span> <span class="attribute">name</span>=<span class="value">"x"</span> <span class="attribute">url</span>=<span class="value">"http://abc.com/a.txt"</span> <span class="attribute">dataSource</span>=<span class="value">"data-source-name"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- copies the text to a field called 'text' in Solr--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"plainText"</span> <span class="attribute">name</span>=<span class="value">"text"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要确保数据源是<code>DataSource&lt;Reader&gt; (FileDataSource, URLDataSource)</code>类型的</p>
<h3 id="LineEntityProcessor">LineEntityProcessor</h3><p>这个实体处理会会从数据源中一行一行的读取所有的内容.每读取一行都会把返回值放入一个叫<code>rawLine</code>的字段中.同样,文本的内容不会做任何的解析,但是你可以根据需要,自己增加转换器来处理<code>rawLine</code>中的数据,甚至是增加一些字段出来.</p>
<p>读取的行数据可以使用<code>acceptLineRegex</code>和<code>omitLineRegex</code>这两个正则表达式来进行过滤.给实体增加的属性有:</p>
<ul>
<li><strong>url</strong>:一个必填的属性,用于指定一个与已配置的数据源相兼容的输入文件路径.如果这个值是个相对路径并且你使用的是<code>FileDataSource</code>或<code>URLDataSource</code>.那么它相当于就是<code>baseLoc</code>.</li>
<li><strong>acceptLineRegex</strong>:一个可选的属性,用于把所有于这个正则表达式不匹配的数据丢掉.</li>
<li><strong>skipLineRegex</strong>:一个可选的属性,用于在<code>acceptLineRegex</code>执行之后,再把所有符合这个正则表达式的数据丢掉.</li>
</ul>
<p>例子:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"jc"</span></span><br><span class="line">        <span class="attribute">processor</span>=<span class="value">"LineEntityProcessor"</span></span><br><span class="line">        <span class="attribute">acceptLineRegex</span>=<span class="value">"^.*\.xml$"</span></span><br><span class="line">        <span class="attribute">skipLineRegex</span>=<span class="value">"/obsolete"</span></span><br><span class="line">        <span class="attribute">url</span>=<span class="value">"file:///Volumes/ts/files.lis"</span></span><br><span class="line">        <span class="attribute">rootEntity</span>=<span class="value">"false"</span></span><br><span class="line">        <span class="attribute">dataSource</span>=<span class="value">"myURIreader1"</span></span><br><span class="line">        <span class="attribute">transformer</span>=<span class="value">"RegexTransformer,DateFormatTransformer"</span></span><br><span class="line">        &gt;</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>当你期望把一个文件中的每一行都当做一个Solr文档的时候,你会需要这个处理器.在大多数情况下,每一行会读取一个路径,而这又会被其他的实体处理器(比如<code>XPathEntityProcessor</code>)所使用.</p>
<p><a href="https://issues.apache.org/jira/browse/SOLR-2549" target="_blank" rel="external">SOLR-2549</a>补丁让<code>LineEntityProcessor</code>支持了可变长度和带有分隔符的文件,这在之前是需要使用转换器的.</p>
<h3 id="SolrEntityProcessor">SolrEntityProcessor</h3><p><a href="https://wiki.apache.org/solr/Solr3.6" target="_blank" rel="external">Solr3.6</a><br>这个实体处理器可以从其他的Solr实例与核心(<code>cores</code>)中导入数据.这个数据是根据一个指定的查询来获取.这个实体处理器在你想从你的Solr索引中稍微修改一下然后放入其他的索引中时非常的有用.在一些情况下,所有的数据可能会只存放在Solr的索引中.那么<code>SolrEntityProcessor</code>只能复制那些在源索引中<code>stored</code>了的字段.<code>SolrEntityProcessor</code>支持以下一些属性:</p>
<ul>
<li><strong>url</strong>:(必填)源Solr实体或核心的URL地址</li>
<li><strong>query</strong>:(必填)在源索引中最主要的查询语句</li>
<li><strong>fq</strong>:在源索引中执行的任何过滤条件(逗号分隔)</li>
<li><strong>rows</strong>:每一次迭代所返回的行数,默认是50</li>
<li><strong>fl</strong>:需要从源索引中返回的字段名(逗号分隔)</li>
<li><strong>qt</strong>:指定哪一个执行器会被使用</li>
<li><strong>wt</strong>:指定返回的格式(<code>javabin</code>或者<code>xml</code>).如果你导入Solr1.x以后的版本的索引,可以使用xml格式.<code>javabin</code>格式在1.4.1和3.1.0版本之间有变动.</li>
<li><strong>timeout</strong>:查询超时时间,单位是秒.你可以用它来做安全的故障点,以防止索引会话被长时间的阻塞.默认情况下超时时间为5分钟.</li>
</ul>
<p>例子:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"sep"</span> <span class="attribute">processor</span>=<span class="value">"SolrEntityProcessor"</span> <span class="attribute">url</span>=<span class="value">"http://localhost:8983/solr/db"</span> <span class="attribute">query</span>=<span class="value">"*:*"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="DataSource">DataSource</h2><p>可以从<code>org.apache.solr.handler.dataimport.DataSource</code>(<a href="http://svn.apache.org/viewvc/lucene/dev/trunk/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataSource.java?view=markup" target="_blank" rel="external">源码</a>)扩展一个类用来作为数据源.它必须在数据源的配置中被定义.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">type</span>=<span class="value">"com.foo.FooDataSource"</span> <span class="attribute">prop1</span>=<span class="value">"hello"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>它可以在标准的实体中使用.</p>
<h3 id="JdbcDataSource">JdbcDataSource</h3><p>这是默认的实现.例子可以见<a href="#jdbcdatasource">这里</a>.它的签名为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDataSource</span> <span class="keyword">extends</span> <span class="title">DataSource</span>&lt;<span class="title">Iterator</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>它被设计来从数据库中一行一行的读取数据.每一行就是一个Map</p>
<h3 id="URLDataSource">URLDataSource</h3><p>这个数据源通常为<code>XPathEntityProcessor</code>从<code>file://</code>或<code>http://</code>地址提供数据.请参阅<a href="#httpds">这里</a>.它的签名为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLDataSource</span> <span class="keyword">extends</span> <span class="title">DataSource</span>&lt;<span class="title">Reader</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="HttpDataSource">HttpDataSource</h3><p><code>HttpDataSource</code>数据源已经在Solr1.4以后被<code>URLDataSource</code>所替代.它和<code>URLDataSource</code>的功能是一样的,仅仅是名字不同而已.</p>
<h3 id="FileDataSource">FileDataSource</h3><p>它可以向<code>URLDataSource</code>那样被使用,只是他是用磁盘上的文件中获取数据.唯一与<code>URLDataSource</code>不同的地方在于访问磁盘文件的时候,路径名定义不一样.它的签名是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDataSource</span> <span class="keyword">extends</span> <span class="title">DataSource</span>&lt;<span class="title">Reader</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性包括:</p>
<ul>
<li><strong>basePath</strong>:(可选)当不是绝对路径的时候的一个相对的基础路径.</li>
<li><strong>encoding</strong>:(可选)在Solr4.1以后的版本中,默认是UTF-8编码(在4.1之前,默认的编码是和机器的默认编码一致)</li>
</ul>
<h3 id="FieldReaderDataSource">FieldReaderDataSource</h3><p>它可以像<code>URLDataSource</code>那样被使用,它的签名是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldReaderDataSource</span> <span class="keyword">extends</span> <span class="title">DataSource</span>&lt;<span class="title">Reader</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当一个数据库字段中包含了一个XML并且期望使用<code>XPathEntityProcessor</code>来处理这些字段内容的时候它非常的有用.这个数据源可以这样配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">name</span>=<span class="value">"f"</span> <span class="attribute">type</span>=<span class="value">"FieldReaderDataSource"</span> <span class="attribute">encoding</span>=<span class="value">"UTF-8"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>encoding</code>属性是可选的,在Solr4.1以后的版本中,默认是UTF-8编码(在4.1之前,默认的编码是和机器的默认编码一致)</p>
<p>要使用这个数据源的实体必须有一个名为<code>dataFiled=&quot;field-name&quot;</code>的变量来保存url值.例如,如果一个叫<code>dbEntity</code>的父实体有一个<code>xmlData</code>字段.那么它的子实体就会是这样的:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">dataSource</span>=<span class="value">"f"</span> <span class="attribute">processor</span>=<span class="value">"XPathEntityProcessor"</span> <span class="attribute">dataField</span>=<span class="value">"dbEntity.xmlData"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="ContentStreamDataSource">ContentStreamDataSource</h3><p>它会使用POST的数据作为数据源.它可以在任何使用<code>DataSource&lt;Reader&gt;</code>作为数据源的实体处理器中被使用.</p>
<h2 id="EventListeners">EventListeners</h2><p>事件监听器会注册<code>onImportStart</code>和<code>onImportEnd</code>两个事件.他们必须实现<a href="http://lucene.apache.org/solr/api/org/apache/solr/handler/dataimport/EventListener.html" target="_blank" rel="external">EventListener</a>接口.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">document</span> <span class="attribute">onImportStart</span> =<span class="value">"com.FooStart"</span> <span class="attribute">onImportEnd</span>=<span class="value">"comFooEnd"</span>&gt;</span></span><br><span class="line">....</span><br><span class="line"><span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="特殊指令">特殊指令</h2><p>一些特殊的指令可以给DIH的任何组件加入某些变量,从而影响它们的返回.</p>
<ul>
<li><strong>$skipDoc</strong>:跳过当前的文档.不把它加入到Solr中.这个是一个布尔值</li>
<li><strong>$skipRow</strong>:跳过当前的行.文档会从其他实体的记录中被增加.这是一个布尔值</li>
<li><strong>$docBoost</strong>:当前文档的权重.这个值是一个数字或者表示数字的字符串</li>
<li><strong>$deletedDocById</strong>:使用id从Solr中删除一个文档.这个值就是文档的唯一键.注意的是这个指令仅仅能删除那些已经被提交到索引中的数据.</li>
<li><strong>$deleteDocByQuery</strong>:使用一个查询语句来删除Solr中的文档.其值必须是一个Solr的查询语句.</li>
</ul>
<p>注意:在Solr3.4,<code>$deleteDocById</code>和<code>$deleteDocByQuery</code>不会增加已删除数(<code>#deletes processed</code>)的统计.同样的,如果一个组件只是使用这些特殊的指令来删除文档.那么DIH是不会提交数据变化的.在Solr3.4以后,<code>commit</code>动作会始终被执行.并且在每一次调用<code>$deleteDocById</code>或<code>$deleteDocByQuery</code>后,已删除数的统计也会加1.并且被删除的文档数量在一次调用可以删除多个文档的情况下(特别是使用$deleteDocByQuery)统计可能不准确.更多的信息可以参阅<a href="https://issues.apache.org/jira/browse/SOLR-2492" target="_blank" rel="external">SOLR-2492</a></p>
<h2 id="在solrConfig-xml中增加数据源">在solrConfig.xml中增加数据源</h2><p>你可以像在<code>data-config.xml</code>增加数据源那样在<code>solrconfig.xml</code>中配置数据源.只是数据源的属性可能有些不同:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">requestHandler</span> <span class="attribute">name</span>=<span class="value">"/dataimport"</span> <span class="attribute">class</span>=<span class="value">"org.apache.solr.handler.dataimport.DataImportHandler"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">lst</span> <span class="attribute">name</span>=<span class="value">"defaults"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">str</span> <span class="attribute">name</span>=<span class="value">"config"</span>&gt;</span>/home/username/data-config.xml<span class="tag">&lt;/<span class="title">str</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">lst</span> <span class="attribute">name</span>=<span class="value">"datasource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">str</span> <span class="attribute">name</span>=<span class="value">"driver"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="title">str</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">str</span> <span class="attribute">name</span>=<span class="value">"url"</span>&gt;</span>jdbc:mysql://localhost/dbname<span class="tag">&lt;/<span class="title">str</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">str</span> <span class="attribute">name</span>=<span class="value">"user"</span>&gt;</span>db_username<span class="tag">&lt;/<span class="title">str</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">str</span> <span class="attribute">name</span>=<span class="value">"password"</span>&gt;</span>db_password<span class="tag">&lt;/<span class="title">str</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="title">lst</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">lst</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">requestHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="架构">架构</h1><p>下面的图展示了一个样例配置的逻辑流程.<br><img src="https://wiki.apache.org/solr/DataImportHandler?action=AttachFile&amp;do=get&amp;target=DataImportHandlerOverview.png" alt=""></p>
<p>这个用例如下:他有三个数据源,其中两个是关系型数据库(<code>jdbc1</code>,<code>jdbc2</code>),还有一个是<code>xml/http</code>的</p>
<ul>
<li><code>jdbc1</code>和<code>jdbc2</code>是两个配置在<code>solrconfig.xml</code>中的<code>JdbcDataSource</code>实例</li>
<li><code>http</code>是一个<code>HttpDataSource</code>的实例</li>
<li>根实体使用<code>jdbc1</code>数据源和名为<code>A</code>的表.实体名为了方便和表名相同.</li>
<li>实体A有B和C两个子实体.B使用<code>http</code>数据源而C使用<code>jdbc2</code>数据源</li>
<li>首先在实体A上执行<code>command=full-import</code>命令</li>
<li>实体A的<code>query</code>每一行查询结果会被赋值给实体B,C</li>
<li>B和C中的查询语句使用了A的列来构造它们的查询占位符(比如<code>${A.a}</code>)<ul>
<li>B有一个url(B是一个xml/http的数据源)</li>
<li>C有一个查询语句</li>
</ul>
</li>
<li>C有两个转换器(<code>f</code>和<code>g</code>)</li>
<li>C的每一行结果都会顺序的交给<code>f</code>和<code>g</code>处理(链式处理转换器).每一个转换器可以改变它们的输入.注意:转换器<code>g</code>从<code>f</code>中输入一行记录会输出两行结果.</li>
<li>所有实体的输出最后都会被组合成一个文档<ul>
<li>需要注意的是来自C的中间记录<code>C.1</code>,<code>C.2</code>,<code>f(C.1)</code>,<code>f(C1)</code>会被忽略</li>
</ul>
</li>
</ul>
<h2 id="字段声明">字段声明</h2><p>在<code>entity</code>标签中声明字段可以帮助我们提供更多的不能被自动得出的信息.它依赖于从结果中获取的<code>column</code>的值.你显示的在配置中增加的字段,这等于在Solr的schema.xml中增加了一些隐式的字段.在schema.xml中会自动的从配置文件中继承所有的属性.当你增加字段条目的时候,你不能增加额外的配置.</p>
<ul>
<li>实体处理器提供的字段与schema.xml中所配置的字段名字不相同.</li>
<li>内置的转换器需要额外的信息来决定哪些字段会被处理,以及如何处理.</li>
<li><code>XPathEntityprocessor</code>或其他的处理器需要每一个字段都提供额外的信息.</li>
</ul>
<h2 id="什么是一行记录?">什么是一行记录?</h2><p>在DIH中,一行记录就是一个Map(<code>Map&lt;String, Object&gt;</code>).在这个map中,key是字段的名字.value可以是任意合法的Solr类型的数据.value同样可以是任意合法的Solr类型的集合(这可能会映射到一个多值字段(<code>multiValued field</code>)中去).在关系型数据库中一条查询不能提供一个多值字段.但是可以通过关联其他的实体查询来创建一个多值字段.如果一个父实体的记录关联了子实体返回的多条记录,那么他们就可以被放入一个多值字段中去.如果数据源是<code>xml</code>.那就可以直接返回一个多值字段.</p>
<h2 id="变量解算器">变量解算器</h2><p>变量解算器(<code>VariableResolver</code>)可以替换那些像<code>${name}</code>的占位符.它是一个多级Map.每一个命名空间就是第一个Map.同时命名空间以<code>.</code>符号分隔.例如这有一个占位符<code>${item.ID}</code>,<code>item</code>就是一个命名空间(是一个Map),<code>ID</code>就是那个命名空间中的一个值.命名空间可以像<code>${item.x.ID}</code>那样嵌套,<code>x</code>又是另外一个命名空间.可以从上下文中获取当前的变量解算器结果的引用.或者可以在关系型数据库的<code>query</code>或HTTP的<code>url</code>中直接使用<code>${name}</code>这样的占位符.</p>
<h2 id="识别器—在查询或URL地址中自定义格式">识别器—在查询或URL地址中自定义格式</h2><p>虽然命名空间的概念十分的有用,当时有可能用户希望在查询或url地址中插入一些计算后的值.比如:有一个日期对象并且你的数据源也能接受一些自定义的日期格式化.</p>
<h3 id="formatDate">formatDate</h3><p>使用这个函数来把日期格式化成字符串,它有4个参数(在Solr4.1以前,它只有两个):</p>
<ol>
<li>一个日期类型的变量或者日期计算表达式(<code>datemath expression</code>)</li>
<li>一个日期格式字符串.具体的格式请参考<code>java.text.SimpleDateFormat</code>的<code>javadoc</code>.(在Solr4.1以后,必须用单引号括起来,在Solr1.4-4.0,引号是可选的,在Solr1.4以前不能有单引号)</li>
<li>一个用于格式化日期的语言环境变量(可选).需要用单引号括起来.具体可以参考<code>java.util.Locale</code>的<code>javadoc</code>文档.如果忽略它,那么默认会使用根的语言环境(在Solr4.1以前,会始终使用机器默认的语言环境)</li>
<li>一个时区码(可选)具体的可以参考<code>java.util.TimeZone#getTimeZone</code>的<code>javadoc</code>文档.如果不填,默认情况下使用机器的时区.如果要设置时区码,那么在第三个参数上必须填入语言环境(<code>Locale</code>)</li>
</ol>
<ul>
<li>变量的例子:<code>${dataimporter.functions.formatDat(item.ID,&#39;yyyy-MM-dd HH:mm&#39;)}</code></li>
<li>日期计算表达式的例子:<code>&#39;${dataimporter.functions.formatDate(&#39;NOW-3DAYS&#39;, &#39;yyyy-MM-dd HH:mm&#39;)}</code></li>
<li>指定语言环境的例子:<code>${dataimporter.functions.formatDate(item.ID, &#39;yyyy-MM-dd HH:mm&#39;, &#39;th_TH&#39;)}</code></li>
<li>指定时区的例子:<code>&#39;${dataimporter.functions.formatDate(item.ID, &#39;yyyy-MM-dd HH:mm&#39;, &#39;en_US&#39;, &#39;GMT-8:00&#39;)}</code></li>
</ul>
<h3 id="escapeSql">escapeSql</h3><p>使用这个可以对特殊的SQL字符进行转义.例如<code>${dataimporter.functions.escapeSql(item.ID)}</code>.它只需要一个参数,并且这个值必须是在<code>VaraiableResolver</code>中合法的.</p>
<h3 id="encodeUrl">encodeUrl</h3><p>使用这个可以编码URL地址.比如:<code>${dataimporter.functions.encodeUrl(item.ID)}</code>.它只需要一个参数,并且这个值必须是在<code>VaraiableResolver</code>中合法的.</p>
<h2 id="自定义识别器">自定义识别器</h2><p>在DIH中提供了插件机制来自定义函数.只要实现<a href="http://lucene.apache.org/solr/api/org/apache/solr/handler/dataimport/Evaluator.html" target="_blank" rel="external">Evaluator</a>接口,并且把它配置在<code>data-config.xml</code>中即可.下面的例子展示了如果定义一个转换字符串为小写的识别器.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataConfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">function</span> <span class="attribute">name</span>=<span class="value">"toLowerCase"</span> <span class="attribute">class</span>=<span class="value">"foo.LowerCaseFunctionEvaluator"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">document</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entity</span> <span class="attribute">query</span>=<span class="value">"select * from table where name='$&#123;dataimporter.functions.toLowerCase(dataimporter.request.user)'"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">!-</span> <span class="attribute">......field</span> <span class="attribute">declarations......-</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实现类是:<code>LowerCaseFunctionEvaluator</code><br>以下代码基于Solr4.1的基础修改:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LowerCaseFunctionEvaluator</span> <span class="keyword">extends</span> <span class="title">Evaluator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">evaluate</span><span class="params">(String expression, Context context)</span> </span>&#123;</span><br><span class="line">      List&lt;Object&gt; l = parseParams(expression, context.getVariableResolver());</span><br><span class="line">      <span class="keyword">if</span> (l.size() != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"'toLowerCase' must have only one parameter "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> l.get(<span class="number">0</span>).toString().toLowerCase(Locale.ROOT);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>像<code>decode</code> <code>load</code> <code>run</code>等函数可以帮助我们使用复杂SQL语句</p>
<h3 id="访问请求参数">访问请求参数</h3><p>当使用DIH时,所有的HTTP请求参数都会发送给Solr.这时你能使用<code>${dataimporter.request.command}</code>命名空间来访问请求中的命令是什么.</p>
<h1 id="交互开发模式">交互开发模式</h1><p>要开启这个模式,需要在DIH的UI界面上把<code>Debug Mode</code>按钮滑向右边.它会在HTML文本区中显示当前你DIH的配置,并且你能修改它.在配置的下面有一个名为<code>Raw Debug-Response</code>的区域,它包含了你点击在屏幕左边的<code>Execute with this Configuration</code>蓝色按钮后从DIH得到的响应.</p>
<p>一些注意事项:</p>
<ul>
<li>你可以在115至118(?)配置启动和行参数来调试文档.</li>
<li>选择<code>verbose</code>下拉选项来获取中间步骤的详细的信息.执行了什么查询,什么被转换器进行了处理,输出是什么.</li>
<li>如果在运行过程中发生异常,错误堆栈信息会显示在这里</li>
<li>一些实体提供的字段,如果这些字段没有在schema.xml中显示的被<code>field</code>标签声明,那么转换器可能不能在文档中访问它们.</li>
</ul>
<h1 id="调度(Scheduling)">调度(Scheduling)</h1><ul>
<li>DataImportScheduler</li>
<li>版本: 1.2</li>
<li>最后修订时间: 20.09.2010.</li>
<li>作者: Marko Bonaci</li>
<li>Jira: <a href="http://issues.apache.org/jira/browse/SOLR-2305" target="_blank" rel="external">http://issues.apache.org/jira/browse/SOLR-2305</a></li>
<li>Download JAR: <a href="http://code.google.com/p/solr-data-import-scheduler/" target="_blank" rel="external">http://code.google.com/p/solr-data-import-scheduler/</a></li>
<li>允许调度DIH的增量和全导入</li>
<li>发送HTTP Post请求给Solr服务器</li>
<li>需要进一步的完善</li>
<li>在Tomcat6中完成测试</li>
<li>还没有提交到trunk中</li>
<li>计划在Solr4.1中提供</li>
</ul>
<p>TODO:</p>
<ul>
<li>允许用户创建多个调度任务(<code>List&lt;DataImportScheduler&gt;</code>)</li>
<li>增加取消功能(以便能在不停止应用程序和服务器的情况下,停止<code>DIHScheduler</code>的后台执行).目前,可以在<code>dataimport.properties</code>文件中把<code>syncEnabled</code>参数设置为<code>非1</code>来关闭同步执行,但是后台线程仍然的存活.并且每一次执行都要去重新加载一次properties属性文件(这样就能同步的进行热部署)</li>
<li>尽可能的使用Solr的类</li>
<li>增加<code>javadoc</code>文档</li>
</ul>
<h2 id="已具备:">已具备:</h2><ul>
<li>在DIH配置同一地方工作.</li>
<li><code>solr.home/conf/</code>文件夹下的<code>dataimport.properties</code>文件有强制属性(具体见下面例子中的dataimport.properties文件)</li>
<li>在Solr的web.xml中声明<code>ApplicationListener</code></li>
<li>在war包部署前,下载或构建jar文件放入solr.war的<code>web-inf/lib</code>文件夹中</li>
</ul>
<p>修订:</p>
<ul>
<li>v1.2:<ul>
<li>成为了<code>core-aware</code>(现在不会关心是单核心还是多核心的Solr了)</li>
<li>调度时间参数化(分钟)<br>*</li>
</ul>
</li>
<li>v1.1:<ul>
<li>现在使用<code>SolrResourceLoader</code>来获取<code>solr.home</code></li>
<li>如果响应代码不是200,那么重加载属性文件</li>
<li>使用<code>slf4j</code>来记录日志</li>
</ul>
</li>
<li>v1.0:<ul>
<li>初始化版本</li>
</ul>
</li>
</ul>
<h2 id="SolrDataImportProperties">SolrDataImportProperties</h2><ul>
<li>使用<a href="http://download.oracle.com/javase/6/docs/api/java/util/Properties.html" target="_blank" rel="external">java.util.Properties</a>来从<code>dataimport.properties</code>中加载配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.solr.handler.dataimport.scheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.solr.core.SolrResourceLoader;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolrDataImportProperties</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYNC_ENABLED         = <span class="string">"syncEnabled"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYNC_CORES           = <span class="string">"syncCores"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER               = <span class="string">"server"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PORT                 = <span class="string">"port"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WEBAPP               = <span class="string">"webapp"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAMS               = <span class="string">"params"</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INTERVAL             = <span class="string">"interval"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SolrDataImportProperties.class);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SolrDataImportProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//              loadProperties(true);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">(<span class="keyword">boolean</span> force)</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                        SolrResourceLoader loader = <span class="keyword">new</span> SolrResourceLoader(<span class="keyword">null</span>);</span><br><span class="line">                        logger.info(<span class="string">"Instance dir = "</span> + loader.getInstanceDir());</span><br><span class="line"></span><br><span class="line">                        String configDir = loader.getConfigDir();</span><br><span class="line">                        configDir = SolrResourceLoader.normalizeDir(configDir);</span><br><span class="line">                        <span class="keyword">if</span>(force || properties == <span class="keyword">null</span>)&#123;</span><br><span class="line">                                properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">                                String dataImportPropertiesPath = configDir + <span class="string">"\\dataimport.properties"</span>;</span><br><span class="line"></span><br><span class="line">                                FileInputStream fis = <span class="keyword">new</span> FileInputStream(dataImportPropertiesPath);</span><br><span class="line">                                properties.load(fis);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(FileNotFoundException fnfe)&#123;</span><br><span class="line">                        logger.error(<span class="string">"Error locating DataImportScheduler dataimport.properties file"</span>, fnfe);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException ioe)&#123;</span><br><span class="line">                        logger.error(<span class="string">"Error reading DataImportScheduler dataimport.properties file"</span>, ioe);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        logger.error(<span class="string">"Error loading DataImportScheduler properties"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> properties.getProperty(key);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ApplicationListener">ApplicationListener</h2><ul>
<li>这个类实现了<a href="http://download.oracle.com/javaee/6/api/javax/servlet/ServletContextListener.html" target="_blank" rel="external">javax.servlet.ServletContextListener</a>接口(用于监听Web应用初始化及销毁事件)</li>
<li>使用了<code>HTTPPostScheduler</code>.提供<a href="http://download.oracle.com/javase/6/docs/api/java/util/Timer.html" target="_blank" rel="external">java.util.Timer</a>和上下文属性Map方便定时方法的调用</li>
<li>计时器本质上是一个用于安排任务在后台线程执行的工具</li>
<li><p>不要忘了在Solr的<code>web.xml</code>中增加下面的监听器定义:</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="title">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.apache.solr.handler.dataimport.scheduler.ApplicationListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为了保证调度器的类能在DIH中被访问,你需要下载jar文件到你的Solr.war的<code>web-inf\lib</code>文件夹中(你可以直接在war包中增加这个文件,或者在部署后的解压文件夹中放入)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.solr.handler.dataimport.scheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ApplicationListener.class);</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">                ServletContext servletContext = servletContextEvent.getServletContext();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// get our timer from the context</span></span><br><span class="line">                Timer timer = (Timer)servletContext.getAttribute(<span class="string">"timer"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// cancel all active tasks in the timers queue</span></span><br><span class="line">                <span class="keyword">if</span> (timer != <span class="keyword">null</span>)</span><br><span class="line">                        timer.cancel();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// remove the timer from the context</span></span><br><span class="line">                servletContext.removeAttribute(<span class="string">"timer"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent servletContextEvent)</span> </span>&#123;</span><br><span class="line">                ServletContext servletContext = servletContextEvent.getServletContext();</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="comment">// create the timer and timer task objects</span></span><br><span class="line">                        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">                        HTTPPostScheduler task = <span class="keyword">new</span> HTTPPostScheduler(servletContext.getServletContextName(), timer);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// get our interval from HTTPPostScheduler</span></span><br><span class="line">                        <span class="keyword">int</span> interval = task.getIntervalInt();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// get a calendar to set the start time (first run)</span></span><br><span class="line">                        Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// set the first run to now + interval (to avoid fireing while the app/server is starting)</span></span><br><span class="line">                        calendar.add(Calendar.MINUTE, interval);</span><br><span class="line">                        Date startTime = calendar.getTime();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// schedule the task</span></span><br><span class="line">                        timer.scheduleAtFixedRate(task, startTime, <span class="number">1000</span> * <span class="number">60</span> * interval);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// save the timer in context</span></span><br><span class="line">                        servletContext.setAttribute(<span class="string">"timer"</span>, timer);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(e.getMessage().endsWith(<span class="string">"disabled"</span>))&#123;</span><br><span class="line">                                logger.info(<span class="string">"Schedule disabled"</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                logger.error(<span class="string">"Problem initializing the scheduled task: "</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HTTPPostScheduler">HTTPPostScheduler</h2><ul>
<li>这个类继承至<a href="http://download.oracle.com/javase/6/docs/api/java/util/TimerTask.html" target="_blank" rel="external">java.util.TimerTask</a>,它实现了<code>java.lang.Runnable</code></li>
<li>它表示了<code>DIHScheduler</code>的主线程</li>
<li>在适当的情况下,使用DIH参数并设置默认值</li>
<li>使用DIH的参数来组装完整的URL</li>
<li>使用HTTP POST请求URL地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.solr.handler.dataimport.scheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTTPPostScheduler</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String syncEnabled;</span><br><span class="line">        <span class="keyword">private</span> String[] syncCores;</span><br><span class="line">        <span class="keyword">private</span> String server;</span><br><span class="line">        <span class="keyword">private</span> String port;</span><br><span class="line">        <span class="keyword">private</span> String webapp;</span><br><span class="line">        <span class="keyword">private</span> String params;</span><br><span class="line">        <span class="keyword">private</span> String interval;</span><br><span class="line">        <span class="keyword">private</span> String cores;</span><br><span class="line">        <span class="keyword">private</span> SolrDataImportProperties p;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> singleCore;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HTTPPostScheduler.class);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HTTPPostScheduler</span><span class="params">(String webAppName, Timer t)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">                <span class="comment">//load properties from global dataimport.properties</span></span><br><span class="line">                p = <span class="keyword">new</span> SolrDataImportProperties();</span><br><span class="line">                reloadParams();</span><br><span class="line">                fixParams(webAppName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!syncEnabled.equals(<span class="string">"1"</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Schedule disabled"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(syncCores == <span class="keyword">null</span> || (syncCores.length == <span class="number">1</span> &amp;&amp; syncCores[<span class="number">0</span>].isEmpty()))&#123;</span><br><span class="line">                        singleCore = <span class="keyword">true</span>;</span><br><span class="line">                        logger.info(<span class="string">"&lt;index update process&gt; Single core identified in dataimport.properties"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        singleCore = <span class="keyword">false</span>;</span><br><span class="line">                        logger.info(<span class="string">"&lt;index update process&gt; Multiple cores identified in dataimport.properties. Sync active for: "</span> + cores);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reloadParams</span><span class="params">()</span></span>&#123;</span><br><span class="line">                p.loadProperties(<span class="keyword">true</span>);</span><br><span class="line">                syncEnabled = p.getProperty(SolrDataImportProperties.SYNC_ENABLED);</span><br><span class="line">                cores           = p.getProperty(SolrDataImportProperties.SYNC_CORES);</span><br><span class="line">                server          = p.getProperty(SolrDataImportProperties.SERVER);</span><br><span class="line">                port            = p.getProperty(SolrDataImportProperties.PORT);</span><br><span class="line">                webapp          = p.getProperty(SolrDataImportProperties.WEBAPP);</span><br><span class="line">                params          = p.getProperty(SolrDataImportProperties.PARAMS);</span><br><span class="line">                interval        = p.getProperty(SolrDataImportProperties.INTERVAL);</span><br><span class="line">                syncCores       = cores != <span class="keyword">null</span> ? cores.split(<span class="string">","</span>) : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixParams</span><span class="params">(String webAppName)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(server == <span class="keyword">null</span> || server.isEmpty())  server = <span class="string">"localhost"</span>;</span><br><span class="line">                <span class="keyword">if</span>(port == <span class="keyword">null</span> || port.isEmpty())              port = <span class="string">"8080"</span>;</span><br><span class="line">                <span class="keyword">if</span>(webapp == <span class="keyword">null</span> || webapp.isEmpty())  webapp = webAppName;</span><br><span class="line">                <span class="keyword">if</span>(interval == <span class="keyword">null</span> || interval.isEmpty() || getIntervalInt() &lt;= <span class="number">0</span>) interval = <span class="string">"30"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="comment">// check mandatory params</span></span><br><span class="line">                        <span class="keyword">if</span>(server.isEmpty() || webapp.isEmpty() || params == <span class="keyword">null</span> || params.isEmpty())&#123;</span><br><span class="line">                                logger.warn(<span class="string">"&lt;index update process&gt; Insuficient info provided for data import"</span>);</span><br><span class="line">                                logger.info(<span class="string">"&lt;index update process&gt; Reloading global dataimport.properties"</span>);</span><br><span class="line">                                reloadParams();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// single-core</span></span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(singleCore)&#123;</span><br><span class="line">                                prepUrlSendHttpPost();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// multi-core</span></span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(syncCores.length == <span class="number">0</span> || (syncCores.length == <span class="number">1</span> &amp;&amp; syncCores[<span class="number">0</span>].isEmpty()))&#123;</span><br><span class="line">                                logger.warn(<span class="string">"&lt;index update process&gt; No cores scheduled for data import"</span>);</span><br><span class="line">                                logger.info(<span class="string">"&lt;index update process&gt; Reloading global dataimport.properties"</span>);</span><br><span class="line">                                reloadParams();</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="keyword">for</span>(String core : syncCores)&#123;</span><br><span class="line">                                        prepUrlSendHttpPost(core);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to prepare for sendHttpPost"</span>, e);</span><br><span class="line">                        reloadParams();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepUrlSendHttpPost</span><span class="params">()</span></span>&#123;</span><br><span class="line">                String coreUrl = <span class="string">"http://"</span> + server + <span class="string">":"</span> + port + <span class="string">"/"</span> + webapp + params;</span><br><span class="line">                sendHttpPost(coreUrl, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepUrlSendHttpPost</span><span class="params">(String coreName)</span></span>&#123;</span><br><span class="line">                String coreUrl = <span class="string">"http://"</span> + server + <span class="string">":"</span> + port + <span class="string">"/"</span> + webapp + <span class="string">"/"</span> + coreName + params;</span><br><span class="line">                sendHttpPost(coreUrl, coreName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendHttpPost</span><span class="params">(String completeUrl, String coreName)</span></span>&#123;</span><br><span class="line">                DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"dd.MM.yyyy HH:mm:ss SSS"</span>);</span><br><span class="line">                Date startTime = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// prepare the core var</span></span><br><span class="line">                String core = coreName == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">"["</span> + coreName + <span class="string">"] "</span>;</span><br><span class="line"></span><br><span class="line">                logger.info(core + <span class="string">"&lt;index update process&gt; Process started at .............. "</span> + df.format(startTime));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                    URL url = <span class="keyword">new</span> URL(completeUrl);</span><br><span class="line">                    HttpURLConnection conn = (HttpURLConnection)url.openConnection();</span><br><span class="line"></span><br><span class="line">                    conn.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">                    conn.setRequestProperty(<span class="string">"type"</span>, <span class="string">"submit"</span>);</span><br><span class="line">                    conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Send HTTP POST</span></span><br><span class="line">                    conn.connect();</span><br><span class="line"></span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; Request method\t\t\t"</span> + conn.getRequestMethod());</span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; Succesfully connected to server\t"</span> + server);</span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; Using port\t\t\t"</span> + port);</span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; Application name\t\t\t"</span> + webapp);</span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; URL params\t\t\t"</span> + params);</span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; Full URL\t\t\t\t"</span> + conn.getURL());</span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; Response message\t\t\t"</span> + conn.getResponseMessage());</span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; Response code\t\t\t"</span> + conn.getResponseCode());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//listen for change in properties file if an error occurs</span></span><br><span class="line">                    <span class="keyword">if</span>(conn.getResponseCode() != <span class="number">200</span>)&#123;</span><br><span class="line">                        reloadParams();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    conn.disconnect();</span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; Disconnected from server\t\t"</span> + server);</span><br><span class="line">                    Date endTime = <span class="keyword">new</span> Date();</span><br><span class="line">                    logger.info(core + <span class="string">"&lt;index update process&gt; Process ended at ................ "</span> + df.format(endTime));</span><br><span class="line">                &#125;<span class="keyword">catch</span>(MalformedURLException mue)&#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to assemble URL for HTTP POST"</span>, mue);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(IOException ioe)&#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to connect to the specified URL while trying to send HTTP POST"</span>, ioe);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to send HTTP POST"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIntervalInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Integer.parseInt(interval);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">                        logger.warn(<span class="string">"Unable to convert 'interval' to number. Using default value (30) instead"</span>, e);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">30</span>; <span class="comment">//return default in case of error</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dataimport-properties_例子">dataimport.properties 例子</h2><ul>
<li>从下面的导入调度配置中拷贝所有的东西到你的<code>dataimport.properties</code>文件,并修改它们的参数</li>
<li>无论你是多核心还是单核心的Solr,把<code>dataimport.properties</code>文件放入你的<code>solr.home/conf</code>下(不是<code>solr.home/core/conf</code>)</li>
</ul>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#Tue Jul 21 12:10:50 CEST 2010</span></span><br><span class="line">metadataObject.last_index_time=<span class="number">2010</span>-<span class="number">09</span>-<span class="number">20</span> <span class="number">11</span>\:<span class="number">12</span>\:<span class="number">47</span></span><br><span class="line">last_index_time=<span class="number">2010</span>-<span class="number">09</span>-<span class="number">20</span> <span class="number">11</span>\:<span class="number">12</span>\:<span class="number">47</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#################################################</span></span><br><span class="line"><span class="preprocessor">#                                               #</span></span><br><span class="line"><span class="preprocessor">#       dataimport scheduler properties         #</span></span><br><span class="line"><span class="preprocessor">#                                               #</span></span><br><span class="line"><span class="preprocessor">#################################################</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#  to sync or not to sync</span></span><br><span class="line"><span class="preprocessor">#  1 - active; anything else - inactive</span></span><br><span class="line">syncEnabled=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#  which cores to schedule</span></span><br><span class="line"><span class="preprocessor">#  in a multi-core environment you can decide which cores you want syncronized</span></span><br><span class="line"><span class="preprocessor">#  leave empty or comment it out if using single-core deployment</span></span><br><span class="line">syncCores=coreHr,coreEn</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#  solr server name or IP address</span></span><br><span class="line"><span class="preprocessor">#  [defaults to localhost if empty]</span></span><br><span class="line">server=localhost</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#  solr server port</span></span><br><span class="line"><span class="preprocessor">#  [defaults to 80 if empty]</span></span><br><span class="line">port=<span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#  application name/context</span></span><br><span class="line"><span class="preprocessor">#  [defaults to current ServletContextListener's context (app) name]</span></span><br><span class="line">webapp=solrTest_WEB</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#  URL params [mandatory]</span></span><br><span class="line"><span class="preprocessor">#  remainder of URL</span></span><br><span class="line">params=/select?qt=/dataimport&amp;command=delta-import&amp;clean=<span class="literal">false</span>&amp;commit=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#  schedule interval</span></span><br><span class="line"><span class="preprocessor">#  number of minutes between two runs</span></span><br><span class="line"><span class="preprocessor">#  [defaults to 30 if empty]</span></span><br><span class="line">interval=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h1 id="哪里可以下载">哪里可以下载</h1><p><code>DataImportHandler</code>是Solr新加的功能,你可以从这找到它:</p>
<ul>
<li>从<a href="http://lucene.apache.org/solr/" target="_blank" rel="external">Solr website</a>下载每日构建版</li>
<li>然后按照全导入的例子一步一步的尝试它.</li>
</ul>
<p>对于<code>DataImportHandler</code>未来的发展和历史的讨论,你可以参见<code>Solr JIRA</code> <a href="http://issues.apache.org/jira/browse/SOLR-469" target="_blank" rel="external">SOLR-469</a> </p>
<p>请提供你的意见,建议或代码贡献来帮助我们实现新的功能</p>
<p>我们希望通过更多的例子来展示这个工具的强大.我们会不定时的更新这个文档.</p>
<h1 id="故障排除">故障排除</h1><ul>
<li><p>如果你在索引国际字符中遇到了问题,请尝试在数据源的配置中设置<code>encoding</code>属性为<code>UTF-8</code>(见上面的例子).这应该能确保你的国际字符能正确的被索引(使用UTF8).</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dataSource</span> <span class="attribute">type</span>=<span class="value">"FileDataSource"</span> <span class="attribute">encoding</span>=<span class="value">"UTF-8"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你从数据库中获取的数据不是你期望的,需要检测以下几个方面:</p>
<ol>
<li>转换器链的排查有点棘手.有些转换器可以指定<code>sourceColName</code>属性来获取数据,但是他们会把转换的结果放入<code>column</code>属性的字段中.所以后面的转换器实际上将作用于同一个没有被转换的数据.为了避免这种情况,最好是在你的sql中使用<code>AS</code>语法,而不是使用<code>sourceColName</code>:</li>
</ol>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">entity</span> <span class="attribute">name</span>=<span class="value">"transaction"</span></span><br><span class="line"> <span class="attribute">transformer</span>=<span class="value">"ClobTransformer, RegexTransformer"</span></span><br><span class="line"> <span class="attribute">query</span>=<span class="value">"SELECT CO_TRANSACTION_ID as TID_COMMON, CO_FROM_SERVICE_DT as FROM_SERVICE_DT, CO_TO_SERVICE_DT as TO_SERVICE_DT, CO_PATIENT_LAST_NM as PATIENT_LAST_NM, CO_TOTAL_CLAIM_CHARGE_AMT as TOTAL_CLAIM_CHARGE_AMT FROM TABLE(pkg_solr_import.cb_get_transactions('$&#123;document.DOCUMENT_ID&#125;'))"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"TID_COMMON"</span> <span class="attribute">splitBy</span>=<span class="value">"#"</span> <span class="attribute">clob</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"FROM_SERVICE_DT"</span> <span class="attribute">splitBy</span>=<span class="value">"#"</span> <span class="attribute">clob</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"TO_SERVICE_DT"</span> <span class="attribute">splitBy</span>=<span class="value">"#"</span> <span class="attribute">clob</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"PATIENT_LAST_NM"</span> <span class="attribute">splitBy</span>=<span class="value">"#"</span> <span class="attribute">clob</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">field</span> <span class="attribute">column</span>=<span class="value">"TOTAL_CLAIM_CHARGE_AMT"</span> <span class="attribute">splitBy</span>=<span class="value">"#"</span> <span class="attribute">clob</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另一个由转换器和<code>sourceColName</code>引起的问题是会让<code>oracle.sql.CLOB@aed3a5</code>这样的数据进入你索引数据中去.</p>
<ol>
<li>注意列名的大小写!我建议值使用大写字母.如果指定字段列为<code>FROM_SERVICE_Dt</code>,但是查询语句中的列名为<code>FROM_SERVICE_DT</code>,那么你不会看到任何的错误,但是你不会在字段中获取任何的数据!</li>
</ol>
<hr>
<p>原文链接:<a href="https://wiki.apache.org/solr/DataImportHandler" target="_blank" rel="external">https://wiki.apache.org/solr/DataImportHandler</a><br>翻译:<a href="sunxiang.cn">翔妖除魔</a><br>时间:2015-8-14 23:53:40</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Solr_数据导入Handler">Solr 数据导入Handler</h2><p>由于在我们新的全文检索引擎中使用了Solr作为底层,因此当时是想直接使用Solr提供的DataImportHandler来进行数据的导入,于是就有在它的官网上看了相关的内容,并且试着进行了翻译.虽然最后我们还是自己实现了一套数据导入,但是它的这篇文章写的确实非常的好.</p>
<h2 id="Data_Import_Request_Handler">Data Import Request Handler</h2><p>大多数系统都会把他们的数据存储在关系型数据库或者XML文件中,并且还要对这些数据进行检索.<code>DataImportHandler</code>就是Solr提供的一个工具:可以通过配置的方式驱动工具全量(<code>full builds</code>)或增量的把数据导入到Solr中.</p>
<p>除了这篇文章外,还可以参见<a href="https://wiki.apache.org/solr/DataImportHandlerFaq">DataImportHandlerFaq</a>.如果想快速开始,可以浏览<a href="https://wiki.apache.org/solr/DIHQuickStart">DIHQuickStart</a></p>
<h1 id="概况">概况</h1><h2 id="目标">目标</h2><ul>
<li>能从关系型数据库中读取数据</li>
<li>能通过配置从多个表以及列数据中构造Solr的文档(<code>Document</code>)</li>
<li>能更新上述的Solr文档</li>
<li>能根据配置提供全导入的功能</li>
<li>能检测增量的数据新增与更新,并做增量导入(我们假设存在一个最后更新时间的时间戳字段来保证增量的工作)</li>
<li>能自动的计划与调度全更新与增量更新</li>
<li>能通过配置从xml/http/file 中读取数据并创建索引</li>
<li>能提供插件机制来保证用户可以选择任何的数据源(ftp,scp等等)和格式(JSON,csv等等)进行索引工作.</li>
</ul>]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="Lucene" scheme="http://sunxiang0918.github.io/tags/Lucene/"/>
    
      <category term="Solr" scheme="http://sunxiang0918.github.io/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 2.0 新特性]]></title>
    <link href="http://sunxiang0918.github.io/2015/08/04/Swift-2-0-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://sunxiang0918.github.io/2015/08/04/Swift-2-0-新特性/</id>
    <published>2015-08-04T13:35:51.000Z</published>
    <updated>2015-09-06T03:24:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift_2-0_新特性">Swift 2.0 新特性</h1><p><code>Swift2.0</code> 算是一个大得版本更新.新增或修改了很多的特性.出来这么久了,我也把我练手写的知乎日报全部转换成了<code>Swfit2.0</code>.其中还是遇到了一些问题.因此,趁有空,就尝试总结一下<code>Swift2.0</code>的一些新特性或新的变化.</p>
<p>PS:本文写的时候采用的是 Swift2.0+Xcode7 beta4 的环境.</p>
<h2 id="1-guard语句">1.guard语句</h2><p><code>Swift2.0</code>中新引入了一个关键字<code>guard</code>用于条件的判断处理.它和<code>if</code>语句比较类似,都是通过一个<code>boolean</code>值来决定流程的走向.但是与<code>if</code>语句不同的是.<code>guard</code>语句只会有一个代码块.没有像<code>if else</code>那样有多个<code>guard else</code>.</p>
<p>那么<code>guard</code>到底有何作用呢?<code>guard</code>允许在一个代码周期中提前退出.也就是说,在<code>guard</code>关键字后接一个布尔表达式,只有当值为<code>false</code>的时候,才会执行<code>else</code>后的内容.如果值为<code>true</code>,那么就跳过这个<code>guard</code>代码块.</p>
<p><code>guard</code>语句最常见的用法就是替代<code>if</code>做参数的合法性校验.<br>比如在以前:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing</span><span class="params">(a:String?,b:String?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>	<span class="keyword">let</span> _a = a &#123;</span><br><span class="line">		<span class="keyword">if</span>	<span class="keyword">let</span> _b = b &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"<span class="subst">\(_a)</span>:<span class="subst">\(_b)</span>"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// print("\(_a):(_b)")  //这个地方不能访问_a和_b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向上面的例子那样,如果每一个参数都使用<code>if</code>语句来判断,那么这样的代码写起来非常的繁琐.读起来也不是很清晰.基于这种的情况,<code>Swift2.0</code>增加了<code>guard</code>关键字.把上面的代码改成使用<code>guard</code>的写法就会成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing2</span><span class="params">(a:String?,b:String?)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    guard <span class="keyword">let</span> _a = a <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guard <span class="keyword">let</span> _b = b <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(_a)</span>:<span class="subst">\(_b)</span>"</span>)	<span class="comment">//这个地方是可以访问_a和_b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写比起以前使用<code>if</code>来做判断,代码的可读性更强了.并且<code>Optaion</code>类型的变量的解包可以在全局可见了.这在网络编程中解析JSON等是非常有用的.</p>
<p><code>guard</code>除了用于入参的校验和可选类型的解包外.还可以用于抛出异常以及结合<code>available</code>做函数的检查:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">guard name != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">	throw <span class="type">IllegalArgumentException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard #available(iOS <span class="number">8</span>, *) <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2-协议扩展">2.协议扩展</h2><p>在之前的<code>Swift</code>中,协议(<code>Protocol</code>)其实相当于JAVA中的接口,可以定义若干的方法以及属性.然后其他的类、结构体、枚举等都继承这个协议.然后有各自的实现.而现在,在<code>Swift2.0</code>中,可以对协议进行扩展(<code>extension</code>),就和给一般的<code>Class</code>进行扩展一样.并且,同<code>JDK1.8</code>一样,现在协议允许拥有默认的<strong>方法实现</strong>了.这样就大大的增加了编程的灵活度.避免了当需要修改协议时候，需要修改全部实现该协议的类.<br>举一个例子:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申明一个协议 要求实现 说话的方法</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展协议 增加 walk 方法, 并默认实现</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">		sayHello()</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"walk"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个Lily类遵循Person协议</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lily</span> : <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//实现协议中定义的方法</span></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"hello!"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个Lily对象</span></span><br><span class="line"><span class="keyword">let</span> lily = <span class="type">Lily</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候lily类可以直接调用协议中的两个方法</span></span><br><span class="line">lily.sayHello()</span><br><span class="line">lily.walk()</span><br></pre></td></tr></table></figure>
<p>在<code>swift2.0</code>中很多的协议都被苹果公司增加了扩展. 比如<code>CollectionType</code>这个协议.所有的集合类型都遵循了这个协议,然后在<code>swift2.0</code>中增加了若干的扩展:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">map</span><span class="generics">&lt;T&gt;</span><span class="params">(@noescape transform: <span class="params">(<span class="keyword">Self</span>.Generator.Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(@noescape includeElement: <span class="params">(<span class="keyword">Self</span>.Generator.Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Self</span>.<span class="type">Generator</span>.<span class="type">Element</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> last: <span class="type">Self</span>.<span class="type">Generator</span>.<span class="type">Element</span>? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">indexOf</span><span class="params">(element: <span class="keyword">Self</span>.Generator.Element)</span></span> -&gt; <span class="type">Self</span>.<span class="type">Index</span>?</span><br></pre></td></tr></table></figure>
<p>等等.</p>
<p>这样就可以在不改变原有协议的基础上给协议增加了若干的方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">42</span>, <span class="number">45</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 1</span></span><br><span class="line"><span class="built_in">find</span>(<span class="built_in">filter</span>(<span class="built_in">map</span>(numbers, &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;), &#123; $<span class="number">0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;), <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 2</span></span><br><span class="line">numbers.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;.indexOf(<span class="number">90</span>) <span class="comment">// returns 2</span></span><br></pre></td></tr></table></figure>
<h2 id="3-Available检查">3.Available检查</h2><p>由于在苹果的生态环境中,基本上每一年都会推出新的<code>OS</code>,每年在发布会上都会说新的操作系统又新增了好多好多的<code>API</code>.好处当然是增加了很多功能,坏处也是显而易见的—-不同版本间的<code>API</code>存在兼容的问题.比如我们调用了一个<code>IOS9</code>中新增的方法,那么这个应用程序运行在了<code>IOS8</code>上,这个时候如果我们不进行系统的版本测试的话,那么我们的应用就会直接的崩溃掉,这显然不是我们所期望的.</p>
<p>为了解决这个问题,在<code>Swift2.0</code>中新引入了<code>#available</code>.配合Available检查,新的<code>Swift</code>编译器,也会在编译的时候就进行检测,当我们在低版本的OS中使用高版本的<code>API</code>的时候,编译器会直接的报错.而当编译器帮我们检测到<code>API</code>版本问题后,接下来就需要我们使用<code>#available</code>语法进行处理了.</p>
<p><code>#available</code>的使用语法是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #abailable(platform name version,...,*)&#123;</span><br><span class="line">	<span class="comment">//执行对应APIS</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">//执行之前老版本APIS</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的<code>platform name version</code>表示的是在平台的版本,允许有多个.<br>后面的* 表示的是其他平台,例如<code>Watch OS</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS9,<span class="type">OSX</span> <span class="number">10.11</span>,*)&#123;</span><br><span class="line">	<span class="comment">//使用iOS 9以上的 API接口 以及使用 OS X10.11以上的API接口</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">//使用老版本接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以使用一套代码来完成不同平台的正确编译与运行了.这对我们现在的开发有了很大的便利.</p>
<h2 id="4-defer关键字">4.defer关键字</h2><p>由于我是学<code>JAVA</code>的,所以当学习<code>Swift</code>的时候就思考过一个问题:在<code>Swift</code>中有没有类似于<code>JAVA</code>中<code>try/finally</code>的语法.也就是说无论前面的代码如何执行,在离开这个代码块之前,一定要执行一段逻辑.很遗憾的是我在<code>swift1</code>中没有发现类似的语法.而在<code>Swift2.0</code>中,Apple提供了这个功能,也就是新引入的<code>defer</code>关键字.</p>
<p><code>defer</code>关键字允许包括一个代码块.然后让这段代码块延迟到<code>defer</code>所在域的最后执行.这样说起来有第一点抽象,看一个例子就明白了.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> throws &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = open(filename)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = try file.readline() &#123;</span><br><span class="line">            <span class="comment">// Work with the file.</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        close(file) <span class="keyword">is</span> called here, at the end of the scope.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码有一个问题,那就是如果file.readline方法抛出异常的时候,那么 这段代码最后的close(file)方法可能就不会执行了,这就造成了资源的未关闭问题.</p>
<p>那么如果我们使用<code>defer</code>来修正这个问题,就会这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename: String)</span></span> throws &#123;</span><br><span class="line">    <span class="keyword">if</span> exists(filename) &#123;</span><br><span class="line">        <span class="keyword">let</span> file = open(filename)</span><br><span class="line">        defer &#123;</span><br><span class="line">            close(file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> line = try file.readline() &#123;</span><br><span class="line">            <span class="comment">// Work with the file.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中,有一个<code>defer</code>代码块.其中编写了文件关闭的逻辑. 而这段逻辑就会在整个<code>if</code>作用域的最后执行,无论是程序是正常的走出<code>if</code>,还是由于异常而跳出<code>if</code>.这样就保证了无论如何程序都会关闭文件.</p>
<p>这里有一个地方需要注意的是多个<code>defer</code>的调用顺序,如果是在不同的作用域中,那么<code>defer</code>的执行顺序是从里到外的.而如果是在同一个作用域中,<code>defer</code>的执行顺序是自下而上的.这和平时的代码调用顺序是相反的.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">aaa</span><span class="params">(a:Boolean)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"1-1"</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"1-2"</span>)</span><br><span class="line">	defer&#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"1-3"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>	a &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"2-1"</span>)</span><br><span class="line">		defer&#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"2-2"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"2-3"</span>)</span><br><span class="line">		defer&#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"2-4"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aaa(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p>上面这段代码最后打印出来的信息是:</p>
<blockquote>
<p>1-1<br>1-2<br>2-1<br>2-3<br>2-4<br>2-2<br>1-3<br>大家注意一下这个的打印顺序,体会一下就明白了.</p>
</blockquote>
<h2 id="5-异常处理">5.异常处理</h2><p>上面说完了类似于<code>JAVA</code>中的<code>try-finally</code>,下面就来说说<code>try-catch</code>.<br>在<code>Swift1</code>中是没有异常处理以及抛出异常的,如果要处理异常.大多数情况下都是使用<code>NSError</code>或者闭包回调的方式来处理的.这些方法都没法像<code>JAVA</code>中的<code>try-catch</code>一样方便简洁的处理异常.虽然现在在<code>JAVA</code>界中现在有人觉得随意的抛出异常是一种不负责任的做法,会导致程序的可读性降低,并且开始反思有没有一种更好的方式来处理异常,但就目前来说,无疑是最好的方式.</p>
<p>在<code>Swift2.0</code>中,苹果提供了<code>throws</code> <code>throw</code> <code>do</code> <code>catch</code> <code>try</code> 这几个关键字来处理异常.</p>
<ul>
<li><code>throws</code>关键字写在一个方法签名的后面,返回值前,用于标识这个方法是会抛出异常的.</li>
<li><code>throw</code>关键字用于在代码块中抛出一个异常</li>
<li><code>do</code>关键字用于包裹一个代码块,形成一个<code>do-catch</code>作用域,来捕获异常</li>
<li><code>catch</code>关键字用于捕获某种异常,并且申明异常的处理逻辑</li>
<li><code>try</code>关键字用于调用某个会抛出异常的方法前,用于标识会尝试调用这个方法</li>
</ul>
<p>例如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个异常类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">AppException</span> : <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">IllegalArgumentException</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">IllegalFormatException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个方法,可能会抛出异常</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing</span><span class="params">(age:Int)</span></span> throws -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">	<span class="comment">// 检测入参是否合法,如果不合法就抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line">		throw <span class="type">AppException</span>.<span class="type">IllegalArgumentException</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 合法 执行业务逻辑</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"age:<span class="subst">\(age)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试执行方法</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tryDoing</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		try doSomeThing(-<span class="number">1</span>)</span><br><span class="line">	&#125; catch e &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"error: <span class="subst">\(e)</span>"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先,需要定义一个异常,和<code>JAVA</code>中所有的异常都需要实现<code>Throwable</code>接口一样,在<code>Swift2</code>中异常是需要遵循<code>ErrorType</code>协议. 这里只是定义了一个异常的枚举.</li>
<li>然后定义一个方法,并用<code>throws</code>关键字来标志这个函数会抛出异常.但是这个关键字后面不需要申明到底抛出什么异常</li>
<li>接着在方法中使用<code>throw</code>抛出一个异常.这个和<code>JAVA</code>类似.</li>
<li>在调用<code>doSomeThing</code>方法的地方使用<code>do-catch</code>来捕获异常.注意的是,这个地方apple又任性了一把,没有使用其他语言中通常使用的<code>try-catch</code>.</li>
<li>在具体调用会抛出异常的方法时,使用<code>try</code>关键字来标识.这样做有一个好处,就是可以一眼就看出在一个代码域中到底是哪可能会抛出异常.而不是将所有的代码都混在<code>try-catch</code>作用域中.</li>
<li><p>在<code>do-catch</code>语法中,同<code>try-catch</code>一样,也是允许有多个<code>catch</code>代码块的.比如:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	try doSomeThing(-<span class="number">1</span>)</span><br><span class="line">&#125;catch <span class="type">AppException</span>.<span class="type">IllegalArgumentException</span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"xxx"</span>) </span><br><span class="line">&#125;catch <span class="type">AppException</span>.<span class="type">IllegalFormatException</span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"aaaa"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同可选类型的解包一样.<code>try</code>也支持<code>try!</code>的写法.用于表示在明确的知道某一个throwing的方法不会抛出异常的情况下,使用<code>try!</code>就可以不用捕捉异常了.比如:</p>
 <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try! doSomeThing(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>当然,现在<code>Swift2.0</code>中的异常捕获还有完善的地方,比如还没有区分运行时异常,非运行时异常,错误等等.但这已经是一个好的开始,期望在以后的版本中继续完善.</p>
<h2 id="6-print改变">6.print改变</h2><p>Apple已经把它的简洁的基因发挥到了极致了.居然想到了把从C语言就开始的<code>println</code>与<code>print</code>函数统一成了一个<code>func print&lt;T&gt;(value: T, appendNewline: Bool)</code>函数.第二个参数就是用于表示是否起新的一行. 默认是<code>true</code>.<br>以后学编程的第一个例子再也不是</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="7-do-while语句重命名">7.do-while语句重命名</h2><p>由于<code>do</code>关键字已经被用于了异常的捕获了.如果这个地方再使用<code>do-while</code>就有可能产生歧义.因此,apple也把这个从C语言开始就有的语法给改了名字:<code>repeat-while</code>.幸好,只是改了一个名字,还是同样的配方,还是同样的味道 ^.^</p>
<h2 id="8-重新可以使用performSelector">8.重新可以使用performSelector</h2><p><code>performSelector</code>方法在<code>Swift1</code>中被Apple认为有安全的问题而去掉了.然后,为了实现相同的功能,广大码农想了千奇百怪的办法.比如使用<code>NSThread.detachNewThreadSelector:</code>,比如<code>NSTimer.scheduledTimerWithTimeInterval:</code>,又比如<code>sendAction:</code>.<br>不过在<code>Swift2.0</code>中,Apple又在<code>NSObjectProtocol</code>协议中恢复了这个方法的调用.<br>现在可以方便的使用了</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector, withObject object: AnyObject!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;!</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector, withObject object1: AnyObject!, withObject object2: AnyObject!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;!</span><br></pre></td></tr></table></figure>
<p>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.performSelector(<span class="string">"action"</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.performSelectorInBackground(<span class="string">"action"</span>, withObject: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>注意,这个方法在<code>Playground</code>中还是不能使用哈.</p>
<h2 id="9-更强的语言结构性">9.更强的语言结构性</h2><p>由于<code>扩展协议</code>功能的出现,Apple把大量原来非面向对象的全局函数都封装到了各个协议中.让整个<code>Swift2</code>的语言结构性更强了.比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">42</span>, <span class="number">45</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 1</span></span><br><span class="line"><span class="built_in">find</span>(<span class="built_in">filter</span>(<span class="built_in">map</span>(numbers, &#123; $<span class="number">0</span> * <span class="number">2</span>&#125;), &#123; $<span class="number">0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;), <span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift 2</span></span><br><span class="line">numbers.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125;.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">3</span> == <span class="number">0</span> &#125;.indexOf(<span class="number">90</span>) <span class="comment">// returns 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift 1</span></span><br><span class="line"><span class="keyword">if</span>	<span class="built_in">contains</span>(numbers,<span class="number">6</span>) &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift 2</span></span><br><span class="line"><span class="keyword">if</span>	numbers.<span class="built_in">contains</span>(<span class="number">6</span>) &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">"success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"Swift"</span></span><br><span class="line"><span class="comment">//Swift 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="built_in">count</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift 2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = str.characters.<span class="built_in">count</span></span><br></pre></td></tr></table></figure>
<h2 id="10-枚举的递归">10.枚举的递归</h2><p>在Swift中枚举类型是非常的强大的.它不仅可以拥有自己的属性,自己的方法.还可以遵循协议.极端点来说上来说,光使用枚举和结构体,就能把一个程序写完.<br>在<code>Swift2.0</code>中枚举又得到了增强,现在可以递归的定义枚举类型了.<br>什么叫递归的枚举喃?就是在枚举定义中引用自己,看一个例子就明白了:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">indirect <span class="class"><span class="keyword">enum</span> <span class="title">Tree</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Leaf</span>(<span class="type">T</span>)</span><br><span class="line">       <span class="keyword">case</span> <span class="type">Branch</span>(<span class="keyword">left</span>: <span class="type">Tree</span>&lt;<span class="type">T</span>&gt;, <span class="keyword">right</span>: <span class="type">Tree</span>&lt;<span class="type">T</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了没,在定义Tree.Branch枚举的时候允许传入两个参数,并且这两个参数又是Tree枚举的.这就形成了枚举的递归.这样做有什么用呢?它其实扩大了枚举的使用场景.通过枚举就可以构建很复杂的数据结构和业务逻辑了.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//: 定义一个计算的协议</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Evaluate</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//: 定义一个计算表达式的枚举</span></span><br><span class="line">indirect <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> : <span class="title">Evaluate</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//表示数  </span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)</span><br><span class="line">  <span class="comment">//表示加法</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>,<span class="type">ArithmeticExpression</span>)</span><br><span class="line">  <span class="comment">//表示乘法</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>,<span class="type">ArithmeticExpression</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//实现Evaluate协议</span></span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  	<span class="comment">//进行计算</span></span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Number</span>(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Addition</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.evaluate() + <span class="keyword">right</span>.evaluate()</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Multiplication</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">left</span>.evaluate() * <span class="keyword">right</span>.evaluate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluate (3 + 8) * 3</span></span><br><span class="line"><span class="keyword">let</span> three = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> eight = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.<span class="type">Addition</span>(three, eight)</span><br><span class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.<span class="type">Multiplication</span>(sum,three)</span><br><span class="line"><span class="built_in">print</span>(product.evaluate())		<span class="comment">//这里打印结果 33</span></span><br></pre></td></tr></table></figure>
<h2 id="11-增强化的模式匹配">11.增强化的模式匹配</h2><p>在<code>Swift2.0</code>中强化了模式匹配,现在对于控制流增加了很多种组合.比如:<br><code>if/case</code> <code>while/case</code> <code>guard/case</code> <code>for-in/case</code>等等,并且上述的语法都允许像<code>switch</code>/<code>case</code>那样后面接上<code>where</code>做判断.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SignUpFormField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FirstName</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">LastName</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">EmailAddress</span>(<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">DOB</span>(<span class="type">NSDate</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift1</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">bornBeforeTaylorSwift</span><span class="params">(signUpFormField: SignUpFormField)</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> signUpFormField &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">DOB</span>(<span class="keyword">let</span> otherBday)</span><br><span class="line">        <span class="keyword">where</span> taylorSwiftsBday.compare(otherBday) == .<span class="type">OrderedDescending</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Fun fact: You were born before Taylor Swift!"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swift2</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">bornBeforeTaylorSwift</span><span class="params">(signUpFormField: SignUpFormField)</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> .<span class="type">DOB</span>(<span class="keyword">let</span> otherBday) = signUpFormField</span><br><span class="line">        <span class="keyword">where</span> taylorSwiftsBday.compare(otherBday) == .<span class="type">OrderedDescending</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Fun fact: You were born before Taylor Swift!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子说明,<code>if/case</code>的用法,它和<code>switch</code>中的<code>case</code>其实是一样的.如果满足case后的条件,那么就执行<code>if</code>中的操作.这样像上例那样只有一个分支的枚举选择,就不需要使用<code>switch</code>语句了.</p>
<p>增强的模式匹配不光是可以用在枚举类型上.对于<code>可选类型</code>的解包操作同样的奏效.比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someNumber:<span class="type">Int</span>? = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用case的方式解包</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="keyword">let</span> x? = someNumber &#123;</span><br><span class="line">	<span class="comment">//这里的x已经不是可选类型了</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"someNumber is <span class="subst">\(x)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayOfNumbers:[<span class="type">Int</span>?] = [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">nil</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">nil</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift1</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> arrayOfNumbers &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">let</span> _x = x &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"Found a number <span class="subst">\(_x)</span>"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Swift2.0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> x? <span class="keyword">in</span> arrayOfNumbers &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Found a number <span class="subst">\(x)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接一步就搞定了,比以前方便了.</p>
<h2 id="结束语">结束语</h2><p><code>Swift2.0</code>是一个大版本,有着许多优化与改动.经过这一次的改变,<code>Swift2.0</code>变得更加的友好、方便、安全,大大的增加了我们的开发体验.这里只介绍了其中的一些大点的改动,更多的API方面的变化等着我们继续的去挖掘.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift_2-0_新特性">Swift 2.0 新特性</h1><p><code>Swift2.0</code> 算是一个大得版本更新.新增或修改了很多的特性.出来这么久了,我也把我练手写的知乎日报全部转换成了<code>Swfit2.0</code>.其中还是遇到了一些问题.因此,趁有空,就尝试总结一下<code>Swift2.0</code>的一些新特性或新的变化.</p>
<p>PS:本文写的时候采用的是 Swift2.0+Xcode7 beta4 的环境.</p>
<h2 id="1-guard语句">1.guard语句</h2><p><code>Swift2.0</code>中新引入了一个关键字<code>guard</code>用于条件的判断处理.它和<code>if</code>语句比较类似,都是通过一个<code>boolean</code>值来决定流程的走向.但是与<code>if</code>语句不同的是.<code>guard</code>语句只会有一个代码块.没有像<code>if else</code>那样有多个<code>guard else</code>.</p>
<p>那么<code>guard</code>到底有何作用呢?<code>guard</code>允许在一个代码周期中提前退出.也就是说,在<code>guard</code>关键字后接一个布尔表达式,只有当值为<code>false</code>的时候,才会执行<code>else</code>后的内容.如果值为<code>true</code>,那么就跳过这个<code>guard</code>代码块.</p>
<p><code>guard</code>语句最常见的用法就是替代<code>if</code>做参数的合法性校验.<br>比如在以前:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing</span><span class="params">(a:String?,b:String?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>	<span class="keyword">let</span> _a = a &#123;</span><br><span class="line">		<span class="keyword">if</span>	<span class="keyword">let</span> _b = b &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"<span class="subst">\(_a)</span>:<span class="subst">\(_b)</span>"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// print("\(_a):(_b)")  //这个地方不能访问_a和_b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向上面的例子那样,如果每一个参数都使用<code>if</code>语句来判断,那么这样的代码写起来非常的繁琐.读起来也不是很清晰.基于这种的情况,<code>Swift2.0</code>增加了<code>guard</code>关键字.把上面的代码改成使用<code>guard</code>的写法就会成这样:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomeThing2</span><span class="params">(a:String?,b:String?)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    guard <span class="keyword">let</span> _a = a <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    guard <span class="keyword">let</span> _b = b <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(_a)</span>:<span class="subst">\(_b)</span>"</span>)	<span class="comment">//这个地方是可以访问_a和_b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写比起以前使用<code>if</code>来做判断,代码的可读性更强了.并且<code>Optaion</code>类型的变量的解包可以在全局可见了.这在网络编程中解析JSON等是非常有用的.</p>
<p><code>guard</code>除了用于入参的校验和可选类型的解包外.还可以用于抛出异常以及结合<code>available</code>做函数的检查:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">guard name != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">	throw <span class="type">IllegalArgumentException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard #available(iOS <span class="number">8</span>, *) <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[swift中多线程的使用方法]]></title>
    <link href="http://sunxiang0918.github.io/2015/08/02/swift%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://sunxiang0918.github.io/2015/08/02/swift中多线程的使用方法/</id>
    <published>2015-08-02T14:34:44.000Z</published>
    <updated>2015-08-02T14:55:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="swift中多线程的使用方法">swift中多线程的使用方法</h1><h2 id="概述">概述</h2><p>多线程可能是每一个程序开发都会遇到的问题.在swift中,苹果并没有重新开发出一套线程框架,而是继续使用ObjectiveC原有的一套线程框架.<br>目前在swift中最常用的线程方案主要有<code>NSThread</code>,<code>GCD</code>,<code>NSOperation&amp;NSOperationQueue</code>三套方案.所以,接下来会分别的描述下这些方案的使用方法以及例子.</p>
<h2 id="NSThread">NSThread</h2><p><code>NSThread</code>是苹果封装的一套完全面向对象的多线程框架.相比其他的两种方案,这种方案更轻量.你可以直接操作线程对象,很直观和方便.但是,由于<code>NSThread</code>只是一个轻量级的封装.所以需要自己管理线程的生命周期，线程同步。并且线程同步对数据的加锁会有一定的系统开销.因此这套方案使用的频率并不高.通常都是用来获取线程的信息<br><a id="more"></a></p>
<h3 id="NSThread的创建">NSThread的创建</h3><p><code>NSThread</code>主要有两种直接创建的方式:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">detachNewThreadSelector</span>(<span class="title">selector</span>: <span class="title">Selector</span>, <span class="title">toTarget</span> <span class="title">target</span>: <span class="title">AnyObject</span>, <span class="title">withObject</span> <span class="title">argument</span>: <span class="title">AnyObject</span>?)</span><br><span class="line"></span><br><span class="line"><span class="title">convenience</span> <span class="title">init</span>(<span class="title">target</span>: <span class="title">AnyObject</span>, <span class="title">selector</span>: <span class="title">Selector</span>, <span class="title">object</span> <span class="title">argument</span>: <span class="title">AnyObject</span>?)</span></span><br></pre></td></tr></table></figure>
<p>第一个方法是<code>NSThread</code>的类方法,可以直接创建并自动启动<code>NSThread</code>线程.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"action:"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>第二个方法是<code>NSThread</code>的构造函数,可以直接实例化一个<code>NSThread</code>实例,然后在需要的时候再调用<code>start()</code>方法启动线程.比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thread = <span class="type">NSThread</span>(target: <span class="keyword">self</span>, selector: <span class="string">"action:"</span>, object: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure>
<p>除了上述的两种直接创建的方式外,还有一种使用<code>NSObject</code>的方法创建并自动启动<code>NSThread</code>的方式.<br>那就是使用:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">performSelectorOnMainThread</span><span class="params">(aSelector: Selector, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector, onThread thr: NSThread, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br><span class="line"></span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">performSelectorInBackground</span><span class="params">(aSelector: Selector, withObject arg: AnyObject?)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NSObjectProtocol</span> </span>&#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(aSelector: Selector, withObject object: AnyObject!)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.performSelector(<span class="string">"action"</span>, withObject: <span class="literal">nil</span>)         <span class="keyword">self</span>.performSelectorInBackground(<span class="string">"action"</span>, withObject: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong>这种方法在<code>swift2.0</code>中,才能使用swift调用.以前苹果一直以安全为由,禁止Swift调用,只能是ObjectiveC调用.</p>
<h3 id="NSThread的其他方法">NSThread的其他方法</h3><p>除了最常用的<code>NSThread</code>创建和启动的方法外.它还内置了一些很方便的方法.使用这些方法,能完整的控制线程的操作与信息.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">currentThread</span>() -&gt; <span class="title">NSThread</span>	//获取当前线程对象</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">isMultiThreaded</span>() -&gt; <span class="title">Bool</span>		//判断是否是多线程</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">sleepUntilDate</span>(<span class="title">date</span>: <span class="title">NSDate</span>)		//休眠当前线程到某个时间</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">sleepForTimeInterval</span>(<span class="title">ti</span>: <span class="title">NSTimeInterval</span>)	//休眠当前线程<span class="title">ti</span>时间,单位是秒</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">exit</span>()		//中断当前线程</span><br><span class="line"></span><br><span class="line">//获取和设置当前线程的优先级</span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">threadPriority</span>() -&gt; <span class="title">Double</span></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">setThreadPriority</span>(<span class="title">p</span>: <span class="title">Double</span>) -&gt; <span class="title">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="title">var</span> <span class="title">name</span>: <span class="title">String</span>?		//线程的名字</span><br><span class="line"></span><br><span class="line"><span class="title">var</span> <span class="title">isMainThread</span>: <span class="title">Bool</span> </span>&#123; <span class="keyword">get</span> &#125;		<span class="comment">//是否是主线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程的执行状态</span></span><br><span class="line"><span class="keyword">var</span> executing: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> finished: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> cancelled: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span>		<span class="comment">//取消计划中的线程</span></span><br></pre></td></tr></table></figure>
<p>具体的信息可以参见苹果的<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSThread_Class/" target="_blank" rel="external">API</a></p>
<p>以上就是最简单的<code>NSThread</code>的介绍,更多复杂的使用方法,比如两个线程的同步,线程间的通信,线程的顺序执行等等,我会新开一篇文章来描述的.</p>
<h2 id="GCD">GCD</h2><p>全称<code>Grand Central Dispatch</code>.是苹果公司开发的一种多核并行运行的技术.它会更合理的使用现代多核CPU的内核.并且与<code>NSThread</code>不同的是,它能自动的管理线程的生命周期,不再需要我们来关心了,我们只需要关心线程的执行内容就可以了.</p>
<h3 id="设计">设计</h3><p><code>GCD</code>的工作原理是让程序多个平行队列的任务,根据可使用的处理资源,安排他们在任何当前可用的处理器内核上执行.<br>从这里就可以看出,<code>GCD</code>引入了两个非常重要的概念,那就是<code>队列</code>以及<code>任务</code>.<br><strong>任务:</strong>即需要执行的动作.也就是<code>Task</code>.在GCD中是一个<code>Block</code>中文称为<code>闭包</code>.它封装了一段代码用来表示这个线程要干什么.<br><strong>队列:</strong>用于存放任务的一个池子.<code>GCD</code>会不断的从队列中取未执行的任务,然后执行.在<code>GCD</code>中队列分为了<code>同步队列</code>和<code>异步队列</code>.他们的区别主要是在于在执行过程中会不会阻塞当前的线程,直到<code>Block</code>中的任务执行完毕.而不管是<code>同步队列</code>还是<code>异步队列</code>,GCD都是采用<code>FIFO</code>先进先出的方式来一个一个的取任务的.只是异步队列会把每一个取出来的任务放入一个新的线程中执行,然后马上又去取下一个任务.需要注意的是,异步队列能同时执行的任务是有限制的,GCD会根据系统资源自动的控制并行执行的数量,并不会把所有的任务都马上执行.</p>
<h3 id="创建">创建</h3><p>在swift中队列的创建可以使用<code>dispatch_queue_create</code>函数.<br>它的方法签名是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_queue_create</span><span class="params">(label: UnsafePointer&lt;Int8&gt;, <span class="number">_</span> attr: dispatch_queue_attr_t!)</span></span> -&gt; dispatch_queue_t!</span><br></pre></td></tr></table></figure>
<p>第一个参数是队列的标志.第二个参数是队列的属性,如果是同步队列那么就传入<code>DISPATCH_QUEUE_SERIAL</code>或者<code>nil</code>,如果是异步队列那么就传入<code>DISPATCH_QUEUE_CONCURRENT</code><br>比如:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#21516;&#27493;&#38431;&#21015;&#10;let serialQueue = dispatch_queue_create(&#34;testSerialQueue&#34;, nil);&#10;let serialQueue2 = dispatch_queue_create(&#34;testSerialQueue2&#34;, DISPATCH_QUEUE_SERIAL)&#10;//&#24322;&#27493;&#38431;&#21015;&#10;let concurrentQueue = dispatch_queue_create(&#34;test concurrentQueue&#34;, DISPATCH_QUEUE_CONCURRENT)</span><br></pre></td></tr></table></figure>
<p>除了上述的手动创建队列外,GCD中还内置了两个全局的队列.</p>
<ul>
<li><p>一个是<code>主队列</code>,这是一个特殊的<code>同步队列</code>.主要是用来在UI上执行一些变化操作的.</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue()</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个是<strong>全局的异步队列</strong>,这个是系统预先提供的一个异步队列.我们可以直接使用.</p>
  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="执行">执行</h3><p>队列创建好了后,就可以开始执行任务了.<br>对应同步和异步两种,可以分别调用<code>dispatch_sync</code>和<code>dispatch_async</code> 来执行任务.</p>
<p>它们的方法签名是:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_sync</span><span class="params">(queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_async</span><span class="params">(queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个参数就是创建的任务队列. 第二个参数就是表示任务的闭包.这个闭包通常都是<code>()-&gt;Void</code>的.</p>
<p>在调用这两个方法的时候,一定要有<code>任务</code>和<code>队列</code>的概念.一定要牢记在同一个队列中的任务必须一个一个的执行完毕然后才执行下一个.</p>
<p>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"before sync"</span>)</span><br><span class="line">dispatch_sync(mainQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in sync"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after sync"</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码在只会在控制台打印一句<code>before sync</code>.出现这种情况的原因在于调用了主队列用作了同步任务的执行线程. 那么在调用<code>dispatch_sync</code>方法的时候,这个方法会阻塞当前线程直到闭包执行完毕,而当前线程又正好是主线程.因此就会出现一种死锁的情况:在主线程的执行主队列同步任务,会把主线程先阻塞了,然后等待主线程的闭包任务完成.要解决这个问题也很简单,就是把任务的执行队列改为新生成的一个队列<code>let queue = dispatch_queue_create(&quot;1231&quot;, nil)</code>而不是使用主队列即可.</p>
<p>同样的,执行同步任务的嵌套也有可能会出现死锁的情况:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"before sync1"</span>)</span><br><span class="line">dispatch_sync(queue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in sync1"</span>)</span><br><span class="line">    dispatch_sync(queue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"in sync2"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after sync1"</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码也只会在控制台打印出<code>before sync1</code>,<code>print(&quot;in sync1&quot;)</code> 两句.原因同样是因为在sync1中调用<code>dispatch_sync</code>会把queue队列线程给阻塞了.然后等待<code>sync2</code>在queue队列线程上执行完毕,这样就造成了死锁.</p>
<h3 id="组执行">组执行</h3><p>在<code>GCD</code>中还可以把一些任务添加到一个任务组里去.这样就能实现监听一组任务是否完成.然后完成后通知执行其他的操作.</p>
<p>组操作的方法签名:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务组</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_group_create</span><span class="params">()</span></span> -&gt; dispatch_group_t!</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步执行任务组</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_group_async</span><span class="params">(group: dispatch_group_t, <span class="number">_</span> queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务组完成后的通知</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_group_notify</span><span class="params">(group: dispatch_group_t, <span class="number">_</span> queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步等待线程组执行完成</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_group_wait</span><span class="params">(group: dispatch_group_t, <span class="number">_</span> timeout: dispatch_time_t)</span></span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure>
<p>线程组的执行<strong>没有同步的方式</strong>,只有异步的方式.其实也很好理解,如果是同步的方式也就不存在线程组的通知了,反正都是顺序执行的.</p>
<p>下面是线程组调用的例子:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = dispatch_group_create()</span><br><span class="line"><span class="keyword">let</span> asyncQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, asyncQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">NSThread</span>.currentThread())</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in async1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, asyncQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">NSThread</span>.currentThread())</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in async2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, asyncQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="type">NSThread</span>.currentThread())</span><br><span class="line">    <span class="type">NSThread</span>.sleepForTimeInterval(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in async3"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, asyncQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"finfish group execute"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行完<code>async1</code> <code>async2</code> <code>async3</code> 后,会执行<code>notify</code>中的任务</p>
<h3 id="Barrier执行">Barrier执行</h3><p>在GCD中还提供了两个阻塞队列执行的方法.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_barrier_async</span><span class="params">(queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">dispatch_barrier_sync</span><span class="params">(queue: dispatch_queue_t, <span class="number">_</span> block: dispatch_block_t)</span></span></span><br></pre></td></tr></table></figure>
<p>这两个方法体现了队列的<code>FIFO</code>先进先出的原则:当它前面的任务执行结束后它才会执行,而且在它后面的任务要等它执行了后再执行.换句话说,这个方法会阻塞这个queue队列(注意是阻塞队列的任务,而不是阻塞当前线程),等到这个队列中排在它之前的任务全部执行完成后,再执行自己的任务.而后取消任务的阻塞.使这个队列中后面的任务继续异步或同步的执行.需要注意的是,如果传入的队列类型不是<code>DISPATCH_QUEUE_CONCURRENT</code>,那么这个方法和普通的<code>dispatch_async</code>或<code>dispatch_sync</code>没区别.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_queue_create(<span class="string">"a concurrent queue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async1"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async2"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(concurrentQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"barrier_async"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_async(concurrentQueue) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"async3"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NSOperation&amp;NSOperationQueue">NSOperation&amp;NSOperationQueue</h2><p><code>NSOperation</code>是苹果公司在GCD之上推出的一个多线程框架,是对GCD的操作做了一层封装.它面向对象的提供了对象的操作,这对我们使用起来更好的理解了.特别是从<code>JAVA</code> <code>.NET</code>这些纯粹面向对象的语言转过来的,更容易使用了.</p>
<p>既然是对<code>GCD</code>的封装,那么GCD中最重要的两个概念<code>任务</code>与<code>队列</code>.同样在这套方案中是有实现的.</p>
<ul>
<li>任务对应的是<code>NSOperation</code>,即要执行的任务封装到一个<code>NSOperation</code>实例中.</li>
<li>队列对应的是<code>NSOperationQueue</code>,即执行的任务会添加到一个<code>NSOperationQueue</code>实例中.</li>
</ul>
<h3 id="创建任务">创建任务</h3><p>由于<code>NSOperation</code>是一个抽象类,因此创建任务主要由两种方式:</p>
<ol>
<li>实例化它的子类<code>NSBlockOperation</code>.然后调用<code>start()</code>启动任务.它会默认在<strong>当前队列</strong>中<strong>同步执行</strong>.</li>
<li>继承<code>NSOperation</code>,自己写实现. 其实如果熟悉JAVA的人,就能发现<code>NSOperation</code>和JAVA中的<code>Runnable</code>接口非常的类似,和<code>Runnable</code>接口的<code>run()</code>方法类似,<code>NSOperation</code>类也有一个<code>main</code>方法被设计用来扩展的.只要继承至这个类,然后重写<code>main</code>方法就可以了.</li>
</ol>
<p>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="keyword">let</span> operation = <span class="type">NSBlockOperation</span> &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in blockOperation"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加执行的闭包</span></span><br><span class="line">operation.addExecutionBlock &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"in addExecutionBlock"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始任务</span></span><br><span class="line">operation.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种继承的方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">customOperation</span>:<span class="title">NSOperation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"in customOperation"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化任务</span></span><br><span class="line"><span class="keyword">let</span> custom = customOperation()</span><br><span class="line"><span class="comment">//开始任务</span></span><br><span class="line">custom.start()</span><br></pre></td></tr></table></figure>
<p>另外对于NSBlockOperation任务,除了在初始化的时候可以传入一个闭包外.还可以在<code>start</code>方法前,调用<code>func addExecutionBlock(block: () -&gt; Void)</code>来增加执行的闭包.这些增加的闭包,会在调用<code>start</code>方法时,<strong>并发</strong>的执行</p>
<p>除此之外,<code>NSOperation</code>可以通过调用<code>func addDependency(op: NSOperation)</code>和<code>func removeDependency(op: NSOperation)</code>增加或删除依赖.只有<strong>所有依赖的对象都已经完成操作</strong>，当前<code>NSOperation</code>对象才会开<strong>始执行操作</strong>。这样就能控制并发线程执行下的任务顺序</p>
<h3 id="创建队列">创建队列</h3><p><code>NSOperationQueue</code>是用来创建执行队列的. 因为在默认的情况下<code>NSOperation</code>的<code>start()</code>方法会在<code>当前线程</code> <code>同步执行</code>的,也就是说会阻塞当前线程执行任务. 要想在其他线程中执行任务的话,这就需要使用<code>NSOperationQueue</code>了.</p>
<p>创建执行队列的方法也很简单,就是调用<code>NSOperationQueue</code>的构造函数初始化一个<code>NSOperationQueue</code>实例即可.<br>初始化以后,直接调用<code>func addOperation(op: NSOperation)</code>即可添加和自动执行任务了.<br>比如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> custom = customOperation()</span><br><span class="line"><span class="comment">//custom.start()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> operationQueue = <span class="type">NSOperationQueue</span>()</span><br><span class="line"></span><br><span class="line">operationQueue.addOperation(custom)</span><br></pre></td></tr></table></figure>
<p>需要注意的是,如果把上面的注释去掉,那么程序就会报错:<code>operation is finished and cannot be enqueued</code>.也就是说执行过一次的任务就不能再一次加入到operationQueue中了.</p>
<p>另外一个需要注意的地方就是:<code>NSOperationQueue</code>是不区分同步还是异步队列的.它默认都是异步的.你只要设置最大并发数<code>maxConcurrentOperationCount</code>就可以了.如果你设置成<strong>1</strong>,那自然就是同步执行的了.</p>
<h2 id="总结">总结</h2><p>以上就是Swift中多线程的基本用法,掌握这些知识对于开发一个高性能的应用非常重要.<br>更多的信息可以参考下<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html" target="_blank" rel="external">官方文档</a>.<br>而更多的用法我会另开文章来说明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="swift中多线程的使用方法">swift中多线程的使用方法</h1><h2 id="概述">概述</h2><p>多线程可能是每一个程序开发都会遇到的问题.在swift中,苹果并没有重新开发出一套线程框架,而是继续使用ObjectiveC原有的一套线程框架.<br>目前在swift中最常用的线程方案主要有<code>NSThread</code>,<code>GCD</code>,<code>NSOperation&amp;NSOperationQueue</code>三套方案.所以,接下来会分别的描述下这些方案的使用方法以及例子.</p>
<h2 id="NSThread">NSThread</h2><p><code>NSThread</code>是苹果封装的一套完全面向对象的多线程框架.相比其他的两种方案,这种方案更轻量.你可以直接操作线程对象,很直观和方便.但是,由于<code>NSThread</code>只是一个轻量级的封装.所以需要自己管理线程的生命周期，线程同步。并且线程同步对数据的加锁会有一定的系统开销.因此这套方案使用的频率并不高.通常都是用来获取线程的信息<br>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>Swift局部SCOPE]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/29/Swift%E5%B1%80%E9%83%A8SCOPE/"/>
    <id>http://sunxiang0918.github.io/2015/07/29/Swift局部SCOPE/</id>
    <published>2015-07-29T02:06:40.000Z</published>
    <updated>2015-07-29T03:02:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="局部SCOPE">局部SCOPE</h1><p>C 系语言中在方法内部我们是可以任意添加成对的大括号 {} 来限定代码的作用范围的。这么做一般来说有两个好处，首先是超过作用域后里面的临时变量就将失效，这不仅可以使方法内的命名更加容易，也使得那些不被需要的引用的回收提前进行了，可以稍微提高一些代码的效率；另外，在合适的位置插入括号也利于方法的梳理，对于那些不太方便提取为一个单独方法，但是又应该和当前方法内的其他部分进行一些区分的代码，使用大括号可以将这样的结构进行一个相对自然的划分。</p>
<p>举一个不失一般性的例子，虽然我个人不太喜欢使用代码手写 UI，但钟情于这么做的人还是不在少数。如果我们要在 Objective-C 中用代码构建 UI 的话，我们一般会选择在 -loadView 里写一些类似这样的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *titleLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    titleLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    titleLabel<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">    [view addSubview:titleLabel];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    textLabel<span class="variable">.text</span> = <span class="string">@"Text"</span>;</span><br><span class="line">    [view addSubview:textLabel];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>在这里只添加了两个 view，就已经够让人心烦的了。真实的界面当然会比这个复杂很多，想想看如果有十来个 view 的话，这段代码会变成什么样子吧。我们需要考虑对各个子 view 的命名，以确保它们的意义明确。如果我们在上面的代码中把某个配置 textLabel 的代码写错成了 titleLabel 的话，编译器也不会给我们任何警告。这种 bug 是非常难以发现的，因此在类似这种一大堆代码但是又不太可能进行重用的时候，我更推荐使用局部 scope 将它们分隔开来。比如上面的代码建议加上括号重写为以下形式，这样至少编译器会提醒我们一些低级错误，我们也可能更专注于每个代码块：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>)];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UILabel</span> *titleLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">                initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">        titleLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">        titleLabel<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">        [view addSubview:titleLabel];    </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">                initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">        textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">        textLabel<span class="variable">.text</span> = <span class="string">@"Text"</span>;</span><br><span class="line">        [view addSubview:textLabel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，直接使用大括号的写法是不支持的，因为这和闭包的定义产生了冲突。如果我们想类似地使用局部 scope 来分隔代码的话，一个不错的选择是定义一个接受 ()-&gt;() 作为函数的全局方法，然后执行它：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">local</span><span class="params">(closure: <span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用时，可以利用尾随闭包的特性模拟局部 scope：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">loadView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> view = <span class="type">UIView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>))</span><br><span class="line"></span><br><span class="line">    local &#123;</span><br><span class="line">        <span class="keyword">let</span> titleLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>))</span><br><span class="line">        titleLabel.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">        titleLabel.text = <span class="string">"Title"</span></span><br><span class="line">        view.addSubview(titleLabel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    local &#123;</span><br><span class="line">        <span class="keyword">let</span> textLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>))</span><br><span class="line">        textLabel.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">        textLabel.text = <span class="string">"Text"</span></span><br><span class="line">        view.addSubview(textLabel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.view = view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Objective-C 中还有一个很棒的技巧是使用 GNU C 的<a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs" target="_blank" rel="external">声明扩展</a>来在限制局部作用域的时候同时进行赋值，运用得当的话，可以使代码更加紧凑和整洁。比如上面的 titleLabel 如果我们需要保留一个引用的话，在 Objective-C 中可以写为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.titleLabel</span> = (&#123;</span><br><span class="line">    <span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    label<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    label<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">    [view addSubview:label];</span><br><span class="line">    label;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Swift 里当然没有 GNU C 的扩展，但是使用匿名的闭包的话，写出类似的代码也不是难事：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">titleLabel = &#123;</span><br><span class="line">    <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame: <span class="type">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>))</span><br><span class="line">    label.textColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line">    label.text = <span class="string">"Title"</span></span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(label)</span><br><span class="line">    <span class="keyword">return</span> label</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>这也是一种隔离代码的很好的方式。</p>
<hr>
<p>原文链接:<a href="http://swifter.tips/local-scope/" target="_blank" rel="external">http://swifter.tips/local-scope/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="局部SCOPE">局部SCOPE</h1><p>C 系语言中在方法内部我们是可以任意添加成对的大括号 {} 来限定代码的作用范围的。这么做一般来说有两个好处，首先是超过作用域后里面的临时变量就将失效，这不仅可以使方法内的命名更加容易，也使得那些不被需要的引用的回收提前进行了，可以稍微提高一些代码的效率；另外，在合适的位置插入括号也利于方法的梳理，对于那些不太方便提取为一个单独方法，但是又应该和当前方法内的其他部分进行一些区分的代码，使用大括号可以将这样的结构进行一个相对自然的划分。</p>
<p>举一个不失一般性的例子，虽然我个人不太喜欢使用代码手写 UI，但钟情于这么做的人还是不在少数。如果我们要在 Objective-C 中用代码构建 UI 的话，我们一般会选择在 -loadView 里写一些类似这样的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)loadView &#123;</span><br><span class="line">    <span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">320</span>, <span class="number">480</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *titleLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    titleLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    titleLabel<span class="variable">.text</span> = <span class="string">@"Title"</span>;</span><br><span class="line">    [view addSubview:titleLabel];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UILabel</span> *textLabel = [[<span class="built_in">UILabel</span> alloc] </span><br><span class="line">            initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">150</span>, <span class="number">80</span>, <span class="number">20</span>, <span class="number">40</span>)];</span><br><span class="line">    textLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    textLabel<span class="variable">.text</span> = <span class="string">@"Text"</span>;</span><br><span class="line">    [view addSubview:textLabel];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.view</span> = view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<翻译>Swift2.0中字符串的设计]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/29/Swift2-0%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://sunxiang0918.github.io/2015/07/29/Swift2-0中字符串的设计/</id>
    <published>2015-07-28T16:19:28.000Z</published>
    <updated>2015-07-28T16:22:27.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Swift2-0中字符串的设计">Swift2.0中字符串的设计</h1><p>Swift中提供了一个高性能的,兼容Unicode的字符串实现作为其标准库中的一部分.在Swift2中,<code>String</code>类型不再实现<code>CollectionType</code>协议.在以前<code>String</code>字符串是一个由<code>Character</code>字符组成的集合,其表现类似于一个数组.而现在,<code>String</code>则是提供了一个<code>characters</code>属性用来暴露字符集合.</p>
<p>为什么会有这样的变化呢?尽管把字符串当做一个字符的集合看起来更自然.但是其实<code>String</code>字符串类型的操作与<code>Array</code>,<code>Set</code>或者<code>Dictionary</code>等集合一直都是完全不同的.但自从Swift2增加了协议扩展后,针对这些差异有必要进行一些根本性的变化了.</p>
<a id="more"></a>
<h2 id="Different_Than_the_Sum_of_Its_Parts">Different Than the Sum of Its Parts</h2><h4 id="每一个部分和的不同计算">每一个部分和的不同计算</h4><p>当你给一个集合增加一个元素的时候,你期望的是这个集合将包含这个元素.换句话说,当你给一个数组增加一个值后,这个数组将会包含这个值.这同样适用于<code>Set</code>和<code>Dictionary</code>.但是,当你给字符串增加一个组合标记字符(<em>combining mark character</em>)的时候,这个字符串内容本身会发生变化.</p>
<p>比如以字符串<code>cafe</code>为例,它由<code>c</code>,<code>a</code>,<code>f</code>,<code>e</code>四个字符组成:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> letters: [<span class="type">Character</span>] = [<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"f"</span>, <span class="string">"e"</span>]</span><br><span class="line"><span class="keyword">var</span> string: <span class="type">String</span> = <span class="type">String</span>(letters)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(letters.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">print</span>(string) <span class="comment">// cafe</span></span><br><span class="line"><span class="built_in">print</span>(string.characters.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>这个时候如果你给字符串增加一个组合重音字符<code>U+0301</code>也就是<code>´</code>.这个字符串仍然只有四个字符,但是最后一个字符现在变成了<code>é</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> acuteAccent: <span class="type">Character</span> = <span class="string">"\u&#123;0301&#125;"</span> <span class="comment">// ´ COMBINING ACUTE ACCENT' (U+0301)</span></span><br><span class="line"></span><br><span class="line">string.append(acuteAccent)</span><br><span class="line"><span class="built_in">print</span>(string.characters.<span class="built_in">count</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">print</span>(string.characters.last!) <span class="comment">// é</span></span><br></pre></td></tr></table></figure>
<p>这个时候,这个字符串的<code>characters</code>属性中并没有包含原来的小写字符<code>e</code>,并且也没有包含新加的组合重音字符<code>´</code>.相反的,现在字符串包含了加上了重音符的小写字符<code>é</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string.characters.<span class="built_in">contains</span>(<span class="string">"e"</span>) <span class="comment">// false</span></span><br><span class="line">string.characters.<span class="built_in">contains</span>(<span class="string">"´"</span>) <span class="comment">// false</span></span><br><span class="line">string.characters.<span class="built_in">contains</span>(<span class="string">"é"</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果其他的集合操作也像字符串那样.那么,它们的结果就会有令人出乎意料的表现.比如把<code>UIColor.redColor()</code>和<code>UIColor.greenColor()</code>放入到一个<code>Set</code>集合中,那么这个时候集合中就应该会包含一个<code>UIColor.yellowColor()</code></p>
<h2 id="Judged_by_the_Contents_of_Its_Characters">Judged by the Contents of Its Characters</h2><h4 id="判断字符内容的相等">判断字符内容的相等</h4><p>另外一个字符串与集合不同的地方在于他们判断相等的方式.</p>
<ul>
<li>两个数组只有当他们有相同数量的元素,并且每一个相同下标的元素都相同,那么这两个数组才相等.</li>
<li>两个Set只有当他们有相同数量的元素,并且在一个Set中的所有元素都在第二个Set中都存在,那么这两个Set才相等.</li>
<li>两个Dictonary只有当他们有相同的<code>Key</code>和<code>Value</code>Set,那么这两个字典才相等.</li>
</ul>
<p>但是,<code>String</code>字符串的相等是基于一种<em>规则相等(canonically equivalent)</em>的方式.当字符拥有相同的语义和表现的时候,我们就认为字符是<em>规则相等</em>的.这个时候,两个字符背后的<code>Unicode</code>有可能是不一样的.</p>
<p>比如朝鲜的文字系统,它是由24个字母,<em>Jamo</em>,元音以及辅音组成的.当我们写字的时候会把这些元素进行组合.比如,字<code>가</code>([ga])是由两个字符<code>ᄀ</code>([g])和<code>ᅡ</code>([a])组成.这在Swift中,无论两个字符串是由分解的字符或者是由预组合的字符序列组成的.只要他们的语义和表现是相同的,那么就认为它们是相同的:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decomposed = <span class="string">"\u&#123;1100&#125;\u&#123;1161&#125;"</span> <span class="comment">// ᄀ + ᅡ</span></span><br><span class="line"><span class="keyword">let</span> precomposed = <span class="string">"\u&#123;AC00&#125;"</span> <span class="comment">// 가</span></span><br><span class="line"></span><br><span class="line">decomposed == precomposed <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这再次说明,字符串的这种行为与Swift中其他的集合类型是完全不同的.否则如果一个数组中有<code>🐟</code>和<code>🍚</code>两个值,那么他们就是被认为是与<code>🍣</code>相等的.</p>
<h2 id="Depends_on_Your_Point_of_View">Depends on Your Point of View</h2><h4 id="选择何种表现取决于你的使用">选择何种表现取决于你的使用</h4><p>字符串并不是一个集合,但是它确实又提供了一些与<code>CollectionType</code>协议相同的表现</p>
<ul>
<li><code>characters</code>是一个<code>Character</code>字符值或扩展字元簇(<em><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html" target="_blank" rel="external">extended grapheme clusters</a></em>)的集合.</li>
<li><code>unicodeScalars</code> 是一个Unicode纯量(<em><a href="http://www.unicode.org/glossary/#unicode_scalar_value" target="_blank" rel="external">Unicode scalar values</a></em>)的集合</li>
<li><code>uft8</code> 是一个UTF-8字符集编码的集合</li>
<li><code>uft16</code> 是一个UTF-16字符集编码的集合</li>
</ul>
<p>如果我们把前面<code>café</code>这个例子中的[c,a,f,e]和[´]这几个字符,用字符串中的这几个属性来表示.那么他们就应该是如下表所示:<br><img src="/img/2015/07/29/1.png" alt=""></p>
<ul>
<li><code>characters</code>属性表示的是扩展字元簇.它与用户所直观看到的字符是相近的(由c,a,f,é四个字符组成).这是因为一个字符串必须能迭代整个串中的每一个位置(每一个位置都被成为一个代码点(<em>code point</em>)),以便能在<code>O(n)</code>时间复杂度上执行存取该属性的操作,并获取字符串的边界.当处理一个包含了人类可读的文字或者高度地域敏感的Unicode编码算法,比如用作<code>localizedStandardCompare(_:)</code>方法的入参或者<code>localizedLowercaseString</code>属性的值的时候,应该使用这种逐个字符的处理方式.</li>
<li><code>unicodeScalars</code>属性暴露了字符串中基本Unicode纯量的存储.当一个原始的字符串是由预组合字符(<em> precomposed character</em>)<code>é</code>组成,而不是由分解成的两个字符<code>e</code>+<code>´</code>组成,那么你应该更倾向于使用这个API来进行更底层的字符串数据的操作.</li>
<li><code>utf8</code>和<code>utf16</code>属性分别被用来提供UTF-8与UTF-16的代码点的操作.这些值通常被用于在写入真正的文件系统的时候转换成某些特定的编码.UTF-8编码通常被用作许多POSIX字符串API的处理.而UTF-16则是更多的用于<code>Cocoa&amp;Cocoa Touch</code>框架,以计算字符串的长度与偏移量.</li>
</ul>
<p>有关如何在Swift中使用字符串以及字符的更多信息,可以阅读<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285" target="_blank" rel="external">The Swift Programming Language</a>和<a href="https://developer.apple.com/library/prerelease/ios//documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/swift/struct/s:SS" target="_blank" rel="external">Swift Standard Library Reference</a>.</p>
<hr>
<p>原文链接:<a href="https://developer.apple.com/swift/blog/?id=30" target="_blank" rel="external">Strings in Swift 2</a><br>翻译:<a href="http://sunxiang0918.github.io/">翔妖除魔</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Swift2-0中字符串的设计">Swift2.0中字符串的设计</h1><p>Swift中提供了一个高性能的,兼容Unicode的字符串实现作为其标准库中的一部分.在Swift2中,<code>String</code>类型不再实现<code>CollectionType</code>协议.在以前<code>String</code>字符串是一个由<code>Character</code>字符组成的集合,其表现类似于一个数组.而现在,<code>String</code>则是提供了一个<code>characters</code>属性用来暴露字符集合.</p>
<p>为什么会有这样的变化呢?尽管把字符串当做一个字符的集合看起来更自然.但是其实<code>String</code>字符串类型的操作与<code>Array</code>,<code>Set</code>或者<code>Dictionary</code>等集合一直都是完全不同的.但自从Swift2增加了协议扩展后,针对这些差异有必要进行一些根本性的变化了.</p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://sunxiang0918.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Macos 通过安装Hexo 来搭建 GitHub Pages 博客系统]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/25/hello-world/"/>
    <id>http://sunxiang0918.github.io/2015/07/25/hello-world/</id>
    <published>2015-07-25T10:06:02.000Z</published>
    <updated>2015-07-25T10:06:02.000Z</updated>
    <content type="html"><![CDATA[<p>现在越来越多的人愿意使用独立的技术博客.如果自己搭建Wordpress等,需要涉及到服务器的问题.所以,很多人选择了GitHub提供的Pages来搭建个人博客,我也赶一回潮流.在MacOS 上 使用Hexo来搭建GitHubPages博客.</p>
<h2 id="Hexo">Hexo</h2><p>hexo出自台湾大学生 <a href="http://twitter.com/tommy351" target="_blank" rel="external">tommy351</a> 之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。</p>
<h3 id="安装Hexo">安装Hexo</h3><p>要安装<code>Hexo</code>需要先安装<code>Npm</code>以及<code>NodeJs</code>.<br>我在MacOS上,是使用<a href="http://brew.sh" target="_blank" rel="external">Brew</a>安装的.</p>
<ol>
<li><p>安装<strong>NodeJS</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install node</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<strong>Git</strong><br>由于我安装了XCode的,并且安装了<code>Command Line Tool</code>,因此,这一步可以省略了.否则还是在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>
<a id="more"></a>
</li>
<li><p>安装<strong>npm</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install npm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<strong>hexo</strong><br>这个就使用nodeJS的安装程序了.<br>同样在终端输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>这个步骤比较慢.因为你懂的</p>
</li>
<li><p>这个时候可以验证一下是否安装好了.<br>在终端中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    $ node -v</span><br><span class="line">v0.<span class="number">12.7</span></span><br><span class="line">$ npm -v</span><br><span class="line">    <span class="number">2.12</span>.<span class="number">1</span></span><br><span class="line">    $ hexo -v</span><br><span class="line">    hexo: <span class="number">3.1</span>.<span class="number">1</span></span><br><span class="line">os: Darwin <span class="number">14.4</span>.<span class="number">0</span> darwin x64</span><br><span class="line">http_parser: <span class="number">2.3</span></span><br><span class="line">node: <span class="number">0.12</span>.<span class="number">7</span></span><br><span class="line">v8: <span class="number">3.28</span>.<span class="number">71.19</span></span><br><span class="line">uv: <span class="number">1.6</span>.<span class="number">1</span></span><br><span class="line">zlib: <span class="number">1.2</span>.<span class="number">8</span></span><br><span class="line">modules: <span class="number">14</span></span><br><span class="line">openssl: <span class="number">1.0</span>.<span class="number">1</span>p</span><br></pre></td></tr></table></figure>
<p>这样就说明安装完成了.<br>但是如果是显示的: <code>hexo: command not found</code>. 说明环境变量没有设置.我也不知道为什么.但是只要补上环境变量就可以了.</p>
<blockquote>
<p><strong>hexo环境变量的设置:</strong> 在<code>~/</code> 用户的根目录下创建一个目录:<code>.bash_profile</code>.其中的内容为:<code>export PATH=&quot;/usr/local/Cellar/node/0.12.7/libexec/npm/lib/node_modules/hexo/bi$</code>  其中的路径就是hexo的安装路径</p>
</blockquote>
</li>
</ol>
<h3 id="使用Hexo创建博客">使用Hexo创建博客</h3><p>当安装完成后,就可以开始创建博客了.</p>
<ol>
<li><p>在本地创建博客文件夹<br>这一步的目的是在你的本地创建一个博客的文件夹.以后博客的source以及编译后的静态文件都会在这个目录中.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/</span><br><span class="line">$ mkdir blog</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>初始化博客文件夹<br>这一步是用于初始化hexo的一些文件的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    $ <span class="built_in">cd</span> ~/  </span><br><span class="line">    $ hexo init blog  </span><br><span class="line">    $ <span class="built_in">cd</span> blog  </span><br><span class="line">    $ ls  </span><br><span class="line">    _config.yml	node_modules	public		<span class="built_in">source</span></span><br><span class="line">db.json		package.json	scaffolds	themes</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化上下文</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的步骤完成后,就完成了hexo的初始化的过程了.<br>接着就可以开始关注于博客的编写了.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"新博客的名字"</span></span><br></pre></td></tr></table></figure>
<p>这样就在<code>_posts</code>文件夹里面新增加了一个<strong>md</strong>文件.直接对这一篇文档进行内容的编写就可以了.</p>
<p>而后,就在命令行中执行 <code>$ hexo generate</code> 就可以生成新的静态文件.新生成的文件全部放在<code>public</code>文件夹中的.</p>
<h3 id="使用Hexo部署博客到github">使用Hexo部署博客到github</h3><p>要使用github的pages功能的话,就需要创建一个 <code>xxxx.github.io</code>的<strong>repository</strong>. 其中<code>xxxx</code>表示的是你的github账号.这样github就会为你分配一个<code>xxxx.github.io</code>的地址.以后你的博客的访问地址也就是这个了.</p>
<p>有了这个地址以后,就要开始使用hexo部署了.<br>修改博客文件夹下的<code>_config.yml</code></p>
<p>主要是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/xxxx/xxxx.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>这个部分.<br>而后就在命令行中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>而后他就会自动的部署到你的github的pages中了.<br>如果报错说 未找到部署类型的话. 就需要安装<code>hexo-deployer-git</code></p>
<p>同样是在博客的目录中执行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="后续">后续</h3><p>这样就搭建完毕了, 后续我会慢慢的把以前记录到 evernote的东西 精选一些转过来. </p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章记录了如何使用Hexo和github搭建个人博客]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://sunxiang0918.github.io/tags/Hexo/"/>
    
      <category term="github" scheme="http://sunxiang0918.github.io/tags/github/"/>
    
      <category term="博客" scheme="http://sunxiang0918.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="其他" scheme="http://sunxiang0918.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>G1垃圾收集器入门]]></title>
    <link href="http://sunxiang0918.github.io/2015/07/23/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%85%A5%E9%97%A8/"/>
    <id>http://sunxiang0918.github.io/2015/07/23/G1垃圾收集器入门/</id>
    <published>2015-07-23T00:37:28.000Z</published>
    <updated>2015-07-28T01:52:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="G1垃圾收集器入门">G1垃圾收集器入门</h1><h2 id="说明">说明</h2><hr>
<p><strong>concurrent</strong>: 并发, 多个线程协同做同一件事情(有状态)</p>
<p><strong>parallel</strong>: 并行, 多个线程各做各的事情(互相间无共享状态)</p>
<p>参考: <a href="http://joearms.github.io/2013/04/05/concurrent-and-parallel-programming.html" target="_blank" rel="external">What’s the difference between concurrency and parallelism</a></p>
<h2 id="概述">概述</h2><h3 id="目的">目的</h3><p>本文介绍如何使用G1,及在 Hotspot JVM 中怎么使用G1垃圾收集器。 您将了解 G1 收集器的内部原理, 切换为 G1 收集器的命令行参数, 以及让其记录GC日志的选项。</p>
<h3 id="需要的时间">需要的时间</h3><p>大约 1 个小时</p>
<h3 id="简介">简介</h3><p>本文涵盖了Java虚拟机(JVM, Java Virtual Machine)中 G1 的基础知识。</p>
<ol>
<li>第一部分, 简单概述JVM的同时介绍了垃圾收集和性能.</li>
<li>接下来讲述了 Hotspot JVM 中 CMS 收集器是如何工作的.</li>
<li>接着再一步一步地指导在 Hotspot JVM 中使用G1进行垃圾回收的工作方式.</li>
<li>之后的一个小节介绍 G1 垃圾收集器可用的命令行参数.</li>
<li>最后,您将了解如何配置使G1收集器记录日志.</li>
</ol>
<h3 id="硬件与软件环境需求">硬件与软件环境需求</h3><p>下面是 硬件与软件环境需求 清单:</p>
<ul>
<li>一台PC机, 运行 Windows XP 以上操作系统, Mac OS X 或者 Linux 都可以. 注意,因为作者在Windows 7上进行开发和测试, 尚未在所有平台上完成测试。 但在 OS X和Linux 上应该也是正常的。最好配置了多核CPU.</li>
<li>Java 7 Update 9 或更高版本</li>
<li>最新的 Java 7 Demos and Samples Zip 文件</li>
</ul>
<h3 id="准备条件">准备条件</h3><p>在开始学习本教程之前, 你需要:</p>
<ul>
<li><p>下载并安装最新的 Java JDK (JDK 7 u9 或 以后的版本): Java 7 JDK 下载页面</p>
</li>
<li><p>下载并安装 Demos and Samples (示例与样例) zip 文件, 下载页面和JDK相同. 然后解压到合适的位置. 如:C:\javademos</p>
</li>
</ul>
<a id="more"></a>
<h2 id="Java_技术_和_JVM">Java 技术 和 JVM</h2><h3 id="Java_概述">Java 概述</h3><p>Java 是 Sun Microsystems 公司在1995年发布的一门编程语言. 同时也是一个运行Java程序的底层平台. 提供工具、游戏和企业应用程序支持。Java 运行在全世界超过8.5亿的PC,以及数十亿的智能设备上,包括 mobile 和 TV. Java 是由许多关键部件组成的一个整体, 统称为Java平台。</p>
<h3 id="JRE(Java_Runtime_Edition)">JRE(Java Runtime Edition)</h3><p>一般来说下载了Java以后, 你就得到了一个Java运行时: Java Runtime Environment (JRE). JRE 由Java虚拟机 Java Virtual Machine (JVM), Java 平台核心类(core classes), 以及 Java平台支持库组成. 必须有这三大组件的支持才能在你的电脑上运行 Java 程序. 例如 Java 7, 可以在操作系统上作为桌面应用程序运行, 还可以通过 Java Web Start 从Web上安装, 或者是作为嵌入式Web程序在浏览器中运行 (通过 JavaFX).</p>
<h3 id="Java_编程语言">Java 编程语言</h3><p>Java 是一门面向对象编程语言(object-oriented programming language), 包涵以下特性.</p>
<ul>
<li>Platform Independence - Java 应用程序被编译为字节码(bytecode)存放到 class 文件中, 由JVM加载. 因为程序在 JVM 中运行, 所以可以跨平台运行在各种操作系统/设备上.</li>
<li>Object-Oriented - Java 是一门面向对象的语言, 继承了 C 和 C++ 的很多特性,并在此基础上进行扩充和优化.</li>
<li>Automatic Garbage Collection - Java对内存进行 自动分配(allocates) 和自动释放(deallocates). 所以程序不再执行这一繁琐的任务(其实自动内存回收,更多的好处是减少了编程需要重复处理的这种细节,另一个例子是对JDBC的封装).</li>
<li>Rich Standard Library - Java包含大量的标准对象,可以执行诸如输入输出(input/output), 网络操作以及日期处理等任务.</li>
</ul>
<h3 id="JDK(Java_Development_Kit)">JDK(Java Development Kit)</h3><p>JDK 是用来开发Java程序的一系列工具集. 通过JDK, 你可以编译用Java语言书写的程序, 并在 JVM 中运行. 另外, JDK 还提供了打包(packaging)和分发(distributing)程序的工具.</p>
<p>JDK 和 JRE 使用同样的 Java Application Programming Interfaces (<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="external">Java API</a>).Java API 是预先打包好以供程序员用来开发程序的类库集合. 通过 Java API 使得很多常规任务可以很轻松的就完成,如 字符串操作(string manipulation), 时间日期处理(date/time processing), 网络编程(networking), 以及实现各种数据结构(data structures, 如 lists, maps, stacks, and queues).</p>
<h3 id="JVM(Java_Virtual_Machine)">JVM(Java Virtual Machine)</h3><p>Java Virtual Machine (JVM) 是一台抽象的计算机(abstract computing machine). JVM 本质是一个程序, 但在运行于JVM上的程序看来, 他就像一台真实机器一样. 这样, Java程序就能使用相同的接口和库. 每种特定操作系统上的 JVM 实现, 都将 Java 程序指令转换为本地机器的指令(instructions)和命令(commands). 由此,实现了Java程序的平台独立性.</p>
<p>Java虚拟机的第一个原型实现,由 Sun Microsystems, Inc. 完成, 在一台手持设备上用软件模拟了 Java虚拟机指令集, 类似于今天的 PDA(Personal Digital Assistant). Oracle 当前在移动设备,桌面系统和服务器上都提供了Java虚拟机实现, 但Java虚拟机不限制使用任何特定的技术,硬件,或操作系统。JVM也不一定都是基于软件的,你可以直接在硬件CPU上实现JVM指令, 还可以芯片上实现,或者采用 microcode 的方式来实现.</p>
<p>Java 虚拟机完全不关心Java语言的细节, 只识别 class 文件这种特定的二进制格式. 一个 class 文件包含 Java虚拟机指令(或称之为字节码 bytecode) 及符号变量表(symbol table), 还有一些辅助信息.</p>
<p>基于安全性考虑, Java虚拟机对 class 文件中的代码执行 强语法检查和组成结构规范限制. 既然虚拟机有这种特征, 那么任何一门编程语言,只要能编译为合法的 class 文件，都可以加载到 Java虚拟机 里面执行。由于具有通用性,跨平台特性, 其他语言的实现者可以把Java虚拟机作为该语言的加载执行工具。(1) <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-1.html" target="_blank" rel="external">The Java Virtual Machine</a></p>
<h2 id="探索_JVM_体系架构">探索 JVM 体系架构</h2><h3 id="Hotspot_架构">Hotspot 架构</h3><p>HotSpot JVM 有一个稳定强悍的架构, 支持强大的功能与特性, 具备实现高性能和大规模可伸缩性的能力。例如,HotSpot JVM JIT编译器能动态进行优化生成。换句话说,他们运行Java程序时,会针对底层系统架构动态生成高性能的本地机器指令。此外,通过成熟的演进和运行时环境的持续工程,加上多线程垃圾收集器,HotSpot JVM即使实在大型计算机系统上也能获得很高的伸缩性.</p>
<p><img src="/img/2015/07/23/01_1_JVM_Arch_CN.png" alt="HotSpot JVM: Architecture"></p>
<p>JVM 的主要组件包括: 类加载器(class loader), 运行时数据区(runtime data areas), 以及执行引擎(execution engine).</p>
<h3 id="Hotspot_关键部分">Hotspot 关键部分</h3><p>与性能(performance)有关的部分是 JVM 最重要的组件,下图中用高亮的颜色来显示.</p>
<p><img src="/img/2015/07/23/01_2_Key_Hotspot_Components_CN.png" alt=""></p>
<p>对JVM进行性能调优时有三大组件需要重点关注。堆(Heap)是存放对象的内存空间。这个区域由JVM启动时选择的垃圾收集器进行管理。大多数调优参数都是调整堆内存的大小,以及根据实际情况选择最合适的垃圾收集器. JIT编译器也对性能有很大的影响, 但新版本的JVM调优中很少需要关注.</p>
<h2 id="性能基础">性能基础</h2><p>大多数情况下对 Java 程序进行调优, 主要关注两个目标之一: 响应速度(responsiveness) 和/或 吞吐量(throughput). 下面的教程中我们将讲述这些概念.</p>
<h3 id="响应能力(Responsiveness)">响应能力(Responsiveness)</h3><p>响应能力就是程序或系统对一个请求的响应有多迅速. 比如:</p>
<ul>
<li>程序UI响应速度有多灵敏</li>
<li>网站页面响应有多快</li>
<li>数据库查询有多快<br>对响应速度要求很高的系统, 较大的停顿时间(large pause times) 是不可接受的. 重点是在非常短的时间周期内快速响应.</li>
</ul>
<h3 id="吞吐量(Throughput)">吞吐量(Throughput)</h3><p>吞吐量关注在一个特定时间段内应用系统的最大工作量。衡量吞吐量的指标/示例包括:</p>
<ul>
<li>给定时间内完成的事务数.</li>
<li>每小时批处理系统能完成的作业(jobs)数量.</li>
<li>每小时能完成多少次数据库查询</li>
</ul>
<p>在吞吐量方面优化的系统, 停顿时间长(High pause times)也是可以接受的。由于高吞吐量应用运行时间长,所以此时更关心的是如何尽可能快地完成整个任务，而不考虑快速响应。</p>
<h2 id="G1_垃圾收集器(Garbage_Collector)">G1 垃圾收集器(Garbage Collector)</h2><h3 id="G1_垃圾收集器">G1 垃圾收集器</h3><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 在Oracle JDK 7 update 4 及以上版本中得到完全支持, 专为以下应用程序设计:</p>
<ul>
<li>可以像CMS收集器一样,GC操作与应用的线程一起并发执行</li>
<li>紧凑的空闲内存区间且没有很长的GC停顿时间.</li>
<li>需要可预测的GC暂停耗时.</li>
<li>不想牺牲太多吞吐量性能.</li>
<li>启动后不需要请求更大的Java堆.</li>
</ul>
<p>G1的长期目标是取代CMS(Concurrent Mark-Sweep Collector, 并发标记-清除). 因为特性的不同使G1成为比CMS更好的解决方案. 一个区别是,G1是一款压缩型的收集器.G1通过有效的压缩完全避免了对细微空闲内存空间的分配,不用依赖于regions，这不仅大大简化了收集器，而且还消除了潜在的内存碎片问题。除压缩以外，G1的垃圾收集停顿也比CMS容易估计，也允许用户自定义所希望的停顿参数(pause targets)</p>
<h3 id="G1_操作概述">G1 操作概述</h3><p>上一代的垃圾收集器(串行serial, 并行parallel, 以及CMS)都把堆内存划分为固定大小的三个部分: 年轻代(young generation), 年老代(old generation), 以及持久代(permanent generation).</p>
<p><img src="/img/2015/07/23/02_1_HeapStructure_CN.png" alt=""></p>
<p>内存中的每个对象都存放在这三个区域中的一个.</p>
<p>而 G1 收集器采用一种不同的方式来管理堆内存.</p>
<p><img src="/img/2015/07/23/02_2_G1HeapAllocation_CN.png" alt=""></p>
<p>堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性。</p>
<p>G1执行垃圾回收的处理方式与CMS相似. G1在全局标记阶段(global marking phase)并发执行, 以确定堆内存中哪些对象是存活的。标记阶段完成后,G1就可以知道哪些heap区的empty空间最大。它会首先回收这些区,通常会得到大量的自由空间. 这也是为什么这种垃圾收集方法叫做Garbage-First(垃圾优先)的原因。顾名思义, G1将精力集中放在可能布满可收回对象的区域, 可回收对象(reclaimable objects)也就是所谓的垃圾. G1使用暂停预测模型(pause prediction model)来达到用户定义的目标暂停时间,并根据目标暂停时间来选择此次进行垃圾回收的heap区域数量.</p>
<p>被G1标记为适合回收的heap区将使用转移(evacuation)的方式进行垃圾回收. G1将一个或多个heap区域中的对象拷贝到其他的单个区域中,并在此过程中压缩和释放内存. 在多核CPU上转移是并行执行的(parallel on multi-processors), 这样能减少停顿时间并增加吞吐量. 因此,每次垃圾收集时, G1都会持续不断地减少碎片, 并且在用户给定的暂停时间内执行. 这比以前的方法强大了很多. CMS垃圾收集器(Concurrent Mark Sweep,并发标记清理)不进行压缩. ParallelOld 垃圾收集只对整个堆执行压缩,从而导致相当长的暂停时间。</p>
<p>需要强调的是, G1并不是一款实时垃圾收集器(real-time collector). 能以极高的概率在设定的目标暂停时间内完成,但不保证绝对在这个时间内完成。 基于以前收集的各种监控数据, G1会根据用户指定的目标时间来预估能回收多少个heap区. 因此,收集器有一个相当精确的heap区耗时计算模型,并根据该模型来确定在给定时间内去回收哪些heap区.</p>
<p><strong>注意 G1</strong>分为两个阶段: 并发阶段(concurrent, 与应用线程一起运行, 如: 细化 refinement、标记 marking、清理 cleanup) 和 并行阶段(parallel, 多线程执行, 如: 停止所有JVM线程, stop the world). 而 FullGC(完整垃圾收集)仍然是单线程的, 但如果进行适当的调优,则应用程序应该能够避免 full GC。</p>
<h3 id="G1_的内存占用(Footprint)">G1 的内存占用(Footprint)</h3><p>如果从 ParallelOldGC 或者 CMS收集器迁移到 G1, 您可能会看到JVM进程占用更多的内存(a larger JVM process size). 这在很大程度上与 “accounting” 数据结构有关, 如 Remembered Sets 和 Collection Sets.</p>
<p><strong>Remembered Sets</strong> 简称 RSets, 跟踪指向某个heap区内的对象引用. 堆内存中的每个区都有一个 RSet. RSet 使heap区能并行独立地进行垃圾集合. RSets的总体影响小于5%.</p>
<p><strong>Collection Sets</strong> 简称 CSets, 收集集合, 在一次GC中将执行垃圾回收的heap区. GC时在CSet中的所有存活数据(live data)都会被转移(复制/移动). 集合中的heap区可以是 Eden, survivor, 和/或 old generation. CSets所占用的JVM内存小于1%.</p>
<h3 id="推荐使用_G1_的场景(Recommended_Use_Cases)">推荐使用 G1 的场景(Recommended Use Cases)</h3><p>G1的首要目标是为需要大量内存的系统提供一个保证GC低延迟的解决方案. 也就是说堆内存在6GB及以上,稳定和可预测的暂停时间小于0.5秒.</p>
<p>如果应用程序具有如下的一个或多个特征,那么将垃圾收集器从CMS或ParallelOldGC切换到G1将会大大提升性能.</p>
<ul>
<li>Full GC 次数太频繁或者消耗时间太长.</li>
<li>对象分配的频率或代数提升(promotion)显著变化.</li>
<li>受够了太长的垃圾回收或内存整理时间(超过0.5~1秒)</li>
</ul>
<p><strong>注意: </strong>如果正在使用CMS或ParallelOldGC,而应用程序的垃圾收集停顿时间并不长,那么继续使用现在的垃圾收集器是个好主意. 使用最新的JDK时并不要求切换到G1收集器。</p>
<h2 id="CMS的GC概述">CMS的GC概述</h2><h3 id="分代GC(Generational_GC)与_CMS">分代GC(Generational GC)与 CMS</h3><p>并发标记清理(CMS, Concurrent Mark Sweep)收集器(也称为多并发低暂停的收集器)回收老年代内存(tenured generation). 它将垃圾回收中的绝大部分工作与应用程序的线程一起并发执行,以期能最小化暂停时间. 通常多并发低暂停收集器收集器不复制或也不压缩存活的对象. 垃圾回收不移动存活的对象, 如果产生内存碎片问题,就会分配/占用更大的堆内存空间。</p>
<p><strong>注意: </strong>年轻代使用的CMS收集器也和并行收集器采用一样的算法.</p>
<h3 id="CMS_垃圾收集阶段划分(Collection_Phases)">CMS 垃圾收集阶段划分(Collection Phases)</h3><p>CMS收集器在老年代堆内存的回收中执行分为以下阶段:</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1) 初始标记 (Initial Mark)</td>
<td>(Stop the World Event,所有应用线程暂停) 在老年代(old generation)中的对象, 如果从年轻代(young generation)中能访问到, 则被 “标记,marked” 为可达的(reachable).对象在旧一代“标志”可以包括这些对象可能可以从年轻一代。暂停时间一般持续时间较短,相对小的收集暂停时间.</td>
</tr>
<tr>
<td>(2) 并发标记 (Concurrent Marking)</td>
<td>在Java应用程序线程运行的同时遍历老年代(tenured generation)的可达对象图。扫描从被标记的对象开始,直到遍历完从root可达的所有对象. 调整器(mutators)在并发阶段的2、3、5阶段执行,在这些阶段中新分配的所有对象(包括被提升的对象)都立刻标记为存活状态.</td>
</tr>
<tr>
<td>(3) 再次标记(Remark)</td>
<td>(Stop the World Event, 所有应用线程暂停) 查找在并发标记阶段漏过的对象，这些对象是在并发收集器完成对象跟踪之后由应用线程更新的.</td>
</tr>
<tr>
<td>(4) 并发清理(Concurrent Sweep)</td>
<td>回收在标记阶段(marking phases)确定为不可及的对象. 死对象的回收将此对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。死对象的合并可能在此时发生. 请注意,存活的对象并没有被移动.</td>
</tr>
<tr>
<td>(5) 重置(Resetting)</td>
<td>清理数据结构,为下一个并发收集做准备.</td>
</tr>
</tbody>
</table>
<h3 id="CMS的GC步骤">CMS的GC步骤</h3><p>接下来,让我们一步步地讲述CMS收集器的操作.</p>
<h4 id="1-_CMS的堆内存结构(Heap_Structure)">1. CMS的堆内存结构(Heap Structure)</h4><p>堆内存被分为3个空间.</p>
<p><img src="/img/2015/07/23/03_1_CMS_Heap_Structure_CN.png" alt=""></p>
<p>年轻代(Young generation)分为 1个新生代空间(Eden)和2个存活区(survivor spaces). 老年代(Old generation)是一大块连续的空间, 垃圾回收(Object collection)就地解决(is done in place), 除了 Full GC, 否则不会进行压缩(compaction).</p>
<h4 id="2-_CMS年轻代(Young)_GC_的工作方式">2. CMS年轻代(Young) GC 的工作方式</h4><p>年轻代(young generation)用高亮的绿色表示, 老年代(old generation)用蓝色表示。如果程序运行了一段时间,那么 CMS 看起来就像下图这个样子. 对象散落在老年代中的各处地方.</p>
<p><img src="/img/2015/07/23/03_2_How_yong_GC_Works_CN.png" alt=""></p>
<p>在使用 CMS 时, 老年代的对象回收就地进行(deallocated in place). 他们不会被移动到其他地方. 除了 Full GC, 否则内存空间不会进行压缩.</p>
<h4 id="3-_年轻代垃圾回收(Young_Generation_Collection)">3. 年轻代垃圾回收(Young Generation Collection)</h4><p>Eden区和survivor区中的存活对象被拷贝到另一个空的survivor 区. 存活时间更长,达到阀值的对象会被提升到老年代(promoted to old generation).</p>
<p><img src="/img/2015/07/23/03_3_Yong_Generation_Collection_CN.png" alt=""></p>
<h4 id="4-_年轻代(Young)_GC_之后">4. 年轻代(Young) GC 之后</h4><p>年轻代(Young)进行一次垃圾回收之后, Eden 区被清理干净(cleared),两个 survivor 区中的一个也被清理干净了. 如下图所示:</p>
<p><img src="/img/2015/07/23/03_4_After_Young_GC_CN.png" alt=""></p>
<p>图中新提升的对象用深蓝色来标识. 绿色的部分是年轻代中存活的对象,但还没被提升到老年代中.</p>
<h4 id="5-_CMS的老年代回收(Old_Generation_Collection)">5. CMS的老年代回收(Old Generation Collection)</h4><p>两次stop the world事件发生在: 初始标记(initial mark)以及重新标记(remark)阶段. 当老年代达到一定的占有率时,CMS垃圾回收器就开始工作.</p>
<p><img src="/img/2015/07/23/03_5_Old_Generation_Collection_in_CMS_CN.png" alt=""></p>
<p>(1) 初始标记(Initial mark)阶段的停顿时间很短,在此阶段存活的(live,reachable,可及的) 对象被记下来. (2) 并发标记(Concurrent marking)在程序继续运行的同时找出存活的对象. 最后, 在第(3)阶段(remark phase), 查找在第(2)阶段(concurrent marking)中错过的对象.</p>
<h4 id="6-_老年代回收_-_并发清理(Concurrent_Sweep)">6. 老年代回收 - 并发清理(Concurrent Sweep)</h4><p>在前面阶段未被标记的对象将会就地释放(deallocated in place). 此处没有压缩(compaction).</p>
<p><img src="/img/2015/07/23/03_6_Concurrent_Sweep_CN.png" alt=""></p>
<p><strong>备注:</strong> 未标记(Unmarked)的对象 == 已死对象(Dead Objects)</p>
<h4 id="7-_老年代回收_-_清理之后(After_Sweeping)">7. 老年代回收 - 清理之后(After Sweeping)</h4><p>在第(4)步(Sweeping phase)之后, 可以看到很多内存被释放了. 还应该注意到,这里并没有执行内存压缩整理(no compaction).</p>
<p><img src="/img/2015/07/23/03_7_After_Sweeping_CN.png" alt=""></p>
<p>最后, CMS 收集器进入(move through)第(5)阶段, 重置(resetting phase), 然后等候下一次的GC阀值到来(GC threshold).</p>
<h2 id="G1垃圾收集器概述">G1垃圾收集器概述</h2><h3 id="一步步介绍G1">一步步介绍G1</h3><p>G1收集器采用一种不同的方式来分配堆. 下面通过图解的方式一步步地讲述G1系统.</p>
<h4 id="1-_G1的堆内存结构">1. G1的堆内存结构</h4><p>堆内存被划分为固定大小的多个区域.</p>
<p><img src="/img/2015/07/23/04_1_G1_Heap_Structure_CN.png" alt=""></p>
<p>每个heap区(Region)的大小在JVM启动时就确定了. JVM 通常生成 2000 个左右的heap区, 根据堆内存的总大小,区的size范围允许为 1Mb 到 32Mb.</p>
<h4 id="2-_G1_堆空间分配">2. G1 堆空间分配</h4><p>实际上,这些区域(regions)被映射为逻辑上的 Eden, Survivor, 和 old generation(老年代)空间.</p>
<p><img src="/img/2015/07/23/02_2_G1HeapAllocation_CN.png" alt=""></p>
<p>图中的颜色标识了每一个区域属于哪个角色. 存活的对象从一块区域转移(复制或移动)到另一块区域。设计成 heap 区的目的是为了并行地进行垃圾回收(的同时停止/或不停止其他应用程序线程).</p>
<p>如图所示,heap区可以分配为 Eden, Survivor, 或 old generation(老年代)区. 此外,还有第四种类型的对象被称为巨无霸区域(Humongous regions),这种巨无霸区是设计了用来保存比标准heap区大50%及以上的对象, 它们存储在一组连续的区中. 最后一个类型是堆内存中的未使用区(unused areas).</p>
<p><strong>备注:</strong> 截止英文原文发表时,巨无霸对象的回收还没有得到优化. 因此,您应该尽量避免创建太大(大于32MB?)的对象.</p>
<h4 id="3-_G1中的年轻代(Young_Generation)">3. G1中的年轻代(Young Generation)</h4><p>堆被分为大约2000个区. 最小size为1 Mb, 最大size为 32Mb. 蓝色的区保存老年代对象,绿色区域保存年轻代对象.</p>
<p><img src="/img/2015/07/23/04_3_Young_Generation_in_G1_CN.png" alt=""></p>
<p>注意G1中各代的heap区不像老一代垃圾收集器一样要求各部分是连续的.</p>
<h4 id="4-_G1中的一次年轻代GC">4. G1中的一次年轻代GC</h4><p>存活的对象被转移(copied or moved)到一个/或多个存活区(survivor regions). 如果存活时间达到阀值,这部分对象就会被提升到老年代(promoted to old generation regions).</p>
<p><img src="/img/2015/07/23/04_4_A_Young_GC_in_G1_CN.png" alt=""></p>
<p>此时会有一次 stop the world(STW)暂停. 会计算出 Eden大小和 survivor 大小,给下一次年轻代GC使用. 清单统计信息(Accounting)保存了用来辅助计算size. 诸如暂停时间目标之类的东西也会纳入考虑.</p>
<p>这种方法使得调整各代区域的尺寸很容易, 让其更大或更小一些以满足需要.</p>
<h4 id="5-_G1的一次年轻代GC完成后">5. G1的一次年轻代GC完成后</h4><p>存活对象被转移到存活区(survivor regions) 或 老年代(old generation regions).</p>
<p><img src="/img/2015/07/23/04_5_End_of_Young_GC_with_G1_CN.png" alt=""></p>
<p>刚刚被提升上来的对象用深绿色显示. Survivor 区用绿色表示.</p>
<p>总结起来,G1的年轻代收集归纳如下:</p>
<ul>
<li>堆一整块内存空间,被分为多个heap区(regions).</li>
<li>年轻代内存由一组不连续的heap区组成. 这使得在需要时很容易进行容量调整.</li>
<li>年轻代的垃圾收集,或者叫 young GCs, 会有 stop the world 事件. 在操作时所有的应用程序线程都会被暂停(stopped).</li>
<li>年轻代 GC 通过多线程并行进行.</li>
<li>存活的对象被拷贝到新的 survivor 区或者老年代.</li>
</ul>
<h3 id="Old_Generation_Collection_with_G1">Old Generation Collection with G1</h3><p>和 CMS 收集器相似, G1 收集器也被设计为用来对老年代的对象进行低延迟(low pause)的垃圾收集. 下表描述了G1收集器在老年代进行垃圾回收的各个阶段.</p>
<h4 id="G1_收集阶段_-_并发标记周期阶段(Concurrent_Marking_Cycle_Phases)">G1 收集阶段 - 并发标记周期阶段(Concurrent Marking Cycle Phases)</h4><p>G1 收集器在老年代堆内存中执行下面的这些阶段. 注意有些阶段也是年轻代垃圾收集的一部分.</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1) 初始标记(Initial Mark)</td>
<td>(Stop the World Event,所有应用线程暂停) 此时会有一次 stop the world(STW)暂停事件. 在G1中, 这附加在(piggybacked on)一次正常的年轻代GC. 标记可能有引用指向老年代对象的survivor区(根regions).</td>
</tr>
<tr>
<td>(2) 扫描根区域(Root Region Scanning)</td>
<td>扫描 survivor 区中引用到老年代的引用. 这个阶段应用程序的线程会继续运行. 在年轻代GC可能发生之前此阶段必须完成.</td>
</tr>
<tr>
<td>(3) 并发标记(Concurrent Marking)</td>
<td>在整个堆中查找活着的对象. 此阶段应用程序的线程正在运行. 此阶段可以被年轻代GC打断(interrupted).</td>
</tr>
<tr>
<td>(4) 再次标记(Remark)</td>
<td>(Stop the World Event,所有应用线程暂停) 完成堆内存中存活对象的标记. 使用一个叫做 snapshot-at-the-beginning(SATB, 起始快照)的算法, 该算法比CMS所使用的算法要快速的多.</td>
</tr>
<tr>
<td>(5) 清理(Cleanup)</td>
<td>(Stop the World Event,所有应用线程暂停,并发执行)</td>
</tr>
</tbody>
</table>
<p>在存活对象和完全空闲的区域上执行统计(accounting). (Stop the world)<br>擦写 Remembered Sets. (Stop the world)<br>重置空heap区并将他们返还给空闲列表(free list). (Concurrent, 并发)|<br>|(*) 拷贝(Copying)|    (Stop the World Event,所有应用线程暂停) 产生STW事件来转移或拷贝存活的对象到新的未使用的heap区(new unused regions). 只在年轻代发生时日志会记录为 <code>[GC pause (young)]</code>. 如果在年轻代和老年代一起执行则会被日志记录为 <code>[GC Pause (mixed)]</code>.|</p>
<h3 id="G1老年代收集步骤">G1老年代收集步骤</h3><p>顺着定义的阶段,让我们看看G1收集器如何处理老年代(old generation).</p>
<h4 id="6-_初始标记阶段(Initial_Marking_Phase)">6. 初始标记阶段(Initial Marking Phase)</h4><p>存活对象的初始标记被固定在年轻代垃圾收集里面. 在日志中被记为 GC pause (young)(inital-mark)。</p>
<p><img src="/img/2015/07/23/04_6_Initial_Marking_Phase_CN.png" alt=""></p>
<h4 id="7-_并发标记阶段(Concurrent_Marking_Phase)">7. 并发标记阶段(Concurrent Marking Phase)</h4><p>如果找到空的区域(如用红叉“X”标示的区域), 则会在 Remark 阶段立即移除. 当然,”清单(accounting)”信息决定了活跃度(liveness)的计算.</p>
<p><img src="/img/2015/07/23/04_7_Concurrent_Marking_Phase_CN.png" alt=""></p>
<h4 id="8-_再次标记阶段(Remark_Phase)">8. 再次标记阶段(Remark Phase)</h4><p>空的区域被移除并回收。现在计算所有区域的活跃度(Region liveness).</p>
<p><img src="/img/2015/07/23/04_8_Remark_Phase_CN.png" alt=""></p>
<h4 id="9-_拷贝/清理阶段(Copying/Cleanup)">9. 拷贝/清理阶段(Copying/Cleanup)</h4><p>G1选择“活跃度(liveness)”最低的区域, 这些区域可以最快的完成回收. 然后这些区域和年轻代GC在同时被垃圾收集 . 在日志被标识为 [GC pause (mixed)]. 所以年轻代和老年代都在同一时间被垃圾收集.</p>
<p><img src="/img/2015/07/23/04_9_Copying_Cleanup_Phase_CN.png" alt=""></p>
<h4 id="10-拷贝/清理之后(After_Copying/Cleanup)">10.拷贝/清理之后(After Copying/Cleanup)</h4><p>所选择的区域被收集和压缩到下图所示的深蓝色区域和深绿色区域.</p>
<p><img src="/img/2015/07/23/04_10_After_Copying_Cleanup_Phase_CN.png" alt=""></p>
<h3 id="老年代GC(Old_Generation_GC)总结">老年代GC(Old Generation GC)总结</h3><p>总结下来,G1对老年代的GC有如下几个关键点:</p>
<ul>
<li>并发标记清理阶段(Concurrent Marking Phase)<ul>
<li>活跃度信息在程序运行的时候被并行计算出来</li>
<li>活跃度(liveness)信息标识出哪些区域在转移暂停期间最适合回收.</li>
<li>不像CMS一样有清理阶段(sweeping phase).</li>
</ul>
</li>
<li>再次标记阶段(Remark Phase)<ul>
<li>使用的 Snapshot-at-the-Beginning (SATB, 开始快照) 算法比起 CMS所用的算法要快得多.</li>
<li>完全空的区域直接被回收.</li>
</ul>
</li>
<li>拷贝/清理阶段(Copying/Cleanup Phase)<ul>
<li>年轻代与老年代同时进行回收.</li>
<li>老年代的选择基于其活跃度(liveness).</li>
</ul>
</li>
</ul>
<h2 id="命令行参数与最佳实践">命令行参数与最佳实践</h2><h3 id="命令行参数与最佳实践-1">命令行参数与最佳实践</h3><p>在本节中,让我们看看G1的各种命令行选项.</p>
<h3 id="命令行基本参数">命令行基本参数</h3><p>要启用 G1 收集器请使用: <code>-XX:+UseG1GC</code></p>
<p>下面是启动 Java2Demo示例程序的命令行示例. Java2Demo位于下载 JDK demos and samples 后解压的文件夹中:</p>
<p><code>java -Xmx50m -Xms50m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar c:\javademos\demo\jfc\Java2D\Java2demo.jar</code></p>
<h3 id="关键命令行开关">关键命令行开关</h3><p><strong>-XX:+UseG1GC</strong> - 让 JVM 使用 G1 垃圾收集器.</p>
<p><strong>-XX:MaxGCPauseMillis=200</strong> - 设置最大GC停顿时间(GC pause time)指标(target). 这是一个软性指标(soft goal), JVM 会尽力去达成这个目标. 所以有时候这个目标并不能达成. 默认值为 200 毫秒.</p>
<p><strong>-XX:InitiatingHeapOccupancyPercent=45</strong> - 启动并发GC时的堆内存占用百分比. G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比例。值为 0 则表示“一直执行GC循环)’. 默认值为 45 (例如, 全部的 45% 或者使用了45%).</p>
<h3 id="最佳实践">最佳实践</h3><p>在使用 G1 作为垃圾收集器时,你应该遵循下面这些最佳实践的指导.</p>
<h4 id="不要设置年轻代的大小(Young_Generation_Size)">不要设置年轻代的大小(Young Generation Size)</h4><p>假若通过 -Xmn 显式地指定了年轻代的大小, 则会干扰到 G1收集器的默认行为.</p>
<ul>
<li>G1在垃圾收集时将不再关心暂停时间指标. 所以从本质上说,设置年轻代的大小将禁用暂停时间目标.</li>
<li>G1在必要时也不能够增加或者缩小年轻代的空间. 因为大小是固定的,所以对更改大小无能为力.</li>
</ul>
<h4 id="响应时间指标(Response_Time_Metrics)">响应时间指标(Response Time Metrics)</h4><p>设置 <code>XX:MaxGCPauseMillis=&lt;N&gt;</code> 时不应该使用平均响应时间(ART, average response time) 作为指标,而应该考虑使用目标时间的90%或者更大作为响应时间指标. 也就是说90%的用户(客户端/?)请求响应时间不会超过预设的目标值. 记住,暂停时间只是一个目标,并不能保证总是得到满足.</p>
<h4 id="什么是转移失败(Evacuation_Failure)?">什么是转移失败(Evacuation Failure)?</h4><p>对 survivors 或 promoted objects 进行GC时如果JVM的heap区不足就会发生提升失败(promotion failure). 堆内存不能继续扩充,因为已经达到最大值了. 当使用 -XX:+PrintGCDetails 时将会在GC日志中显示 <strong>to-space overflow</strong> (to-空间溢出)。</p>
<p><strong>这是很昂贵的操作!</strong></p>
<ul>
<li>GC仍继续所以空间必须被释放.</li>
<li>拷贝失败的对象必须被放到正确的位置(tenured in place).</li>
<li>CSet指向区域中的任何 RSets 更新都必须重新生成(regenerated).</li>
<li>所有这些步骤都是代价高昂的.</li>
</ul>
<h4 id="如何避免转移失败(Evacuation_Failure)">如何避免转移失败(Evacuation Failure)</h4><p>要避免避免转移失败, 考虑采纳下列选项.</p>
<ul>
<li>增加堆内存大小<ul>
<li>增加 <strong>-XX:G1ReservePercent=n</strong>, 其默认值是 10.</li>
<li>G1创建了一个假天花板(false ceiling),在需要更大 ‘to-space’ 的情况下会尝试从保留内存获取(leave the reserve memory free).</li>
</ul>
</li>
<li>更早启动标记周期(marking cycle)</li>
<li>通过采用 <strong>-XX:ConcGCThreads=n</strong> 选项增加标记线程(marking threads)的数量.</li>
</ul>
<h4 id="G1_的_GC_参数完全列表">G1 的 GC 参数完全列表</h4><p>下面是完整的 G1 的 GC 开关参数列表. 在使用时请记住上面所述的最佳实践.</p>
<table>
<thead>
<tr>
<th>选项/默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:+UseG1GC</td>
<td>使用 G1 (Garbage First) 垃圾收集器</td>
</tr>
<tr>
<td>-XX:MaxGCPauseMillis=n</td>
<td>设置最大GC停顿时间(GC pause time)指标(target). 这是一个软性指标(soft goal), JVM 会尽量去达成这个目标.</td>
</tr>
<tr>
<td>-XX:InitiatingHeapOccupancyPercent=n</td>
<td>启动并发GC周期时的堆内存占用百分比. G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示”一直执行GC循环”. 默认值为 45.</td>
</tr>
<tr>
<td>-XX:NewRatio=n</td>
<td>新生代与老生代(new/old generation)的大小比例(Ratio). 默认值为 2.</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=n</td>
<td>eden/survivor 空间大小的比例(Ratio). 默认值为 8.</td>
</tr>
<tr>
<td>-XX:MaxTenuringThreshold=n</td>
<td>提升年老代的最大临界值(tenuring threshold). 默认值为 15.</td>
</tr>
<tr>
<td>-XX:ParallelGCThreads=n</td>
<td>设置垃圾收集器在并行阶段使用的线程数,默认值随JVM运行的平台不同而不同.</td>
</tr>
<tr>
<td>-XX:ConcGCThreads=n</td>
<td>并发垃圾收集器使用的线程数量. 默认值随JVM运行的平台不同而不同.</td>
</tr>
<tr>
<td>-XX:G1ReservePercent=n</td>
<td>设置堆内存保留为假天花板的总量,以降低提升失败的可能性. 默认值是 10.</td>
</tr>
<tr>
<td>-XX:G1HeapRegionSize=n</td>
<td>使用G1时Java堆会被分为大小统一的的区(region)。此参数可以指定每个heap区的大小. 默认值将根据 heap size 算出最优解. 最小值为 1Mb, 最大值为 32Mb.</td>
</tr>
</tbody>
</table>
<h2 id="记录G1的GC日志">记录G1的GC日志</h2><h3 id="记录G1的GC日志-1">记录G1的GC日志</h3><p>我们要介绍的最后一个主题是使用日志信息来分享G1收集器的性能. 本节简要介绍垃圾收集的相关参数,以及日志中打印的相关信息.</p>
<h3 id="设置日志细节(Log_Detail)">设置日志细节(Log Detail)</h3><p>可以设置3种不同的日志级别.</p>
<p><strong>(1) -verbosegc (等价于 -XX:+PrintGC)</strong> 设置日志级别为 <strong>好</strong> <em>fine</em>.</p>
<p><strong>日志输出示例</strong></p>
<pre><code><span class="list">[<span class="keyword">GC</span> pause <span class="list">(<span class="keyword">G1</span> Humongous Allocation)</span> <span class="list">(<span class="keyword">young</span>)</span> <span class="list">(<span class="keyword">initial-mark</span>)</span> <span class="number">24</span>M- &gt;21M<span class="list">(<span class="keyword">64M</span>)</span>, <span class="number">0.2349730</span> secs]
<span class="list">[<span class="keyword">GC</span> pause <span class="list">(<span class="keyword">G1</span> Evacuation Pause)</span> <span class="list">(<span class="keyword">mixed</span>)</span> <span class="number">66</span>M-&gt;21M<span class="list">(<span class="keyword">236M</span>)</span>, <span class="number">0.1625268</span> secs]  </span></span>
</code></pre><p><strong>(2) -XX:+PrintGCDetails</strong> 设置日志级别为 <strong>更好</strong> <em>finer</em>. 使用此选项会显示以下信息:</p>
<ul>
<li>每个阶段的 Average, Min, 以及 Max 时间.</li>
<li>根扫描(Root Scan), RSet 更新(同时处理缓冲区信息), RSet扫描(Scan), 对象拷贝(Object Copy), 终止(Termination, 包括尝试次数).</li>
<li>还显示 “other” 执行时间, 比如选择 CSet, 引用处理(reference processing), 引用排队(reference enqueuing) 以及释放(freeing) CSet等.</li>
<li>显示 Eden, Survivors 以及总的 Heap 占用信息(occupancies).</li>
</ul>
<p><strong>日志输出示例</strong></p>
<pre><code><span class="list">[<span class="keyword">Ext</span> Root Scanning <span class="list">(<span class="keyword">ms</span>)</span>: Avg: <span class="number">1.7</span> Min: <span class="number">0.0</span> Max: <span class="number">3.7</span> Diff: <span class="number">3.7</span>]
<span class="list">[<span class="keyword">Eden:</span> <span class="number">818</span>M<span class="list">(<span class="keyword">818M</span>)</span>-&gt;0B<span class="list">(<span class="keyword">714M</span>)</span> Survivors: <span class="number">0</span>B-&gt;104M Heap: <span class="number">836</span>M<span class="list">(<span class="keyword">4096M</span>)</span>-&gt;409M<span class="list">(<span class="keyword">4096M</span>)</span>]</span></span>
</code></pre><p><strong>(3) -XX:+UnlockExperimentalVMOptions -XX:G1LogLevel=finest</strong> 设置日志级别为 <strong>最好</strong> <em>finest</em>. 和 finer 级别类似, 包含每个 worker 线程信息.</p>
<pre><code>[Ext Root Scanning (ms): <span class="number">2.1</span> <span class="number">2.4</span> <span class="number">2.0</span> <span class="number">0.0</span>
<span class="label">       Avg:</span> <span class="number">1.6</span> <span class="string">Min:</span> <span class="number">0.0</span> <span class="string">Max:</span> <span class="number">2.4</span> <span class="string">Diff:</span> <span class="number">2.3</span>]
   [Update RS (ms):  <span class="number">0.4</span>  <span class="number">0.2</span>  <span class="number">0.4</span>  <span class="number">0.0</span>
<span class="label">       Avg:</span> <span class="number">0.2</span> <span class="string">Min:</span> <span class="number">0.0</span> <span class="string">Max:</span> <span class="number">0.4</span> <span class="string">Diff:</span> <span class="number">0.4</span>]
       [Processed <span class="string">Buffers :</span> <span class="number">5</span> <span class="number">1</span> <span class="number">10</span> <span class="number">0</span>
<span class="label">       Sum:</span> <span class="number">16</span>, <span class="string">Avg:</span> <span class="number">4</span>, <span class="string">Min:</span> <span class="number">0</span>, <span class="string">Max:</span> <span class="number">10</span>, <span class="string">Diff:</span> <span class="number">10</span>]
</code></pre><h3 id="Determining_Time">Determining Time</h3><p>有两个参数决定了GC日志中打印的时间显示形式.</p>
<p><strong>(1) -XX:+PrintGCTimeStamps</strong> - 显示从JVM启动时算起的运行时间.</p>
<p><strong>日志输出示例</strong></p>
<pre><code>1<span class="class">.729</span>: <span class="attr_selector">[GC pause (young) 46M-&gt;35M(1332M), 0.0310029 secs]</span>
</code></pre><p><strong>(2) -XX:+PrintGCDateStamps</strong> - 在每条记录前加上日期时间.</p>
<p><strong>日志输出示例</strong></p>
<pre><code>2012<span class="tag">-05-02T11</span><span class="pseudo">:16</span><span class="pseudo">:32</span><span class="class">.057</span>+0200: <span class="attr_selector">[GC pause (young) 46M-&gt;35M(1332M), 0.0317225 secs]</span>
</code></pre><h3 id="理解_G1_日志">理解 G1 日志</h3><p>为了使你更好地理解GC日志, 本节通过实际的日志输出，定义了许多专业术语. 下面的例子显示了GC日志的内容,并加上日志中出现的术语和值的解释说明.</p>
<p><strong>Note:</strong> 更多信息请参考 <a href="https://blogs.oracle.com/poonam/entry/understanding_g1_gc_logs" target="_blank" rel="external">Poonam Bajaj的博客： G1垃圾回收日志</a>.</p>
<h3 id="G1_日志相关术语">G1 日志相关术语</h3><ul>
<li>Clear CT</li>
<li>CSet</li>
<li>External Root Scanning</li>
<li>Free CSet</li>
<li>GC Worker End</li>
<li>GC Worker Other</li>
<li>Object Copy</li>
<li>Other</li>
<li>Parallel Time</li>
<li>Ref Eng</li>
<li>Ref Proc</li>
<li>Scanning Remembered Sets</li>
<li>Termination Time</li>
<li>Update Remembered Set</li>
<li>Worker Start</li>
</ul>
<h4 id="Parallel_Time(并行阶段耗时)">Parallel Time(并行阶段耗时)</h4><pre><code><span class="number">414.557</span>: [GC pause (young), <span class="number">0.03039600</span> secs] [Parallel Time: 22.9 ms]
[GC Worker Start (ms): <span class="number">7096.0 70</span><span class="number">96.0 7096</span>.<span class="number">1 7096.1</span> <span class="number">706.1 70</span><span class="number">96.1 7096</span>.<span class="number">1 7096.1</span> <span class="number">7096.2 70</span><span class="number">96.2 7096</span>.<span class="number">2 7096.2</span>
   Avg: 7096.1, Min: 7096.0, Max: 7096.2, Diff: 0.2]
</code></pre><p><code>Parallel Time</code> – 主要并行部分运行停顿的整体时间</p>
<p><code>Worker Start</code>– 各个工作线程(workers)启动时的时间戳(Timestamp)</p>
<p><strong>Note: </strong>日志是根据 thread id 排序,并且每条记录都是一致的.</p>
<h4 id="External_Root_Scanning(外部根扫描)">External Root Scanning(外部根扫描)</h4><pre><code>[Ext Root Scanning (ms): <span class="number">3.1 3.4</span> <span class="number">3.4 3.0</span> <span class="number">4.2 2.0</span> <span class="number">3.6 3.2</span> <span class="number">3.4 7.7</span> <span class="number">3.7 4.4</span>
 Avg: 3.8, Min: 2.0, Max: 7.7, Diff: 5.7]
</code></pre><p><code>External root scanning</code> - 扫描外部根花费的时间(如指向堆内存的系统词典(system dictionary)等部分)</p>
<h4 id="Update_Remembered_Set(更新_RSet)">Update Remembered Set(更新 RSet)</h4><pre><code>[Update RS (ms): <span class="number">0.1</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> Avg: <span class="number">0.0</span>, Min: <span class="number">0.0</span>, Max: <span class="number">0.1</span>, Diff: <span class="number">0.1</span>]
[Processed Buffers : <span class="number">26</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>
Sum: <span class="number">26</span>, Avg: <span class="number">2</span>, Min: <span class="number">0</span>, Max: <span class="number">26</span>, Diff: <span class="number">26</span>]
</code></pre><p><code>Update Remembered Set</code> - 必须更新在pause之前已经完成但尚未处理的缓冲. 花费的时间取决于cards的密度。cards越多,耗费的时间就越长。</p>
<h4 id="Scanning_Remembered_Sets(扫描_RSets)">Scanning Remembered Sets(扫描 RSets)</h4><pre><code>[Scan RS (ms): <span class="number">0.4 0.2</span> <span class="number">0.1 0.3</span> <span class="number">0.0 0.0</span> <span class="number">0.1 0.2</span> <span class="number">0.0 0.1</span> <span class="number">0.0 0.0</span> Avg: 0.1, Min: 0.0, Max: 0.4, Diff: 0.3]F
</code></pre><p><code>Scanning Remembered Sets</code> - 查找指向 Collection Set 的指针(pointers)</p>
<h4 id="Object_Copy(对象拷贝)">Object Copy(对象拷贝)</h4><pre><code>[Object Copy (ms): <span class="number">16.7 16.7</span> <span class="number">16.7 16.9</span> <span class="number">16.0 18.1</span> <span class="number">16.5 16.8</span> <span class="number">16.7 12.3</span> <span class="number">16.4 15.7</span> Avg: 16.3, Min: 12.3, Max:  18.1, Diff: 5.8]
</code></pre><p><code>Object copy</code> – 每个独立的线程在拷贝和转移对象时所消耗的时间.</p>
<h4 id="Termination_Time(结束时间)">Termination Time(结束时间)</h4><pre><code>[Termination (ms): <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span>
<span class="number">0.0</span> Avg: <span class="number">0.0</span>, Min: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>] [Termination Attempts : <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> Sum: <span class="number">12</span>, Avg: <span class="number">1</span>, Min: <span class="number">1</span>, Max: <span class="number">1</span>, Diff: <span class="number">0</span>]
</code></pre><p><code>Termination time</code> - 当worker线程完成了自己那部分对象的复制和扫描,就进入终止协议(termination protocol)。它查找未完成的工作(looks for work to steal), 一旦它完成就会再进入终止协议。 终止尝试记录(Termination attempt counts)所有查找工作的尝试次数(attempts to steal work).</p>
<h4 id="GC_Worker_End">GC Worker End</h4><pre><code>[GC Worker End (ms): <span class="number">7116.4 71</span><span class="number">16.3 7116</span>.<span class="number">4 7116.3</span> <span class="number">7116.4 71</span><span class="number">16.3 7116</span>.<span class="number">4 7116.4</span> <span class="number">7116.4 71</span><span class="number">16.4 7116</span>.<span class="number">3 7116.3</span>
Avg: 7116.4, Min: 7116.3, Max: 7116.4, Diff:   0.1]
[GC Worker (ms): <span class="number">20.4 20.3</span> <span class="number">20.3 20.2</span> <span class="number">20.3 20.2</span> <span class="number">20.2 20.2</span> <span class="number">20.3 20.2</span> <span class="number">20.1 20.1</span>
 Avg: 20.2, Min: 20.1, Max: 20.4, Diff: 0.3]
</code></pre><p><code>GC worker end time</code> – 独立的 GC worker 停止时的时间戳.</p>
<p><code>GC worker time</code> – 每个独立的 GC worker 线程消耗的时间.</p>
<h4 id="GC_Worker_Other">GC Worker Other</h4><pre><code>[GC Worker Other (ms): <span class="number">2.6 2.6</span> <span class="number">2.7 2.7</span> <span class="number">2.7 2.7</span> <span class="number">2.7 2.8</span> <span class="number">2.8 2.8</span> <span class="number">2.8 2.8</span>
Avg: 2.7, Min: 2.6, Max: 2.8, Diff: 0.2]
</code></pre><p><code>GC worker other</code> – 每个GC线程中不能归属到之前列出的worker阶段的其他时间. 这个值应该很低. 过去我们见过很高的值,是由于JVM的其他部分的瓶颈引起的(例如在分层[Tiered]代码缓存[Code Cache]占有率的增加)。</p>
<h4 id="Clear_CT">Clear CT</h4><pre><code>[Clear CT: <span class="number">0.6</span> ms]
</code></pre><p>清除 RSet 扫描元数据(scanning meta-data)的 card table 消耗的时间.</p>
<h4 id="Other">Other</h4><pre><code>[Other: <span class="number">6.8</span> ms]
</code></pre><p>其他各种GC暂停的连续阶段花费的时间.</p>
<h4 id="CSet">CSet</h4><pre><code>[Choose CSet: <span class="number">0.1</span> ms]
</code></pre><p>敲定要进行垃圾回收的region集合时消耗的时间. 通常很小,在必须选择 old 区时会稍微长一点点.</p>
<h4 id="Ref_Proc">Ref Proc</h4><pre><code>[Ref Proc: <span class="number">4.4</span> ms]
</code></pre><p>处理 soft, weak, 等引用所花费的时间,不同于前面的GC阶段</p>
<h4 id="Ref_Enq">Ref Enq</h4><pre><code>[Ref Enq: <span class="number">0.1</span> ms]
</code></pre><p>将 soft, weak, 等引用放置到待处理列表(pending list)花费的时间.</p>
<h4 id="Free_CSet">Free CSet</h4><pre><code>[Free CSet: <span class="number">2.0</span> ms]
</code></pre><p>释放刚被垃圾收集的 heap区所消耗的时间,包括对应的remembered sets。</p>
<h2 id="总结">总结</h2><p>在此OBE中, 您对Java JVM 中的G1垃圾收集器有了个大致的了解。首先你学到了为何堆和垃圾收集器是所有Java JVM的关键部分。接下来讲述了使用CMS和G1收集器进行垃圾回收的工作方式. 接下来,您了解了G1的命令行参数/开关以及和使用它们的最佳实践。最后,您了解了日志对象以及GC日志中的数据。</p>
<p>在本教程中,你学到了这些知识:</p>
<ul>
<li>Java JVM 的组成部分</li>
<li>对 G1 的概述</li>
<li>概述 CMS 垃圾收集器</li>
<li>概述 G1 垃圾收集器</li>
<li>命令行参数与最佳实践</li>
<li>G1 的日志信息</li>
</ul>
<h2 id="相关资源">相关资源</h2><p>更多相关信息请参考以下网站链接.</p>
<p><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="external">HotSpot 虚拟机参数</a><br><a href="http://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html" target="_blank" rel="external">G1(垃圾优先)收集器</a><br><a href="https://blogs.oracle.com/poonam/entry/understanding_g1_gc_logs" target="_blank" rel="external">Poonam Bajaj的博客： G1垃圾回收日志</a><br><a href="http://education.oracle.com/pls/web_prod-plq-dad/db_pages.getpage?page_id=609&amp;p_org_id=1001&amp;lang=US&amp;get_params=dc:D67232GC10,p_preview:N" target="_blank" rel="external">Java SE 7: 开发富客户端应用程序</a><br><a href="http://www.amazon.cn/gp/product/B00IOB0K1Q" target="_blank" rel="external">Java性能优化权威指南 - 中文版</a><br><a href="http://www.oracle.com/oll" target="_blank" rel="external">Oracle 学习资料库</a>  </p>
<h2 id="作者信息">作者信息</h2><ul>
<li>课程开发人员: Michael J Williams</li>
<li>质量保证: Krishnanjani Chitta</li>
<li>翻译人员: <a href="http://blog.csdn.net/renfufei" target="_blank" rel="external">铁锚 http://blog.csdn.net/renfufei</a></li>
<li>参考: <a href="http://www.infoq.com/cn/news/2008/05/g1" target="_blank" rel="external">JavaOne: Garbage First</a></li>
<li>这里有一群纯技术Java程序员: <a href="http://jq.qq.com/?_wv=1027&amp;k=cXLDjh" target="_blank" rel="external">欢迎大牛和爱好者加入【Java高级交流群: 329019348】
</a></li>
<li>原文链接: <a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="external">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html</a></li>
</ul>
<hr>
<p>转帖地址:<a href="http://blog.csdn.net/renfufei/article/details/41897113" target="_blank" rel="external">http://blog.csdn.net/renfufei/article/details/41897113</a></p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章非常详细的介绍了G1垃圾收集器的相关知识]]>
    
    </summary>
    
      <category term="JAVA" scheme="http://sunxiang0918.github.io/tags/JAVA/"/>
    
      <category term="JVM" scheme="http://sunxiang0918.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MongoDB在Linux下的集群安装与配置]]></title>
    <link href="http://sunxiang0918.github.io/2015/06/29/MongoDB%E5%9C%A8Linux%E4%B8%8B%E7%9A%84%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://sunxiang0918.github.io/2015/06/29/MongoDB在Linux下的集群安装与配置/</id>
    <published>2015-06-29T13:24:24.000Z</published>
    <updated>2015-08-01T13:54:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="MongoDB在Linux下的集群安装与配置">MongoDB在Linux下的集群安装与配置</h1><h2 id="一-MongoDB集群方式">一.MongoDB集群方式</h2><p><strong>Mongodb</strong>是时下流行的NoSql数据库.它拥有三种集群的搭建方式:<code>Replica Set</code> / <code>Sharding</code> / <code>Master-Slaver</code>.   分别为 副本集方式集群, 分片集群, 主从集群.<br>三种集群搭建方式首选<code>Replica Set</code>，只有真的是大数据，Sharding才能显现威力，毕竟备节点同步数据是需要时间的。Sharding可以将多片数据集中到路由节点上进行一些对比，然后将数据返回给客户端，但是效率还是比较低的说。  </p>
<p>这里用最常用的 Replica的方式集群来做介绍</p>
<h2 id="二-Replica_Set">二.Replica Set</h2><p><code>Replica Set</code>集群当中包含了多份数据，保证主节点挂掉了，备节点能继续提供数据服务，提供的前提就是数据需要和主节点一致。如下图：<br><img src="/img/2015/06/29/1.png" alt=""></p>
<p><code>Mongodb(M)</code>表示主节点，<code>Mongodb(S)</code>表示备节点，<code>Mongodb(A)</code>表示仲裁节点。主备节点存储数据，仲裁节点不存储数据。客户端同时连接主节点与备节点，不连接仲裁节点。</p>
<p>使用的时候 可以通过配置 让M负责写,S负责读.从而达到读写分离的效果</p>
<p>仲裁节点是一种特殊的节点，它本身并<code>不存储数据</code>，主要的作用是决定哪一个备节点在主节点挂掉之后提升为主节点，所以客户端不需要连接此节点。这里虽然只有一个备节点，但是仍然需要一个仲裁节点来提升备节点级别。</p>
<a id="more"></a>
<h2 id="三-集群搭建">三.集群搭建</h2><p>我们在这里使用了两台机器来安装.<br><img src="/img/2015/06/29/2.png" alt=""></p>
<p>147和148两个作为两个Replica节点,负责数据的存储.同时这两个机器又同时作为仲裁节点负责节点的提升</p>
<ul>
<li><p>下载mongodb<br>在官网上直接下载:<a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1204-3.0.4.tgz" target="_blank" rel="external">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1204-3.0.4.tgz</a></p>
</li>
<li><p>上传到两台机器上去:  </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /Users/SUN/Downloads/mongodb-linux-x86_64-ubuntu1204-<span class="number">3.0</span>.<span class="number">4</span>.tgz root@<span class="number">172.16</span>.<span class="number">128.147</span>:~/</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压到目的地:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf mongodb-linux-x86_64-ubuntu1204-<span class="number">3.0</span>.<span class="number">4</span>.tgz -C /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改目录的名字:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv mongodb-linux-x86_64-ubuntu1204-<span class="number">3.0</span>.<span class="number">4</span>/ mongo</span><br><span class="line">cp -r mongo/ mongo2</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立数据文件夹:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir data</span><br><span class="line">mkdir data/db</span><br><span class="line">mkdir <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>建立mongodb的配置文件:</p>
</li>
<li><p>Replica Node1:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#master.conf</span></span><br><span class="line">dbpath=/mongo/data/db</span><br><span class="line">logpath=/mongo/<span class="built_in">log</span>/db.log</span><br><span class="line">pidfilepath=/mongo/db.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">replSet=testrs</span><br><span class="line"><span class="built_in">bind</span>_ip=<span class="number">172.16</span>.<span class="number">128.147</span></span><br><span class="line">port=<span class="number">27017</span></span><br><span class="line">oplogSize=<span class="number">1000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">noprealloc=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Replica Node2:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#master.conf</span></span><br><span class="line">dbpath=/mongo/data/db</span><br><span class="line">logpath=/mongo/<span class="built_in">log</span>/db.log</span><br><span class="line">pidfilepath=/mongo/db.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">replSet=testrs</span><br><span class="line"><span class="built_in">bind</span>_ip=<span class="number">172.16</span>.<span class="number">128.148</span></span><br><span class="line">port=<span class="number">27017</span></span><br><span class="line">oplogSize=<span class="number">1000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">noprealloc=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Replica arbiterNode1:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#arbiter.conf </span></span><br><span class="line">dbpath=/mongo2/data/db</span><br><span class="line">logpath=/mongo2/<span class="built_in">log</span>/db.log</span><br><span class="line">pidfilepath=/mongo2/db.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">replSet=testrs</span><br><span class="line"><span class="built_in">bind</span>_ip=<span class="number">172.16</span>.<span class="number">128.147</span></span><br><span class="line">port=<span class="number">27018</span></span><br><span class="line">oplogSize=<span class="number">1000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">noprealloc=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Replica arbiterNode2:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#arbiter.conf </span></span><br><span class="line">dbpath=/mongo2/data/db</span><br><span class="line">logpath=/mongo2/<span class="built_in">log</span>/db.log</span><br><span class="line">pidfilepath=/mongo2/db.pid</span><br><span class="line">directoryperdb=<span class="literal">true</span></span><br><span class="line">logappend=<span class="literal">true</span></span><br><span class="line">replSet=testrs</span><br><span class="line"><span class="built_in">bind</span>_ip=<span class="number">172.16</span>.<span class="number">128.148</span></span><br><span class="line">port=<span class="number">27018</span></span><br><span class="line">oplogSize=<span class="number">1000</span></span><br><span class="line">fork=<span class="literal">true</span></span><br><span class="line">noprealloc=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>参数解释：</strong><br><code>dbpath</code>：数据存放目录<br><code>logpath</code>：日志存放路径<br><code>pidfilepath</code>：进程文件，方便停止mongodb<br><code>directoryperdb</code>：为每一个数据库按照数据库名建立文件夹存放<br><code>logappend</code>：以追加的方式记录日志<br><code>replSet</code>：replica set的名字<br><code>bind_ip</code>：mongodb所绑定的ip地址<br><code>port</code>：mongodb进程所使用的端口号，默认为27017<br><code>oplogSize</code>：mongodb操作日志文件的最大大小。单位为Mb，默认为硬盘剩余空间的5%<br><code>fork</code>：以后台方式运行进程<br><code>noprealloc</code>：不预先分配存储</p>
<ul>
<li><p>设置全局的Local环境变量:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/default/locale</span><br></pre></td></tr></table></figure>
<p>  在locale文件中 加入:  <code>LC_ALL=&quot;zh_CN&quot;</code><br>  然后再执行:  </p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LC_ALL=zh_CN</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>启动mongodb:<br>  分别在三台机器上执行:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mongod <span class="operator">-f</span> ../dbconfig.conf</span><br></pre></td></tr></table></figure>
<p>  <img src="/img/2015/06/29/3.png" alt=""></p>
</li>
<li><p>完成启动:<br>  这个时候可以输入:<code>pgrep mongo -l</code>  来判断mongo服务是否启动</p>
</li>
<li><p>配置Replica Set:</p>
<p>  随便登陆任意一个mongodb:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mongo <span class="number">172.16</span>.<span class="number">128.147</span>:<span class="number">27017</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	&gt;use admin</span><br><span class="line"></span><br><span class="line">	&gt;cfg=&#123; _id:<span class="string">"testrs"</span>, members:[ &#123;_id:<span class="number">0</span>,host:<span class="string">'172.16.128.147:27017'</span>,priority:<span class="number">2</span>&#125;, &#123;_id:<span class="number">1</span>,host:<span class="string">'172.16.128.148:27017'</span>,priority:<span class="number">1</span>&#125;,   </span><br><span class="line">&#123;_id:<span class="number">2</span>,host:<span class="string">'172.16.128.147:27018'</span>,arbiterOnly:<span class="literal">true</span>&#125;,&#123;_id:<span class="number">3</span>,host:<span class="string">'172.16.128.148:27018'</span>,arbiterOnly:<span class="literal">true</span>&#125;] &#125;;</span><br><span class="line"></span><br><span class="line">	&gt;rs.initiate(cfg)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>到此,就给mongodb 指定了 <code>replica</code>模式的 集群了.</p>
<p>这个时候可以通过: <code>&gt;rs.status()</code> 命令来查看集群的状态</p>
<ul>
<li><p>配置成为ubuntu的服务:<br>  在<code>/etc/init.d/</code>目录下新建脚本文件mongodb</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/sh</span><br><span class="line"></span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:     mongodb</span></span><br><span class="line"><span class="comment"># Required-Start:</span></span><br><span class="line"><span class="comment"># Required-Stop:</span></span><br><span class="line"><span class="comment"># Default-Start:        2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:         0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: mongodb</span></span><br><span class="line"><span class="comment"># Description: mongo db server</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line">PROGRAM=/usr/<span class="built_in">local</span>/mongo/bin/mongod</span><br><span class="line">MONGOPID=`ps -ef | grep <span class="string">'mongod'</span> | grep -v grep | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$PROGRAM</span> || <span class="built_in">exit</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line">  start)</span><br><span class="line">     <span class="built_in">ulimit</span> -n <span class="number">3000</span></span><br><span class="line">     <span class="built_in">log</span>_begin_msg <span class="string">"Starting MongoDB server”</span><br><span class="line">     export LC_ALL=zh_CN</span><br><span class="line">     <span class="variable">$PROGRAM</span> -f /usr/local/mongo/dbconfig.conf</span><br><span class="line">     log_end_msg 0</span><br><span class="line">     ;;</span><br><span class="line">  stop)</span><br><span class="line">     log_begin_msg "</span>Stopping MongoDB server”</span><br><span class="line">     <span class="built_in">export</span> LC_ALL=zh_CN</span><br><span class="line">     <span class="variable">$PROGRAM</span> --dbpath /usr/<span class="built_in">local</span>/mongo/data/db --shutdown</span><br><span class="line">     <span class="built_in">log</span>_end_msg <span class="number">0</span></span><br><span class="line">     ;;</span><br><span class="line">  status)</span><br><span class="line">     ;;</span><br><span class="line">  *)</span><br><span class="line">     <span class="built_in">log</span>_success_msg <span class="string">"Usage: /etc/init.d/mongodb &#123;start|stop|status&#125;"</span></span><br><span class="line">     <span class="built_in">exit</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后给这个文件 增加运行权限 <code>chmod +x /etc/init.d/mongodb</code></p>
<p>这样就可以使用:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongodb stop</span><br><span class="line">sudo service mongodb start</span><br></pre></td></tr></table></figure>
<p>启动或停止服务了</p>
<p>如果再加一句: <code>update-rc.d mongodb defaults</code><br>那么就会 开机自启动</p>
<h2 id="四-集群测试">四.集群测试</h2><p>正常运行的时候 应该是有 两个数据节点 和两个决策节点. 其中147为主  148为辅</p>
<p>使用工具连接到mongo中去.这时显示的是:<br><img src="/img/2015/06/29/4.png" alt=""></p>
<p>然后直接kill mongo 进程:   sudo kill 1004</p>
<p>然后再连接数据库,这个时候会发现 连接变了.<br><img src="/img/2015/06/29/5.png" alt=""></p>
<p>这个时候继续正常的操作.  插入新的数据等等.<br>而后,重新启动147节点. 会发现 一切数据恢复正常. </p>
<p>集群成功</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MongoDB在Linux下的集群安装与配置">MongoDB在Linux下的集群安装与配置</h1><h2 id="一-MongoDB集群方式">一.MongoDB集群方式</h2><p><strong>Mongodb</strong>是时下流行的NoSql数据库.它拥有三种集群的搭建方式:<code>Replica Set</code> / <code>Sharding</code> / <code>Master-Slaver</code>.   分别为 副本集方式集群, 分片集群, 主从集群.<br>三种集群搭建方式首选<code>Replica Set</code>，只有真的是大数据，Sharding才能显现威力，毕竟备节点同步数据是需要时间的。Sharding可以将多片数据集中到路由节点上进行一些对比，然后将数据返回给客户端，但是效率还是比较低的说。  </p>
<p>这里用最常用的 Replica的方式集群来做介绍</p>
<h2 id="二-Replica_Set">二.Replica Set</h2><p><code>Replica Set</code>集群当中包含了多份数据，保证主节点挂掉了，备节点能继续提供数据服务，提供的前提就是数据需要和主节点一致。如下图：<br><img src="/img/2015/06/29/1.png" alt=""></p>
<p><code>Mongodb(M)</code>表示主节点，<code>Mongodb(S)</code>表示备节点，<code>Mongodb(A)</code>表示仲裁节点。主备节点存储数据，仲裁节点不存储数据。客户端同时连接主节点与备节点，不连接仲裁节点。</p>
<p>使用的时候 可以通过配置 让M负责写,S负责读.从而达到读写分离的效果</p>
<p>仲裁节点是一种特殊的节点，它本身并<code>不存储数据</code>，主要的作用是决定哪一个备节点在主节点挂掉之后提升为主节点，所以客户端不需要连接此节点。这里虽然只有一个备节点，但是仍然需要一个仲裁节点来提升备节点级别。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://sunxiang0918.github.io/tags/Linux/"/>
    
      <category term="MongoDB" scheme="http://sunxiang0918.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>Neo4j 底层存储结构分析]]></title>
    <link href="http://sunxiang0918.github.io/2015/06/27/neo4j-%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <id>http://sunxiang0918.github.io/2015/06/27/neo4j-底层存储结构分析/</id>
    <published>2015-06-27T13:08:13.000Z</published>
    <updated>2015-08-06T15:05:21.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Neo4j_底层存储结构分析">Neo4j 底层存储结构分析</h1><h2 id="neo4j_中节点和关系的物理存储模型">neo4j 中节点和关系的物理存储模型</h2><h3 id="neo4j存储模型">neo4j存储模型</h3><p><img src="/img/2015/06/27/1.jpg" alt=""></p>
<p>The node records contain only a pointer to their first property and their first relationship (in what is oftentermed the _relationship chain). From here, we can follow the (doubly) linked-list of relationships until we find the one we’re interested in, the  LIKES relationship from  Node 1 to  Node 2 in this case. Once we’ve found the relationship record of interest, we can simply read its properties if there are any via the same singly-linked list structure as node properties, or we can examine the node records that it relates via its start node and end node IDs. These IDs, multiplied by the node record size, of course give the immediate offset of both nodes in the node store file.</p>
<p>上面的英文摘自<code>&lt;Graph Databases&gt;</code>(作者：IanRobinson) 一书，描述了 neo4j 的存储模型。Node和Relationship 的 Property 是用一个 Key-Value 的双向列表来保存的； Node 的 Relatsionship 是用一个双向列表来保存的，通过关系，可以方便的找到关系的 from-to Node. Node 节点保存第1个属性和第1个关系ID。</p>
<p>通过上述存储模型，从一个Node-A开始，可以方便的遍历以该Node-A为起点的图。下面给个示例，来帮助理解上面的存储模型，存储文件的具体格式在第2章详细描述。</p>
<h3 id="示例1">示例1</h3><p><img src="/img/2015/06/27/2.png" alt=""><br>在这个例子中，A~E表示Node 的编号，R1~R7 表示 <code>Relationship</code> 编号，P1~P10 表示<code>Property</code> 的编号。</p>
<ul>
<li>Node 的存储示例图如下,每个<code>Node</code> 保存了第1个<code>Property</code> 和 第1个<code>Relationship</code>：<br><img src="/img/2015/06/27/3.png" alt=""></li>
<li>关系的存储示意图如下：<br><img src="/img/2015/06/27/4.png" alt=""><br>从示意图可以看出，从 Node-B 开始，可以通过关系的 next 指针，遍历Node-B 的所有关系，然后可以到达与其有关系的第1层Nodes,在通过遍历第1层Nodes的关系，可以达到第2层Nodes,…</li>
</ul>
<a id="more"></a>
<h2 id="neo4j_graph_db的存储文件介绍">neo4j graph db的存储文件介绍</h2><p>当我们下载neo4j-community-2.1.0-M01 并安装，然后拿 neo4j embedded-example 的EmbeddedNeo4j 例子跑一下，可以看到在target/neo4j-hello-db下会生成如下neo4j graph db 的存储文件。</p>
<pre><code><span class="tag">-rw-r</span>–<span class="tag">r</span>–     11 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">active_tx_log</span>

<span class="tag">drwxr-xr-x</span>   4096 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">index</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–  23740 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">messages</span><span class="class">.log</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     78 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     22 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.labeltokenstore</span><span class="class">.db</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.labeltokenstore</span><span class="class">.db</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     64 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.labeltokenstore</span><span class="class">.db</span><span class="class">.names</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.labeltokenstore</span><span class="class">.db</span><span class="class">.names</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     61 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.nodestore</span><span class="class">.db</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.nodestore</span><span class="class">.db</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     93 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.nodestore</span><span class="class">.db</span><span class="class">.labels</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.nodestore</span><span class="class">.db</span><span class="class">.labels</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–    307 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–    153 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span><span class="class">.arrays</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span><span class="class">.arrays</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     61 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span><span class="class">.index</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span><span class="class">.index</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–    216 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span><span class="class">.index</span><span class="class">.keys</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span><span class="class">.index</span><span class="class">.keys</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–    410 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span><span class="class">.strings</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.propertystore</span><span class="class">.db</span><span class="class">.strings</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     69 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.relationshipgroupstore</span><span class="class">.db</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.relationshipgroupstore</span><span class="class">.db</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     92 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.relationshipstore</span><span class="class">.db</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.relationshipstore</span><span class="class">.db</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     38 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.relationshiptypestore</span><span class="class">.db</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.relationshiptypestore</span><span class="class">.db</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–    140 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.relationshiptypestore</span><span class="class">.db</span><span class="class">.names</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.relationshiptypestore</span><span class="class">.db</span><span class="class">.names</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–     82 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.schemastore</span><span class="class">.db</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      9 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">neostore</span><span class="class">.schemastore</span><span class="class">.db</span><span class="class">.id</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      4 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">nioneo_logical</span><span class="class">.log</span><span class="class">.active</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–   2249 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">nioneo_logical</span><span class="class">.log</span><span class="class">.v0</span>

<span class="tag">drwxr-xr-x</span>   4096 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">schema</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–      0 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">store_lock</span>

<span class="tag">-rw-r</span>–<span class="tag">r</span>–    800 04<span class="tag">-11</span> 13<span class="pseudo">:28</span> <span class="tag">tm_tx_log</span><span class="class">.1</span>
</code></pre><h3 id="存储_node_的文件">存储 node 的文件</h3><ol>
<li>存储节点数据及其序列Id<ul>
<li><code>neostore.nodestore.db</code>:  存储节点数组，数组的下标即是该节点的ID</li>
<li><code>neostore.nodestore.db.id</code>  ：存储最大的ID 及已经free的ID</li>
</ul>
</li>
<li>存储节点label及其序列Id<ul>
<li><code>neostore.nodestore.db.labels</code>  ：存储节点label数组数据，数组的下标即是该节点label的ID</li>
<li><code>neostore.nodestore.db.labels.id</code></li>
</ul>
</li>
</ol>
<h3 id="存储_relationship_的文件">存储 relationship 的文件</h3><ol>
<li>存储关系数据及其序列Id<ul>
<li><code>neostore.relationshipstore.db</code> 存储关系 record 数组数据</li>
<li><code>neostore.relationshipstore.db.id</code></li>
</ul>
</li>
<li>存储关系组数据及其序列Id<ul>
<li><code>neostore.relationshipgroupstore.db</code>  存储关系 group数组数据</li>
<li><code>neostore.relationshipgroupstore.db.id</code></li>
</ul>
</li>
<li>存储关系类型及其序列Id<ul>
<li><code>neostore.relationshiptypestore.db</code>  存储关系类型数组数据</li>
<li><code>neostore.relationshiptypestore.db.id</code></li>
</ul>
</li>
<li>存储关系类型的名称及其序列Id<ul>
<li><code>neostore.relationshiptypestore.db.names</code> 存储关系类型 token 数组数据</li>
<li><code>neostore.relationshiptypestore.db.names.id</code></li>
</ul>
</li>
</ol>
<h3 id="存储_label_的文件">存储 label 的文件</h3><ol>
<li>存储label token数据及其序列Id<ul>
<li><code>neostore.labeltokenstore.db</code> 存储lable token 数组数据</li>
<li><code>neostore.labeltokenstore.db.id</code></li>
</ul>
</li>
<li>存储label token名字数据及其序列Id<ul>
<li><code>neostore.labeltokenstore.db.names</code>  存储 label token 的 names 数据</li>
<li><code>neostore.labeltokenstore.db.names.id</code></li>
</ul>
</li>
</ol>
<h3 id="存储_property_的文件">存储 property 的文件</h3><ol>
<li>存储属性数据及其序列Id<ul>
<li><code>neostore.propertystore.db</code>  存储 property 数据</li>
<li><code>neostore.propertystore.db.id</code></li>
</ul>
</li>
<li>存储属性数据中的数组类型数据及其序列Id<ul>
<li><code>neostore.propertystore.db.arrays</code>  存储 property (key-value 结构)的Value值是数组的数据。</li>
<li><code>neostore.propertystore.db.arrays.id</code></li>
</ul>
</li>
<li>属性数据为长字符串类型的存储文件及其序列Id<ul>
<li><code>neostore.propertystore.db.strings</code>     存储 property (key-value 结构)的Value值是字符串的数据。</li>
<li><code>neostore.propertystore.db.strings.id</code></li>
</ul>
</li>
<li>属性数据的索引数据文件及其序列Id<ul>
<li><code>neostore.propertystore.db.index</code>      存储 property (key-value 结构)的key 的索引数据。</li>
<li><code>neostore.propertystore.db.index.id</code></li>
</ul>
</li>
<li>属性数据的键值数据存储文件及其序列Id<ul>
<li><code>neostore.propertystore.db.index.keys</code>     存储 property (key-value 结构)的key 的字符串值。</li>
<li><code>neostore.propertystore.db.index.keys.id</code></li>
</ul>
</li>
</ol>
<h3 id="其他的文件">其他的文件</h3><ol>
<li>存储版本信息<ul>
<li><code>neostore</code></li>
<li><code>neostore.id</code></li>
</ul>
</li>
<li>存储 schema 数据<ul>
<li><code>neostore.schemastore.db</code></li>
<li><code>neostore.schemastore.db.id</code></li>
</ul>
</li>
<li>活动的逻辑日志<ul>
<li><code>nioneo_logical.log.active</code></li>
</ul>
</li>
<li>记录当前活动的日志文件名称<ul>
<li><code>active_tx_log</code></li>
</ul>
</li>
</ol>
<h2 id="neo4j存储结构">neo4j存储结构</h2><p>neo4j 中,主要有4类节点，属性，关系等文件是以数组作为核心存储结构；同时对节点，属性，关系等类型的每个数据项都会分配一个唯一的ID，在存储时以该ID 为数组的下标。这样，在访问时通过其ID作为下标，实现快速定位。所以在图遍历等操作时，可以实现 free-index。</p>
<h3 id="neo4j_的_store_部分类图">neo4j 的 store 部分类图</h3><p><img src="/img/2015/06/27/5.png" alt=""></p>
<p><strong>3.1.1 CommonAbstractStore.java</strong><br><code>CommonAbstractStore</code> 是所有 <code>Store</code> 类的基类，下面的代码片段是 CommonAbstractStore 的成员变量，比较重要的是飘红的几个，特别是<code>IdGenerator</code>，每种Store 的实例都有自己的 id 分配管理器; <code>StoreChannel</code> 是负责Store文件的读写和定位；<code>WindowsPool</code> 是与Store Record相关的缓存，用来提升性能的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonAbstractStore</span> <span class="keyword">implements</span> <span class="title">IdSequence</span></span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span></span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting store_dir = InternalAbstractGraphDatabase.Configuration.store_dir;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting neo_store = InternalAbstractGraphDatabase.Configuration.neo_store;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting read_only = GraphDatabaseSettings.read_only;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting backup_slave = GraphDatabaseSettings.backup_slave;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting use_memory_mapped_buffers = GraphDatabaseSettings.use_memory_mapped_buffers;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALL_STORES_VERSION = <span class="string">"v0.A.2"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNKNOWN_VERSION = <span class="string">"Uknown"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> Config configuration;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IdGeneratorFactory idGeneratorFactory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WindowPoolFactory windowPoolFactory;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> FileSystemAbstraction fileSystemAbstraction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> File storageFileName;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> IdType idType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> StringLogger stringLogger;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> IdGenerator idGenerator = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> StoreChannel fileChannel = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> WindowPool windowPool;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> storeOk = <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> Throwable causeOfStoreNotOk;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> FileLock fileLock;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> readOnly = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> backupSlave = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> highestUpdateRecordId = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="neo4j_的db文件及对应的存储格式类型">neo4j 的db文件及对应的存储格式类型</h3><table>
<thead>
<tr>
<th style="text-align:left">文件名</th>
<th style="text-align:left">文件存储格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">neostore.labeltokenstore.db</td>
<td style="text-align:left">LabelTokenStore（TokenStore）</td>
</tr>
<tr>
<td style="text-align:left">neostore.labeltokenstore.db.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.labeltokenstore.db.names</td>
<td style="text-align:left">StringPropertyStore (AbstractDynamicStore, NAME_STORE_BLOCK_SIZE = 30)</td>
</tr>
<tr>
<td style="text-align:left">neostore.labeltokenstore.db.names.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.nodestore.db</td>
<td style="text-align:left">NodeStore</td>
</tr>
<tr>
<td style="text-align:left">neostore.nodestore.db.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.nodestore.db.labels</td>
<td style="text-align:left">ArrayPropertyStore (AbstractDynamicStorelabel_block_size=60)</td>
</tr>
<tr>
<td style="text-align:left">neostore.nodestore.db.labels.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db</td>
<td style="text-align:left">PropertyStore</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db.arrays</td>
<td style="text-align:left">ArrayPropertyStore (AbstractDynamicStorearray_block_size=120)</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db.arrays.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db.index</td>
<td style="text-align:left">PropertyIndexStore</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db.index.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db.index.keys</td>
<td style="text-align:left">StringPropertyStore (AbstractDynamicStore, NAME_STORE_BLOCK_SIZE = 30)</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db.index.keys.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db.strings</td>
<td style="text-align:left">StringPropertyStore (AbstractDynamicStorestring_block_size=120)</td>
</tr>
<tr>
<td style="text-align:left">neostore.propertystore.db.strings.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.relationshipgroupstore.db</td>
<td style="text-align:left">RelationshipGroupStore</td>
</tr>
<tr>
<td style="text-align:left">neostore.relationshipgroupstore.db.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.relationshipstore.db</td>
<td style="text-align:left">RelationshipStore</td>
</tr>
<tr>
<td style="text-align:left">neostore.relationshipstore.db.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.relationshiptypestore.db</td>
<td style="text-align:left">RelationshipTypeTokenStore（TokenStore）</td>
</tr>
<tr>
<td style="text-align:left">neostore.relationshiptypestore.db.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.relationshiptypestore.db.names</td>
<td style="text-align:left">StringPropertyStore (AbstractDynamicStore, NAME_STORE_BLOCK_SIZE = 30)</td>
</tr>
<tr>
<td style="text-align:left">neostore.relationshiptypestore.db.names.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
<tr>
<td style="text-align:left">neostore.schemastore.db</td>
<td style="text-align:left">SchemaStore(AbstractDynamicStore, BLOCK_SIZE = 56)</td>
</tr>
<tr>
<td style="text-align:left">neostore.schemastore.db.id</td>
<td style="text-align:left">ID 类型</td>
</tr>
</tbody>
</table>
<h3 id="通用的Store_类型">通用的Store 类型</h3><h4 id="id_类型">id 类型</h4><p>下面是 neo4j db 中,每种<code>Store</code>都有自己的ID文件(即后缀.id 文件)，它们的格式都是一样的。</p>
<pre><code>[test00]$ls -lh target/neo4j-test00.db/ |grep .id

-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.labeltokenstore.db.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.labeltokenstore.db.names.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.nodestore.db.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.nodestore.db.labels.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.propertystore.db.arrays.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.propertystore.db.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.propertystore.db.index.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.propertystore.db.index.keys.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.propertystore.db.strings.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.relationshipgroupstore.db.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.relationshipstore.db.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.relationshiptypestore.db.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.relationshiptypestore.db.names.id
</span>
-<span class="ruby">rw-r–r–<span class="number">9</span> <span class="number">04</span>-<span class="number">11</span> <span class="number">13</span><span class="symbol">:</span><span class="number">28</span> neostore.schemastore.db.id</span>
</code></pre><p><strong>3.3.1.1. ID类型文件的存储格式</strong><br><img src="/img/2015/06/27/6.png" alt=""><br>neo4j 中后缀为 “.id”的文件格式如上图所示，由<code>文件头</code>（9 Bytes）和 <code>long类型 数组</code> 2部分构成：</p>
<ul>
<li><code>sticky(1 byte)</code> : if sticky the id generator wasn’t closed properly so it has to berebuilt (go through the node, relationship, property, rel type etc files).</li>
<li><code>nextFreeId(long)</code> : 保存最大的ID,该值与对应类型的存储数组的数组大小相对应。</li>
<li><code>reuseId(long)</code>:用来保存已经释放且可复用的ID值。通过复用ID ,可以减少资源数组的空洞，提高磁盘利用率。</li>
</ul>
<p><strong>3.3.1.2. IdGeneratorImpl.java</strong><br>每一种资源类型的ID 分配 neo4j 中是通过 <code>IdGeneratorImpl</code> 来实现的，其功能是负责ID管理分配和回收复用。对于<code>节点</code>，<code>关系</code>，<code>属性</code>等每一种资源类型，都可以生成一个<code>IdGenerator</code>  实例来负责其ID管理分配和回收复用。</p>
<p><strong>3.3.1.2.1. 读取id 文件进行初始化</strong><br>下面是 <code>IdGeneratorImpl.java</code> 中， 读取id 文件进行初始化的过程，<code>IdGeneratorImpl</code> 会从 id 文件中读取grabSize 个<code>可复用的ID</code> (reuseId) 到<code>idsReadFromFile(LinkedList&lt;Long&gt;)</code>中，在需要申请id 时优先分配 <code>idsReadFromFile</code>中的<code>可复用ID</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initGenerator</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            fileChannel = fs.open(fileName, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(HEADER_SIZE);</span><br><span class="line"></span><br><span class="line">            readHeader(buffer);</span><br><span class="line"></span><br><span class="line">            markAsSticky(buffer);</span><br><span class="line"></span><br><span class="line">            fileChannel.position(HEADER_SIZE);</span><br><span class="line"></span><br><span class="line">            maxReadPosition = fileChannel.size();</span><br><span class="line"></span><br><span class="line">            defraggedIdCount = (<span class="keyword">int</span>) (maxReadPosition - HEADER_SIZE) / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            readIdBatch();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnderlyingStorageException(</span><br><span class="line"></span><br><span class="line">                    <span class="string">"Unable to init id generator "</span> + fileName, e);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readHeader</span><span class="params">(ByteBuffer buffer)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"></span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        readPosition = fileChannel.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (readPosition != HEADER_SIZE)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            fileChannel.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidIdGeneratorException(</span><br><span class="line"></span><br><span class="line">                    <span class="string">"Unable to read header, bytes read: "</span> + readPosition);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span> storageStatus = buffer.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (storageStatus != CLEAN_GENERATOR)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            fileChannel.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidIdGeneratorException(<span class="string">"Sticky generator[ "</span> +</span><br><span class="line"></span><br><span class="line">                    fileName + <span class="string">"] delete this id file and build a new one"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.highId.set(buffer.getLong());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIdBatch</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!canReadMoreIdBatches())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> howMuchToRead = (<span class="keyword">int</span>) Math.min(grabSize * <span class="number">8</span>, maxReadPosition - readPosition);</span><br><span class="line"></span><br><span class="line">            ByteBuffer readBuffer = ByteBuffer.allocate(howMuchToRead);</span><br><span class="line"></span><br><span class="line">            fileChannel.position(readPosition);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> bytesRead = fileChannel.read(readBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> fileChannel.position() &lt;= maxReadPosition;</span><br><span class="line"></span><br><span class="line">            readPosition += bytesRead;</span><br><span class="line"></span><br><span class="line">            readBuffer.flip();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">assert</span> (bytesRead % <span class="number">8</span>) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> idsRead = bytesRead / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            defraggedIdCount -= idsRead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idsRead; i++)</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> id = readBuffer.getLong();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (id != INTEGER_MINUS_ONE)</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    idsReadFromFile.add(id);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnderlyingStorageException(</span><br><span class="line"></span><br><span class="line">                    <span class="string">"Failed reading defragged id batch"</span>, e);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.3.1.2.2. 释放id(freeId)</strong><br>用户释放一个 id 后，会先放入 <code>releasedIdList （LinkedList&lt;Long&gt;）</code>，当<code>releasedIdList</code> 中回收的 id 个数超过 <code>grabSize</code> 个时， 写入到 id 文件的末尾。所以可见，对于一个 <code>IdGeneratorImpl</code>， 最多有 <code>2 * grabSize</code> 个 id 缓存(releasedIdList 和 idsReadFromFile)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the id generator and performs a simple validation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Frees the &lt;CODE&gt;id&lt;/CODE&gt; making it a defragged id that will be</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * returned by next id before any new id (that hasn't been used yet) is</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * returned.</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * This method will throw an &lt;CODE&gt;IOException&lt;/CODE&gt; if id is negative or</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * if id is greater than the highest returned id. However as stated in the</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * class documentation above the id isn't validated to see if it really is</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * free.</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">freeId</span><span class="params">(<span class="keyword">long</span> id)</span></span><br><span class="line"></span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == INTEGER_MINUS_ONE)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fileChannel == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Generator closed "</span> + fileName);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= highId.get())</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal id["</span> + id + <span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        releasedIdList.add(id);</span><br><span class="line"></span><br><span class="line">        defraggedIdCount++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (releasedIdList.size() &gt;= grabSize)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            writeIdBatch(ByteBuffer.allocate(grabSize * <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.3.1.2.3. 申请id ( nextId)</strong><br>当用户申请一个 id  时，<code>IdGeneratorImpl</code> 在分配时，有2种分配策略：<code>“正常的分配策略”</code> 和<code>“激进分配策略”</code>（aggressiveReuse），可以根据配置进行选择。</p>
<ul>
<li>“正常的分配策略”：<ul>
<li>首先从idsReadFromFile 中分配; 如果 idsReadFromFile 为空，则先从对应的 id 文件中读取已释放且可复用的 id 到idsReadFromFile.</li>
<li>如果 idsReadFromFile 及 id 文件中没有已释放且可复用的 id了，则分配全新的id,即id = highId.get()  并将highId 加1；</li>
</ul>
</li>
<li>“激进分配策略”（aggressiveReuse）:<ul>
<li>首先从releasedIdList（刚回收的ID List）中分配。</li>
<li>releasedIdList分配光了，则从idsReadFromFile 中分配; 如果 idsReadFromFile 为空，则先从对应的 id 文件中读取已释放且可复用的 id 到idsReadFromFile.</li>
<li>如果 idsReadFromFile 及 id 文件中没有已释放且可复用的 id了，则分配全新的id,即id = highId.get()  并将highId 加1；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Returns the next "free" id. If a defragged id exist it will be returned</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * else the next free id that hasn't been used yet is returned. If no id</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * exist the capacity is exceeded (all values &lt;= max are taken) and a</span><br><span class="line">     * &lt;p/&gt;</span><br><span class="line">     * &#123;<span class="doctag">@link</span> UnderlyingStorageException&#125; will be thrown.</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        assertStillOpen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> nextDefragId = nextIdFromDefragList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextDefragId != -<span class="number">1</span>) <span class="keyword">return</span> nextDefragId;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> id = highId.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == INTEGER_MINUS_ONE)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Skip the integer -1 (0xFFFFFFFF) because it represents</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// special values, f.ex. the end of a relationships/property chain.</span></span><br><span class="line"></span><br><span class="line">            id = highId.incrementAndGet();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        assertIdWithinCapacity(id);</span><br><span class="line"></span><br><span class="line">        highId.incrementAndGet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="DynamicStore_类型">DynamicStore 类型</h4><p><strong>3.3.2.1. AbstractDynamicStore 的存储格式</strong><br>neo4j 中对于字符串等变长值的保存策略是用一组定长的 block 来保存，block之间用单向链表链接。类 AbstractDynamicStore 实现了该功能，下面是其注释说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"></span><br><span class="line"> * An abstract representation of a dynamic store. The difference between a</span><br><span class="line"></span><br><span class="line"> * normal AbstractStore and a AbstractDynamicStore is</span><br><span class="line"></span><br><span class="line"> * that the size of a record/entry can be dynamic.</span><br><span class="line"></span><br><span class="line"> * Instead of a fixed record this class uses blocks to store a record. If a</span><br><span class="line"></span><br><span class="line"> * record size is greater than the block size the record will use one or more</span><br><span class="line"></span><br><span class="line"> * blocks to store its data.</span><br><span class="line"></span><br><span class="line"> * A dynamic store don’t have a IdGenerator because the position of a</span><br><span class="line"></span><br><span class="line"> * record can’t be calculated just by knowing the id. Instead one should use a</span><br><span class="line"></span><br><span class="line"> * AbstractStore and store the start block of the record located in the</span><br><span class="line"></span><br><span class="line"> * dynamic store. Note: This class makes use of an id generator internally for</span><br><span class="line"></span><br><span class="line"> * managing free and non free blocks.</span><br><span class="line"></span><br><span class="line"> * Note, the first block of a dynamic store is reserved and contains information</span><br><span class="line"></span><br><span class="line"> * about the store.</span><br><span class="line"></span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/2015/06/27/7.jpg" alt=""><br><code>AbstractDynamicStore</code>类对应的存储文件格式如上图所示, 整个文件是有一个<code>block_size=BLOCK_HEADER_SIZE(8Bytes)+block_content_size</code>的定长数组和一个字符串<code>“StringPropertyStore v0.A.2”</code>或<code>“ArrayPropertyStore v0.A.2”</code>或<code>“SchemaStore v0.A.2”</code>(文件类型描述TYPE_DESCRIPTOR和 neo4j 的 ALL_STORES_VERSION构成)。访问时，可以通过 id 作为数组的下标进行访问。其中，文件的第1个 record 中前4 字节用来保存 block_size。文件的第2个 record开始保存实际的block数据,它由8个字节的block_header和定长的 block_content（可配置）构成. block_header 结构如下:</p>
<ul>
<li>inUse(1 Byte):第1字节,共分成3部分<br>  [x__ ,    ]  0: start record, 1: linked record<br>  [   x,    ]  inUse<br>  [    ,xxxx]  high next block bits  <ul>
<li>第1~4 bit 表示<code>next_block</code> 的高4位</li>
<li>第5 bit表示<code>block</code> 是否在 use;</li>
<li>第8 bit 表示 <code>block</code> 是否是单向链表的第1个 block；<code>0</code>表示第1个block, <code>1</code>表示后续 block.</li>
</ul>
</li>
<li>nr_of_bytes(3Bytes)：本 block 中保存的数据的长度。</li>
<li>next_block(4Bytes): next_block 的低 4 个字节，加上 <code>inUse</code> 的第1~4 位，<code>next_block</code> 的实际长度共 36 bit。以数组方式存储的单向链表的指针，指向保存同一条数据的下一个 block 的id.</li>
</ul>
<p><strong>3.3.2.2. AbstractDynamicStore.java</strong><br>下面看一下 AbstractDynamicStore.java 中 <code>getRecord()</code> 和<code>readAndVerifyBlockSize()</code> 成员函数，可以帮助理解 DynamicStore 的存储格式。</p>
<ul>
<li>getRecord( long blockId, PersistenceWindow window, RecordLoad load )</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DynamicRecord <span class="title">getRecord</span><span class="params">( <span class="keyword">long</span> blockId, PersistenceWindow window, RecordLoad load )</span>&lt;/pre&gt;</span><br><span class="line">&lt;div&gt;</span>&#123;</span><br><span class="line"> </span><br><span class="line">DynamicRecord record = <span class="keyword">new</span> DynamicRecord( blockId );</span><br><span class="line"> </span><br><span class="line">Buffer buffer = window.getOffsettedBuffer( blockId );</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span><br><span class="line"> </span><br><span class="line">* First 4b</span><br><span class="line"> </span><br><span class="line">* [x   ,    ][    ,    ][    ,    ][    ,    ] 0: start record, 1: linked record</span><br><span class="line"> </span><br><span class="line">* [   x,    ][    ,    ][    ,    ][    ,    ] inUse</span><br><span class="line"> </span><br><span class="line">* [    ,xxxx][    ,    ][    ,    ][    ,    ] high next block bits</span><br><span class="line"> </span><br><span class="line">* [    ,    ][xxxx,xxxx][xxxx,xxxx][xxxx,xxxx] nr of bytes in the data field in this record</span><br><span class="line"> </span><br><span class="line">*</span><br><span class="line"> </span><br><span class="line">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> firstInteger = buffer.getUnsignedInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">boolean</span> isStartRecord = (firstInteger &amp; <span class="number">0x80000000</span>) == <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> maskedInteger = firstInteger &amp; ~<span class="number">0x80000000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> highNibbleInMaskedInteger = (<span class="keyword">int</span>) ( ( maskedInteger ) &gt;&gt; <span class="number">28</span> );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">boolean</span> inUse = highNibbleInMaskedInteger == Record.IN_USE.intValue();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( !inUse &amp;&amp; load != RecordLoad.FORCE )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidRecordException( <span class="string">"DynamicRecord Not in use, blockId["</span> + blockId + <span class="string">"]"</span> );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dataSize = getBlockSize() - BLOCK_HEADER_SIZE;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> nrOfBytes = (<span class="keyword">int</span>) ( firstInteger &amp; <span class="number">0xFFFFFF</span> );</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span><br><span class="line"> </span><br><span class="line">* Pointer to next block 4b (low bits of the pointer)</span><br><span class="line"> </span><br><span class="line">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> nextBlock = buffer.getUnsignedInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> nextModifier = ( firstInteger &amp; <span class="number">0xF000000L</span> ) &lt;&lt; <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> longNextBlock = longFromIntAndMod( nextBlock, nextModifier );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">boolean</span> readData = load != RecordLoad.CHECK;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( longNextBlock != Record.NO_NEXT_BLOCK.intValue()</span><br><span class="line"> </span><br><span class="line">&amp;&amp; nrOfBytes &lt; dataSize || nrOfBytes &gt; dataSize )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">readData = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( load != RecordLoad.FORCE )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidRecordException( <span class="string">"Next block set["</span> + nextBlock</span><br><span class="line"> </span><br><span class="line">+ <span class="string">"] current block illegal size["</span> + nrOfBytes + <span class="string">"/"</span> + dataSize + <span class="string">"]"</span> );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">record.setInUse( inUse );</span><br><span class="line"> </span><br><span class="line">record.setStartRecord( isStartRecord );</span><br><span class="line"> </span><br><span class="line">record.setLength( nrOfBytes );</span><br><span class="line"> </span><br><span class="line">record.setNextBlock( longNextBlock );</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span><br><span class="line"> </span><br><span class="line">* Data 'nrOfBytes' bytes</span><br><span class="line"> </span><br><span class="line">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( readData )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">byte</span> byteArrayElement[] = <span class="keyword">new</span> <span class="keyword">byte</span>[nrOfBytes];</span><br><span class="line"> </span><br><span class="line">buffer.get( byteArrayElement );</span><br><span class="line"> </span><br><span class="line">record.setData( byteArrayElement );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> record;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>readAndVerifyBlockSize()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">readAndVerifyBlockSize</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">4</span> );</span><br><span class="line"> </span><br><span class="line">getFileChannel().position( <span class="number">0</span> );</span><br><span class="line"> </span><br><span class="line">getFileChannel().read( buffer );</span><br><span class="line"> </span><br><span class="line">buffer.flip();</span><br><span class="line"> </span><br><span class="line">blockSize = buffer.getInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( blockSize &lt;= <span class="number">0</span> )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidRecordException( <span class="string">"Illegal block size: "</span> +</span><br><span class="line"> </span><br><span class="line">blockSize + <span class="string">" in "</span> + getStorageFileName() );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.3.2.3  类DynamicArrayStore, DynamicStringStore</strong><br>类<code>SchemaStore</code>，<code>DynamicArrayStore(ArrayPropertyStore)</code>, <code>DynamicStringStore(StringPropertyStore)</code>都是继承成自类<code>AbstractDynamicStore</code>，所以与类DynamicArrayStore, DynamicStringStore和 SchemaStore对应文件的存储格式，都是遵循AbstractDynamicStore的存储格式，除了block块的大小（block_size）不同外。</p>
<table>
<thead>
<tr>
<th style="text-align:center">db 文件</th>
<th style="text-align:center">存储类型</th>
<th style="text-align:center">block_size</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">neostore.labeltokenstore.db.names</td>
<td style="text-align:center">StringPropertyStore</td>
<td style="text-align:center">NAME_STORE_BLOCK_SIZE=30</td>
</tr>
<tr>
<td style="text-align:center">neostore.propertystore.db.index.keys</td>
<td style="text-align:center">StringPropertyStore</td>
<td style="text-align:center">NAME_STORE_BLOCK_SIZE=30</td>
</tr>
<tr>
<td style="text-align:center">neostore.relationshiptypestore.db.names</td>
<td style="text-align:center">StringPropertyStore</td>
<td style="text-align:center">NAME_STORE_BLOCK_SIZE=30</td>
</tr>
<tr>
<td style="text-align:center">neostore.propertystore.db.strings</td>
<td style="text-align:center">StringPropertyStore</td>
<td style="text-align:center">string_block_size=120</td>
</tr>
<tr>
<td style="text-align:center">neostore.nodestore.db.labels</td>
<td style="text-align:center">ArrayPropertyStore</td>
<td style="text-align:center">label_block_size=60</td>
</tr>
<tr>
<td style="text-align:center">neostore.propertystore.db.arrays</td>
<td style="text-align:center">ArrayPropertyStore</td>
<td style="text-align:center">array_block_size=120</td>
</tr>
<tr>
<td style="text-align:center">neostore.schemastore.db</td>
<td style="text-align:center">SchemaStore</td>
<td style="text-align:center">BLOCK_SIZE=56</td>
</tr>
</tbody>
</table>
<p><code>block_size</code> 通过配置文件或缺省值来设置的，下面的代码片段展示了neostore.propertystore.db.strings 文件的创建过程及block_size 的大小如何传入。</p>
<ol>
<li><p>GraphDatabaseSettings.java</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting string_block_size = setting(<span class="string">"string_block_size"</span>, INTEGER, <span class="string">"120"</span>,min(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting array_block_size = setting(<span class="string">"array_block_size"</span>, INTEGER, <span class="string">"120"</span>,min(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting label_block_size = setting(<span class="string">"label_block_size"</span>, INTEGER, <span class="string">"60"</span>,min(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>StoreFactory.java的Configuration 类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting string_block_size = GraphDatabaseSettings.string_block_size;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting array_block_size = GraphDatabaseSettings.array_block_size;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting label_block_size = GraphDatabaseSettings.label_block_size;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Setting dense_node_threshold = GraphDatabaseSettings.dense_node_threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>StoreFactory.java的createPropertyStore 函数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPropertyStore</span><span class="params">( File fileName )</span></span>&#123;</span><br><span class="line">	createEmptyStore( fileName, buildTypeDescriptorAndVersion( PropertyStore.TYPE_DESCRIPTOR )); </span><br><span class="line">	<span class="keyword">int</span> stringStoreBlockSize = config.get( Configuration.string_block_size );</span><br><span class="line">	<span class="keyword">int</span> arrayStoreBlockSize = config.get( Configuration.array_block_size )</span><br><span class="line">createDynamicStringStore(<span class="keyword">new</span> File( fileName.getPath() + STRINGS_PART), 	stringStoreBlockSize, IdType.STRING_BLOCK);</span><br><span class="line">	createPropertyKeyTokenStore( <span class="keyword">new</span> File( fileName.getPath() + INDEX_PART ) );</span><br><span class="line">	createDynamicArrayStore( <span class="keyword">new</span> File( fileName.getPath() + ARRAYS_PART ), 	arrayStoreBlockSize );</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>StoreFactory.java的createDynamicStringStore函数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createDynamicStringStore</span><span class="params">( File fileName, <span class="keyword">int</span> blockSize, IdType idType )</span></span>&#123;</span><br><span class="line">createEmptyDynamicStore(fileName, blockSize, DynamicStringStore.VERSION, idType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>StoreFactory.java的createEmptyDynamicStore 函数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">* Creates a new empty store. A factory method returning an implementation</span><br><span class="line">* should make use of this method to initialize an empty store. Block size</span><br><span class="line">* must be greater than zero. Not that the first block will be marked as</span><br><span class="line">* reserved (contains info about the block size). There will be an overhead</span><br><span class="line">* for each block of &lt;CODE&gt;AbstractDynamicStore.BLOCK_HEADER_SIZE&lt;/CODE&gt;bytes.</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEmptyDynamicStore</span><span class="params">( File fileName, <span class="keyword">int</span> baseBlockSize,</span><br><span class="line">String typeAndVersionDescriptor, IdType idType)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> blockSize = baseBlockSize;</span><br><span class="line"><span class="comment">// sanity checks</span></span><br><span class="line">…</span><br><span class="line">blockSize += AbstractDynamicStore.BLOCK_HEADER_SIZE;</span><br><span class="line"><span class="comment">// write the header</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">FileChannel channel = fileSystemAbstraction.create(fileName);</span><br><span class="line"><span class="keyword">int</span> endHeaderSize = blockSize</span><br><span class="line">+ UTF8.encode( typeAndVersionDescriptor ).length;</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( endHeaderSize );</span><br><span class="line">buffer.putInt( blockSize );</span><br><span class="line">buffer.position( endHeaderSize - typeAndVersionDescriptor.length() );</span><br><span class="line">buffer.put( UTF8.encode( typeAndVersionDescriptor ) ).flip();</span><br><span class="line">channel.write( buffer );</span><br><span class="line">channel.force( <span class="keyword">false</span> );</span><br><span class="line">channel.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> ( IOException e )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnderlyingStorageException( <span class="string">"Unable to create store "</span></span><br><span class="line">+ fileName, e );</span><br><span class="line">&#125;</span><br><span class="line">idGeneratorFactory.create( fileSystemAbstraction, <span class="keyword">new</span> File( fileName.getPath() + <span class="string">".id"</span>), <span class="number">0</span> );</span><br><span class="line"><span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span> highestIdInUse = 0 works now, but not when slave can create store files.</span></span><br><span class="line">IdGenerator idGenerator = idGeneratorFactory.open(fileSystemAbstraction,</span><br><span class="line"><span class="keyword">new</span> File( fileName.getPath() + <span class="string">".id"</span>),idType.getGrabSize(), idType, <span class="number">0</span> );</span><br><span class="line">idGenerator.nextId(); <span class="comment">// reserve first for blockSize</span></span><br><span class="line">idGenerator.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Property_的存储">Property 的存储</h3><p>下面是neo4j graph db 中，Property数据存储对应的文件：</p>
<pre><code>neostore<span class="class">.propertystore</span><span class="class">.db</span>

neostore<span class="class">.propertystore</span><span class="class">.db</span><span class="class">.arrays</span>

neostore<span class="class">.propertystore</span><span class="class">.db</span><span class="class">.arrays</span><span class="class">.id</span>

neostore<span class="class">.propertystore</span><span class="class">.db</span><span class="class">.id</span>

neostore<span class="class">.propertystore</span><span class="class">.db</span><span class="class">.index</span>

neostore<span class="class">.propertystore</span><span class="class">.db</span><span class="class">.index</span><span class="class">.id</span>

neostore<span class="class">.propertystore</span><span class="class">.db</span><span class="class">.index</span><span class="class">.keys</span>

neostore<span class="class">.propertystore</span><span class="class">.db</span><span class="class">.index</span><span class="class">.keys</span><span class="class">.id</span>

neostore<span class="class">.propertystore</span><span class="class">.db</span><span class="class">.strings</span>

neostore<span class="class">.propertystore</span><span class="class">.db</span><span class="class">.strings</span><span class="class">.id</span>
</code></pre><p>neo4j 中, <code>Property</code> 的存储是由 <code>PropertyStore</code>, <code>ArrayPropertyStore</code>, <code>StringPropertyStore</code> 和<code>PropertyKeyTokenStore</code> 4种类型的Store配合来完成的.</p>
<p>类<code>PropertyStore</code>对应的存储文件是neostore.propertystore.db, 相应的用来存储 string/array 类型属性值的文件分别是neostore.propertystore.db.strings (StringPropertyStore) 和 neostore.propertystore.db.arrays(ArrayPropertyStore). 其存储模型示意图如下：<br><img src="/img/2015/06/27/8.png" alt=""><br>其中<code>PropertyStore</code>是Property最主要的存储结构，当Property的Key-Value对的Value 是字符串或数组类型并且要求的存储空间比较大，在PropertyStore中保存不了，则会存在StringPropertyStore/ ArrayPropertyStore这样的DynamicStore 中。如果长度超过一个block ，则分block存储，并将其在StringPropertyStore/ ArrayPropertyStore中的第1个block 的 block_id 保存到 PropertyStore类型文件相应record 的PropertyBlock字段中。</p>
<p><code>PropertyKeyTokenStore</code>和<code>StringPropertyStore</code> 配合用来存储Propery的Key部分。Propery的Key是编码的，key 的 id 保存在 PropertyKeyTokenStore (即 neostore.propertystore.db.index)，key 的字符串名保存在对应的StringPropertyStore类型文件neostore.propertystore.db.index.keys 中。</p>
<p><code>ArrayPropertyStore</code>的存储格式见&lt; 3.3.2 DynamicStore 类型&gt;，下面分别介绍一下PropertyStore和PropertyKeyTokenStore（PropertyKeyTokenStore）的文件存储格式。</p>
<h4 id="PropertyStore类型的存储格式">PropertyStore类型的存储格式</h4><p>neostore.propertystore.db文件存储格式示意图如下，整个文件是有一个 <code>RECORD_SIZE=41 Bytes</code> 的定长数组和一个字符串描述符<code>“PropertyStore v0.A.2”</code>(文件类型描述TYPE_DESCRIPTOR和 neo4j 的 ALL_STORES_VERSION构成)。访问时，可以通过 prop_id 作为数组的下标进行访问。</p>
<p><img src="/img/2015/06/27/9.png" alt=""></p>
<p>下面介绍一下 property record 中每个字段的含义：</p>
<ul>
<li><code>highByte(1 Byte)</code>:第1字节,共分成2部分<br>  //[pppp,nnnn] previous, next high bits<br>  byte modifiers = buffer.get();  <ul>
<li>第1~4 bit 表示 <code>next</code> 的高4位；</li>
<li>第 5~8 bit表示 <code>prev</code> 的高4位 </li>
</ul>
</li>
<li><code>prev(4 Bytes)</code>: Node或Relationship 的属性是通过双向链表方式组织的，prev 表示本属性在双向链表中的上一个属性的id。第2~5字节是prev property_id的 低32位. 加上highByte字节的第 5~8 bit作为高4位，构成一个完整的36位property_id。</li>
<li><code>next(4 Bytes)</code>: next 表示本属性在双向链表中的下一个属性的id。第6~9字节是next property_id的 低32位. 加上highByte字节的第 1~4 bit作为高4位，构成一个完整的36位property_id。</li>
<li><code>payload</code>:  payload 由block_header(8 Bytes)加3个property_block(8 Bytes)组成，共计 32 Bytes.  block_header 分成3部分:<ul>
<li><code>key_id(24 bits)</code>: 第1 ~24 bit , property 的key 的 id</li>
<li><code>type( 4 bits )</code>:   第25 ~28 bit , property 的 value 的类型，支持 string, Interger,Boolean, Float, Long,Double, Byte, Character,Short, array.</li>
<li><code>payload(36 bits)</code>: 第29 ~64 bit, 共计36bit；对于Interger, Boolean, Float, Byte, Character , Short 类型的值，直接保存在payload；对于long，如果36位可以表示，则直接保存在payload，如果不够，则保存到第1个PropertyBlock中；double 类型，保存到第1个PropertyBlock中；对于 array/string ，如果编码后在 block_header及3个PropertyBlock 能保存，则直接保存；否则，保存到ArrayDynamicStore/StringDynamicStore 中， payload 保存其在ArrayDynamicStore中的数组下表。</li>
</ul>
</li>
</ul>
<h4 id="String_类型属性值的保存过程">String 类型属性值的保存过程</h4><p>下面的代码片段展示了neo4j 中，比较长的 String 类型属性值的保存处理过程，其是如何<code>分成多个</code> DynamicBlock 来存储的。<br><img src="/img/2015/06/27/10.jpg" alt=""></p>
<p><strong>3.5.2.1 encodeValue 函数</strong><br>encodeValue 函数是 PropertySTore.java 的成员函数, 它实现了不同类型的属性值的编码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encodeValue</span><span class="params">( PropertyBlock block, <span class="keyword">int</span> keyId, Object value )</span></span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( value <span class="keyword">instanceof</span> String )</span><br><span class="line"> </span><br><span class="line">&#123;   <span class="comment">// Try short string first, i.e. inlined in the property block</span></span><br><span class="line"> </span><br><span class="line">String string = (String) value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( LongerShortString.encode( keyId, string, block, PropertyType.getPayloadSize() ) )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fall back to dynamic string store</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">byte</span>[] encodedString = encodeString( string );</span><br><span class="line"> </span><br><span class="line">Collection valueRecords = allocateStringRecords( encodedString );</span><br><span class="line"> </span><br><span class="line">setSingleBlockValue( block, keyId, PropertyType.STRING, first( valueRecords ).getId() );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> ( DynamicRecord valueRecord : valueRecords )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">valueRecord.setType( PropertyType.STRING.intValue() );</span><br><span class="line"> </span><br><span class="line">block.addValueRecord( valueRecord );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( value <span class="keyword">instanceof</span> Integer )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">setSingleBlockValue( block, keyId, PropertyType.INT, ((Integer) value).longValue() );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( value <span class="keyword">instanceof</span> Boolean )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">setSingleBlockValue( block, keyId, PropertyType.BOOL, ((Boolean) value ? <span class="number">1L</span> : <span class="number">0L</span>) );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( value <span class="keyword">instanceof</span> Float )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">setSingleBlockValue( block, keyId, PropertyType.FLOAT, Float.floatToRawIntBits( (Float) value ) );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( value <span class="keyword">instanceof</span> Long )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> keyAndType = keyId | (((<span class="keyword">long</span>) PropertyType.LONG.intValue()) &lt;&lt; <span class="number">24</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( ShortArray.LONG.getRequiredBits( (Long) value ) &lt;= <span class="number">35</span> )</span><br><span class="line"> </span><br><span class="line">&#123;   <span class="comment">// We only need one block for this value, special layout compared to, say, an integer</span></span><br><span class="line"> </span><br><span class="line">block.setSingleBlock( keyAndType | (<span class="number">1L</span> &lt;&lt; <span class="number">28</span>) | ((Long) value &lt;&lt; <span class="number">29</span>) );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">&#123;   <span class="comment">// We need two blocks for this value</span></span><br><span class="line"> </span><br><span class="line">block.setValueBlocks( <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;keyAndType, (Long) value&#125; );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( value <span class="keyword">instanceof</span> Double )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">block.setValueBlocks( <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;</span><br><span class="line"> </span><br><span class="line">keyId | (((<span class="keyword">long</span>) PropertyType.DOUBLE.intValue()) &lt;&lt; <span class="number">24</span>),</span><br><span class="line"> </span><br><span class="line">Double.doubleToRawLongBits( (Double) value )&#125; );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( value <span class="keyword">instanceof</span> Byte )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">setSingleBlockValue( block, keyId, PropertyType.BYTE, ((Byte) value).longValue() );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( value <span class="keyword">instanceof</span> Character )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">setSingleBlockValue( block, keyId, PropertyType.CHAR, (Character) value );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( value <span class="keyword">instanceof</span> Short )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">setSingleBlockValue( block, keyId, PropertyType.SHORT, ((Short) value).longValue() );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( value.getClass().isArray() )</span><br><span class="line"> </span><br><span class="line">&#123;   <span class="comment">// Try short array first, i.e. inlined in the property block</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( ShortArray.encode( keyId, value, block, PropertyType.getPayloadSize() ) )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fall back to dynamic array store</span></span><br><span class="line"> </span><br><span class="line">Collection arrayRecords = allocateArrayRecords( value );</span><br><span class="line"> </span><br><span class="line">setSingleBlockValue( block, keyId, PropertyType.ARRAY, first( arrayRecords ).getId() );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> ( DynamicRecord valueRecord : arrayRecords )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">valueRecord.setType( PropertyType.ARRAY.intValue() );</span><br><span class="line"> </span><br><span class="line">block.addValueRecord( valueRecord );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Unknown property type on: "</span> + value + <span class="string">", "</span> + value.getClass() );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.5.2.2 allocateStringRecords 函数</strong><br><code>allocateStringRecords</code> 函数是 PropertySTore.java 的成员函数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Collection <span class="title">allocateStringRecords</span><span class="params">( <span class="keyword">byte</span>[] chars )</span></span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> stringPropertyStore.allocateRecordsFromBytes( chars );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.5.2.3 allocateRecordsFromBytes 函数</strong><br><code>allocateRecordsFromBytes</code> 函数是 AbstractDynamicStore .java 的成员函数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Collection <span class="title">allocateRecordsFromBytes</span><span class="params">( <span class="keyword">byte</span> src[] )</span></span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> allocateRecordsFromBytes( src, Collections.emptyList().iterator(),</span><br><span class="line"> </span><br><span class="line">recordAllocator );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.5.2.4 allocateRecordsFromBytes 函数</strong><br><code>allocateRecordsFromBytes</code> 函数是 AbstractDynamicStore .java 的成员函数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">allocateRecordsFromBytes</span><span class="params">(</span><br><span class="line"> </span><br><span class="line"><span class="keyword">byte</span> src[], Iterator recordsToUseFirst,</span><br><span class="line"> </span><br><span class="line">DynamicRecordAllocator dynamicRecordAllocator )</span></span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span> src != <span class="keyword">null</span> : <span class="string">"Null src argument"</span>;</span><br><span class="line"> </span><br><span class="line">List recordList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">DynamicRecord nextRecord = dynamicRecordAllocator.nextUsedRecordOrNew( recordsToUseFirst );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> srcOffset = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dataSize = dynamicRecordAllocator.dataSize();</span><br><span class="line"> </span><br><span class="line">do</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">DynamicRecord record = nextRecord;</span><br><span class="line"> </span><br><span class="line">record.setStartRecord( srcOffset == <span class="number">0</span> );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( src.length - srcOffset &gt; dataSize )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">byte</span> data[] = <span class="keyword">new</span> <span class="keyword">byte</span>[dataSize];</span><br><span class="line"> </span><br><span class="line">System.arraycopy( src, srcOffset, data, <span class="number">0</span>, dataSize );</span><br><span class="line"> </span><br><span class="line">record.setData( data );</span><br><span class="line"> </span><br><span class="line">nextRecord = dynamicRecordAllocator.nextUsedRecordOrNew( recordsToUseFirst );</span><br><span class="line"> </span><br><span class="line">record.setNextBlock( nextRecord.getId() );</span><br><span class="line"> </span><br><span class="line">srcOffset += dataSize;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">byte</span> data[] = <span class="keyword">new</span> <span class="keyword">byte</span>[src.length - srcOffset];</span><br><span class="line"> </span><br><span class="line">System.arraycopy( src, srcOffset, data, <span class="number">0</span>, data.length );</span><br><span class="line"> </span><br><span class="line">record.setData( data );</span><br><span class="line"> </span><br><span class="line">nextRecord = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">record.setNextBlock( Record.NO_NEXT_BLOCK.intValue() );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">recordList.add( record );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span> !record.isLight();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span> record.getData() != <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> ( nextRecord != <span class="keyword">null</span> );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> recordList;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ShortArray_类型属性值的保存过程">ShortArray 类型属性值的保存过程</h4><p><code>ShortArray.encode( keyId, value, block, PropertyType.getPayloadSize() )</code>, 它是在 kernel/impl/nioneo/store/ShortArray.java 中实现的，下面是其代码片段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">encode</span><span class="params">( <span class="keyword">int</span> keyId, Object array, PropertyBlock target, <span class="keyword">int</span> payloadSizeInBytes )</span></span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span><br><span class="line"> </span><br><span class="line">*  If the array is huge, we don't have to check anything else.</span><br><span class="line"> </span><br><span class="line">*  So do the length check first.</span><br><span class="line"> </span><br><span class="line">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> arrayLength = Array.getLength( array );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( arrayLength &gt; <span class="number">63</span> )<span class="comment">/*because we only use 6 bits for length*/</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ShortArray type = typeOf( array );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( type == <span class="keyword">null</span> )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> requiredBits = type.calculateRequiredBitsForArray( array, arrayLength );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( !willFit( requiredBits, arrayLength, payloadSizeInBytes ) )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Too big array</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> numberOfBytes = calculateNumberOfBlocksUsed( arrayLength, requiredBits ) * <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( Bits.requiredLongs( numberOfBytes ) &gt; PropertyType.getPayloadSizeLongs() )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Bits result = Bits.bits( numberOfBytes );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// [][][    ,bbbb][bbll,llll][yyyy,tttt][kkkk,kkkk][kkkk,kkkk][kkkk,kkkk]</span></span><br><span class="line"> </span><br><span class="line">writeHeader( keyId, type, arrayLength, requiredBits, result );</span><br><span class="line"> </span><br><span class="line">type.writeAll( array, arrayLength, requiredBits, result );</span><br><span class="line"> </span><br><span class="line">target.setValueBlocks( result.getLongs() );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeHeader</span><span class="params">( <span class="keyword">int</span> keyId, ShortArray type, <span class="keyword">int</span> arrayLength, <span class="keyword">int</span> requiredBits, Bits result )</span></span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line">result.put( keyId, <span class="number">24</span> );</span><br><span class="line"> </span><br><span class="line">result.put( PropertyType.SHORT_ARRAY.intValue(), <span class="number">4</span> );</span><br><span class="line"> </span><br><span class="line">result.put( type.type.intValue(), <span class="number">4</span> );</span><br><span class="line"> </span><br><span class="line">result.put( arrayLength, <span class="number">6</span> );</span><br><span class="line"> </span><br><span class="line">result.put( requiredBits, <span class="number">6</span> );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PropertyKeyTokenStore的文件存储格式">PropertyKeyTokenStore的文件存储格式</h4><p><img src="/img/2015/06/27/11.png" alt=""><br>类PropertyTypeTokenStore对应的存储文件名是neostore.propertystore.db.index，其对应的存储格式如上图所示: 是一个长度为 RECORD_SIZE=9Bytes 的 record 数组和和一个字符串“PropertyIndexStore v0.A.2”(文件类型描述TYPE_DESCRIPTOR和 neo4j 的 ALL_STORES_VERSION构成)。访问时，可以通过 token_id 作为数组的下标进行访问。</p>
<p>record 是由 in_use(1 Byte) ,prop_count(4 Bytes), name_id(4 Bytes)构成。</p>
<h3 id="Node_数据存储">Node 数据存储</h3><p>neo4j 中, Node 的存储是由 <code>NodeStore</code> 和 <code>ArrayPropertyStore</code> 2中类型配合来完成的. node 的label 内容是存在ArrayPropertyStore这样的DynamicStore 中，如果长度超过一个block ，则分block存储，并将其在ArrayPropertyStore中的第1个block 的 block_id 保存到 NodeStore类型文件相应record 的labels字段中。</p>
<p>下面是neo4j graph db 中，Node数据存储对应的文件：</p>
<pre><code>neostore<span class="class">.nodestore</span><span class="class">.db</span>

neostore<span class="class">.nodestore</span><span class="class">.db</span><span class="class">.id</span>

neostore<span class="class">.nodestore</span><span class="class">.db</span><span class="class">.labels</span>

neostore<span class="class">.nodestore</span><span class="class">.db</span><span class="class">.labels</span><span class="class">.id</span>
</code></pre><p>ArrayPropertyStore的存储格式见&lt; 3.3.2 DynamicStore 类型&gt;，下面介绍一下 NodeStore 的文件存储格式。</p>
<h4 id="NodeStore的主文件存储格式">NodeStore的主文件存储格式</h4><p>NodeStore的主文件是neostore.nodestore.db， 其文件存储格式示意图如下，整个文件是有一个 RECORD_SIZE=15Bytes  的定长数组和一个字符串描述符“NodeStore v0.A.2”(文件类型描述TYPE_DESCRIPTOR和 neo4j 的 ALL_STORES_VERSION) 构成。访问时，可以通过 node_id 作为数组的下标进行访问。<br><img src="/img/2015/06/27/12.png" alt=""><br><img src="/img/2015/06/27/13.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in_use(byte)+next_rel_id(int)+next_prop_id(int)+labels(5)+extra(byte)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECORD_SIZE = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>下面介绍一下 node record 中每个字段的含义：</p>
<ul>
<li><code>inUse(1 Byte)</code>:第1字节,共分成3部分<ul>
<li>第1 bit 表示 record 是否在 use;</li>
<li>第2~4 bit 表示 node 的第1个 relationship_id 的 高3位；</li>
<li>第 5~8 bit表示 node 的第1个property_id 的 高4位</li>
</ul>
</li>
<li><code>next_rel_id(4 Bytes)</code> : 第2~5字节是node 的第1个 relationship_id 的 低32位. 加上inUse 字节的第 2~4 bit作为高3位，构成一个完整的35位relationship_id。</li>
<li><code>next_prop_id(4 Bytes)</code> : 第6~9字节是node 的第1个 property_id 的 低32位. 加上inUse 字节的第 5~8 bit作为高4位，构成一个完整的36 位 property_id。</li>
<li><code>labels(5 Bytes)</code> : 第10~14字节是node 的label field。</li>
<li><code>extra(1 Byte)</code> : 第15字节是 extra , 目前只用到第 1 bit ，表示该node 是否 dense, 缺省的配置是 该 node 的 relationshiop 的数量超过 50 个，这表示是 dense.</li>
</ul>
<h4 id="NodeStore-java">NodeStore.java</h4><p>neo4j 中与neostore.nodestore.db文件相对应的类是NodeStore,负责NodeRecord在neostore.nodestore.db文件中的读写。</p>
<p>下面看一下 NodeStore.java 中 getRecord 成员函数，可以帮助理解 Node Record 的存储格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> NodeRecord <span class="title">getRecord</span><span class="params">(<span class="keyword">long</span> id, PersistenceWindow window, RecordLoad load)</span> </span>&#123;</span><br><span class="line">        Buffer buffer = window.getOffsettedBuffer(id);</span><br><span class="line">        <span class="comment">// [    ,   x] in use bit</span></span><br><span class="line">        <span class="comment">// [    ,xxx ] higher bits for rel id</span></span><br><span class="line">        <span class="comment">// [xxxx,    ] higher bits for prop idlong </span></span><br><span class="line">        inUseByte = buffer.get();</span><br><span class="line">        <span class="keyword">boolean</span> inUse = (inUseByte &amp; amp; <span class="number">0x1</span>)==Record.IN_USE.intValue();</span><br><span class="line">        <span class="keyword">if</span> (!inUse) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (load) &#123;</span><br><span class="line">                <span class="keyword">case</span> NORMAL:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRecordException(<span class="string">"NodeRecord["</span> + id + <span class="string">"] not in use"</span>);</span><br><span class="line">                <span class="keyword">case</span> CHECK:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">case</span> FORCE:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> nextRel = buffer.getUnsignedInt();</span><br><span class="line">        <span class="keyword">long</span> nextProp = buffer.getUnsignedInt();</span><br><span class="line">        <span class="keyword">long</span> relModifier = (inUseByte &amp; amp; <span class="number">0xEL</span>)&lt;&lt;<span class="number">31</span>;</span><br><span class="line">        <span class="keyword">long</span> propModifier = (inUseByte &amp; amp; <span class="number">0xF0L</span>)&lt;&lt;<span class="number">28</span>;</span><br><span class="line">        <span class="keyword">long</span> lsbLabels = buffer.getUnsignedInt();</span><br><span class="line">        <span class="keyword">long</span> hsbLabels = buffer.get() &amp; <span class="number">0xFF</span>; </span><br><span class="line">        <span class="comment">// so that a negative byte won't fill the "extended" bits with ones.long labels = lsbLabels | (hsbLabels &amp;lt;&amp;lt; 32);byte extra = buffer.get();boolean dense = (extra &amp;amp; 0x1) &amp;gt; 0;NodeRecord nodeRecord = new NodeRecord( id, dense, longFromIntAndMod( nextRel, relModifier ),longFromIntAndMod( nextProp, propModifier ) );nodeRecord.setInUse( inUse );nodeRecord.setLabelField( labels, Collections.&amp;lt;DynamicRecord&amp;gt;emptyList() );return nodeRecord;&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Relationship_的存储">Relationship 的存储</h3><p>下面是neo4j graph db 中，Relationship数据存储对应的文件：</p>
<pre><code>neostore<span class="class">.relationshipgroupstore</span><span class="class">.db</span>

neostore<span class="class">.relationshipgroupstore</span><span class="class">.db</span><span class="class">.id</span>

neostore<span class="class">.relationshipstore</span><span class="class">.db</span>

neostore<span class="class">.relationshipstore</span><span class="class">.db</span><span class="class">.id</span>

neostore<span class="class">.relationshiptypestore</span><span class="class">.db</span>

neostore<span class="class">.relationshiptypestore</span><span class="class">.db</span><span class="class">.id</span>

neostore<span class="class">.relationshiptypestore</span><span class="class">.db</span><span class="class">.names</span>

neostore<span class="class">.relationshiptypestore</span><span class="class">.db</span><span class="class">.names</span><span class="class">.id</span>
</code></pre><p>neo4j 中, Relationship 的存储是由 RelationshipStore , RelationshipGroupStore, RelationshipTypeTokenStore和StringPropertyStore 4种类型的Store配合来完成的. 其中RelationshipStore 是Relationship最主要的存储结构；当一个Node 的关系数达到一定的阀值时，才会对关系分组(group), RelationshipGroupStore 用来保存关系分组数据；RelationshipTypeTokenStore和StringPropertyStore 配合用来存储关系的类型。</p>
<p>关系的类型的字符串描述值是存在StringPropertyStore这样的DynamicStore 中，如果长度超过一个block ，则分block存储，并将其在StringPropertyStore中的第1个block 的 block_id 保存到 RelationshipTypeTokenStore类型文件相应record 的name_id字段中。<br><img src="/img/2015/06/27/14.png" alt=""></p>
<p>ArrayPropertyStore的存储格式见&lt; 3.3.2 DynamicStore 类型&gt;，下面分别介绍一下RelationshipTypeTokenStore, RelationshipStore和RelationshipStore的文件存储格式。</p>
<h4 id="RelationshipTypeTokenStore的主文件存储格式">RelationshipTypeTokenStore的主文件存储格式</h4><p><img src="/img/2015/06/27/15.png" alt=""></p>
<p>类RelationshipTypeTokenStore对应的存储文件是neostore.relationshiptypestore.db，其对应的存储格式如上图所示:是一个长度为 RECORD_SIZE=5 Bytes 的 record 数组和和一个字符串描述符“RelationshipTypeStore v0.A.2”(文件类型描述TYPE_DESCRIPTOR和 neo4j 的 ALL_STORES_VERSION) 构成。访问时，可以通过 token_id 作为数组的下标进行访问。</p>
<p>record 是有 1Byte的 in_use 和 4Bytes 的 name_id 构成。</p>
<h4 id="RelationshipStore的文件存储格式">RelationshipStore的文件存储格式</h4><p>类RelationshipTypeTokenStore对应的存储文件是neostore.relationshipstore.db,其文件存储格式示意图如下，整个文件是有一个 RECORD_SIZE=34Bytes 的定长数组和一个字符串描述符“RelationshipStore v0.A.2”(文件类型描述TYPE_DESCRIPTOR和 neo4j 的 ALL_STORES_VERSION构成)。访问时，可以通过 node_id 作为数组的下标进行访问。</p>
<p><img src="/img/2015/06/27/16.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// record header size</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// directed|in_use(byte)+first_node(int)+second_node(int)+rel_type(int)+</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// first_prev_rel_id(int)+first_next_rel_id+second_prev_rel_id(int)+</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// second_next_rel_id+next_prop_id(int)+first-in-chain-markers(1)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECORD_SIZE = <span class="number">34</span>;</span><br></pre></td></tr></table></figure>
<p>下面介绍一下 relationship record 中每个字段的含义：</p>
<ul>
<li><code>in_use(1 Byte)</code> : 第 1 字节, 分成3部分.<ul>
<li>第1 bit 表示 record 是否在 use;</li>
<li>第2~4 bit 表示first_node的node_id的高3位；</li>
<li>第 5~8 bit表示 next_prop_id 的property_id 的 高4位</li>
</ul>
</li>
<li><code>first_node(4 Bytes)</code> : 第2~5字节是RelationShip的from_node 的node_id 的低32位. 加上inUse 字节的第 2~4 bit 作为高3位，构成一个完整的35位node_id。</li>
<li><code>second_node(4 Bytes)</code> : 第6~9字节是RelationShip的to_node 的node_id 的低32位. 加上rel_type的第29~31 bit作为高3位，构成一个完整的35位node_id。</li>
<li><code>rel_type(4 Bytes)</code> : 第 10~13 字节, 分成6部分;<ul>
<li>第29~31 位是second_node 的node_id高3位;</li>
<li>第26~28 位是first_next_rel_id 的 relationship_id高3位;</li>
<li>第23~25 位是first_next_rel_id 的relationship_id高3位;</li>
<li>第20~22 位是second_prev_rel_id 的relationship_id高3位;</li>
<li>第17~19 位是second_next_rel_id 的relationship_id高3位;</li>
<li>第 1~16 位 表示 RelationShipType;</li>
</ul>
</li>
<li><code>first_prev_rel_id(4 Bytes)</code> : 第14~17字节是from_node 的排在本RelationShip 前面一个RelationShip的 relationship_id 的低32位. 加上rel_type的第 26~28 bit 作为高3位，构成一个完整的35位relationship_id。</li>
<li><code>first_next_rel_id(4 Bytes)</code> : 第18~21字节是from_node 的排在本RelationShip 前面一个RelationShip的 relationship_id 的低32位. 加上rel_type的第 23~25 bit 作为高3位，构成一个完整的35位relationship_id。</li>
<li><code>second_prev_rel_id(4 Bytes)</code> : 第22~25字节是from_node 的排在本RelationShip 前面一个RelationShip的 relationship_id 的低32位. 加上rel_type的第 20~22 bit 作为高3位，构成一个完整的35位relationship_id。</li>
<li><code>second_next_rel_id(4 Bytes)</code>: 第26~29字节是from_node 的排在本RelationShip 前面一个RelationShip的 relationship_id 的低32位. 加上rel_type的第 17~19 bit 作为高3位，构成一个完整的35位relationship_id。</li>
<li><code>next_prop_id(4 Bytes)</code> : 第30~33字节是本RelationShip第1个Property的property_id 的低32位. 加上in_use的第 5~8 bit 作为高3位，构成一个完整的36 位property_id。</li>
<li><code>first-in-chain-markers(1 Byte)</code>: 目前只用了第1位和第2位，其作用笔者还没搞清楚。</li>
</ul>
<p><strong>3.7.2.1 RelationshipStore.java</strong><br>与neostore.relationshipstore.db文件相对应的类是RelationshipStore,负责RelationshipRecord从neostore.relationshipstore.db文件的读写。下面看一下 neostore.relationshipstore.db 中 getRecord 成员函数，可以帮助理解 Relationship Record 的存储格式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RelationshipRecord <span class="title">getRecord</span><span class="params">( <span class="keyword">long</span> id, PersistenceWindow window,RecordLoad load )</span></span><br><span class="line"> </span><br><span class="line"></span>&#123;</span><br><span class="line"> </span><br><span class="line">Buffer buffer = window.getOffsettedBuffer( id );</span><br><span class="line"> </span><br><span class="line"><span class="comment">// [    ,   x] in use flag</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// [    ,xxx ] first node high order bits</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// [xxxx,    ] next prop high order bits</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> inUseByte = buffer.get();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">boolean</span> inUse = (inUseByte &amp; <span class="number">0x1</span>) == Record.IN_USE.intValue();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( !inUse )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> ( load )</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> NORMAL:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidRecordException( <span class="string">"RelationshipRecord["</span> + id + <span class="string">"] not in use"</span> );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> CHECK:</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> firstNode = buffer.getUnsignedInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> firstNodeMod = (inUseByte &amp; <span class="number">0xEL</span>) &lt;&lt; <span class="number">31</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> secondNode = buffer.getUnsignedInt();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// [ xxx,    ][    ,    ][    ,    ][    ,    ] second node high order bits,     0x70000000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// [    ,xxx ][    ,    ][    ,    ][    ,    ] first prev rel high order bits,  0xE000000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// [    ,   x][xx  ,    ][    ,    ][    ,    ] first next rel high order bits,  0x1C00000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// [    ,    ][  xx,x   ][    ,    ][    ,    ] second prev rel high order bits, 0x380000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// [    ,    ][    , xxx][    ,    ][    ,    ] second next rel high order bits, 0x70000</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// [    ,    ][    ,    ][xxxx,xxxx][xxxx,xxxx] type</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> typeInt = buffer.getInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> secondNodeMod = (typeInt &amp; <span class="number">0x70000000L</span>) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> type = (<span class="keyword">int</span>)(typeInt &amp; <span class="number">0xFFFF</span>);</span><br><span class="line"> </span><br><span class="line">RelationshipRecord record = <span class="keyword">new</span> RelationshipRecord( id,</span><br><span class="line"> </span><br><span class="line">longFromIntAndMod( firstNode, firstNodeMod ),</span><br><span class="line"> </span><br><span class="line">longFromIntAndMod( secondNode, secondNodeMod ), type );</span><br><span class="line"> </span><br><span class="line">record.setInUse( inUse );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> firstPrevRel = buffer.getUnsignedInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> firstPrevRelMod = (typeInt &amp; <span class="number">0xE000000L</span>) &lt;&lt; <span class="number">7</span>;</span><br><span class="line"> </span><br><span class="line">record.setFirstPrevRel( longFromIntAndMod( firstPrevRel, firstPrevRelMod ) );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> firstNextRel = buffer.getUnsignedInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> firstNextRelMod = (typeInt &amp; <span class="number">0x1C00000L</span>) &lt;&lt; <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">record.setFirstNextRel( longFromIntAndMod( firstNextRel, firstNextRelMod ) );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> secondPrevRel = buffer.getUnsignedInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> secondPrevRelMod = (typeInt &amp; <span class="number">0x380000L</span>) &lt;&lt; <span class="number">13</span>;</span><br><span class="line"> </span><br><span class="line">record.setSecondPrevRel( longFromIntAndMod( secondPrevRel, secondPrevRelMod ) );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> secondNextRel = buffer.getUnsignedInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> secondNextRelMod = (typeInt &amp; <span class="number">0x70000L</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line"> </span><br><span class="line">record.setSecondNextRel( longFromIntAndMod( secondNextRel, secondNextRelMod ) );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> nextProp = buffer.getUnsignedInt();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> nextPropMod = (inUseByte &amp; <span class="number">0xF0L</span>) &lt;&lt; <span class="number">28</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">byte</span> extraByte = buffer.get();</span><br><span class="line"> </span><br><span class="line">record.setFirstInFirstChain( (extraByte &amp; <span class="number">0x1</span>) != <span class="number">0</span> );</span><br><span class="line"> </span><br><span class="line">record.setFirstInSecondChain( (extraByte &amp; <span class="number">0x2</span>) != <span class="number">0</span> );</span><br><span class="line"> </span><br><span class="line">record.setNextProp( longFromIntAndMod( nextProp, nextPropMod ) );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> record;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RelationshipGroupStore类型的存储格式">RelationshipGroupStore类型的存储格式</h4><p>当Node的Relationship数量超过一个阀值时，neo4j 会对 Relationship 进行分组，以便提供性能。neo4j 中用来实现这一功能的类是 RelationshipGroupStore.<br><img src="/img/2015/06/27/17.png" alt=""><br>其对应的文件存储格式如下：<br>整个文件是有一个 RECORD_SIZE=20Bytes 的定长数组和一个字符串“RelationshipGroupStore v0.A.2”(文件类型描述TYPE_DESCRIPTOR和 neo4j 的 ALL_STORES_VERSION构成)。访问时，可以通过 id 作为数组的下标进行访问。数组下标为0的 record 前4 Bytes 保存Relationship分组的阀值。</p>
<p>RelationshipGroupStore 的record 的格式如下：</p>
<ul>
<li><code>inUse(1 Byte)</code>:第1字节,共分成4部分<ul>
<li><code>第1 bit</code>： 表示 record 是否在 use;</li>
<li><code>第2~4 bit</code>： 表示 next 的高3位；</li>
<li><code>第 5~7 bit</code>：表示 firstOut高3位</li>
<li><code>第8 bit</code>：没有用。</li>
</ul>
</li>
<li><code>highByte(1 Byte)</code>:第1字节,共分成4部分<ul>
<li><code>第1 bit</code>：没有用;</li>
<li><code>第2~4 bit</code>： 表示 firstIn 的高3位；</li>
<li><code>第 5~7 bit</code>：表示 firstLoop高3位</li>
<li><code>第8 bit</code>：没有用。 </li>
</ul>
</li>
<li><code>next</code> :</li>
<li><code>firstOut</code></li>
<li><code>firstIn</code></li>
<li><code>firstLoop</code></li>
</ul>
<h3 id="示例1:neo4j_exam">示例1:neo4j_exam</h3><p>下面看一个简单的例子，然后看一下几个主要的存储文件，有助于理解<3–neo4j存储结构>描述的neo4j 的存储格式。</3–neo4j存储结构></p>
<h4 id="neo4j_exm_代码">neo4j_exm 代码</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line">packagecom.wuzhu.neo4j_exam;</span><br><span class="line"></span><br><span class="line">        importjava.util.List;</span><br><span class="line"></span><br><span class="line">        importjava.util.ArrayList;</span><br><span class="line"></span><br><span class="line">        importjava.util.Iterator;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.Direction;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.GraphDatabaseService;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.factory.GraphDatabaseFactory;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.Node;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.Relationship;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.Path;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.RelationshipType;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.Transaction;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.index.Index;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.traversal.Evaluation;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.traversal.Evaluator;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.traversal.Evaluators;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.graphdb.traversal.Traverser;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.kernel.EmbeddedReadOnlyGraphDatabase;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.kernel.Traversal;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.kernel.Uniqueness;</span><br><span class="line"></span><br><span class="line">        importorg.neo4j.tooling.GlobalGraphOperations;</span><br><span class="line"></span><br><span class="line">        importcom.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line">        publicclassNeo4jTest00</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        GraphDatabaseService gds;</span><br><span class="line"></span><br><span class="line">        Node fromNode;</span><br><span class="line"></span><br><span class="line">        Node toNode;</span><br><span class="line"></span><br><span class="line">        Node companyNode;</span><br><span class="line"></span><br><span class="line">        Relationship relationship;</span><br><span class="line"></span><br><span class="line">        Relationship belongRelationship;</span><br><span class="line"></span><br><span class="line">        privatestaticenum UserRelationship implementsRelationshipType</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        FELLOW,BELONG</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        publicvoidcreateDb()</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        String DB_PATH="target/neo4j-test00.db";</span><br><span class="line"></span><br><span class="line">        GraphDatabaseFactory factory=newGraphDatabaseFactory();</span><br><span class="line"></span><br><span class="line">        gds=factory.newEmbeddedDatabase(DB_PATH);</span><br><span class="line"></span><br><span class="line">        GlobalGraphOperations ggo=GlobalGraphOperations.at(gds);</span><br><span class="line"></span><br><span class="line">        try&lt;/b&gt;(Transaction tx=gds.beginTx())</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        fromNode=gds.createNode();</span><br><span class="line"></span><br><span class="line">        fromNode.setProperty("prop_key_table","prop_value_table_person");</span><br><span class="line"></span><br><span class="line">        fromNode.setProperty("prop_key_name","prop_value_name_mayu");</span><br><span class="line"></span><br><span class="line">        toNode=gds.createNode();</span><br><span class="line"></span><br><span class="line">        toNode.setProperty("prop_key_table","prop_value_table_person");</span><br><span class="line"></span><br><span class="line">        toNode.setProperty("prop_key_name","prop_value_name_liyanhong");</span><br><span class="line"></span><br><span class="line">        relationship=fromNode.createRelationshipTo(toNode,UserRelationship.FELLOW);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt;eventList=newArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">//eventList.add("2013福布斯中国富豪榜:李彦宏第三、马化腾第五、马云第八 ");</span><br><span class="line"></span><br><span class="line">//eventList.add("李彦宏推轻应用马云入股浏览器 移动入口争夺暗战升级 ");</span><br><span class="line"></span><br><span class="line">        eventList.add("2013fubushi zhongguo fuhaobang:liyanhong no.3 mahuateng no.5 mayu no.8 ");</span><br><span class="line"></span><br><span class="line">        eventList.add("liyanhong tui qinyingyong,mayu rugu liulanqi; yidong rukou zhengduo anzhan shengji");</span><br><span class="line"></span><br><span class="line">        relationship.setProperty("prop_key_event",JSON.toJSONString(eventList));</span><br><span class="line"></span><br><span class="line">        companyNode=gds.createNode();</span><br><span class="line"></span><br><span class="line">        companyNode.setProperty("prop_key_table","company");</span><br><span class="line"></span><br><span class="line">        companyNode.setProperty("prop_key_name","alibaba corp");</span><br><span class="line"></span><br><span class="line">        belongRelationship=fromNode.createRelationshipTo(companyNode,UserRelationship.BELONG);</span><br><span class="line"></span><br><span class="line">        belongRelationship.setProperty("event","mayu ruhe zhuangkong alibaba? ");</span><br><span class="line"></span><br><span class="line">        tx.success();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Node&gt;iterator=ggo.getAllNodes().iterator();</span><br><span class="line"></span><br><span class="line">        while(iterator.hasNext())</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        Node node=iterator.next();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt;keysIterator=node.getPropertyKeys().iterator();</span><br><span class="line"></span><br><span class="line">        System.out.println("nodeId="+node.getId());</span><br><span class="line"></span><br><span class="line">        while(keysIterator.hasNext())</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        String key=keysIterator.next();</span><br><span class="line"></span><br><span class="line">        System.out.println("node property : "+key+"-&gt;"+node.getProperty(key));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Relationship&gt;relationshipsIterator=node.getRelationships().iterator();</span><br><span class="line"></span><br><span class="line">        while(relationshipsIterator.hasNext())</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        Relationship relationships=relationshipsIterator.next();</span><br><span class="line"></span><br><span class="line">        System.out.println("关系："+relationships.getType());</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt;keysIterator2=relationships.getPropertyKeys().iterator();</span><br><span class="line"></span><br><span class="line">        while(keysIterator2.hasNext())</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        String key=keysIterator2.next();</span><br><span class="line"></span><br><span class="line">        System.out.println("relationship property : "+key+"-&gt;"</span><br><span class="line"></span><br><span class="line">        +relationships.getProperty(key));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        publicvoidremoveData()</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        try(Transaction tx=gds.beginTx())</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        belongRelationship.delete();</span><br><span class="line"></span><br><span class="line">        companyNode.delete();</span><br><span class="line"></span><br><span class="line">        tx.success();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        publicvoidstopDb()</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        gds.shutdown();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        publicstaticvoidmain(String[]args)</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        Neo4jTest00 test00=newNeo4jTest00();</span><br><span class="line"></span><br><span class="line">        test00.createDb();</span><br><span class="line"></span><br><span class="line">        test00.removeData();</span><br><span class="line"></span><br><span class="line">        test00.stopDb();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上述程序执行后，会在target/neo4j-test00.db 下生成 neo4j 的 db 存储文件，</p>
<p>下面我们看几个主要的存储文件，来帮助我们对 neo4j 的存储格式有个直观的认识。</p>
<p>为了看文件的内容，笔者用二进制方式打开neo4j_exam的db存储文件，并用虚拟打印机输出到pdf 文件,并根据每个文件的格式，进行了着色。</p>
<h4 id="neostore-nodestore-db-id_的内容">neostore.nodestore.db.id 的内容</h4><p>打开neo4j_exam的neostore.nodestore.db.id文件看到如下内容：<br><img src="/img/2015/06/27/18.jpg" alt=""><br>id 文件的header 部分： sticky 值是0， nextFreeId是3，目前已回收可复用的 ID 是 02。</p>
<h4 id="neostore-nodestore-db_的内容">neostore.nodestore.db 的内容</h4><p><img src="/img/2015/06/27/19.jpg" alt=""><br>从neo4j_exam的neostore.nodestore.db文件内容可以看到，文件中保存了有 3 条node record 几率的数组和一个字符串“NodeStore v0.A.2”(文件类型描述TYPE_DESCRIPTOR和 neo4j 的 ALL_STORES_VERSION构成)。</p>
<p>其中3 条 node record 的内容如下：</p>
<ol>
<li>node_id=0 (即数组下标为0) 的node record 是在使用的, nextRelId=0, nextPropId=1, labels=0, extra=0</li>
<li>node_id=1 (即数组下标为0) 的node record 是在使用的, nextRelId=0, nextPropId=3, labels=0, extra=0</li>
<li>node_id=2 (即数组下标为0) 的node record 是已经释放了, nextRelId=1, nextPropId=4, labels=0, extra=0 </li>
</ol>
<p>结合 2.6.1 的源代码，可以的看到，fromNode 的 node_id=0, toNode的node_id=1, companyNode 的 node_id=2.</p>
<h4 id="neostore-relationshipstore-db_的内容">neostore.relationshipstore.db 的内容</h4><p><img src="/img/2015/06/27/20.jpg" alt=""><br>从neo4j_exam的neostore.relationshipstore.db文件内容可以看到，文件中保存了有 2 条 relationship record记录的数组和一个字符串“RelationshipStore v0.A.2”(文件类型描述TYPE_DESCRIPTOR和 neo4j 的 ALL_STORES_VERSION构成)。</p>
<p>其中2 个 relationship record 的内容如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">第1条记录</th>
<th style="text-align:center">第2条记录</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">in_use</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">first_node</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">second_node</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">rel_type</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">first_prev_rel_id</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">first_next_rel_id</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">second_prev_rel_id</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">second_next_rel_id</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">next_prop_id</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">first-in-chain-markers</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<h4 id="neostore-relationshiptypestore-db的内容">neostore.relationshiptypestore.db的内容</h4><p><img src="/img/2015/06/27/21.jpg" alt=""></p>
<ul>
<li>record[0].name_id=0×01</li>
<li>record[1].name_id=0×02</li>
</ul>
<h4 id="neostore-relationshiptypestore-db-names_的内容">neostore.relationshiptypestore.db.names 的内容</h4><p><img src="/img/2015/06/27/22.jpg" alt=""></p>
<ul>
<li>record[1]=”FELLOW”</li>
<li>record[2]=”BELONG”</li>
</ul>
<h4 id="neostore-propertystore-db的内容">neostore.propertystore.db的内容</h4><p><img src="/img/2015/06/27/23.jpg" alt=""><br>type=0xB 表示 SHORT_STRING, type=0×9 表示 STRING.</p>
<p>因为 companyNode 节点和 belongRelationship 关系已经删除，所以其属性property[4], property[5] , property[7] 的 block_header (key,type,value)部分填充为0。</p>
<h4 id="neostore-propertystore-db-strings的内容">neostore.propertystore.db.strings的内容</h4><p><img src="/img/2015/06/27/24.jpg" alt=""><br>打开neo4j_exam的neostore.nodestore.db.id文件看到如上内容：</p>
<ul>
<li>第0个block 的前4个Bytes 保存 block_size=0×80, 即 block_header_size=8 和 string_block_size=120</li>
<li>第1个block 的保存例子中关系relationship的属性值一部分: &lt; [“2013fubushi zhongguo fuhaobang:liyanhong no.3 mahuateng no.5 mayu no.8 “,”liyanhong tui qinyingyong,mayu rugu liulanq &gt;, 其中 block_header的值如下：link_block=0, in_use=1, nr_of_bytes=0x78 , next_block=2</li>
<li>第2个block 的保存例子中关系relationship的属性值一部分: &lt; i; yidong rukou zhengduo anzhan shengji”] &gt;, 其中 block_header的值如下：link_block=1, in_use=1, nr_of_bytes=0×28 , next_block=0xFFFFFFFF(即NULL)</li>
</ul>
<h4 id="neostore-propertystore-db-index的内容">neostore.propertystore.db.index的内容</h4><p><img src="/img/2015/06/27/25.jpg" alt=""></p>
<ul>
<li>record[0].name_id=01</li>
<li>record[1].name_id=02</li>
<li>record[2].name_id=03</li>
<li>record[3].name_id=04</li>
</ul>
<h4 id="neostore-propertystore-db-index-keys的内容">neostore.propertystore.db.index.keys的内容</h4><p><img src="/img/2015/06/27/26.jpg" alt=""></p>
<ul>
<li>block[1]=”prop_key_table”</li>
<li>block[2]=”prop_key_name”</li>
<li>block[3]=”prop_key_event”</li>
<li>block[4]=”event”</li>
</ul>
<hr>
<p>原文链接:<a href="http://www.searchtb.com/2014/04/neo4j-底层存储结构分析1.html" target="_blank" rel="external">http://www.searchtb.com/2014/04/neo4j-底层存储结构分析1.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Neo4j_底层存储结构分析">Neo4j 底层存储结构分析</h1><h2 id="neo4j_中节点和关系的物理存储模型">neo4j 中节点和关系的物理存储模型</h2><h3 id="neo4j存储模型">neo4j存储模型</h3><p><img src="/img/2015/06/27/1.jpg" alt=""></p>
<p>The node records contain only a pointer to their first property and their first relationship (in what is oftentermed the _relationship chain). From here, we can follow the (doubly) linked-list of relationships until we find the one we’re interested in, the  LIKES relationship from  Node 1 to  Node 2 in this case. Once we’ve found the relationship record of interest, we can simply read its properties if there are any via the same singly-linked list structure as node properties, or we can examine the node records that it relates via its start node and end node IDs. These IDs, multiplied by the node record size, of course give the immediate offset of both nodes in the node store file.</p>
<p>上面的英文摘自<code>&lt;Graph Databases&gt;</code>(作者：IanRobinson) 一书，描述了 neo4j 的存储模型。Node和Relationship 的 Property 是用一个 Key-Value 的双向列表来保存的； Node 的 Relatsionship 是用一个双向列表来保存的，通过关系，可以方便的找到关系的 from-to Node. Node 节点保存第1个属性和第1个关系ID。</p>
<p>通过上述存储模型，从一个Node-A开始，可以方便的遍历以该Node-A为起点的图。下面给个示例，来帮助理解上面的存储模型，存储文件的具体格式在第2章详细描述。</p>
<h3 id="示例1">示例1</h3><p><img src="/img/2015/06/27/2.png" alt=""><br>在这个例子中，A~E表示Node 的编号，R1~R7 表示 <code>Relationship</code> 编号，P1~P10 表示<code>Property</code> 的编号。</p>
<ul>
<li>Node 的存储示例图如下,每个<code>Node</code> 保存了第1个<code>Property</code> 和 第1个<code>Relationship</code>：<br><img src="/img/2015/06/27/3.png" alt=""></li>
<li>关系的存储示意图如下：<br><img src="/img/2015/06/27/4.png" alt=""><br>从示意图可以看出，从 Node-B 开始，可以通过关系的 next 指针，遍历Node-B 的所有关系，然后可以到达与其有关系的第1层Nodes,在通过遍历第1层Nodes的关系，可以达到第2层Nodes,…</li>
</ul>]]>
    
    </summary>
    
      <category term="Neo4j" scheme="http://sunxiang0918.github.io/tags/Neo4j/"/>
    
      <category term="大数据" scheme="http://sunxiang0918.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[<转>如何在Git中撤销一切]]></title>
    <link href="http://sunxiang0918.github.io/2015/06/24/%E5%A6%82%E4%BD%95%E5%9C%A8Git%E4%B8%AD%E6%92%A4%E9%94%80%E4%B8%80%E5%88%87/"/>
    <id>http://sunxiang0918.github.io/2015/06/24/如何在Git中撤销一切/</id>
    <published>2015-06-24T12:23:29.000Z</published>
    <updated>2015-07-28T01:52:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="如何在Git中撤销一切">如何在Git中撤销一切</h1><p>翻译：李伟<br>审校：张帆<br>译自：<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">Github</a></p>
<p><img src="https://jf-bucket-public.oss-cn-qingdao.aliyuncs.com/jfperiodical/attached/image/20150612/2016242594.png" alt=""></p>
<p>任何一个版本控制系统中，最有用的特性之一莫过于 “撤销（undo）”操作。在Git中，“撤销”有很多种含义。<br>当你完成了一次新的提交（commit），Git会及时存储当前时刻仓库（repository）的快照（snapshot）；你能够使用Git将项目回退到任何之前的版本。<br>下文中，我将列举几个常见的、需要“撤销”的场景，并且展示如何使用Git来完成这些操作。</p>
<h3 id="一、撤销一个公共修改_Undo_a_“public”_change">一、撤销一个公共修改 Undo a “public” change</h3><p><strong>场景：</strong>你刚刚用git push将本地修改推送到了GitHub，这时你意识到在提交中有一个错误。你想撤销这次提交。</p>
<p><strong>使用撤销命令：</strong><code>git revert</code></p>
<p><strong>发生了什么：</strong>git revert将根据给定SHA的相反值，创建一个新的提交。如果旧提交是“matter”，那么新的提交就是“anti-matter”——旧提交中所有已移除的东西将会被添加进到新提交中，旧提交中增加的东西将在新提交中移除。</p>
<p>这是Git最安全、也是最简单的“撤销”场景，因为这样不会修改历史记录——你现在可以git push下刚刚revert之后的提交来纠正错误了。</p>
<a id="more"></a>
<h3 id="二、修改最近一次的提交信息_Fix_the_last_commit_message">二、修改最近一次的提交信息 Fix the last commit message</h3><p><strong>场景：</strong>你只是在最后的提交信息中敲错了字，比如你敲了git commit -m “Fxies bug #42”，而在执行git push之前你已经意识到你应该敲”Fixes bug #42”。</p>
<p><strong>使用撤销命令：</strong><code>git commit –amend或git commit --amend -m &quot;Fixes bug #42&quot;</code></p>
<p><strong>发生了什么：</strong>git commit –amend将使用一个包含了刚刚错误提交所有变更的新提交，来更新并替换这个错误提交。由于没有staged的提交，所以实际上这个提交只是重写了先前的提交信息。</p>
<h3 id="三、撤销本地更改_Undo_“local”_changes">三、撤销本地更改 Undo “local” changes</h3><p><strong>场景：</strong>当你的猫爬过键盘时，你正在编辑的文件恰好被保存了，你的编辑器也恰在此时崩溃了。此时你并没有提交过代码。你期望撤销这个文件中的所有修改——将这个文件回退到上次提交的状态。</p>
<p><strong>使用撤销命令：</strong><code>git checkout --</code></p>
<p><strong>发生了什么：</strong>git checkout将工作目录（working directory）里的文件修改成先前Git已知的状态。你可以提供一个期待回退分支的名字或者一个确切的SHA码，Git也会默认检出HEAD——即：当前分支的上一次提交。</p>
<p><strong>注意：</strong>用这种方法“撤销”的修改都将真正的消失。它们永远不会被提交。因此Git不能恢复它们。此时，一定要明确自己在做什么！（或许可以用git diff来确定）</p>
<h3 id="四、重置本地修改_Reset_“local”_changes">四、重置本地修改 Reset “local” changes</h3><p><strong>场景：</strong>你已经在本地做了一些提交（还没push），但所有的东西都糟糕透了，你想撤销最近的三次提交——就像它们从没发生过一样。<br><strong>使用撤销命令：</strong><code>git reset或git reset --hard</code><br><strong>发生了什么：</strong>git reset将你的仓库纪录一直回退到指定的最后一个SHA代表的提交，那些提交就像从未发生过一样。默认情况下，git reset会保留工作目录（working directory）。这些提交虽然消失了，但是内容还在磁盘上。这是最安全的做法，但通常情况是：你想使用一个命令来“撤销”所有提交和本地修改——那么请使用—hard参数吧。</p>
<h3 id="五、撤销本地后重做_Redo_after_undo_“local”">五、撤销本地后重做 Redo after undo “local”</h3><p><strong>场景：</strong>你已经提交了一些内容，并使用git reset –hard撤销了这些更改（见上面），突然意识到：你想还原这些修改！<br><strong>使用撤销命令：</strong><code>git reflog和git reset, 或者git checkout</code><br><strong>发生了什么：</strong>git reflog是一个用来恢复项目历史记录的好办法。你可以通过git reflog恢复几乎任何已提交的内容。<br>你或许对git log命令比较熟悉，它能显示提交列表。git reflog与之类似，只不过git reflog显示的是HEAD变更次数的列表。</p>
<h3 id="一些说明：">一些说明：</h3><ol>
<li>只有HEAD会改变。当你切换分支时，用git commit提交变更时，或是用git reset撤销提交时，HEAD都会改变。但当你用git checkout —时， HEAD不会发生改变。（就像上文提到的情形，那些更改根本就没有提交，因此reflog就不能帮助我们进行恢复了）</li>
<li>git reflog不会永远存在。Git将会定期清理那些“不可达（unreachable）”的对象。不要期望能够在reflog里找到数月前的提交记录。</li>
<li>reflog只是你个人的。你不能用你的reflog来恢复其他开发者未push的提交。  </li>
</ol>
<p><img src="/img/2015/06/24/1.png" alt="">  </p>
<p>因此，怎样合理使用reflog来找回之前“未完成”的提交呢？这要看你究竟要做什么：  </p>
<ol>
<li>如果你想恢复项目历史到某次提交，那请使用git reset —hard</li>
<li>如果你想在工作目录（working direcotry）中恢复某次提交中的一个或多个文件，并且不改变提交历史，那请使用git checkout—</li>
<li>如果你想确切的回滚到某次提交，那么请使用git cherry-pick。</li>
</ol>
<h3 id="六、与分支有关的那些事_Once_more,_with_branching">六、与分支有关的那些事 Once more, with branching</h3><p><strong>场景：</strong>你提交了一些变更，然后你意识到你正在master分支上，但你期望的是在feature分支上执行这些提交。<br><strong>使用撤销命令：</strong><code>git branch feature, git reset --hard origin/master, 和 git checkout feature</code><br><strong>发生了什么：</strong>你可能用的是git checkout -b来建立新的分支，这是创建和检出分支的便捷方法——但实际你并不想立刻切换分支。git branch feature会建立一个叫feature的分支，这个分支指向你最近的提交，但是你还停留在master分支上。<br>git reset —hard将master回退至origin/master，并忽略所有新提交。别担心，那些提交都还保留在feature上。<br>最后，git checkout将分支切换到feature，这个分支原封不动的保留了你最近的所有工作。</p>
<h3 id="七、事半功倍处理分支_Branch_in_time_saves_nine">七、事半功倍处理分支 Branch in time saves nine</h3><p><strong>场景：</strong>你基于master新建了一个feature分支，但是master分支远远落后与origin/master。现在master分支与origin/master同步了，你期望此刻能在feature下立刻commit代码，并且不是在远远落后master的情况下。<br><strong>使用撤销命令：</strong><code>git checkout feature和git rebase master</code><br><strong>发生了什么：</strong>你也许已经敲了命令：git reset（但是没用—hard,有意在磁盘上保存这些提交内容），然后敲了git checkout -b，之后重新提交更改，但是那样的话，你将失去本地的提交记录。不过，一个更好的方法：</p>
<p><strong>使用git rebase master可以做到一些事情：</strong></p>
<ol>
<li>首先，它定位你当前检出分支和master之间的共同祖先节点（common ancestor）。</li>
<li>然后，它将当前检出的分支重置到祖先节点（ancestor），并将后来所有的提交都暂存起来。</li>
<li>最后，它将当前检出分支推进至master末尾，同时在master最后一次提交之后，再次提交那些在暂存区的变更。</li>
</ol>
<h3 id="八、批量撤销/找回_Mass_undo/redo">八、批量撤销/找回 Mass undo/redo</h3><p><strong>场景：</strong>你开始朝一个既定目标开发功能，但是中途你感觉用另一个方法更好。你已经有十几个提交，但是你只想要其中的某几个，其他的都可以删除不要。<br><strong>使用撤销命令：</strong><code>git rebase -i</code><br><strong>发生了什么：</strong>-i将rebases设置为“交互模式（interactive mode）”。rebase开始执行的操作就像上文讨论的一样，但是在重新执行某个提交时，它会暂停下来，让你修改每一次提交。<br>rebase –i将会打开你的默认文本编辑器，然后列出正在执行的提交，就像这样：<br><img src="/img/2015/06/24/2.png" alt=""><br>前两列最关键：第一列是选择命令，它会根据第二列中的SHA码选择相应的提交。默认情况下，rebase –i会认为每个更改都正通过pick命令被提交。<br>要撤销一个提交，直接在编辑器删除对应的行就可以了。如果在你的项目不再需要这些错误的提交，你可以直接删除上图中的第1行和3-4行。<br>如果你想保留提交但修改提交信息，你可以使用reword命令。即，将命令关键字pick换成reword（或者r）。你现在可能想立刻修改提交消息，但这么做不会生效——rebase –i将忽略SHA列后的所有东西。现有的提交信息会帮助我们记住0835fe2代表什么。当你敲完rebase –i命令后，Git才开始提示你重写那些新提交消息。<br>如果你需要将2个提交合并，你可以用squash或者fixup命令，如下图：<br><img src="/img/2015/06/24/3.png" alt=""><br>squash和fixup都是“向上”结合的——那些用了这些合并命令（编者按：指squash、fixup）的提交，将会和它之前的提交合并：上图中，0835fe2和6943e85将会合并成一个提交，而38f5e4e和af67f82将会合并成另一个提交。<br>当你用squash时，Git将会提示是否填写新的提交消息；fixup则会给出列表中第一个提交的提交信息。在上图中，af67f82是一个“Ooops”信息，因为这个提交信息已经同38f5e4e一样了。但是你可以为0835fe2和6943e85合并的新提交编写提交信息。<br>当你保存并退出编辑器时，Git将会按照从上到下的顺序执行你的提交。你可以在保存这些提交之前，修改提交的执行顺序。如果有需要，你可以将af67f82和0835fe2合并，并且可以这样排序：<br><img src="/img/2015/06/24/4.png" alt="">  </p>
<h3 id="九、修复早先的提交_Fix_an_earlier_commit">九、修复早先的提交 Fix an earlier commit</h3><p><strong>场景：</strong>之前的提交里落下了一个文件，如果先前的提交能有你留下的东西就好了。你还没有push，并且这个提交也不是最近的提交，因此你不能用commit –amend。<br><strong>使用撤销命令：</strong><code>git commit --squash和git rebase --autosquash -i</code><br><strong>发生了什么：</strong>git commit –squash将会创建一个新的提交，该提交信息可能像这样“squash! Earlier commit”。（你也可以手写这些提交信息，commit –squash只是省得让你打字了）。<br>如果你不想为合并的提交编写信息，也可以考虑使用命令git commit —fixup。这种情况下，你可能会使用commit —fixup，因为你仅希望在rebase中使用之前的提交信息。<br>rebase —autosquash –i将会启动rebase交互编辑器，编辑器会列出任何已完成的squash!和fixup!提交，如下图：<br><img src="/img/2015/06/24/5.png" alt=""><br>当使用—squash和–fixup时，你或许记不清你想修复的某个提交的SHA码——只知道它可能在一个或五个提交之前。你或许可以使用Git的^和~操作符手动找回。HEAD^表示HEAD的前一次提交。HEAD~4表示HEAD前的4次提交，加起来总共是前5次提交。</p>
<h3 id="十、停止跟踪一个已被跟踪的文件_Stop_tracking_a_tracked_file">十、停止跟踪一个已被跟踪的文件 Stop tracking a tracked file</h3><p><strong>场景：</strong>你意外将application.log添加到仓库中，现在你每次运行程序，Git都提示application.log中有unstaged的提交。你在.gitignore中写上”<em>.log”，但仍旧没用——怎样告诉Git“撤销”跟踪这个文件的变化呢？<br><strong>使用撤销命令：</strong> git rm —cached application.log<br><em>*发生了什么：</em></em>尽管.gitignore阻止Git跟踪文件的变化，甚至是之前没被跟踪的文件是否存在，但是，一旦文件被add或者commit，Git会开始持续跟踪这个文件的变化。类似的，如果你用git add –f来“强制”add，或者覆盖.gitignore，Git还是会继续监视变化。所以以后最好不要使用–f来add .gitignore文件。<br>如果你希望移除那些应当被忽略的文件，git rm –cached可以帮助你，并将这些文件保留在磁盘上。因为这个文件现在被忽略了，你将不会在git status中看到它，也不会再把这个文件commit了。<br>以上就是如何在Git上撤销的方法。如果你想学习更多Git命令用法，可以移步下面相关的文档：<br>· <a href="http://git-scm.com/docs/git-checkout" target="_blank" rel="external">checkout</a><br>· <a href="http://git-scm.com/docs/git-commit" target="_blank" rel="external">commit</a><br>· <a href="http://git-scm.com/docs/git-rebase" target="_blank" rel="external">rebase</a><br>· <a href="http://git-scm.com/docs/git-reflog" target="_blank" rel="external">reflog</a><br>· <a href="http://git-scm.com/docs/git-reset" target="_blank" rel="external">reset</a><br>· <a href="http://git-scm.com/docs/git-revert" target="_blank" rel="external">revert</a><br>· <a href="http://git-scm.com/docs/git-rm" target="_blank" rel="external">rm</a></p>
<p>原文地址：<a href="https://github.com/blog/2019-how-to-undo-almost-anything-with-git" target="_blank" rel="external">Github</a><br>译文地址：<a href="http://www.jointforce.com/jfperiodical/article/show/796?m=d03" target="_blank" rel="external">http://www.jointforce.com/jfperiodical/article/show/796?m=d03</a></p>
]]></content>
    <summary type="html">
    <![CDATA[这篇文章非常详细的介绍了GIT中撤销提交的相关知识]]>
    
    </summary>
    
      <category term="GIT" scheme="http://sunxiang0918.github.io/tags/GIT/"/>
    
  </entry>
  
</feed>